[
  {
    "function_name": "nfsd_export_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1331-1345",
    "snippet": "void\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: export shutdown complete (net: %p).\\n\"",
            "net"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_unix_purge",
          "args": [
            "net"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_unregister_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cache_unregister_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/cache_lib.c",
          "lines": "148-158",
          "snippet": "void nfs_cache_unregister_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs_cache_unregister_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t}\n\tsunrpc_destroy_cache_detail(cd);\n}",
          "includes": [
            "#include \"cache_lib.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/cache.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache_lib.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n\nvoid nfs_cache_unregister_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs_cache_unregister_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t}\n\tsunrpc_destroy_cache_detail(cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: shutting down export module (net: %p).\\n\"",
            "net"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}"
  },
  {
    "function_name": "nfsd_export_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1319-1326",
    "snippet": "void\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_purge",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "171-203",
          "snippet": "void ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}"
  },
  {
    "function_name": "nfsd_export_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1282-1314",
    "snippet": "int\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};",
      "static struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_unregister_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cache_unregister_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/cache_lib.c",
          "lines": "148-158",
          "snippet": "void nfs_cache_unregister_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs_cache_unregister_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t}\n\tsunrpc_destroy_cache_detail(cd);\n}",
          "includes": [
            "#include \"cache_lib.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/cache.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache_lib.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n\nvoid nfs_cache_unregister_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tnfs_cache_unregister_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t}\n\tsunrpc_destroy_cache_detail(cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_register_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_cache_register_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/cache_lib.c",
          "lines": "126-140",
          "snippet": "int nfs_cache_register_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\tint ret = 0;\n\n\tsunrpc_init_cache_detail(cd);\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tret = nfs_cache_register_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t\tif (ret)\n\t\t\tsunrpc_destroy_cache_detail(cd);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cache_lib.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/cache.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache_lib.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kmod.h>\n\nint nfs_cache_register_net(struct net *net, struct cache_detail *cd)\n{\n\tstruct super_block *pipefs_sb;\n\tint ret = 0;\n\n\tsunrpc_init_cache_detail(cd);\n\tpipefs_sb = rpc_get_sb_net(net);\n\tif (pipefs_sb) {\n\t\tret = nfs_cache_register_sb(pipefs_sb, cd);\n\t\trpc_put_sb_net(net);\n\t\tif (ret)\n\t\t\tsunrpc_destroy_cache_detail(cd);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->svc_expkey_cache"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->svc_expkey_cache"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_create_net",
          "args": [
            "&svc_expkey_cache_template",
            "net"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_create_net",
          "args": [
            "&svc_export_cache_template",
            "net"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: initializing export module (net: %p).\\n\"",
            "net"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};\nstatic struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};\n\nint\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}"
  },
  {
    "function_name": "e_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1253-1270",
    "snippet": "static int e_show(struct seq_file *m, void *p)\n{\n\tstruct cache_head *cp = p;\n\tstruct svc_export *exp = container_of(cp, struct svc_export, h);\n\tstruct cache_detail *cd = m->private;\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"# Version 1.1\\n\");\n\t\tseq_puts(m, \"# Path Client(Flags) # IPs\\n\");\n\t\treturn 0;\n\t}\n\n\texp_get(exp);\n\tif (cache_check(cd, &exp->h, NULL))\n\t\treturn 0;\n\texp_put(exp);\n\treturn svc_export_show(m, cd, cp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_export_show",
          "args": [
            "m",
            "cd",
            "cp"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "656-688",
          "snippet": "static int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&exp->h",
            "NULL"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_cache_check_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
          "lines": "314-361",
          "snippet": "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
            "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
            "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
            "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
            "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "106-110",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# Path Client(Flags) # IPs\\n\""
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cp",
            "structsvc_export",
            "h"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int e_show(struct seq_file *m, void *p)\n{\n\tstruct cache_head *cp = p;\n\tstruct svc_export *exp = container_of(cp, struct svc_export, h);\n\tstruct cache_detail *cd = m->private;\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"# Version 1.1\\n\");\n\t\tseq_puts(m, \"# Path Client(Flags) # IPs\\n\");\n\t\treturn 0;\n\t}\n\n\texp_get(exp);\n\tif (cache_check(cd, &exp->h, NULL))\n\t\treturn 0;\n\texp_put(exp);\n\treturn svc_export_show(m, cd, cp);\n}"
  },
  {
    "function_name": "exp_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1224-1251",
    "snippet": "static void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "fsloc->locations[i].hosts",
            "\",;@ \\t\\n\\\\\""
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "374-397",
          "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'@'"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",%s=\"",
            "loctype"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "anong"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "anong",
            "make_kgid(&init_user_ns, 0x10000-2)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "0x10000-2"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "anong",
            "make_kgid(&init_user_ns, (gid_t)-2)"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "(gid_t)-2"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "anonu"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "anonu",
            "make_kuid(&init_user_ns, 0x10000-2)"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "0x10000-2"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "(uid_t)-2"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_expflags",
          "args": [
            "m",
            "flag",
            "NFSEXP_ALLFLAGS"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "show_expflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1165-1177",
          "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "show_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1206-1222",
    "snippet": "static void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_secinfo_flags",
          "args": [
            "m",
            "flags"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1179-1183",
          "snippet": "static void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_secinfo_run",
          "args": [
            "m",
            "&f",
            "end"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1192-1204",
          "snippet": "static int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secinfo_flags_equal",
          "args": [
            "flags",
            "exp->ex_flags"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_flags_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1185-1190",
          "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}"
  },
  {
    "function_name": "show_secinfo_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1192-1204",
    "snippet": "static int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":%d\"",
            "(*fp)->pseudoflavor"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secinfo_flags_equal",
          "args": [
            "flags",
            "(*fp)->flags"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_flags_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1185-1190",
          "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}"
  },
  {
    "function_name": "secinfo_flags_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1185-1190",
    "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
  },
  {
    "function_name": "show_secinfo_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1179-1183",
    "snippet": "static void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_expflags",
          "args": [
            "m",
            "flags",
            "NFSEXP_SECINFO_FLAGS"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "show_expflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1165-1177",
          "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",\""
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}"
  },
  {
    "function_name": "show_expflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1165-1177",
    "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s%s\"",
            "first++?\",\":\"\"",
            "flg->name[state]"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
  },
  {
    "function_name": "e_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1138-1144",
    "snippet": "static void e_stop(struct seq_file *m, void *p)\n\t__releases(((struct cache_detail *)m->private)->hash_lock)\n{\n\tstruct cache_detail *cd = m->private;\n\n\tread_unlock(&cd->hash_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&cd->hash_lock"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "((struct cache_detail *)m->private)->hash_lock)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void e_stop(struct seq_file *m, void *p)\n\t__releases(((struct cache_detail *)m->private)->hash_lock)\n{\n\tstruct cache_detail *cd = m->private;\n\n\tread_unlock(&cd->hash_lock);\n}"
  },
  {
    "function_name": "e_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1111-1136",
    "snippet": "static void *e_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct cache_head *ch = p;\n\tint hash = (*pos >> 32);\n\tstruct cache_detail *cd = m->private;\n\tstruct cache_head **export_table = cd->hash_table;\n\n\tif (p == SEQ_START_TOKEN)\n\t\thash = 0;\n\telse if (ch->next == NULL) {\n\t\thash++;\n\t\t*pos += 1LL<<32;\n\t} else {\n\t\t++*pos;\n\t\treturn ch->next;\n\t}\n\t*pos &= ~((1LL<<32) - 1);\n\twhile (hash < EXPORT_HASHMAX && export_table[hash] == NULL) {\n\t\thash++;\n\t\t*pos += 1LL<<32;\n\t}\n\tif (hash >= EXPORT_HASHMAX)\n\t\treturn NULL;\n\t++*pos;\n\treturn export_table[hash];\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPORT_HASHMAX\t\t(1<< EXPORT_HASHBITS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHMAX\t\t(1<< EXPORT_HASHBITS)\n\nstatic void *e_next(struct seq_file *m, void *p, loff_t *pos)\n{\n\tstruct cache_head *ch = p;\n\tint hash = (*pos >> 32);\n\tstruct cache_detail *cd = m->private;\n\tstruct cache_head **export_table = cd->hash_table;\n\n\tif (p == SEQ_START_TOKEN)\n\t\thash = 0;\n\telse if (ch->next == NULL) {\n\t\thash++;\n\t\t*pos += 1LL<<32;\n\t} else {\n\t\t++*pos;\n\t\treturn ch->next;\n\t}\n\t*pos &= ~((1LL<<32) - 1);\n\twhile (hash < EXPORT_HASHMAX && export_table[hash] == NULL) {\n\t\thash++;\n\t\t*pos += 1LL<<32;\n\t}\n\tif (hash >= EXPORT_HASHMAX)\n\t\treturn NULL;\n\t++*pos;\n\treturn export_table[hash];\n}"
  },
  {
    "function_name": "e_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1081-1109",
    "snippet": "static void *e_start(struct seq_file *m, loff_t *pos)\n\t__acquires(((struct cache_detail *)m->private)->hash_lock)\n{\n\tloff_t n = *pos;\n\tunsigned hash, export;\n\tstruct cache_head *ch;\n\tstruct cache_detail *cd = m->private;\n\tstruct cache_head **export_table = cd->hash_table;\n\n\tread_lock(&cd->hash_lock);\n\tif (!n--)\n\t\treturn SEQ_START_TOKEN;\n\thash = n >> 32;\n\texport = n & ((1LL<<32) - 1);\n\n\t\n\tfor (ch=export_table[hash]; ch; ch=ch->next)\n\t\tif (!export--)\n\t\t\treturn ch;\n\tn &= ~((1LL<<32) - 1);\n\tdo {\n\t\thash++;\n\t\tn += 1LL<<32;\n\t} while(hash < EXPORT_HASHMAX && export_table[hash]==NULL);\n\tif (hash >= EXPORT_HASHMAX)\n\t\treturn NULL;\n\t*pos = n+1;\n\treturn export_table[hash];\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPORT_HASHMAX\t\t(1<< EXPORT_HASHBITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&cd->hash_lock"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "((struct cache_detail *)m->private)->hash_lock)"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHMAX\t\t(1<< EXPORT_HASHBITS)\n\nstatic void *e_start(struct seq_file *m, loff_t *pos)\n\t__acquires(((struct cache_detail *)m->private)->hash_lock)\n{\n\tloff_t n = *pos;\n\tunsigned hash, export;\n\tstruct cache_head *ch;\n\tstruct cache_detail *cd = m->private;\n\tstruct cache_head **export_table = cd->hash_table;\n\n\tread_lock(&cd->hash_lock);\n\tif (!n--)\n\t\treturn SEQ_START_TOKEN;\n\thash = n >> 32;\n\texport = n & ((1LL<<32) - 1);\n\n\t\n\tfor (ch=export_table[hash]; ch; ch=ch->next)\n\t\tif (!export--)\n\t\t\treturn ch;\n\tn &= ~((1LL<<32) - 1);\n\tdo {\n\t\thash++;\n\t\tn += 1LL<<32;\n\t} while(hash < EXPORT_HASHMAX && export_table[hash]==NULL);\n\tif (hash >= EXPORT_HASHMAX)\n\t\treturn NULL;\n\t*pos = n+1;\n\treturn export_table[hash];\n}"
  },
  {
    "function_name": "exp_pseudoroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1065-1077",
    "snippet": "__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "fhp",
            "exp",
            "exp->ex_path.dentry",
            "NULL"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(exp)"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsproc.c",
          "lines": "708-758",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_find_fsidzero_export",
          "args": [
            "rqstp"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_find_fsidzero_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1051-1058",
          "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}"
  },
  {
    "function_name": "rqst_find_fsidzero_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1051-1058",
    "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rqst_exp_find",
          "args": [
            "rqstp",
            "FSID_NUM",
            "fsidv"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1001-1032",
          "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "FSID_NUM",
            "fsidv",
            "0",
            "0",
            "0",
            "NULL"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "86-136",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
  },
  {
    "function_name": "rqst_exp_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1034-1049",
    "snippet": "struct svc_export *\nrqst_exp_parent(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = rqst_exp_get_by_name(rqstp, path);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = rqst_exp_get_by_name(rqstp, path);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rqst_exp_get_by_name",
          "args": [
            "rqstp",
            "path"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "970-999",
          "snippet": "struct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "path->dentry"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_parent(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = rqst_exp_get_by_name(rqstp, path);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = rqst_exp_get_by_name(rqstp, path);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
  },
  {
    "function_name": "rqst_exp_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "1001-1032",
    "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gssexp"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_find",
          "args": [
            "cd",
            "rqstp->rq_gssclient",
            "fsid_type",
            "fsidv",
            "&rqstp->rq_chandle"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "921-937",
          "snippet": "static struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
  },
  {
    "function_name": "rqst_exp_get_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "970-999",
    "snippet": "struct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gssexp"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "rqstp->rq_gssclient",
            "path",
            "&rqstp->rq_chandle"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "826-847",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
  },
  {
    "function_name": "check_nfsd_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "939-959",
    "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
  },
  {
    "function_name": "exp_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "921-937",
    "snippet": "static struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "exp"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_put",
          "args": [
            "&ek->h",
            "nn->svc_expkey_cache"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "193-206",
          "snippet": "static void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "clp",
            "&ek->ek_path",
            "reqp"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "826-847",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "ek"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ek"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_find_key",
          "args": [
            "nn->svc_expkey_cache",
            "clp",
            "fsid_type",
            "fsidv",
            "reqp"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "exp_find_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "803-824",
          "snippet": "static struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "cd->net",
            "nfsd_net_id"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_rootfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "876-919",
    "snippet": "int\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = path.dentry->d_inode;\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&fh"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "625-645",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n#ifdef CONFIG_NFSD_V3\n\t\tfhp->fh_pre_saved = 0;\n\t\tfhp->fh_post_saved = 0;\n#endif\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "f",
            "&fh.fh_handle",
            "sizeof(struct knfsd_fh)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "&fh",
            "exp",
            "path.dentry",
            "NULL"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = dentry->d_inode;\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) exp->ex_path.dentry->d_inode->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(exp->ex_path.dentry->d_inode->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\texp->ex_path.dentry->d_inode->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&fh",
            "maxsize"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "182-188",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_parent",
          "args": [
            "cd",
            "clp",
            "&path"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "exp_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "852-867",
          "snippet": "static struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\"",
            "name",
            "path.dentry",
            "clp->name",
            "inode->i_sb->s_id",
            "inode->i_ino"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: exp_rootfh path not found %s\"",
            "name"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "0",
            "&path"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nint\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = path.dentry->d_inode;\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}"
  },
  {
    "function_name": "exp_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "852-867",
    "snippet": "static struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "clp",
            "path",
            "NULL"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "826-847",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "path->dentry"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_get_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "826-847",
    "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&exp->h",
            "reqp"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_cache_check_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
          "lines": "314-361",
          "snippet": "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
            "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
            "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
            "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
            "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_lookup",
          "args": [
            "&key"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "776-787",
          "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_find_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "803-824",
    "snippet": "static struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&ek->h",
            "reqp"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_cache_check_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/cache.c",
          "lines": "314-361",
          "snippet": "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);",
            "static uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);",
            "static uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);",
            "static uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);",
            "static enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);",
            "static void afs_vnode_cache_now_uncached(void *cookie_netfs_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n\nstatic uint16_t afs_cell_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic uint16_t afs_cell_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t       void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_cell_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t      const void *buffer,\n\t\t\t\t\t\t      uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic uint16_t afs_vlocation_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vlocation_cache_check_aux(\n\tvoid *cookie_netfs_data, const void *buffer, uint16_t buflen);\nstatic uint16_t afs_volume_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t void *buffer, uint16_t buflen);\nstatic uint16_t afs_vnode_cache_get_key(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic void afs_vnode_cache_get_attr(const void *cookie_netfs_data,\n\t\t\t\t     uint64_t *size);\nstatic uint16_t afs_vnode_cache_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\tvoid *buffer, uint16_t buflen);\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen);\nstatic void afs_vnode_cache_now_uncached(void *cookie_netfs_data);\n\nstatic enum fscache_checkaux afs_vnode_cache_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t\t       uint16_t buflen)\n{\n\tstruct afs_vnode *vnode = cookie_netfs_data;\n\tuint16_t dlen;\n\n\t_enter(\"{%x,%x,%llx},%p,%u\",\n\t       vnode->fid.vnode, vnode->fid.unique, vnode->status.data_version,\n\t       buffer, buflen);\n\n\t/* check the size of the data is what we're expecting */\n\tdlen = sizeof(vnode->fid.unique) + sizeof(vnode->status.data_version);\n\tif (dlen != buflen) {\n\t\t_leave(\" = OBSOLETE [len %hx != %hx]\", dlen, buflen);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer,\n\t\t   &vnode->fid.unique,\n\t\t   sizeof(vnode->fid.unique)\n\t\t   ) != 0) {\n\t\tunsigned unique;\n\n\t\tmemcpy(&unique, buffer, sizeof(unique));\n\n\t\t_leave(\" = OBSOLETE [uniq %x != %x]\",\n\t\t       unique, vnode->fid.unique);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tif (memcmp(buffer + sizeof(vnode->fid.unique),\n\t\t   &vnode->status.data_version,\n\t\t   sizeof(vnode->status.data_version)\n\t\t   ) != 0) {\n\t\tafs_dataversion_t version;\n\n\t\tmemcpy(&version, buffer + sizeof(vnode->fid.unique),\n\t\t       sizeof(version));\n\n\t\t_leave(\" = OBSOLETE [vers %llx != %llx]\",\n\t\t       version, vnode->status.data_version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = SUCCESS\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_lookup",
          "args": [
            "cd",
            "&key"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "261-272",
          "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key.ek_fsid",
            "fsidv",
            "key_len(fsid_type)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fsid_type"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}"
  },
  {
    "function_name": "svc_export_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "789-800",
    "snippet": "static struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
      "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);",
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_export",
            "h"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_update",
          "args": [
            "old->cd",
            "&new->h",
            "&old->h",
            "hash"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_hash",
          "args": [
            "old"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "765-774",
          "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPORT_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_export_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "776-787",
    "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_export",
            "h"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_lookup",
          "args": [
            "exp->cd",
            "&exp->h",
            "hash"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_hash",
          "args": [
            "exp"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "765-774",
          "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPORT_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_export_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "765-774",
    "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPORT_HASHBITS\t\t8"
    ],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_path.mnt",
            "EXPORT_HASHBITS"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_path.dentry",
            "EXPORT_HASHBITS"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_client",
            "EXPORT_HASHBITS"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
  },
  {
    "function_name": "svc_export_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "742-749",
    "snippet": "static struct cache_head *svc_export_alloc(void)\n{\n\tstruct svc_export *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*i)",
            "GFP_KERNEL"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct cache_head *svc_export_alloc(void)\n{\n\tstruct svc_export *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "export_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "715-740",
    "snippet": "static void export_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\tint i;\n\n\tnew->ex_flags = item->ex_flags;\n\tnew->ex_anon_uid = item->ex_anon_uid;\n\tnew->ex_anon_gid = item->ex_anon_gid;\n\tnew->ex_fsid = item->ex_fsid;\n\tnew->ex_devid_map = item->ex_devid_map;\n\titem->ex_devid_map = NULL;\n\tnew->ex_uuid = item->ex_uuid;\n\titem->ex_uuid = NULL;\n\tnew->ex_fslocs.locations = item->ex_fslocs.locations;\n\titem->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = item->ex_fslocs.locations_count;\n\titem->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = item->ex_fslocs.migrated;\n\titem->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = item->ex_layout_type;\n\tnew->ex_nflavors = item->ex_nflavors;\n\tfor (i = 0; i < MAX_SECINFO_LIST; i++) {\n\t\tnew->ex_flavors[i] = item->ex_flavors[i];\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_export",
            "h"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_export",
            "h"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic void export_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\tint i;\n\n\tnew->ex_flags = item->ex_flags;\n\tnew->ex_anon_uid = item->ex_anon_uid;\n\tnew->ex_anon_gid = item->ex_anon_gid;\n\tnew->ex_fsid = item->ex_fsid;\n\tnew->ex_devid_map = item->ex_devid_map;\n\titem->ex_devid_map = NULL;\n\tnew->ex_uuid = item->ex_uuid;\n\titem->ex_uuid = NULL;\n\tnew->ex_fslocs.locations = item->ex_fslocs.locations;\n\titem->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = item->ex_fslocs.locations_count;\n\titem->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = item->ex_fslocs.migrated;\n\titem->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = item->ex_layout_type;\n\tnew->ex_nflavors = item->ex_nflavors;\n\tfor (i = 0; i < MAX_SECINFO_LIST; i++) {\n\t\tnew->ex_flavors[i] = item->ex_flavors[i];\n\t}\n}"
  },
  {
    "function_name": "svc_export_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "698-713",
    "snippet": "static void svc_export_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\n\tkref_get(&item->ex_client->ref);\n\tnew->ex_client = item->ex_client;\n\tnew->ex_path = item->ex_path;\n\tpath_get(&item->ex_path);\n\tnew->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = 0;\n\tnew->ex_uuid = NULL;\n\tnew->cd = item->cd;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&item->ex_path"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&item->ex_client->ref"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_export",
            "h"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_export",
            "h"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic void svc_export_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\n\tkref_get(&item->ex_client->ref);\n\tnew->ex_client = item->ex_client;\n\tnew->ex_path = item->ex_path;\n\tpath_get(&item->ex_path);\n\tnew->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = 0;\n\tnew->ex_uuid = NULL;\n\tnew->cd = item->cd;\n}"
  },
  {
    "function_name": "svc_export_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "689-696",
    "snippet": "static int svc_export_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_export *orig = container_of(a, struct svc_export, h);\n\tstruct svc_export *new = container_of(b, struct svc_export, h);\n\treturn orig->ex_client == new->ex_client &&\n\t\torig->ex_path.dentry == new->ex_path.dentry &&\n\t\torig->ex_path.mnt == new->ex_path.mnt;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structsvc_export",
            "h"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structsvc_export",
            "h"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic int svc_export_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_export *orig = container_of(a, struct svc_export, h);\n\tstruct svc_export *new = container_of(b, struct svc_export, h);\n\treturn orig->ex_client == new->ex_client &&\n\t\torig->ex_path.dentry == new->ex_path.dentry &&\n\t\torig->ex_path.mnt == new->ex_path.mnt;\n}"
  },
  {
    "function_name": "svc_export_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "656-688",
    "snippet": "static int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\\n\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_secinfo",
          "args": [
            "m",
            "exp"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1206-1222",
          "snippet": "static void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%02x\"",
            "exp->ex_uuid[i]"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "':'"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_flags",
          "args": [
            "m",
            "exp->ex_flags",
            "exp->ex_fsid",
            "exp->ex_anon_uid",
            "exp->ex_anon_gid",
            "&exp->ex_fslocs"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "exp_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "1224-1251",
          "snippet": "static void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&h->flags"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "exp->ex_client->name",
            "\" \\t\\n\\\\\""
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "374-397",
          "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&exp->ex_path",
            "\" \\t\\n\\\\\""
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_export",
            "h"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "svc_export_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "509-650",
    "snippet": "static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client path expiry [flags anonuid anongid fsid] */\n\tchar *buf;\n\tint len;\n\tint err;\n\tstruct auth_domain *dom = NULL;\n\tstruct svc_export exp = {}, *expp;\n\tint an_int;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* client */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\n\t/* path */\n\terr = -EINVAL;\n\tif ((len = qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out1;\n\n\terr = kern_path(buf, 0, &exp.ex_path);\n\tif (err)\n\t\tgoto out1;\n\n\texp.ex_client = dom;\n\texp.cd = cd;\n\texp.ex_devid_map = NULL;\n\n\t/* expiry */\n\terr = -EINVAL;\n\texp.h.expiry_time = get_expiry(&mesg);\n\tif (exp.h.expiry_time == 0)\n\t\tgoto out3;\n\n\t/* flags */\n\terr = get_int(&mesg, &an_int);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tset_bit(CACHE_NEGATIVE, &exp.h.flags);\n\t} else {\n\t\tif (err || an_int < 0)\n\t\t\tgoto out3;\n\t\texp.ex_flags= an_int;\n\t\n\t\t/* anon uid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_uid= make_kuid(&init_user_ns, an_int);\n\n\t\t/* anon gid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_gid= make_kgid(&init_user_ns, an_int);\n\n\t\t/* fsid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_fsid = an_int;\n\n\t\twhile ((len = qword_get(&mesg, buf, PAGE_SIZE)) > 0) {\n\t\t\tif (strcmp(buf, \"fsloc\") == 0)\n\t\t\t\terr = fsloc_parse(&mesg, buf, &exp.ex_fslocs);\n\t\t\telse if (strcmp(buf, \"uuid\") == 0)\n\t\t\t\terr = uuid_parse(&mesg, buf, &exp.ex_uuid);\n\t\t\telse if (strcmp(buf, \"secinfo\") == 0)\n\t\t\t\terr = secinfo_parse(&mesg, buf, &exp);\n\t\t\telse\n\t\t\t\t/* quietly ignore unknown words and anything\n\t\t\t\t * following. Newer user-space can try to set\n\t\t\t\t * new values, then see what the result was.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\tgoto out4;\n\t\t}\n\n\t\terr = check_export(exp.ex_path.dentry->d_inode, &exp.ex_flags,\n\t\t\t\t   exp.ex_uuid);\n\t\tif (err)\n\t\t\tgoto out4;\n\t\t/*\n\t\t * No point caching this if it would immediately expire.\n\t\t * Also, this protects exportfs's dummy export from the\n\t\t * anon_uid/anon_gid checks:\n\t\t */\n\t\tif (exp.h.expiry_time < seconds_since_boot())\n\t\t\tgoto out4;\n\t\t/*\n\t\t * For some reason exportfs has been passing down an\n\t\t * invalid (-1) uid & gid on the \"dummy\" export which it\n\t\t * uses to test export support.  To make sure exportfs\n\t\t * sees errors from check_export we therefore need to\n\t\t * delay these checks till after check_export:\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (!uid_valid(exp.ex_anon_uid))\n\t\t\tgoto out4;\n\t\tif (!gid_valid(exp.ex_anon_gid))\n\t\t\tgoto out4;\n\t\terr = 0;\n\n\t\tnfsd4_setup_layout_type(&exp);\n\t}\n\n\texpp = svc_export_lookup(&exp);\n\tif (expp)\n\t\texpp = svc_export_update(&exp, expp);\n\telse\n\t\terr = -ENOMEM;\n\tcache_flush();\n\tif (expp == NULL)\n\t\terr = -ENOMEM;\n\telse\n\t\texp_put(expp);\nout4:\n\tnfsd4_fslocs_free(&exp.ex_fslocs);\n\tkfree(exp.ex_uuid);\nout3:\n\tpath_put(&exp.ex_path);\nout1:\n\tauth_domain_put(dom);\nout:\n\tkfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "dom"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&exp.ex_path"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp.ex_uuid"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "&exp.ex_fslocs"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "expp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.h",
          "lines": "101-104",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_flush",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_update",
          "args": [
            "&exp",
            "expp"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "789-800",
          "snippet": "static struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
            "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);",
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_export_lookup",
          "args": [
            "&exp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "776-787",
          "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_setup_layout_type",
          "args": [
            "&exp"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_setup_layout_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "117-128",
          "snippet": "void nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (exp->ex_flags & NFSEXP_NOPNFS)\n\t\treturn;\n\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (exp->ex_flags & NFSEXP_NOPNFS)\n\t\treturn;\n\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "exp.ex_anon_gid"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "exp.ex_anon_uid"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_export",
          "args": [
            "exp.ex_path.dentry->d_inode",
            "&exp.ex_flags",
            "exp.ex_uuid"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "check_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "342-383",
          "snippet": "static int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "secinfo_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "484-485",
          "snippet": "static inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"secinfo\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uuid_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp.ex_uuid"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "488-507",
          "snippet": "static inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsloc_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp.ex_fslocs"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "fsloc_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "482-483",
          "snippet": "static inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "an_int"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "an_int"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&exp.h.flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_expiry",
          "args": [
            "&mesg"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "buf",
            "0",
            "&exp.ex_path"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_find",
          "args": [
            "buf"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client path expiry [flags anonuid anongid fsid] */\n\tchar *buf;\n\tint len;\n\tint err;\n\tstruct auth_domain *dom = NULL;\n\tstruct svc_export exp = {}, *expp;\n\tint an_int;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* client */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\n\t/* path */\n\terr = -EINVAL;\n\tif ((len = qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out1;\n\n\terr = kern_path(buf, 0, &exp.ex_path);\n\tif (err)\n\t\tgoto out1;\n\n\texp.ex_client = dom;\n\texp.cd = cd;\n\texp.ex_devid_map = NULL;\n\n\t/* expiry */\n\terr = -EINVAL;\n\texp.h.expiry_time = get_expiry(&mesg);\n\tif (exp.h.expiry_time == 0)\n\t\tgoto out3;\n\n\t/* flags */\n\terr = get_int(&mesg, &an_int);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tset_bit(CACHE_NEGATIVE, &exp.h.flags);\n\t} else {\n\t\tif (err || an_int < 0)\n\t\t\tgoto out3;\n\t\texp.ex_flags= an_int;\n\t\n\t\t/* anon uid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_uid= make_kuid(&init_user_ns, an_int);\n\n\t\t/* anon gid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_gid= make_kgid(&init_user_ns, an_int);\n\n\t\t/* fsid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_fsid = an_int;\n\n\t\twhile ((len = qword_get(&mesg, buf, PAGE_SIZE)) > 0) {\n\t\t\tif (strcmp(buf, \"fsloc\") == 0)\n\t\t\t\terr = fsloc_parse(&mesg, buf, &exp.ex_fslocs);\n\t\t\telse if (strcmp(buf, \"uuid\") == 0)\n\t\t\t\terr = uuid_parse(&mesg, buf, &exp.ex_uuid);\n\t\t\telse if (strcmp(buf, \"secinfo\") == 0)\n\t\t\t\terr = secinfo_parse(&mesg, buf, &exp);\n\t\t\telse\n\t\t\t\t/* quietly ignore unknown words and anything\n\t\t\t\t * following. Newer user-space can try to set\n\t\t\t\t * new values, then see what the result was.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\tgoto out4;\n\t\t}\n\n\t\terr = check_export(exp.ex_path.dentry->d_inode, &exp.ex_flags,\n\t\t\t\t   exp.ex_uuid);\n\t\tif (err)\n\t\t\tgoto out4;\n\t\t/*\n\t\t * No point caching this if it would immediately expire.\n\t\t * Also, this protects exportfs's dummy export from the\n\t\t * anon_uid/anon_gid checks:\n\t\t */\n\t\tif (exp.h.expiry_time < seconds_since_boot())\n\t\t\tgoto out4;\n\t\t/*\n\t\t * For some reason exportfs has been passing down an\n\t\t * invalid (-1) uid & gid on the \"dummy\" export which it\n\t\t * uses to test export support.  To make sure exportfs\n\t\t * sees errors from check_export we therefore need to\n\t\t * delay these checks till after check_export:\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (!uid_valid(exp.ex_anon_uid))\n\t\t\tgoto out4;\n\t\tif (!gid_valid(exp.ex_anon_gid))\n\t\t\tgoto out4;\n\t\terr = 0;\n\n\t\tnfsd4_setup_layout_type(&exp);\n\t}\n\n\texpp = svc_export_lookup(&exp);\n\tif (expp)\n\t\texpp = svc_export_update(&exp, expp);\n\telse\n\t\terr = -ENOMEM;\n\tcache_flush();\n\tif (expp == NULL)\n\t\terr = -ENOMEM;\n\telse\n\t\texp_put(expp);\nout4:\n\tnfsd4_fslocs_free(&exp.ex_fslocs);\n\tkfree(exp.ex_uuid);\nout3:\n\tpath_put(&exp.ex_path);\nout1:\n\tauth_domain_put(dom);\nout:\n\tkfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "uuid_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "488-507",
    "snippet": "static inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "buf",
            "EX_UUID_LEN",
            "GFP_KERNEL"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "secinfo_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "484-485",
    "snippet": "static inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }"
  },
  {
    "function_name": "fsloc_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "482-483",
    "snippet": "static inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}"
  },
  {
    "function_name": "secinfo_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "444-479",
    "snippet": "static int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tu32 listsize;\n\tint err;\n\n\t/* more than one secinfo */\n\tif (exp->ex_nflavors)\n\t\treturn -EINVAL;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > MAX_SECINFO_LIST)\n\t\treturn -EINVAL;\n\n\tfor (f = exp->ex_flavors; f < exp->ex_flavors + listsize; f++) {\n\t\terr = get_uint(mesg, &f->pseudoflavor);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * XXX: It would be nice to also check whether this\n\t\t * pseudoflavor is supported, so we can discover the\n\t\t * problem at export time instead of when a client fails\n\t\t * to authenticate.\n\t\t */\n\t\terr = get_uint(mesg, &f->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/* Only some flags are allowed to differ between flavors: */\n\t\tif (~NFSEXP_SECINFO_FLAGS & (f->flags ^ exp->ex_flags))\n\t\t\treturn -EINVAL;\n\t}\n\texp->ex_nflavors = listsize;\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&f->flags"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&f->pseudoflavor"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&listsize"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tu32 listsize;\n\tint err;\n\n\t/* more than one secinfo */\n\tif (exp->ex_nflavors)\n\t\treturn -EINVAL;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > MAX_SECINFO_LIST)\n\t\treturn -EINVAL;\n\n\tfor (f = exp->ex_flavors; f < exp->ex_flavors + listsize; f++) {\n\t\terr = get_uint(mesg, &f->pseudoflavor);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * XXX: It would be nice to also check whether this\n\t\t * pseudoflavor is supported, so we can discover the\n\t\t * problem at export time instead of when a client fails\n\t\t * to authenticate.\n\t\t */\n\t\terr = get_uint(mesg, &f->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/* Only some flags are allowed to differ between flavors: */\n\t\tif (~NFSEXP_SECINFO_FLAGS & (f->flags ^ exp->ex_flags))\n\t\t\treturn -EINVAL;\n\t}\n\texp->ex_nflavors = listsize;\n\treturn 0;\n}"
  },
  {
    "function_name": "fsloc_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "387-442",
    "snippet": "static int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)\n{\n\tint len;\n\tint migrated, i, err;\n\n\t/* more than one fsloc */\n\tif (fsloc->locations)\n\t\treturn -EINVAL;\n\n\t/* listsize */\n\terr = get_uint(mesg, &fsloc->locations_count);\n\tif (err)\n\t\treturn err;\n\tif (fsloc->locations_count > MAX_FS_LOCATIONS)\n\t\treturn -EINVAL;\n\tif (fsloc->locations_count == 0)\n\t\treturn 0;\n\n\tfsloc->locations = kzalloc(fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location), GFP_KERNEL);\n\tif (!fsloc->locations)\n\t\treturn -ENOMEM;\n\tfor (i=0; i < fsloc->locations_count; i++) {\n\t\t/* colon separated host list */\n\t\terr = -EINVAL;\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].hosts = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].hosts)\n\t\t\tgoto out_free_all;\n\t\terr = -EINVAL;\n\t\t/* slash separated path component list */\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].path = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].path)\n\t\t\tgoto out_free_all;\n\t}\n\t/* migrated */\n\terr = get_int(mesg, &migrated);\n\tif (err)\n\t\tgoto out_free_all;\n\terr = -EINVAL;\n\tif (migrated < 0 || migrated > 1)\n\t\tgoto out_free_all;\n\tfsloc->migrated = migrated;\n\treturn 0;\nout_free_all:\n\tnfsd4_fslocs_free(fsloc);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "fsloc"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "mesg",
            "&migrated"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location)",
            "GFP_KERNEL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&fsloc->locations_count"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)\n{\n\tint len;\n\tint migrated, i, err;\n\n\t/* more than one fsloc */\n\tif (fsloc->locations)\n\t\treturn -EINVAL;\n\n\t/* listsize */\n\terr = get_uint(mesg, &fsloc->locations_count);\n\tif (err)\n\t\treturn err;\n\tif (fsloc->locations_count > MAX_FS_LOCATIONS)\n\t\treturn -EINVAL;\n\tif (fsloc->locations_count == 0)\n\t\treturn 0;\n\n\tfsloc->locations = kzalloc(fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location), GFP_KERNEL);\n\tif (!fsloc->locations)\n\t\treturn -ENOMEM;\n\tfor (i=0; i < fsloc->locations_count; i++) {\n\t\t/* colon separated host list */\n\t\terr = -EINVAL;\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].hosts = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].hosts)\n\t\t\tgoto out_free_all;\n\t\terr = -EINVAL;\n\t\t/* slash separated path component list */\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].path = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].path)\n\t\t\tgoto out_free_all;\n\t}\n\t/* migrated */\n\terr = get_int(mesg, &migrated);\n\tif (err)\n\t\tgoto out_free_all;\n\terr = -EINVAL;\n\tif (migrated < 0 || migrated > 1)\n\t\tgoto out_free_all;\n\tfsloc->migrated = migrated;\n\treturn 0;\nout_free_all:\n\tnfsd4_fslocs_free(fsloc);\n\treturn err;\n}"
  },
  {
    "function_name": "check_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "342-383",
    "snippet": "static int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"exp_export: export of invalid fs type.\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"exp_export: export of non-dev fs without fsid\\n\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "function_name": "svc_export_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "319-336",
    "snippet": "static void svc_export_request(struct cache_detail *cd,\n\t\t\t       struct cache_head *h,\n\t\t\t       char **bpp, int *blen)\n{\n\t/*  client path */\n\tstruct svc_export *exp = container_of(h, struct svc_export, h);\n\tchar *pth;\n\n\tqword_add(bpp, blen, exp->ex_client->name);\n\tpth = d_path(&exp->ex_path, *bpp, *blen);\n\tif (IS_ERR(pth)) {\n\t\t/* is this correct? */\n\t\t(*bpp)[0] = '\\n';\n\t\treturn;\n\t}\n\tqword_add(bpp, blen, pth);\n\t(*bpp)[-1] = '\\n';\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "pth"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pth"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&exp->ex_path",
            "*bpp",
            "*blen"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3047-3076",
          "snippet": "char *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nchar *d_path(const struct path *path, char *buf, int buflen)\n{\n\tchar *res = buf + buflen;\n\tstruct path root;\n\tint error;\n\n\t/*\n\t * We have various synthetic filesystems that never get mounted.  On\n\t * these filesystems dentries are never used for lookup purposes, and\n\t * thus don't need to be hashed.  They also don't need a name until a\n\t * user wants to identify the object in /proc/pid/fd/.  The little hack\n\t * below allows us to generate a name for these objects on demand:\n\t *\n\t * Some pseudo inodes are mountable.  When they are mounted\n\t * path->dentry == path->mnt->mnt_root.  In that case don't call d_dname\n\t * and instead have d_path return the mounted path.\n\t */\n\tif (path->dentry->d_op && path->dentry->d_op->d_dname &&\n\t    (!IS_ROOT(path->dentry) || path->dentry != path->mnt->mnt_root))\n\t\treturn path->dentry->d_op->d_dname(path->dentry, buf, buflen);\n\n\trcu_read_lock();\n\tget_fs_root_rcu(current->fs, &root);\n\terror = path_with_deleted(path, &root, &res, &buflen);\n\trcu_read_unlock();\n\n\tif (error < 0)\n\t\tres = ERR_PTR(error);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "exp->ex_client->name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_export",
            "h"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void svc_export_request(struct cache_detail *cd,\n\t\t\t       struct cache_head *h,\n\t\t\t       char **bpp, int *blen)\n{\n\t/*  client path */\n\tstruct svc_export *exp = container_of(h, struct svc_export, h);\n\tchar *pth;\n\n\tqword_add(bpp, blen, exp->ex_client->name);\n\tpth = d_path(&exp->ex_path, *bpp, *blen);\n\tif (IS_ERR(pth)) {\n\t\t/* is this correct? */\n\t\t(*bpp)[0] = '\\n';\n\t\treturn;\n\t}\n\tqword_add(bpp, blen, pth);\n\t(*bpp)[-1] = '\\n';\n}"
  },
  {
    "function_name": "svc_export_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "309-317",
    "snippet": "static void svc_export_put(struct kref *ref)\n{\n\tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n\tpath_put(&exp->ex_path);\n\tauth_domain_put(exp->ex_client);\n\tnfsd4_fslocs_free(&exp->ex_fslocs);\n\tkfree(exp->ex_uuid);\n\tkfree(exp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp->ex_uuid"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "&exp->ex_fslocs"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "exp->ex_client"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&exp->ex_path"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structsvc_export",
            "h.ref"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void svc_export_put(struct kref *ref)\n{\n\tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n\tpath_put(&exp->ex_path);\n\tauth_domain_put(exp->ex_client);\n\tnfsd4_fslocs_free(&exp->ex_fslocs);\n\tkfree(exp->ex_uuid);\n\tkfree(exp);\n}"
  },
  {
    "function_name": "nfsd4_fslocs_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "292-307",
    "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations[i].hosts"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations[i].path"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
  },
  {
    "function_name": "svc_expkey_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "274-286",
    "snippet": "static struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_expkey",
            "h"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_update",
          "args": [
            "cd",
            "&new->h",
            "&old->h",
            "hash"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_hash",
          "args": [
            "new"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "248-259",
          "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
            "#define\tEXPKEY_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\n\nstatic struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_expkey_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "261-272",
    "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_expkey",
            "h"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_lookup",
          "args": [
            "cd",
            "&item->h",
            "hash"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_hash",
          "args": [
            "item"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "248-259",
          "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
            "#define\tEXPKEY_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_expkey_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "248-259",
    "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
      "#define\tEXPKEY_HASHBITS\t\t8"
    ],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "item->ek_client",
            "EXPKEY_HASHBITS"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_mem",
          "args": [
            "cp",
            "len",
            "EXPKEY_HASHBITS"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "item->ek_fsidtype"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
  },
  {
    "function_name": "expkey_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "225-232",
    "snippet": "static struct cache_head *expkey_alloc(void)\n{\n\tstruct svc_expkey *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*i)",
            "GFP_KERNEL"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct cache_head *expkey_alloc(void)\n{\n\tstruct svc_expkey *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "expkey_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "215-223",
    "snippet": "static inline void expkey_update(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tnew->ek_path = item->ek_path;\n\tpath_get(&item->ek_path);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&item->ek_path"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_expkey",
            "h"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_expkey",
            "h"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline void expkey_update(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tnew->ek_path = item->ek_path;\n\tpath_get(&item->ek_path);\n}"
  },
  {
    "function_name": "expkey_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "202-213",
    "snippet": "static inline void expkey_init(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tkref_get(&item->ek_client->ref);\n\tnew->ek_client = item->ek_client;\n\tnew->ek_fsidtype = item->ek_fsidtype;\n\n\tmemcpy(new->ek_fsid, item->ek_fsid, sizeof(new->ek_fsid));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->ek_fsid",
            "item->ek_fsid",
            "sizeof(new->ek_fsid)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&item->ek_client->ref"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_expkey",
            "h"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_expkey",
            "h"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline void expkey_init(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tkref_get(&item->ek_client->ref);\n\tnew->ek_client = item->ek_client;\n\tnew->ek_fsidtype = item->ek_fsidtype;\n\n\tmemcpy(new->ek_fsid, item->ek_fsid, sizeof(new->ek_fsid));\n}"
  },
  {
    "function_name": "expkey_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "190-200",
    "snippet": "static inline int expkey_match (struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_expkey *orig = container_of(a, struct svc_expkey, h);\n\tstruct svc_expkey *new = container_of(b, struct svc_expkey, h);\n\n\tif (orig->ek_fsidtype != new->ek_fsidtype ||\n\t    orig->ek_client != new->ek_client ||\n\t    memcmp(orig->ek_fsid, new->ek_fsid, key_len(orig->ek_fsidtype)) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "orig->ek_fsid",
            "new->ek_fsid",
            "key_len(orig->ek_fsidtype)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "orig->ek_fsidtype"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structsvc_expkey",
            "h"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structsvc_expkey",
            "h"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline int expkey_match (struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_expkey *orig = container_of(a, struct svc_expkey, h);\n\tstruct svc_expkey *new = container_of(b, struct svc_expkey, h);\n\n\tif (orig->ek_fsidtype != new->ek_fsidtype ||\n\t    orig->ek_client != new->ek_client ||\n\t    memcmp(orig->ek_fsid, new->ek_fsid, key_len(orig->ek_fsidtype)) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "expkey_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "165-188",
    "snippet": "static int expkey_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct svc_expkey *ek ;\n\tint i;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#domain fsidtype fsid [path]\\n\");\n\t\treturn 0;\n\t}\n\tek = container_of(h, struct svc_expkey, h);\n\tseq_printf(m, \"%s %d 0x\", ek->ek_client->name,\n\t\t   ek->ek_fsidtype);\n\tfor (i=0; i < key_len(ek->ek_fsidtype)/4; i++)\n\t\tseq_printf(m, \"%08x\", ek->ek_fsid[i]);\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tseq_printf(m, \" \");\n\t\tseq_path(m, &ek->ek_path, \"\\\\ \\t\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&ek->ek_path",
            "\"\\\\ \\t\\n\""
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "470-487",
          "snippet": "int seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path(struct seq_file *m, const struct path *path, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = d_path(path, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&h->flags"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "ek->ek_fsidtype"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_expkey",
            "h"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#domain fsidtype fsid [path]\\n\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int expkey_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct svc_expkey *ek ;\n\tint i;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#domain fsidtype fsid [path]\\n\");\n\t\treturn 0;\n\t}\n\tek = container_of(h, struct svc_expkey, h);\n\tseq_printf(m, \"%s %d 0x\", ek->ek_client->name,\n\t\t   ek->ek_fsidtype);\n\tfor (i=0; i < key_len(ek->ek_fsidtype)/4; i++)\n\t\tseq_printf(m, \"%08x\", ek->ek_fsid[i]);\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tseq_printf(m, \" \");\n\t\tseq_path(m, &ek->ek_path, \"\\\\ \\t\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "expkey_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "70-163",
    "snippet": "static int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk(\"found domain %s\\n\", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk(\"found fsidtype %d\\n\", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk(\"found fsid length %d\\n\", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk(\"Path seems to be <%s>\\n\", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk(\"Found the path %s\\n\", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n\t}\n\tcache_flush();\n out:\n\tif (ek)\n\t\tcache_put(&ek->h, cd);\n\tif (dom)\n\t\tauth_domain_put(dom);\n\tkfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "dom"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_put",
          "args": [
            "&ek->h",
            "cd"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_cache_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/overlayfs/readdir.c",
          "lines": "193-206",
          "snippet": "static void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/rbtree.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ovl_cache_put(struct ovl_dir_file *od, struct dentry *dentry)\n{\n\tstruct ovl_dir_cache *cache = od->cache;\n\n\tWARN_ON(cache->refcount <= 0);\n\tcache->refcount--;\n\tif (!cache->refcount) {\n\t\tif (ovl_dir_cache(dentry) == cache)\n\t\t\tovl_set_dir_cache(dentry, NULL);\n\n\t\tovl_cache_free(&cache->entries);\n\t\tkfree(cache);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_flush",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&key.ek_path"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_expkey_update",
          "args": [
            "cd",
            "&key",
            "ek"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "274-286",
          "snippet": "static struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
            "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\n\nstatic struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Found the path %s\\n\"",
            "buf"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "buf",
            "0",
            "&key.ek_path"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&key.h.flags"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Path seems to be <%s>\\n\"",
            "buf"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_lookup",
          "args": [
            "cd",
            "&key"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "261-272",
          "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key.ek_fsid",
            "buf",
            "len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_expiry",
          "args": [
            "&mesg"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fsidtype"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found fsid length %d\\n\"",
            "len"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found fsidtype %d\\n\"",
            "fsidtype"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "&ep",
            "10"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found domain %s\\n\"",
            "buf"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_find",
          "args": [
            "buf"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk(\"found domain %s\\n\", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk(\"found fsidtype %d\\n\", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk(\"found fsid length %d\\n\", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk(\"Path seems to be <%s>\\n\", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk(\"Found the path %s\\n\", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n\t}\n\tcache_flush();\n out:\n\tif (ek)\n\t\tcache_put(&ek->h, cd);\n\tif (dom)\n\t\tauth_domain_put(dom);\n\tkfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "expkey_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "51-64",
    "snippet": "static void expkey_request(struct cache_detail *cd,\n\t\t\t   struct cache_head *h,\n\t\t\t   char **bpp, int *blen)\n{\n\t/* client fsidtype \\xfsid */\n\tstruct svc_expkey *ek = container_of(h, struct svc_expkey, h);\n\tchar type[5];\n\n\tqword_add(bpp, blen, ek->ek_client->name);\n\tsnprintf(type, 5, \"%d\", ek->ek_fsidtype);\n\tqword_add(bpp, blen, type);\n\tqword_addhex(bpp, blen, (char*)ek->ek_fsid, key_len(ek->ek_fsidtype));\n\t(*bpp)[-1] = '\\n';\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qword_addhex",
          "args": [
            "bpp",
            "blen",
            "(char*)ek->ek_fsid",
            "key_len(ek->ek_fsidtype)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "ek->ek_fsidtype"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfsfh.h",
          "lines": "138-151",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "type"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "type",
            "5",
            "\"%d\"",
            "ek->ek_fsidtype"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "ek->ek_client->name"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_expkey",
            "h"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void expkey_request(struct cache_detail *cd,\n\t\t\t   struct cache_head *h,\n\t\t\t   char **bpp, int *blen)\n{\n\t/* client fsidtype \\xfsid */\n\tstruct svc_expkey *ek = container_of(h, struct svc_expkey, h);\n\tchar type[5];\n\n\tqword_add(bpp, blen, ek->ek_client->name);\n\tsnprintf(type, 5, \"%d\", ek->ek_fsidtype);\n\tqword_add(bpp, blen, type);\n\tqword_addhex(bpp, blen, (char*)ek->ek_fsid, key_len(ek->ek_fsidtype));\n\t(*bpp)[-1] = '\\n';\n}"
  },
  {
    "function_name": "expkey_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
    "lines": "40-49",
    "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "key->ek_client"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&key->ek_path"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&key->h.flags"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structsvc_expkey",
            "h.ref"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
  }
]