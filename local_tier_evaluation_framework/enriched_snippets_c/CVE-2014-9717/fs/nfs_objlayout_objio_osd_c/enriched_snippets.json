[
  {
    "function_name": "objlayout_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "665-671",
    "snippet": "static void __exit\nobjlayout_exit(void)\n{\n\tpnfs_unregister_layoutdriver(&objlayout_type);\n\tprintk(KERN_INFO \"NFS: %s: Unregistered OSD pNFS Layout Driver\\n\",\n\t       __func__);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type objlayout_type = {\n\t.id = LAYOUT_OSD2_OBJECTS,\n\t.name = \"LAYOUT_OSD2_OBJECTS\",\n\t.flags                   = PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t   PNFS_LAYOUTRET_ON_ERROR,\n\n\t.max_deviceinfo_size\t = PAGE_SIZE,\n\t.owner\t\t       \t = THIS_MODULE,\n\t.alloc_layout_hdr        = objlayout_alloc_layout_hdr,\n\t.free_layout_hdr         = objlayout_free_layout_hdr,\n\n\t.alloc_lseg              = objlayout_alloc_lseg,\n\t.free_lseg               = objlayout_free_lseg,\n\n\t.read_pagelist           = objlayout_read_pagelist,\n\t.write_pagelist          = objlayout_write_pagelist,\n\t.pg_read_ops             = &objio_pg_read_ops,\n\t.pg_write_ops            = &objio_pg_write_ops,\n\n\t.free_deviceid_node\t = objio_free_deviceid_node,\n\n\t.encode_layoutcommit\t = objlayout_encode_layoutcommit,\n\t.encode_layoutreturn     = objlayout_encode_layoutreturn,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFS: %s: Unregistered OSD pNFS Layout Driver\\n\"",
            "__func__"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_unregister_layoutdriver",
          "args": [
            "&objlayout_type"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_unregister_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "184-191",
          "snippet": "void\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\n\nvoid\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tdprintk(\"%s Deregistering id:%u\\n\", __func__, ld_type->id);\n\tspin_lock(&pnfs_spinlock);\n\tlist_del(&ld_type->pnfs_tblid);\n\tspin_unlock(&pnfs_spinlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layoutdriver_type objlayout_type = {\n\t.id = LAYOUT_OSD2_OBJECTS,\n\t.name = \"LAYOUT_OSD2_OBJECTS\",\n\t.flags                   = PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t   PNFS_LAYOUTRET_ON_ERROR,\n\n\t.max_deviceinfo_size\t = PAGE_SIZE,\n\t.owner\t\t       \t = THIS_MODULE,\n\t.alloc_layout_hdr        = objlayout_alloc_layout_hdr,\n\t.free_layout_hdr         = objlayout_free_layout_hdr,\n\n\t.alloc_lseg              = objlayout_alloc_lseg,\n\t.free_lseg               = objlayout_free_lseg,\n\n\t.read_pagelist           = objlayout_read_pagelist,\n\t.write_pagelist          = objlayout_write_pagelist,\n\t.pg_read_ops             = &objio_pg_read_ops,\n\t.pg_write_ops            = &objio_pg_write_ops,\n\n\t.free_deviceid_node\t = objio_free_deviceid_node,\n\n\t.encode_layoutcommit\t = objlayout_encode_layoutcommit,\n\t.encode_layoutreturn     = objlayout_encode_layoutreturn,\n};\n\nstatic void __exit\nobjlayout_exit(void)\n{\n\tpnfs_unregister_layoutdriver(&objlayout_type);\n\tprintk(KERN_INFO \"NFS: %s: Unregistered OSD pNFS Layout Driver\\n\",\n\t       __func__);\n}"
  },
  {
    "function_name": "objlayout_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "650-663",
    "snippet": "static int __init\nobjlayout_init(void)\n{\n\tint ret = pnfs_register_layoutdriver(&objlayout_type);\n\n\tif (ret)\n\t\tprintk(KERN_INFO\n\t\t\t\"NFS: %s: Registering OSD pNFS Layout Driver failed: error=%d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\tprintk(KERN_INFO \"NFS: %s: Registered OSD pNFS Layout Driver\\n\",\n\t\t\t__func__);\n\treturn ret;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct pnfs_layoutdriver_type objlayout_type = {\n\t.id = LAYOUT_OSD2_OBJECTS,\n\t.name = \"LAYOUT_OSD2_OBJECTS\",\n\t.flags                   = PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t   PNFS_LAYOUTRET_ON_ERROR,\n\n\t.max_deviceinfo_size\t = PAGE_SIZE,\n\t.owner\t\t       \t = THIS_MODULE,\n\t.alloc_layout_hdr        = objlayout_alloc_layout_hdr,\n\t.free_layout_hdr         = objlayout_free_layout_hdr,\n\n\t.alloc_lseg              = objlayout_alloc_lseg,\n\t.free_lseg               = objlayout_free_lseg,\n\n\t.read_pagelist           = objlayout_read_pagelist,\n\t.write_pagelist          = objlayout_write_pagelist,\n\t.pg_read_ops             = &objio_pg_read_ops,\n\t.pg_write_ops            = &objio_pg_write_ops,\n\n\t.free_deviceid_node\t = objio_free_deviceid_node,\n\n\t.encode_layoutcommit\t = objlayout_encode_layoutcommit,\n\t.encode_layoutreturn     = objlayout_encode_layoutreturn,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFS: %s: Registered OSD pNFS Layout Driver\\n\"",
            "__func__"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_register_layoutdriver",
          "args": [
            "&objlayout_type"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_register_layoutdriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "151-181",
          "snippet": "int\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(pnfs_spinlock);",
            "static LIST_HEAD(pnfs_modules_tbl);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nstatic DEFINE_SPINLOCK(pnfs_spinlock);\nstatic LIST_HEAD(pnfs_modules_tbl);\n\nint\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\n{\n\tint status = -EINVAL;\n\tstruct pnfs_layoutdriver_type *tmp;\n\n\tif (ld_type->id == 0) {\n\t\tprintk(KERN_ERR \"NFS: %s id 0 is reserved\\n\", __func__);\n\t\treturn status;\n\t}\n\tif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\n\t\tprintk(KERN_ERR \"NFS: %s Layout driver must provide \"\n\t\t       \"alloc_lseg and free_lseg.\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tspin_lock(&pnfs_spinlock);\n\ttmp = find_pnfs_driver_locked(ld_type->id);\n\tif (!tmp) {\n\t\tlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\n\t\tstatus = 0;\n\t\tdprintk(\"%s Registering id:%u name:%s\\n\", __func__, ld_type->id,\n\t\t\tld_type->name);\n\t} else {\n\t\tprintk(KERN_ERR \"NFS: %s Module with id %d already loaded!\\n\",\n\t\t\t__func__, ld_type->id);\n\t}\n\tspin_unlock(&pnfs_spinlock);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic struct pnfs_layoutdriver_type objlayout_type = {\n\t.id = LAYOUT_OSD2_OBJECTS,\n\t.name = \"LAYOUT_OSD2_OBJECTS\",\n\t.flags                   = PNFS_LAYOUTRET_ON_SETATTR |\n\t\t\t\t   PNFS_LAYOUTRET_ON_ERROR,\n\n\t.max_deviceinfo_size\t = PAGE_SIZE,\n\t.owner\t\t       \t = THIS_MODULE,\n\t.alloc_layout_hdr        = objlayout_alloc_layout_hdr,\n\t.free_layout_hdr         = objlayout_free_layout_hdr,\n\n\t.alloc_lseg              = objlayout_alloc_lseg,\n\t.free_lseg               = objlayout_free_lseg,\n\n\t.read_pagelist           = objlayout_read_pagelist,\n\t.write_pagelist          = objlayout_write_pagelist,\n\t.pg_read_ops             = &objio_pg_read_ops,\n\t.pg_write_ops            = &objio_pg_write_ops,\n\n\t.free_deviceid_node\t = objio_free_deviceid_node,\n\n\t.encode_layoutcommit\t = objlayout_encode_layoutcommit,\n\t.encode_layoutreturn     = objlayout_encode_layoutreturn,\n};\n\nstatic int __init\nobjlayout_init(void)\n{\n\tint ret = pnfs_register_layoutdriver(&objlayout_type);\n\n\tif (ret)\n\t\tprintk(KERN_INFO\n\t\t\t\"NFS: %s: Registering OSD pNFS Layout Driver failed: error=%d\\n\",\n\t\t\t__func__, ret);\n\telse\n\t\tprintk(KERN_INFO \"NFS: %s: Registered OSD pNFS Layout Driver\\n\",\n\t\t\t__func__);\n\treturn ret;\n}"
  },
  {
    "function_name": "objio_init_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "582-605",
    "snippet": "static void objio_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tunsigned long stripe_end = 0;\n\tu64 wb_size;\n\n\tif (pgio->pg_dreq == NULL)\n\t\twb_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\telse\n\t\twb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\tpnfs_generic_pg_init_write(pgio, req, wb_size);\n\tif (unlikely(pgio->pg_lseg == NULL))\n\t\treturn; /* Not pNFS */\n\n\tif (req->wb_offset ||\n\t    !aligned_on_raid_stripe(req->wb_index * PAGE_SIZE,\n\t\t\t       &OBJIO_LSEG(pgio->pg_lseg)->layout,\n\t\t\t       &stripe_end)) {\n\t\tpgio->pg_layout_private = (void *)stripe_end;\n\t} else {\n\t\tpgio->pg_layout_private = (void *)\n\t\t\t\tOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\n\t}\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OBJIO_LSEG",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "OBJIO_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "70-74",
          "snippet": "static inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aligned_on_raid_stripe",
          "args": [
            "req->wb_index * PAGE_SIZE",
            "&OBJIO_LSEG(pgio->pg_lseg)->layout",
            "&stripe_end"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "aligned_on_raid_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "562-580",
          "snippet": "static bool aligned_on_raid_stripe(u64 offset, struct ore_layout *layout,\n\t\t\t\t   unsigned long *stripe_end)\n{\n\tu32 stripe_off;\n\tunsigned stripe_size;\n\n\tif (layout->raid_algorithm == PNFS_OSD_RAID_0)\n\t\treturn true;\n\n\tstripe_size = layout->stripe_unit *\n\t\t\t\t(layout->group_width - layout->parity);\n\n\tdiv_u64_rem(offset, stripe_size, &stripe_off);\n\tif (!stripe_off)\n\t\treturn true;\n\n\t*stripe_end = stripe_size - stripe_off;\n\treturn false;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic bool aligned_on_raid_stripe(u64 offset, struct ore_layout *layout,\n\t\t\t\t   unsigned long *stripe_end)\n{\n\tu32 stripe_off;\n\tunsigned stripe_size;\n\n\tif (layout->raid_algorithm == PNFS_OSD_RAID_0)\n\t\treturn true;\n\n\tstripe_size = layout->stripe_unit *\n\t\t\t\t(layout->group_width - layout->parity);\n\n\tdiv_u64_rem(offset, stripe_size, &stripe_off);\n\tif (!stripe_off)\n\t\treturn true;\n\n\t*stripe_end = stripe_size - stripe_off;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgio->pg_lseg == NULL"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_pg_init_write",
          "args": [
            "pgio",
            "req",
            "wb_size"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_init_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1735-1749",
          "snippet": "void\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\n\t\t\t   struct nfs_page *req, u64 wb_size)\n{\n\tif (pgio->pg_lseg == NULL)\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   wb_size,\n\t\t\t\t\t\t   IOMODE_RW,\n\t\t\t\t\t\t   GFP_NOFS);\n\t/* If no lseg, fall back to write through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_write_mds(pgio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_dreq_bytes_left",
          "args": [
            "pgio->pg_dreq"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dreq_bytes_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "342-345",
          "snippet": "ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq)\n{\n\treturn dreq->bytes_left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "req_offset",
          "args": [
            "req"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "pgio->pg_inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void objio_init_write(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tunsigned long stripe_end = 0;\n\tu64 wb_size;\n\n\tif (pgio->pg_dreq == NULL)\n\t\twb_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\telse\n\t\twb_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\tpnfs_generic_pg_init_write(pgio, req, wb_size);\n\tif (unlikely(pgio->pg_lseg == NULL))\n\t\treturn; /* Not pNFS */\n\n\tif (req->wb_offset ||\n\t    !aligned_on_raid_stripe(req->wb_index * PAGE_SIZE,\n\t\t\t       &OBJIO_LSEG(pgio->pg_lseg)->layout,\n\t\t\t       &stripe_end)) {\n\t\tpgio->pg_layout_private = (void *)stripe_end;\n\t} else {\n\t\tpgio->pg_layout_private = (void *)\n\t\t\t\tOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\n\t}\n}"
  },
  {
    "function_name": "aligned_on_raid_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "562-580",
    "snippet": "static bool aligned_on_raid_stripe(u64 offset, struct ore_layout *layout,\n\t\t\t\t   unsigned long *stripe_end)\n{\n\tu32 stripe_off;\n\tunsigned stripe_size;\n\n\tif (layout->raid_algorithm == PNFS_OSD_RAID_0)\n\t\treturn true;\n\n\tstripe_size = layout->stripe_unit *\n\t\t\t\t(layout->group_width - layout->parity);\n\n\tdiv_u64_rem(offset, stripe_size, &stripe_off);\n\tif (!stripe_off)\n\t\treturn true;\n\n\t*stripe_end = stripe_size - stripe_off;\n\treturn false;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "offset",
            "stripe_size",
            "&stripe_off"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic bool aligned_on_raid_stripe(u64 offset, struct ore_layout *layout,\n\t\t\t\t   unsigned long *stripe_end)\n{\n\tu32 stripe_off;\n\tunsigned stripe_size;\n\n\tif (layout->raid_algorithm == PNFS_OSD_RAID_0)\n\t\treturn true;\n\n\tstripe_size = layout->stripe_unit *\n\t\t\t\t(layout->group_width - layout->parity);\n\n\tdiv_u64_rem(offset, stripe_size, &stripe_off);\n\tif (!stripe_off)\n\t\treturn true;\n\n\t*stripe_end = stripe_size - stripe_off;\n\treturn false;\n}"
  },
  {
    "function_name": "objio_init_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "552-560",
    "snippet": "static void objio_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tpnfs_generic_pg_init_read(pgio, req);\n\tif (unlikely(pgio->pg_lseg == NULL))\n\t\treturn; /* Not pNFS */\n\n\tpgio->pg_layout_private = (void *)\n\t\t\t\tOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OBJIO_LSEG",
          "args": [
            "pgio->pg_lseg"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "OBJIO_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "70-74",
          "snippet": "static inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pgio->pg_lseg == NULL"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_generic_pg_init_read",
          "args": [
            "pgio",
            "req"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_init_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1710-1732",
          "snippet": "void\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nvoid\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tu64 rd_size = req->wb_bytes;\n\n\tif (pgio->pg_lseg == NULL) {\n\t\tif (pgio->pg_dreq == NULL)\n\t\t\trd_size = i_size_read(pgio->pg_inode) - req_offset(req);\n\t\telse\n\t\t\trd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\n\n\t\tpgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\n\t\t\t\t\t\t   req->wb_context,\n\t\t\t\t\t\t   req_offset(req),\n\t\t\t\t\t\t   rd_size,\n\t\t\t\t\t\t   IOMODE_READ,\n\t\t\t\t\t\t   GFP_KERNEL);\n\t}\n\t/* If no lseg, fall back to read through mds */\n\tif (pgio->pg_lseg == NULL)\n\t\tnfs_pageio_reset_read_mds(pgio);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void objio_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\n{\n\tpnfs_generic_pg_init_read(pgio, req);\n\tif (unlikely(pgio->pg_lseg == NULL))\n\t\treturn; /* Not pNFS */\n\n\tpgio->pg_layout_private = (void *)\n\t\t\t\tOBJIO_LSEG(pgio->pg_lseg)->layout.max_io_length;\n}"
  },
  {
    "function_name": "objio_pg_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "537-550",
    "snippet": "static size_t objio_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t\t  struct nfs_page *prev, struct nfs_page *req)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(pgio);\n\tunsigned int size;\n\n\tsize = pnfs_generic_pg_test(pgio, prev, req);\n\n\tif (!size || mirror->pg_count + req->wb_bytes >\n\t    (unsigned long)pgio->pg_layout_private)\n\t\treturn 0;\n\n\treturn min(size, req->wb_bytes);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "size",
            "req->wb_bytes"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_generic_pg_test",
          "args": [
            "pgio",
            "prev",
            "req"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_generic_pg_test",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs.c",
          "lines": "1766-1811",
          "snippet": "size_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"delegation.h\"",
            "#include \"nfs4trace.h\"",
            "#include \"iostat.h\"",
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delegation.h\"\n#include \"nfs4trace.h\"\n#include \"iostat.h\"\n#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n\nsize_t\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t     struct nfs_page *prev, struct nfs_page *req)\n{\n\tunsigned int size;\n\tu64 seg_end, req_start, seg_left;\n\n\tsize = nfs_generic_pg_test(pgio, prev, req);\n\tif (!size)\n\t\treturn 0;\n\n\t/*\n\t * 'size' contains the number of bytes left in the current page (up\n\t * to the original size asked for in @req->wb_bytes).\n\t *\n\t * Calculate how many bytes are left in the layout segment\n\t * and if there are less bytes than 'size', return that instead.\n\t *\n\t * Please also note that 'end_offset' is actually the offset of the\n\t * first byte that lies outside the pnfs_layout_range. FIXME?\n\t *\n\t */\n\tif (pgio->pg_lseg) {\n\t\tseg_end = end_offset(pgio->pg_lseg->pls_range.offset,\n\t\t\t\t     pgio->pg_lseg->pls_range.length);\n\t\treq_start = req_offset(req);\n\t\tWARN_ON_ONCE(req_start >= seg_end);\n\t\t/* start of request is past the last byte of this segment */\n\t\tif (req_start >= seg_end) {\n\t\t\t/* reference the new lseg */\n\t\t\tif (pgio->pg_ops->pg_cleanup)\n\t\t\t\tpgio->pg_ops->pg_cleanup(pgio);\n\t\t\tif (pgio->pg_ops->pg_init)\n\t\t\t\tpgio->pg_ops->pg_init(pgio, req);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* adjust 'size' iff there are fewer bytes left in the\n\t\t * segment than what nfs_generic_pg_test returned */\n\t\tseg_left = seg_end - req_start;\n\t\tif (seg_left < size)\n\t\t\tsize = (unsigned int)seg_left;\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_pgio_current_mirror",
          "args": [
            "pgio"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_pgio_current_mirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pagelist.c",
          "lines": "45-51",
          "snippet": "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include <linux/export.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sched.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include <linux/export.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc)\n{\n\treturn nfs_pgio_has_mirroring(desc) ?\n\t\t&desc->pg_mirrors[desc->pg_mirror_idx] :\n\t\t&desc->pg_mirrors[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic size_t objio_pg_test(struct nfs_pageio_descriptor *pgio,\n\t\t\t  struct nfs_page *prev, struct nfs_page *req)\n{\n\tstruct nfs_pgio_mirror *mirror = nfs_pgio_current_mirror(pgio);\n\tunsigned int size;\n\n\tsize = pnfs_generic_pg_test(pgio, prev, req);\n\n\tif (!size || mirror->pg_count + req->wb_bytes >\n\t    (unsigned long)pgio->pg_layout_private)\n\t\treturn 0;\n\n\treturn min(size, req->wb_bytes);\n}"
  },
  {
    "function_name": "objio_write_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "501-531",
    "snippet": "int objio_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, false,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr, GFP_NOFS,\n\t\t\t&objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->sync = 0 != (how & FLUSH_SYNC);\n\tobjios->ios->r4w = &_r4w_op;\n\n\tif (!objios->sync)\n\t\tobjios->ios->done = _write_done;\n\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_write(objios->ios);\n\tif (unlikely(ret)) {\n\t\tobjio_free_result(&objios->oir);\n\t\treturn ret;\n\t}\n\n\tif (objios->sync)\n\t\t_write_done(objios->ios, objios);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_write_done",
          "args": [
            "objios->ios",
            "objios"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "_write_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "434-452",
          "snippet": "static void _write_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret)) {\n\t\t/* FIXME: should be based on the OSD's persistence model\n\t\t * See OSD2r05 Section 4.13 Data persistence model */\n\t\tobjios->oir.committed = NFS_FILE_SYNC;\n\t\tstatus = ios->length;\n\t} else {\n\t\tstatus = ret;\n\t}\n\n\tobjlayout_write_done(&objios->oir, status, objios->sync);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void _write_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret)) {\n\t\t/* FIXME: should be based on the OSD's persistence model\n\t\t * See OSD2r05 Section 4.13 Data persistence model */\n\t\tobjios->oir.committed = NFS_FILE_SYNC;\n\t\tstatus = ios->length;\n\t} else {\n\t\tstatus = ret;\n\t}\n\n\tobjlayout_write_done(&objios->oir, status, objios->sync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "objio_free_result",
          "args": [
            "&objios->oir"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "332-338",
          "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_write",
          "args": [
            "objios->ios"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: offset=0x%llx length=0x%x\\n\"",
            "__func__",
            "hdr->args.offset",
            "hdr->args.count"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objio_alloc_io_state",
          "args": [
            "NFS_I(hdr->inode)->layout",
            "false",
            "hdr->lseg",
            "hdr->args.pages",
            "hdr->args.pgbase",
            "hdr->args.offset",
            "hdr->args.count",
            "hdr",
            "GFP_NOFS",
            "&objios"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "objio_alloc_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "293-330",
          "snippet": "static int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "hdr->inode"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic const struct _ore_r4w_op _r4w_op = {\n\t.get_page = &__r4w_get_page,\n\t.put_page = &__r4w_put_page,\n};\n\nint objio_write_pagelist(struct nfs_pgio_header *hdr, int how)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, false,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr, GFP_NOFS,\n\t\t\t&objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->sync = 0 != (how & FLUSH_SYNC);\n\tobjios->ios->r4w = &_r4w_op;\n\n\tif (!objios->sync)\n\t\tobjios->ios->done = _write_done;\n\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_write(objios->ios);\n\tif (unlikely(ret)) {\n\t\tobjio_free_result(&objios->oir);\n\t\treturn ret;\n\t}\n\n\tif (objios->sync)\n\t\t_write_done(objios->ios, objios);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__r4w_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "487-494",
    "snippet": "static void __r4w_put_page(void *priv, struct page *page)\n{\n\tdprintk(\"%s: index=0x%lx\\n\", __func__,\n\t\t(page == ZERO_PAGE(0)) ? -1UL : page->index);\n\tif (ZERO_PAGE(0) != page)\n\t\tpage_cache_release(page);\n\treturn;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: index=0x%lx\\n\"",
            "__func__",
            "(page == ZERO_PAGE(0)) ? -1UL : page->index"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void __r4w_put_page(void *priv, struct page *page)\n{\n\tdprintk(\"%s: index=0x%lx\\n\", __func__,\n\t\t(page == ZERO_PAGE(0)) ? -1UL : page->index);\n\tif (ZERO_PAGE(0) != page)\n\t\tpage_cache_release(page);\n\treturn;\n}"
  },
  {
    "function_name": "__r4w_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "454-485",
    "snippet": "static struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\n{\n\tstruct objio_state *objios = priv;\n\tstruct nfs_pgio_header *hdr = objios->oir.rpcdata;\n\tstruct address_space *mapping = hdr->inode->i_mapping;\n\tpgoff_t index = offset / PAGE_SIZE;\n\tstruct page *page;\n\tloff_t i_size = i_size_read(hdr->inode);\n\n\tif (offset >= i_size) {\n\t\t*uptodate = true;\n\t\tdprintk(\"%s: g_zero_page index=0x%lx\\n\", __func__, index);\n\t\treturn ZERO_PAGE(0);\n\t}\n\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\tdprintk(\"%s: grab_cache_page Failed index=0x%lx\\n\",\n\t\t\t\t__func__, index);\n\t\t\treturn NULL;\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tif (PageDirty(page) || PageWriteback(page))\n\t\t*uptodate = true;\n\telse\n\t\t*uptodate = PageUptodate(page);\n\tdprintk(\"%s: index=0x%lx uptodate=%d\\n\", __func__, index, *uptodate);\n\treturn page;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: index=0x%lx uptodate=%d\\n\"",
            "__func__",
            "index",
            "*uptodate"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: grab_cache_page Failed index=0x%lx\\n\"",
            "__func__",
            "index"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: g_zero_page index=0x%lx\\n\"",
            "__func__",
            "index"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "hdr->inode"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)\n{\n\tstruct objio_state *objios = priv;\n\tstruct nfs_pgio_header *hdr = objios->oir.rpcdata;\n\tstruct address_space *mapping = hdr->inode->i_mapping;\n\tpgoff_t index = offset / PAGE_SIZE;\n\tstruct page *page;\n\tloff_t i_size = i_size_read(hdr->inode);\n\n\tif (offset >= i_size) {\n\t\t*uptodate = true;\n\t\tdprintk(\"%s: g_zero_page index=0x%lx\\n\", __func__, index);\n\t\treturn ZERO_PAGE(0);\n\t}\n\n\tpage = find_get_page(mapping, index);\n\tif (!page) {\n\t\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\tdprintk(\"%s: grab_cache_page Failed index=0x%lx\\n\",\n\t\t\t\t__func__, index);\n\t\t\treturn NULL;\n\t\t}\n\t\tunlock_page(page);\n\t}\n\tif (PageDirty(page) || PageWriteback(page))\n\t\t*uptodate = true;\n\telse\n\t\t*uptodate = PageUptodate(page);\n\tdprintk(\"%s: index=0x%lx uptodate=%d\\n\", __func__, index, *uptodate);\n\treturn page;\n}"
  },
  {
    "function_name": "_write_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "434-452",
    "snippet": "static void _write_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret)) {\n\t\t/* FIXME: should be based on the OSD's persistence model\n\t\t * See OSD2r05 Section 4.13 Data persistence model */\n\t\tobjios->oir.committed = NFS_FILE_SYNC;\n\t\tstatus = ios->length;\n\t} else {\n\t\tstatus = ret;\n\t}\n\n\tobjlayout_write_done(&objios->oir, status, objios->sync);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objlayout_write_done",
          "args": [
            "&objios->oir",
            "status",
            "objios->sync"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_write_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "323-347",
          "snippet": "void\nobjlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0) {\n\t\thdr->res.count = status;\n\t\thdr->verf.committed = oir->committed;\n\t} else {\n\t\thdr->pnfs_error = status;\n\t}\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status %zd committed %d sync=%d\\n\", __func__,\n\t\tstatus, hdr->verf.committed, sync);\n\n\tif (sync)\n\t\tpnfs_ld_write_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_write_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0) {\n\t\thdr->res.count = status;\n\t\thdr->verf.committed = oir->committed;\n\t} else {\n\t\thdr->pnfs_error = status;\n\t}\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status %zd committed %d sync=%d\\n\", __func__,\n\t\tstatus, hdr->verf.committed, sync);\n\n\tif (sync)\n\t\tpnfs_ld_write_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_write_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "ios",
            "&__on_dev_error"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void _write_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret)) {\n\t\t/* FIXME: should be based on the OSD's persistence model\n\t\t * See OSD2r05 Section 4.13 Data persistence model */\n\t\tobjios->oir.committed = NFS_FILE_SYNC;\n\t\tstatus = ios->length;\n\t} else {\n\t\tstatus = ret;\n\t}\n\n\tobjlayout_write_done(&objios->oir, status, objios->sync);\n}"
  },
  {
    "function_name": "objio_read_pagelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "410-429",
    "snippet": "int objio_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, true,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr,\n\t\t\tGFP_KERNEL, &objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->ios->done = _read_done;\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_read(objios->ios);\n\tif (unlikely(ret))\n\t\tobjio_free_result(&objios->oir);\n\treturn ret;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objio_free_result",
          "args": [
            "&objios->oir"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "objio_free_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "332-338",
          "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "objios->ios"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: offset=0x%llx length=0x%x\\n\"",
            "__func__",
            "hdr->args.offset",
            "hdr->args.count"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objio_alloc_io_state",
          "args": [
            "NFS_I(hdr->inode)->layout",
            "true",
            "hdr->lseg",
            "hdr->args.pages",
            "hdr->args.pgbase",
            "hdr->args.offset",
            "hdr->args.count",
            "hdr",
            "GFP_KERNEL",
            "&objios"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "objio_alloc_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "293-330",
          "snippet": "static int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_I",
          "args": [
            "hdr->inode"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nint objio_read_pagelist(struct nfs_pgio_header *hdr)\n{\n\tstruct objio_state *objios;\n\tint ret;\n\n\tret = objio_alloc_io_state(NFS_I(hdr->inode)->layout, true,\n\t\t\thdr->lseg, hdr->args.pages, hdr->args.pgbase,\n\t\t\thdr->args.offset, hdr->args.count, hdr,\n\t\t\tGFP_KERNEL, &objios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tobjios->ios->done = _read_done;\n\tdprintk(\"%s: offset=0x%llx length=0x%x\\n\", __func__,\n\t\thdr->args.offset, hdr->args.count);\n\tret = ore_read(objios->ios);\n\tif (unlikely(ret))\n\t\tobjio_free_result(&objios->oir);\n\treturn ret;\n}"
  },
  {
    "function_name": "_read_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "394-408",
    "snippet": "static void _read_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret))\n\t\tstatus = ios->length;\n\telse\n\t\tstatus = ret;\n\n\tobjlayout_read_done(&objios->oir, status, objios->sync);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objlayout_read_done",
          "args": [
            "&objios->oir",
            "status",
            "objios->sync"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_read_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "241-263",
          "snippet": "void\nobjlayout_read_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0)\n\t\thdr->res.count = status;\n\telse\n\t\thdr->pnfs_error = status;\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status=%zd eof=%d sync=%d\\n\", __func__,\n\t\tstatus, hdr->res.eof, sync);\n\n\tif (sync)\n\t\tpnfs_ld_read_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_read_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_read_done(struct objlayout_io_res *oir, ssize_t status, bool sync)\n{\n\tstruct nfs_pgio_header *hdr = oir->rpcdata;\n\n\toir->status = hdr->task.tk_status = status;\n\tif (status >= 0)\n\t\thdr->res.count = status;\n\telse\n\t\thdr->pnfs_error = status;\n\tobjlayout_iodone(oir);\n\t/* must not use oir after this point */\n\n\tdprintk(\"%s: Return status=%zd eof=%d sync=%d\\n\", __func__,\n\t\tstatus, hdr->res.eof, sync);\n\n\tif (sync)\n\t\tpnfs_ld_read_done(hdr);\n\telse {\n\t\tINIT_WORK(&hdr->task.u.tk_work, _rpc_read_complete);\n\t\tschedule_work(&hdr->task.u.tk_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_check_io",
          "args": [
            "ios",
            "&__on_dev_error"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ore_check_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "420-471",
          "snippet": "int ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_check_io(struct ore_io_state *ios, ore_on_dev_error on_dev_error)\n{\n\tenum osd_err_priority acumulated_osd_err = 0;\n\tint acumulated_lin_err = 0;\n\tint i;\n\n\tfor (i = 0; i < ios->numdevs; i++) {\n\t\tstruct osd_sense_info osi;\n\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\t\tstruct osd_request *or = per_dev->or;\n\t\tint ret;\n\n\t\tif (unlikely(!or))\n\t\t\tcontinue;\n\n\t\tret = osd_req_decode_sense(or, &osi);\n\t\tif (likely(!ret))\n\t\t\tcontinue;\n\n\t\tif ((OSD_ERR_PRI_CLEAR_PAGES == osi.osd_err_pri) &&\n\t\t    per_dev->bio) {\n\t\t\t/* start read offset passed endof file.\n\t\t\t * Note: if we do not have bio it means read-attributes\n\t\t\t * In this case we should return error to caller.\n\t\t\t */\n\t\t\t_clear_bio(per_dev->bio);\n\t\t\tORE_DBGMSG(\"start read offset passed end of file \"\n\t\t\t\t\"offset=0x%llx, length=0x%llx\\n\",\n\t\t\t\t_LLU(per_dev->offset),\n\t\t\t\t_LLU(per_dev->length));\n\n\t\t\tcontinue; /* we recovered */\n\t\t}\n\n\t\tif (on_dev_error) {\n\t\t\tu64 residual = ios->reading ?\n\t\t\t\t\tor->in.residual : or->out.residual;\n\t\t\tu64 offset = (ios->offset + ios->length) - residual;\n\t\t\tunsigned dev = per_dev->dev - ios->oc->first_dev;\n\t\t\tstruct ore_dev *od = ios->oc->ods[dev];\n\n\t\t\ton_dev_error(ios, od, dev, osi.osd_err_pri,\n\t\t\t\t     offset, residual);\n\t\t}\n\t\tif (osi.osd_err_pri >= acumulated_osd_err) {\n\t\t\tacumulated_osd_err = osi.osd_err_pri;\n\t\t\tacumulated_lin_err = ret;\n\t\t}\n\t}\n\n\treturn acumulated_lin_err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void _read_done(struct ore_io_state *ios, void *private)\n{\n\tstruct objio_state *objios = private;\n\tssize_t status;\n\tint ret = ore_check_io(ios, &__on_dev_error);\n\n\t/* FIXME: _io_free(ios) can we dealocate the libosd resources; */\n\n\tif (likely(!ret))\n\t\tstatus = ios->length;\n\telse\n\t\tstatus = ret;\n\n\tobjlayout_read_done(&objios->oir, status, objios->sync);\n}"
  },
  {
    "function_name": "__on_dev_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "370-389",
    "snippet": "static void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "objlayout_io_set_result",
          "args": [
            "&objios->oir",
            "comp",
            "&pooid",
            "osd_pri_2_pnfs_err(oep)",
            "dev_offset",
            "dev_len",
            "!ios->reading"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_io_set_result",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "194-223",
          "snippet": "void\nobjlayout_io_set_result(struct objlayout_io_res *oir, unsigned index,\n\t\t\tstruct pnfs_osd_objid *pooid, int osd_error,\n\t\t\tu64 offset, u64 length, bool is_write)\n{\n\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[index];\n\n\tBUG_ON(index >= oir->num_comps);\n\tif (osd_error) {\n\t\tioerr->oer_component = *pooid;\n\t\tioerr->oer_comp_offset = offset;\n\t\tioerr->oer_comp_length = length;\n\t\tioerr->oer_iswrite = is_write;\n\t\tioerr->oer_errno = osd_error;\n\n\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d dev(%llx:%llx) \"\n\t\t\t\"par=0x%llx obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t__func__, index, ioerr->oer_errno,\n\t\t\tioerr->oer_iswrite,\n\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\tioerr->oer_component.oid_object_id,\n\t\t\tioerr->oer_comp_offset,\n\t\t\tioerr->oer_comp_length);\n\t} else {\n\t\t/* User need not call if no error is reported */\n\t\tioerr->oer_errno = 0;\n\t}\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nvoid\nobjlayout_io_set_result(struct objlayout_io_res *oir, unsigned index,\n\t\t\tstruct pnfs_osd_objid *pooid, int osd_error,\n\t\t\tu64 offset, u64 length, bool is_write)\n{\n\tstruct pnfs_osd_ioerr *ioerr = &oir->ioerrs[index];\n\n\tBUG_ON(index >= oir->num_comps);\n\tif (osd_error) {\n\t\tioerr->oer_component = *pooid;\n\t\tioerr->oer_comp_offset = offset;\n\t\tioerr->oer_comp_length = length;\n\t\tioerr->oer_iswrite = is_write;\n\t\tioerr->oer_errno = osd_error;\n\n\t\tdprintk(\"%s: err[%d]: errno=%d is_write=%d dev(%llx:%llx) \"\n\t\t\t\"par=0x%llx obj=0x%llx offset=0x%llx length=0x%llx\\n\",\n\t\t\t__func__, index, ioerr->oer_errno,\n\t\t\tioerr->oer_iswrite,\n\t\t\t_DEVID_LO(&ioerr->oer_component.oid_device_id),\n\t\t\t_DEVID_HI(&ioerr->oer_component.oid_device_id),\n\t\t\tioerr->oer_component.oid_partition_id,\n\t\t\tioerr->oer_component.oid_object_id,\n\t\t\tioerr->oer_comp_offset,\n\t\t\tioerr->oer_comp_length);\n\t} else {\n\t\t/* User need not call if no error is reported */\n\t\tioerr->oer_errno = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "osd_pri_2_pnfs_err",
          "args": [
            "oep"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "osd_pri_2_pnfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "340-368",
          "snippet": "static enum pnfs_osd_errno osd_pri_2_pnfs_err(enum osd_err_priority oep)\n{\n\tswitch (oep) {\n\tcase OSD_ERR_PRI_NO_ERROR:\n\t\treturn (enum pnfs_osd_errno)0;\n\n\tcase OSD_ERR_PRI_CLEAR_PAGES:\n\t\tBUG_ON(1);\n\t\treturn 0;\n\n\tcase OSD_ERR_PRI_RESOURCE:\n\t\treturn PNFS_OSD_ERR_RESOURCE;\n\tcase OSD_ERR_PRI_BAD_CRED:\n\t\treturn PNFS_OSD_ERR_BAD_CRED;\n\tcase OSD_ERR_PRI_NO_ACCESS:\n\t\treturn PNFS_OSD_ERR_NO_ACCESS;\n\tcase OSD_ERR_PRI_UNREACHABLE:\n\t\treturn PNFS_OSD_ERR_UNREACHABLE;\n\tcase OSD_ERR_PRI_NOT_FOUND:\n\t\treturn PNFS_OSD_ERR_NOT_FOUND;\n\tcase OSD_ERR_PRI_NO_SPACE:\n\t\treturn PNFS_OSD_ERR_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase OSD_ERR_PRI_EIO:\n\t\treturn PNFS_OSD_ERR_EIO;\n\t}\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic enum pnfs_osd_errno osd_pri_2_pnfs_err(enum osd_err_priority oep)\n{\n\tswitch (oep) {\n\tcase OSD_ERR_PRI_NO_ERROR:\n\t\treturn (enum pnfs_osd_errno)0;\n\n\tcase OSD_ERR_PRI_CLEAR_PAGES:\n\t\tBUG_ON(1);\n\t\treturn 0;\n\n\tcase OSD_ERR_PRI_RESOURCE:\n\t\treturn PNFS_OSD_ERR_RESOURCE;\n\tcase OSD_ERR_PRI_BAD_CRED:\n\t\treturn PNFS_OSD_ERR_BAD_CRED;\n\tcase OSD_ERR_PRI_NO_ACCESS:\n\t\treturn PNFS_OSD_ERR_NO_ACCESS;\n\tcase OSD_ERR_PRI_UNREACHABLE:\n\t\treturn PNFS_OSD_ERR_UNREACHABLE;\n\tcase OSD_ERR_PRI_NOT_FOUND:\n\t\treturn PNFS_OSD_ERR_NOT_FOUND;\n\tcase OSD_ERR_PRI_NO_SPACE:\n\t\treturn PNFS_OSD_ERR_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase OSD_ERR_PRI_EIO:\n\t\treturn PNFS_OSD_ERR_EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "od",
            "typeof(*ode)",
            "od"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ode"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void __on_dev_error(struct ore_io_state *ios,\n\tstruct ore_dev *od, unsigned dev_index, enum osd_err_priority oep,\n\tu64 dev_offset, u64  dev_len)\n{\n\tstruct objio_state *objios = ios->private;\n\tstruct pnfs_osd_objid pooid;\n\tstruct objio_dev_ent *ode = container_of(od, typeof(*ode), od);\n\t/* FIXME: what to do with more-then-one-group layouts. We need to\n\t * translate from ore_io_state index to oc->comps index\n\t */\n\tunsigned comp = dev_index;\n\n\tpooid.oid_device_id = ode->id_node.deviceid;\n\tpooid.oid_partition_id = ios->oc->comps[comp].obj.partition;\n\tpooid.oid_object_id = ios->oc->comps[comp].obj.id;\n\n\tobjlayout_io_set_result(&objios->oir, comp,\n\t\t\t\t&pooid, osd_pri_2_pnfs_err(oep),\n\t\t\t\tdev_offset, dev_len, !ios->reading);\n}"
  },
  {
    "function_name": "osd_pri_2_pnfs_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "340-368",
    "snippet": "static enum pnfs_osd_errno osd_pri_2_pnfs_err(enum osd_err_priority oep)\n{\n\tswitch (oep) {\n\tcase OSD_ERR_PRI_NO_ERROR:\n\t\treturn (enum pnfs_osd_errno)0;\n\n\tcase OSD_ERR_PRI_CLEAR_PAGES:\n\t\tBUG_ON(1);\n\t\treturn 0;\n\n\tcase OSD_ERR_PRI_RESOURCE:\n\t\treturn PNFS_OSD_ERR_RESOURCE;\n\tcase OSD_ERR_PRI_BAD_CRED:\n\t\treturn PNFS_OSD_ERR_BAD_CRED;\n\tcase OSD_ERR_PRI_NO_ACCESS:\n\t\treturn PNFS_OSD_ERR_NO_ACCESS;\n\tcase OSD_ERR_PRI_UNREACHABLE:\n\t\treturn PNFS_OSD_ERR_UNREACHABLE;\n\tcase OSD_ERR_PRI_NOT_FOUND:\n\t\treturn PNFS_OSD_ERR_NOT_FOUND;\n\tcase OSD_ERR_PRI_NO_SPACE:\n\t\treturn PNFS_OSD_ERR_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase OSD_ERR_PRI_EIO:\n\t\treturn PNFS_OSD_ERR_EIO;\n\t}\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic enum pnfs_osd_errno osd_pri_2_pnfs_err(enum osd_err_priority oep)\n{\n\tswitch (oep) {\n\tcase OSD_ERR_PRI_NO_ERROR:\n\t\treturn (enum pnfs_osd_errno)0;\n\n\tcase OSD_ERR_PRI_CLEAR_PAGES:\n\t\tBUG_ON(1);\n\t\treturn 0;\n\n\tcase OSD_ERR_PRI_RESOURCE:\n\t\treturn PNFS_OSD_ERR_RESOURCE;\n\tcase OSD_ERR_PRI_BAD_CRED:\n\t\treturn PNFS_OSD_ERR_BAD_CRED;\n\tcase OSD_ERR_PRI_NO_ACCESS:\n\t\treturn PNFS_OSD_ERR_NO_ACCESS;\n\tcase OSD_ERR_PRI_UNREACHABLE:\n\t\treturn PNFS_OSD_ERR_UNREACHABLE;\n\tcase OSD_ERR_PRI_NOT_FOUND:\n\t\treturn PNFS_OSD_ERR_NOT_FOUND;\n\tcase OSD_ERR_PRI_NO_SPACE:\n\t\treturn PNFS_OSD_ERR_NO_SPACE;\n\tdefault:\n\t\tWARN_ON(1);\n\t\t/* fallthrough */\n\tcase OSD_ERR_PRI_EIO:\n\t\treturn PNFS_OSD_ERR_EIO;\n\t}\n}"
  },
  {
    "function_name": "objio_free_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "332-338",
    "snippet": "void objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "objios"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "objios->ios"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "oir",
            "structobjio_state",
            "oir"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_result(struct objlayout_io_res *oir)\n{\n\tstruct objio_state *objios = container_of(oir, struct objio_state, oir);\n\n\tore_put_io_state(objios->ios);\n\tkfree(objios);\n}"
  },
  {
    "function_name": "objio_alloc_io_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "293-330",
    "snippet": "static int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aos"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_rw_state",
          "args": [
            "&objio_seg->layout",
            "&objio_seg->oc",
            "is_reading",
            "offset",
            "count",
            "&ios"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_rw_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "242-301",
          "snippet": "int  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_rw_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      bool is_reading, u64 offset, u64 length,\n\t\t      struct ore_io_state **pios)\n{\n\tstruct ore_io_state *ios;\n\tunsigned numdevs = layout->group_width * layout->mirrors_p1;\n\tunsigned sgs_per_dev = 0, max_par_pages = 0;\n\tint ret;\n\n\tif (layout->parity && length) {\n\t\tunsigned data_devs = layout->group_width - layout->parity;\n\t\tunsigned stripe_size = layout->stripe_unit * data_devs;\n\t\tunsigned pages_in_unit = layout->stripe_unit / PAGE_SIZE;\n\t\tu32 remainder;\n\t\tu64 num_stripes;\n\t\tu64 num_raid_units;\n\n\t\tnum_stripes = div_u64_rem(length, stripe_size, &remainder);\n\t\tif (remainder)\n\t\t\t++num_stripes;\n\n\t\tnum_raid_units =  num_stripes * layout->parity;\n\n\t\tif (is_reading) {\n\t\t\t/* For reads add per_dev sglist array */\n\t\t\t/* TODO: Raid 6 we need twice more. Actually:\n\t\t\t*         num_stripes / LCMdP(W,P);\n\t\t\t*         if (W%P != 0) num_stripes *= parity;\n\t\t\t*/\n\n\t\t\t/* first/last seg is split */\n\t\t\tnum_raid_units += layout->group_width;\n\t\t\tsgs_per_dev = div_u64(num_raid_units, data_devs) + 2;\n\t\t} else {\n\t\t\t/* For Writes add parity pages array. */\n\t\t\tmax_par_pages = num_raid_units * pages_in_unit *\n\t\t\t\t\t\tsizeof(struct page *);\n\t\t}\n\t}\n\n\tret = _ore_get_io_state(layout, oc, numdevs, sgs_per_dev, max_par_pages,\n\t\t\t\tpios);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tios = *pios;\n\tios->reading = is_reading;\n\tios->offset = offset;\n\n\tif (length) {\n\t\tore_calc_stripe_info(layout, offset, length, &ios->si);\n\t\tios->length = ios->si.length;\n\t\tios->nr_pages = ((ios->offset & (PAGE_SIZE - 1)) +\n\t\t\t\t ios->length + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tif (layout->parity)\n\t\t\t_ore_post_alloc_raid_stuff(ios);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "objlayout_init_ioerrs",
          "args": [
            "&aos->objios.oir",
            "objio_seg->oc.numdevs",
            "aos->ioerrs",
            "rpcdata",
            "pnfs_layout_type"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_init_ioerrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.h",
          "lines": "95-105",
          "snippet": "static inline\nvoid objlayout_init_ioerrs(struct objlayout_io_res *oir, unsigned num_comps,\n\t\t\tstruct pnfs_osd_ioerr *ioerrs, void *rpcdata,\n\t\t\tstruct pnfs_layout_hdr *pnfs_layout_type)\n{\n\toir->objlay = OBJLAYOUT(pnfs_layout_type);\n\toir->rpcdata = rpcdata;\n\tINIT_LIST_HEAD(&oir->err_list);\n\toir->num_comps = num_comps;\n\toir->ioerrs = ioerrs;\n}",
          "includes": [
            "#include \"../pnfs.h\"",
            "#include <linux/pnfs_osd_xdr.h>",
            "#include <linux/nfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../pnfs.h\"\n#include <linux/pnfs_osd_xdr.h>\n#include <linux/nfs_fs.h>\n\nstatic inline\nvoid objlayout_init_ioerrs(struct objlayout_io_res *oir, unsigned num_comps,\n\t\t\tstruct pnfs_osd_ioerr *ioerrs, void *rpcdata,\n\t\t\tstruct pnfs_layout_hdr *pnfs_layout_type)\n{\n\toir->objlay = OBJLAYOUT(pnfs_layout_type);\n\toir->rpcdata = rpcdata;\n\tINIT_LIST_HEAD(&oir->err_list);\n\toir->num_comps = num_comps;\n\toir->ioerrs = ioerrs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!aos"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aos)",
            "gfp_flags"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJIO_LSEG",
          "args": [
            "lseg"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "OBJIO_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "70-74",
          "snippet": "static inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic int\nobjio_alloc_io_state(struct pnfs_layout_hdr *pnfs_layout_type, bool is_reading,\n\tstruct pnfs_layout_segment *lseg, struct page **pages, unsigned pgbase,\n\tloff_t offset, size_t count, void *rpcdata, gfp_t gfp_flags,\n\tstruct objio_state **outp)\n{\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\tstruct ore_io_state *ios;\n\tint ret;\n\tstruct __alloc_objio_state {\n\t\tstruct objio_state objios;\n\t\tstruct pnfs_osd_ioerr ioerrs[objio_seg->oc.numdevs];\n\t} *aos;\n\n\taos = kzalloc(sizeof(*aos), gfp_flags);\n\tif (unlikely(!aos))\n\t\treturn -ENOMEM;\n\n\tobjlayout_init_ioerrs(&aos->objios.oir, objio_seg->oc.numdevs,\n\t\t\taos->ioerrs, rpcdata, pnfs_layout_type);\n\n\tret = ore_get_rw_state(&objio_seg->layout, &objio_seg->oc, is_reading,\n\t\t\t       offset, count, &ios);\n\tif (unlikely(ret)) {\n\t\tkfree(aos);\n\t\treturn ret;\n\t}\n\n\tios->pages = pages;\n\tios->pgbase = pgbase;\n\tios->private = aos;\n\tBUG_ON(ios->nr_pages > (pgbase + count + PAGE_SIZE - 1) >> PAGE_SHIFT);\n\n\taos->objios.sync = 0;\n\taos->objios.ios = ios;\n\t*outp = &aos->objios;\n\treturn 0;\n}"
  },
  {
    "function_name": "objio_free_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "276-291",
    "snippet": "void objio_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tint i;\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\n\tfor (i = 0; i < objio_seg->oc.numdevs; i++) {\n\t\tstruct ore_dev *od = objio_seg->oc.ods[i];\n\t\tstruct objio_dev_ent *ode;\n\n\t\tif (!od)\n\t\t\tbreak;\n\t\tode = container_of(od, typeof(*ode), od);\n\t\tnfs4_put_deviceid_node(&ode->id_node);\n\t}\n\tkfree(objio_seg);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "objio_seg"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deviceid_node",
          "args": [
            "&ode->id_node"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "271-278",
          "snippet": "bool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nbool\nnfs4_put_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tif (!atomic_dec_and_test(&d->ref))\n\t\treturn false;\n\td->ld->free_deviceid_node(d);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "od",
            "typeof(*ode)",
            "od"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ode"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OBJIO_LSEG",
          "args": [
            "lseg"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "OBJIO_LSEG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "70-74",
          "snippet": "static inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nvoid objio_free_lseg(struct pnfs_layout_segment *lseg)\n{\n\tint i;\n\tstruct objio_segment *objio_seg = OBJIO_LSEG(lseg);\n\n\tfor (i = 0; i < objio_seg->oc.numdevs; i++) {\n\t\tstruct ore_dev *od = objio_seg->oc.ods[i];\n\t\tstruct objio_dev_ent *ode;\n\n\t\tif (!od)\n\t\t\tbreak;\n\t\tode = container_of(od, typeof(*ode), od);\n\t\tnfs4_put_deviceid_node(&ode->id_node);\n\t}\n\tkfree(objio_seg);\n}"
  },
  {
    "function_name": "objio_alloc_lseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "210-274",
    "snippet": "int objio_alloc_lseg(struct pnfs_layout_segment **outp,\n\tstruct pnfs_layout_hdr *pnfslay,\n\tstruct pnfs_layout_range *range,\n\tstruct xdr_stream *xdr,\n\tgfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(pnfslay->plh_inode);\n\tstruct objio_segment *objio_seg;\n\tstruct pnfs_osd_xdr_decode_layout_iter iter;\n\tstruct pnfs_osd_layout layout;\n\tstruct pnfs_osd_object_cred src_comp;\n\tunsigned cur_comp;\n\tint err;\n\n\terr = pnfs_osd_xdr_decode_layout_map(&layout, &iter, xdr);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = __alloc_objio_seg(layout.olo_num_comps, gfp_flags, &objio_seg);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tobjio_seg->layout.stripe_unit = layout.olo_map.odm_stripe_unit;\n\tobjio_seg->layout.group_width = layout.olo_map.odm_group_width;\n\tobjio_seg->layout.group_depth = layout.olo_map.odm_group_depth;\n\tobjio_seg->layout.mirrors_p1 = layout.olo_map.odm_mirror_cnt + 1;\n\tobjio_seg->layout.raid_algorithm = layout.olo_map.odm_raid_algorithm;\n\n\terr = ore_verify_layout(layout.olo_map.odm_num_comps,\n\t\t\t\t\t  &objio_seg->layout);\n\tif (unlikely(err))\n\t\tgoto err;\n\n\tobjio_seg->oc.first_dev = layout.olo_comps_index;\n\tcur_comp = 0;\n\twhile (pnfs_osd_xdr_decode_layout_comp(&src_comp, &iter, xdr, &err)) {\n\t\tstruct nfs4_deviceid_node *d;\n\t\tstruct objio_dev_ent *ode;\n\n\t\tcopy_single_comp(&objio_seg->oc, cur_comp, &src_comp);\n\n\t\td = nfs4_find_get_deviceid(server,\n\t\t\t\t&src_comp.oc_object_id.oid_device_id,\n\t\t\t\tpnfslay->plh_lc_cred, gfp_flags);\n\t\tif (!d) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tode = container_of(d, struct objio_dev_ent, id_node);\n\t\tobjio_seg->oc.ods[cur_comp++] = &ode->od;\n\t}\n\t/* pnfs_osd_xdr_decode_layout_comp returns false on error */\n\tif (unlikely(err))\n\t\tgoto err;\n\n\t*outp = &objio_seg->lseg;\n\treturn 0;\n\nerr:\n\tkfree(objio_seg);\n\tdprintk(\"%s: Error: return %d\\n\", __func__, err);\n\t*outp = NULL;\n\treturn err;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Error: return %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "objio_seg"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "d",
            "structobjio_dev_ent",
            "id_node"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_find_get_deviceid",
          "args": [
            "server",
            "&src_comp.oc_object_id.oid_device_id",
            "pnfslay->plh_lc_cred",
            "gfp_flags"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_get_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "184-212",
          "snippet": "struct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfs4_deviceid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head nfs4_deviceid_cache[NFS4_DEVICE_ID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfs4_deviceid_lock);\n\nstruct nfs4_deviceid_node *\nnfs4_find_get_deviceid(struct nfs_server *server,\n\t\tconst struct nfs4_deviceid *id, struct rpc_cred *cred,\n\t\tgfp_t gfp_mask)\n{\n\tlong hash = nfs4_deviceid_hash(id);\n\tstruct nfs4_deviceid_node *d, *new;\n\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d)\n\t\treturn d;\n\n\tnew = nfs4_get_device_info(server, id, cred, gfp_mask);\n\tif (!new)\n\t\treturn new;\n\n\tspin_lock(&nfs4_deviceid_lock);\n\td = __nfs4_find_get_deviceid(server, id, hash);\n\tif (d) {\n\t\tspin_unlock(&nfs4_deviceid_lock);\n\t\tserver->pnfs_curr_ld->free_deviceid_node(new);\n\t\treturn d;\n\t}\n\thlist_add_head_rcu(&new->node, &nfs4_deviceid_cache[hash]);\n\tatomic_inc(&new->ref);\n\tspin_unlock(&nfs4_deviceid_lock);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_single_comp",
          "args": [
            "&objio_seg->oc",
            "cur_comp",
            "&src_comp"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "copy_single_comp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "160-172",
          "snippet": "static void copy_single_comp(struct ore_components *oc, unsigned c,\n\t\t\t     struct pnfs_osd_object_cred *src_comp)\n{\n\tstruct ore_comp *ocomp = &oc->comps[c];\n\n\tWARN_ON(src_comp->oc_cap_key.cred_len > 0); /* libosd is NO_SEC only */\n\tWARN_ON(src_comp->oc_cap.cred_len > sizeof(ocomp->cred));\n\n\tocomp->obj.partition = src_comp->oc_object_id.oid_partition_id;\n\tocomp->obj.id = src_comp->oc_object_id.oid_object_id;\n\n\tmemcpy(ocomp->cred, src_comp->oc_cap.cred, sizeof(ocomp->cred));\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void copy_single_comp(struct ore_components *oc, unsigned c,\n\t\t\t     struct pnfs_osd_object_cred *src_comp)\n{\n\tstruct ore_comp *ocomp = &oc->comps[c];\n\n\tWARN_ON(src_comp->oc_cap_key.cred_len > 0); /* libosd is NO_SEC only */\n\tWARN_ON(src_comp->oc_cap.cred_len > sizeof(ocomp->cred));\n\n\tocomp->obj.partition = src_comp->oc_object_id.oid_partition_id;\n\tocomp->obj.id = src_comp->oc_object_id.oid_object_id;\n\n\tmemcpy(ocomp->cred, src_comp->oc_cap.cred, sizeof(ocomp->cred));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_decode_layout_comp",
          "args": [
            "&src_comp",
            "&iter",
            "xdr",
            "&err"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_decode_layout_comp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "180-206",
          "snippet": "bool pnfs_osd_xdr_decode_layout_comp(struct pnfs_osd_object_cred *comp,\n\tstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr,\n\tint *err)\n{\n\tBUG_ON(iter->decoded_comps > iter->total_comps);\n\tif (iter->decoded_comps == iter->total_comps)\n\t\treturn false;\n\n\t*err = _osd_xdr_decode_object_cred(comp, xdr);\n\tif (unlikely(*err)) {\n\t\tdprintk(\"%s: _osd_xdr_decode_object_cred=>%d decoded_comps=%d \"\n\t\t\t\"total_comps=%d\\n\", __func__, *err,\n\t\t\titer->decoded_comps, iter->total_comps);\n\t\treturn false; /* stop the loop */\n\t}\n\tdprintk(\"%s: dev(%llx:%llx) par=0x%llx obj=0x%llx \"\n\t\t\"key_len=%u cap_len=%u\\n\",\n\t\t__func__,\n\t\t_DEVID_LO(&comp->oc_object_id.oid_device_id),\n\t\t_DEVID_HI(&comp->oc_object_id.oid_device_id),\n\t\tcomp->oc_object_id.oid_partition_id,\n\t\tcomp->oc_object_id.oid_object_id,\n\t\tcomp->oc_cap_key.cred_len, comp->oc_cap.cred_len);\n\n\titer->decoded_comps++;\n\treturn true;\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nbool pnfs_osd_xdr_decode_layout_comp(struct pnfs_osd_object_cred *comp,\n\tstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr,\n\tint *err)\n{\n\tBUG_ON(iter->decoded_comps > iter->total_comps);\n\tif (iter->decoded_comps == iter->total_comps)\n\t\treturn false;\n\n\t*err = _osd_xdr_decode_object_cred(comp, xdr);\n\tif (unlikely(*err)) {\n\t\tdprintk(\"%s: _osd_xdr_decode_object_cred=>%d decoded_comps=%d \"\n\t\t\t\"total_comps=%d\\n\", __func__, *err,\n\t\t\titer->decoded_comps, iter->total_comps);\n\t\treturn false; /* stop the loop */\n\t}\n\tdprintk(\"%s: dev(%llx:%llx) par=0x%llx obj=0x%llx \"\n\t\t\"key_len=%u cap_len=%u\\n\",\n\t\t__func__,\n\t\t_DEVID_LO(&comp->oc_object_id.oid_device_id),\n\t\t_DEVID_HI(&comp->oc_object_id.oid_device_id),\n\t\tcomp->oc_object_id.oid_partition_id,\n\t\tcomp->oc_object_id.oid_object_id,\n\t\tcomp->oc_cap_key.cred_len, comp->oc_cap.cred_len);\n\n\titer->decoded_comps++;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_verify_layout",
          "args": [
            "layout.olo_map.odm_num_comps",
            "&objio_seg->layout"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ore_verify_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "49-121",
          "snippet": "int ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_objio_seg",
          "args": [
            "layout.olo_num_comps",
            "gfp_flags",
            "&objio_seg"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_objio_seg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
          "lines": "174-208",
          "snippet": "static int __alloc_objio_seg(unsigned numdevs, gfp_t gfp_flags,\n\t\t       struct objio_segment **pseg)\n{\n/*\tThis is the in memory structure of the objio_segment\n *\n *\tstruct __alloc_objio_segment {\n *\t\tstruct objio_segment olseg;\n *\t\tstruct ore_dev *ods[numdevs];\n *\t\tstruct ore_comp\tcomps[numdevs];\n *\t} *aolseg;\n *\tNOTE: The code as above compiles and runs perfectly. It is elegant,\n *\ttype safe and compact. At some Past time Linus has decided he does not\n *\tlike variable length arrays, For the sake of this principal we uglify\n *\tthe code as below.\n */\n\tstruct objio_segment *lseg;\n\tsize_t lseg_size = sizeof(*lseg) +\n\t\t\tnumdevs * sizeof(lseg->oc.ods[0]) +\n\t\t\tnumdevs * sizeof(*lseg->oc.comps);\n\n\tlseg = kzalloc(lseg_size, gfp_flags);\n\tif (unlikely(!lseg)) {\n\t\tdprintk(\"%s: Failed allocation numdevs=%d size=%zd\\n\", __func__,\n\t\t\tnumdevs, lseg_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tlseg->oc.numdevs = numdevs;\n\tlseg->oc.single_comp = EC_MULTPLE_COMPS;\n\tlseg->oc.ods = (void *)(lseg + 1);\n\tlseg->oc.comps = (void *)(lseg->oc.ods + numdevs);\n\n\t*pseg = lseg;\n\treturn 0;\n}",
          "includes": [
            "#include \"../internal.h\"",
            "#include \"objlayout.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic int __alloc_objio_seg(unsigned numdevs, gfp_t gfp_flags,\n\t\t       struct objio_segment **pseg)\n{\n/*\tThis is the in memory structure of the objio_segment\n *\n *\tstruct __alloc_objio_segment {\n *\t\tstruct objio_segment olseg;\n *\t\tstruct ore_dev *ods[numdevs];\n *\t\tstruct ore_comp\tcomps[numdevs];\n *\t} *aolseg;\n *\tNOTE: The code as above compiles and runs perfectly. It is elegant,\n *\ttype safe and compact. At some Past time Linus has decided he does not\n *\tlike variable length arrays, For the sake of this principal we uglify\n *\tthe code as below.\n */\n\tstruct objio_segment *lseg;\n\tsize_t lseg_size = sizeof(*lseg) +\n\t\t\tnumdevs * sizeof(lseg->oc.ods[0]) +\n\t\t\tnumdevs * sizeof(*lseg->oc.comps);\n\n\tlseg = kzalloc(lseg_size, gfp_flags);\n\tif (unlikely(!lseg)) {\n\t\tdprintk(\"%s: Failed allocation numdevs=%d size=%zd\\n\", __func__,\n\t\t\tnumdevs, lseg_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tlseg->oc.numdevs = numdevs;\n\tlseg->oc.single_comp = EC_MULTPLE_COMPS;\n\tlseg->oc.ods = (void *)(lseg + 1);\n\tlseg->oc.comps = (void *)(lseg->oc.ods + numdevs);\n\n\t*pseg = lseg;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_decode_layout_map",
          "args": [
            "&layout",
            "&iter",
            "xdr"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_decode_layout_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "159-178",
          "snippet": "int pnfs_osd_xdr_decode_layout_map(struct pnfs_osd_layout *layout,\n\tstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tp = xdr_inline_decode(xdr, _osd_data_map_xdr_sz() + 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EINVAL;\n\n\tp = _osd_xdr_decode_data_map(p, &layout->olo_map);\n\tlayout->olo_comps_index = be32_to_cpup(p++);\n\tlayout->olo_num_comps = be32_to_cpup(p++);\n\tdprintk(\"%s: olo_comps_index=%d olo_num_comps=%d\\n\", __func__,\n\t\tlayout->olo_comps_index, layout->olo_num_comps);\n\n\titer->total_comps = layout->olo_num_comps;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nint pnfs_osd_xdr_decode_layout_map(struct pnfs_osd_layout *layout,\n\tstruct pnfs_osd_xdr_decode_layout_iter *iter, struct xdr_stream *xdr)\n{\n\t__be32 *p;\n\n\tmemset(iter, 0, sizeof(*iter));\n\n\tp = xdr_inline_decode(xdr, _osd_data_map_xdr_sz() + 4 + 4);\n\tif (unlikely(!p))\n\t\treturn -EINVAL;\n\n\tp = _osd_xdr_decode_data_map(p, &layout->olo_map);\n\tlayout->olo_comps_index = be32_to_cpup(p++);\n\tlayout->olo_num_comps = be32_to_cpup(p++);\n\tdprintk(\"%s: olo_comps_index=%d olo_num_comps=%d\\n\", __func__,\n\t\tlayout->olo_comps_index, layout->olo_num_comps);\n\n\titer->total_comps = layout->olo_num_comps;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "pnfslay->plh_inode"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nint objio_alloc_lseg(struct pnfs_layout_segment **outp,\n\tstruct pnfs_layout_hdr *pnfslay,\n\tstruct pnfs_layout_range *range,\n\tstruct xdr_stream *xdr,\n\tgfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(pnfslay->plh_inode);\n\tstruct objio_segment *objio_seg;\n\tstruct pnfs_osd_xdr_decode_layout_iter iter;\n\tstruct pnfs_osd_layout layout;\n\tstruct pnfs_osd_object_cred src_comp;\n\tunsigned cur_comp;\n\tint err;\n\n\terr = pnfs_osd_xdr_decode_layout_map(&layout, &iter, xdr);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = __alloc_objio_seg(layout.olo_num_comps, gfp_flags, &objio_seg);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tobjio_seg->layout.stripe_unit = layout.olo_map.odm_stripe_unit;\n\tobjio_seg->layout.group_width = layout.olo_map.odm_group_width;\n\tobjio_seg->layout.group_depth = layout.olo_map.odm_group_depth;\n\tobjio_seg->layout.mirrors_p1 = layout.olo_map.odm_mirror_cnt + 1;\n\tobjio_seg->layout.raid_algorithm = layout.olo_map.odm_raid_algorithm;\n\n\terr = ore_verify_layout(layout.olo_map.odm_num_comps,\n\t\t\t\t\t  &objio_seg->layout);\n\tif (unlikely(err))\n\t\tgoto err;\n\n\tobjio_seg->oc.first_dev = layout.olo_comps_index;\n\tcur_comp = 0;\n\twhile (pnfs_osd_xdr_decode_layout_comp(&src_comp, &iter, xdr, &err)) {\n\t\tstruct nfs4_deviceid_node *d;\n\t\tstruct objio_dev_ent *ode;\n\n\t\tcopy_single_comp(&objio_seg->oc, cur_comp, &src_comp);\n\n\t\td = nfs4_find_get_deviceid(server,\n\t\t\t\t&src_comp.oc_object_id.oid_device_id,\n\t\t\t\tpnfslay->plh_lc_cred, gfp_flags);\n\t\tif (!d) {\n\t\t\terr = -ENXIO;\n\t\t\tgoto err;\n\t\t}\n\n\t\tode = container_of(d, struct objio_dev_ent, id_node);\n\t\tobjio_seg->oc.ods[cur_comp++] = &ode->od;\n\t}\n\t/* pnfs_osd_xdr_decode_layout_comp returns false on error */\n\tif (unlikely(err))\n\t\tgoto err;\n\n\t*outp = &objio_seg->lseg;\n\treturn 0;\n\nerr:\n\tkfree(objio_seg);\n\tdprintk(\"%s: Error: return %d\\n\", __func__, err);\n\t*outp = NULL;\n\treturn err;\n}"
  },
  {
    "function_name": "__alloc_objio_seg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "174-208",
    "snippet": "static int __alloc_objio_seg(unsigned numdevs, gfp_t gfp_flags,\n\t\t       struct objio_segment **pseg)\n{\n/*\tThis is the in memory structure of the objio_segment\n *\n *\tstruct __alloc_objio_segment {\n *\t\tstruct objio_segment olseg;\n *\t\tstruct ore_dev *ods[numdevs];\n *\t\tstruct ore_comp\tcomps[numdevs];\n *\t} *aolseg;\n *\tNOTE: The code as above compiles and runs perfectly. It is elegant,\n *\ttype safe and compact. At some Past time Linus has decided he does not\n *\tlike variable length arrays, For the sake of this principal we uglify\n *\tthe code as below.\n */\n\tstruct objio_segment *lseg;\n\tsize_t lseg_size = sizeof(*lseg) +\n\t\t\tnumdevs * sizeof(lseg->oc.ods[0]) +\n\t\t\tnumdevs * sizeof(*lseg->oc.comps);\n\n\tlseg = kzalloc(lseg_size, gfp_flags);\n\tif (unlikely(!lseg)) {\n\t\tdprintk(\"%s: Failed allocation numdevs=%d size=%zd\\n\", __func__,\n\t\t\tnumdevs, lseg_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tlseg->oc.numdevs = numdevs;\n\tlseg->oc.single_comp = EC_MULTPLE_COMPS;\n\tlseg->oc.ods = (void *)(lseg + 1);\n\tlseg->oc.comps = (void *)(lseg->oc.ods + numdevs);\n\n\t*pseg = lseg;\n\treturn 0;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: Failed allocation numdevs=%d size=%zd\\n\"",
            "__func__",
            "numdevs",
            "lseg_size"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lseg"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "lseg_size",
            "gfp_flags"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic int __alloc_objio_seg(unsigned numdevs, gfp_t gfp_flags,\n\t\t       struct objio_segment **pseg)\n{\n/*\tThis is the in memory structure of the objio_segment\n *\n *\tstruct __alloc_objio_segment {\n *\t\tstruct objio_segment olseg;\n *\t\tstruct ore_dev *ods[numdevs];\n *\t\tstruct ore_comp\tcomps[numdevs];\n *\t} *aolseg;\n *\tNOTE: The code as above compiles and runs perfectly. It is elegant,\n *\ttype safe and compact. At some Past time Linus has decided he does not\n *\tlike variable length arrays, For the sake of this principal we uglify\n *\tthe code as below.\n */\n\tstruct objio_segment *lseg;\n\tsize_t lseg_size = sizeof(*lseg) +\n\t\t\tnumdevs * sizeof(lseg->oc.ods[0]) +\n\t\t\tnumdevs * sizeof(*lseg->oc.comps);\n\n\tlseg = kzalloc(lseg_size, gfp_flags);\n\tif (unlikely(!lseg)) {\n\t\tdprintk(\"%s: Failed allocation numdevs=%d size=%zd\\n\", __func__,\n\t\t\tnumdevs, lseg_size);\n\t\treturn -ENOMEM;\n\t}\n\n\tlseg->oc.numdevs = numdevs;\n\tlseg->oc.single_comp = EC_MULTPLE_COMPS;\n\tlseg->oc.ods = (void *)(lseg + 1);\n\tlseg->oc.comps = (void *)(lseg->oc.ods + numdevs);\n\n\t*pseg = lseg;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_single_comp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "160-172",
    "snippet": "static void copy_single_comp(struct ore_components *oc, unsigned c,\n\t\t\t     struct pnfs_osd_object_cred *src_comp)\n{\n\tstruct ore_comp *ocomp = &oc->comps[c];\n\n\tWARN_ON(src_comp->oc_cap_key.cred_len > 0); /* libosd is NO_SEC only */\n\tWARN_ON(src_comp->oc_cap.cred_len > sizeof(ocomp->cred));\n\n\tocomp->obj.partition = src_comp->oc_object_id.oid_partition_id;\n\tocomp->obj.id = src_comp->oc_object_id.oid_object_id;\n\n\tmemcpy(ocomp->cred, src_comp->oc_cap.cred, sizeof(ocomp->cred));\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ocomp->cred",
            "src_comp->oc_cap.cred",
            "sizeof(ocomp->cred)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_comp->oc_cap.cred_len > sizeof(ocomp->cred)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "src_comp->oc_cap_key.cred_len > 0"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void copy_single_comp(struct ore_components *oc, unsigned c,\n\t\t\t     struct pnfs_osd_object_cred *src_comp)\n{\n\tstruct ore_comp *ocomp = &oc->comps[c];\n\n\tWARN_ON(src_comp->oc_cap_key.cred_len > 0); /* libosd is NO_SEC only */\n\tWARN_ON(src_comp->oc_cap.cred_len > sizeof(ocomp->cred));\n\n\tocomp->obj.partition = src_comp->oc_object_id.oid_partition_id;\n\tocomp->obj.id = src_comp->oc_object_id.oid_object_id;\n\n\tmemcpy(ocomp->cred, src_comp->oc_cap.cred, sizeof(ocomp->cred));\n}"
  },
  {
    "function_name": "objio_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "87-158",
    "snippet": "struct nfs4_deviceid_node *\nobjio_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct pnfs_osd_deviceaddr *deviceaddr;\n\tstruct objio_dev_ent *ode = NULL;\n\tstruct osd_dev *od;\n\tstruct osd_dev_info odi;\n\tbool retry_flag = true;\n\t__be32 *p;\n\tint err;\n\n\tdeviceaddr = kzalloc(sizeof(*deviceaddr), gfp_flags);\n\tif (!deviceaddr)\n\t\treturn NULL;\n\n\tp = page_address(pdev->pages[0]);\n\tpnfs_osd_xdr_decode_deviceaddr(deviceaddr, p);\n\n\todi.systemid_len = deviceaddr->oda_systemid.len;\n\tif (odi.systemid_len > sizeof(odi.systemid)) {\n\t\tdprintk(\"%s: odi.systemid_len > sizeof(systemid=%zd)\\n\",\n\t\t\t__func__, sizeof(odi.systemid));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (odi.systemid_len)\n\t\tmemcpy(odi.systemid, deviceaddr->oda_systemid.data,\n\t\t       odi.systemid_len);\n\todi.osdname_len\t = deviceaddr->oda_osdname.len;\n\todi.osdname\t = (u8 *)deviceaddr->oda_osdname.data;\n\n\tif (!odi.osdname_len && !odi.systemid_len) {\n\t\tdprintk(\"%s: !odi.osdname_len && !odi.systemid_len\\n\",\n\t\t\t__func__);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\nretry_lookup:\n\tod = osduld_info_lookup(&odi);\n\tif (unlikely(IS_ERR(od))) {\n\t\terr = PTR_ERR(od);\n\t\tdprintk(\"%s: osduld_info_lookup => %d\\n\", __func__, err);\n\t\tif (err == -ENODEV && retry_flag) {\n\t\t\terr = objlayout_autologin(deviceaddr);\n\t\t\tif (likely(!err)) {\n\t\t\t\tretry_flag = false;\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdprintk(\"Adding new dev_id(%llx:%llx)\\n\",\n\t\t_DEVID_LO(&pdev->dev_id), _DEVID_HI(&pdev->dev_id));\n\n\tode = kzalloc(sizeof(*ode), gfp_flags);\n\tif (!ode) {\n\t\tdprintk(\"%s: -ENOMEM od=%p\\n\", __func__, od);\n\t\tgoto out;\n\t}\n\n\tnfs4_init_deviceid_node(&ode->id_node, server, &pdev->dev_id);\n\tkfree(deviceaddr);\n\n\tode->od.od = od;\n\treturn &ode->id_node;\n\nout:\n\tkfree(deviceaddr);\n\treturn NULL;\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "deviceaddr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "deviceaddr"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_deviceid_node",
          "args": [
            "&ode->id_node",
            "server",
            "&pdev->dev_id"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "247-258",
          "snippet": "void\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: -ENOMEM od=%p\\n\"",
            "__func__",
            "od"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ode)",
            "gfp_flags"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Adding new dev_id(%llx:%llx)\\n\"",
            "_DEVID_LO(&pdev->dev_id)",
            "_DEVID_HI(&pdev->dev_id)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_HI",
          "args": [
            "&pdev->dev_id"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_DEVID_LO",
          "args": [
            "&pdev->dev_id"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "objlayout_autologin",
          "args": [
            "deviceaddr"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "objlayout_autologin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objlayout.c",
          "lines": "682-706",
          "snippet": "int objlayout_autologin(struct pnfs_osd_deviceaddr *deviceaddr)\n{\n\tint rc;\n\tstruct __auto_login login;\n\n\tif (!deviceaddr->oda_targetaddr.ota_netaddr.r_addr.len)\n\t\treturn -ENODEV;\n\n\tmemset(&login, 0, sizeof(login));\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_targetaddr.ota_netaddr.r_addr,\n\t\tlogin.uri, sizeof(login.uri), \"URI\");\n\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_osdname,\n\t\tlogin.osdname, sizeof(login.osdname), \"OSDNAME\");\n\n\t_sysid_2_hex(deviceaddr->oda_systemid, login.systemid_hex);\n\n\trc = __objlayout_upcall(&login);\n\tif (rc > 0) /* script returns positive values */\n\t\trc = -ENODEV;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"objlayout.h\"",
            "#include <scsi/osd_initiator.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objlayout.h\"\n#include <scsi/osd_initiator.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kmod.h>\n\nint objlayout_autologin(struct pnfs_osd_deviceaddr *deviceaddr)\n{\n\tint rc;\n\tstruct __auto_login login;\n\n\tif (!deviceaddr->oda_targetaddr.ota_netaddr.r_addr.len)\n\t\treturn -ENODEV;\n\n\tmemset(&login, 0, sizeof(login));\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_targetaddr.ota_netaddr.r_addr,\n\t\tlogin.uri, sizeof(login.uri), \"URI\");\n\n\t__copy_nfsS_and_zero_terminate(\n\t\tdeviceaddr->oda_osdname,\n\t\tlogin.osdname, sizeof(login.osdname), \"OSDNAME\");\n\n\t_sysid_2_hex(deviceaddr->oda_systemid, login.systemid_hex);\n\n\trc = __objlayout_upcall(&login);\n\tif (rc > 0) /* script returns positive values */\n\t\trc = -ENODEV;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: osduld_info_lookup => %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "od"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(od)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "od"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_info_lookup",
          "args": [
            "&odi"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: !odi.osdname_len && !odi.systemid_len\\n\"",
            "__func__"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "odi.systemid",
            "deviceaddr->oda_systemid.data",
            "odi.systemid_len"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: odi.systemid_len > sizeof(systemid=%zd)\\n\"",
            "__func__",
            "sizeof(odi.systemid)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnfs_osd_xdr_decode_deviceaddr",
          "args": [
            "deviceaddr",
            "p"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "pnfs_osd_xdr_decode_deviceaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/pnfs_osd_xdr_cli.c",
          "lines": "327-345",
          "snippet": "void pnfs_osd_xdr_decode_deviceaddr(\n\tstruct pnfs_osd_deviceaddr *deviceaddr, __be32 *p)\n{\n\tp = __read_targetid(p, &deviceaddr->oda_targetid);\n\n\tp = __read_targetaddr(p, &deviceaddr->oda_targetaddr);\n\n\tp = xdr_decode_opaque_fixed(p, deviceaddr->oda_lun,\n\t\t\t\t    sizeof(deviceaddr->oda_lun));\n\n\tp = __read_u8_opaque(p, &deviceaddr->oda_systemid);\n\n\tp = __read_object_cred(p, &deviceaddr->oda_root_obj_cred);\n\n\tp = __read_u8_opaque(p, &deviceaddr->oda_osdname);\n\n\t/* libosd likes this terminated in dbg. It's last, so no problems */\n\tdeviceaddr->oda_osdname.data[deviceaddr->oda_osdname.len] = 0;\n}",
          "includes": [
            "#include <linux/pnfs_osd_xdr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pnfs_osd_xdr.h>\n\nvoid pnfs_osd_xdr_decode_deviceaddr(\n\tstruct pnfs_osd_deviceaddr *deviceaddr, __be32 *p)\n{\n\tp = __read_targetid(p, &deviceaddr->oda_targetid);\n\n\tp = __read_targetaddr(p, &deviceaddr->oda_targetaddr);\n\n\tp = xdr_decode_opaque_fixed(p, deviceaddr->oda_lun,\n\t\t\t\t    sizeof(deviceaddr->oda_lun));\n\n\tp = __read_u8_opaque(p, &deviceaddr->oda_systemid);\n\n\tp = __read_object_cred(p, &deviceaddr->oda_root_obj_cred);\n\n\tp = __read_u8_opaque(p, &deviceaddr->oda_osdname);\n\n\t/* libosd likes this terminated in dbg. It's last, so no problems */\n\tdeviceaddr->oda_osdname.data[deviceaddr->oda_osdname.len] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pdev->pages[0]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*deviceaddr)",
            "gfp_flags"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstruct nfs4_deviceid_node *\nobjio_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct pnfs_osd_deviceaddr *deviceaddr;\n\tstruct objio_dev_ent *ode = NULL;\n\tstruct osd_dev *od;\n\tstruct osd_dev_info odi;\n\tbool retry_flag = true;\n\t__be32 *p;\n\tint err;\n\n\tdeviceaddr = kzalloc(sizeof(*deviceaddr), gfp_flags);\n\tif (!deviceaddr)\n\t\treturn NULL;\n\n\tp = page_address(pdev->pages[0]);\n\tpnfs_osd_xdr_decode_deviceaddr(deviceaddr, p);\n\n\todi.systemid_len = deviceaddr->oda_systemid.len;\n\tif (odi.systemid_len > sizeof(odi.systemid)) {\n\t\tdprintk(\"%s: odi.systemid_len > sizeof(systemid=%zd)\\n\",\n\t\t\t__func__, sizeof(odi.systemid));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (odi.systemid_len)\n\t\tmemcpy(odi.systemid, deviceaddr->oda_systemid.data,\n\t\t       odi.systemid_len);\n\todi.osdname_len\t = deviceaddr->oda_osdname.len;\n\todi.osdname\t = (u8 *)deviceaddr->oda_osdname.data;\n\n\tif (!odi.osdname_len && !odi.systemid_len) {\n\t\tdprintk(\"%s: !odi.osdname_len && !odi.systemid_len\\n\",\n\t\t\t__func__);\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\nretry_lookup:\n\tod = osduld_info_lookup(&odi);\n\tif (unlikely(IS_ERR(od))) {\n\t\terr = PTR_ERR(od);\n\t\tdprintk(\"%s: osduld_info_lookup => %d\\n\", __func__, err);\n\t\tif (err == -ENODEV && retry_flag) {\n\t\t\terr = objlayout_autologin(deviceaddr);\n\t\t\tif (likely(!err)) {\n\t\t\t\tretry_flag = false;\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\t\t}\n\t\tgoto out;\n\t}\n\n\tdprintk(\"Adding new dev_id(%llx:%llx)\\n\",\n\t\t_DEVID_LO(&pdev->dev_id), _DEVID_HI(&pdev->dev_id));\n\n\tode = kzalloc(sizeof(*ode), gfp_flags);\n\tif (!ode) {\n\t\tdprintk(\"%s: -ENOMEM od=%p\\n\", __func__, od);\n\t\tgoto out;\n\t}\n\n\tnfs4_init_deviceid_node(&ode->id_node, server, &pdev->dev_id);\n\tkfree(deviceaddr);\n\n\tode->od.od = od;\n\treturn &ode->id_node;\n\nout:\n\tkfree(deviceaddr);\n\treturn NULL;\n}"
  },
  {
    "function_name": "OBJIO_LSEG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "70-74",
    "snippet": "static inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lseg",
            "structobjio_segment",
            "lseg"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic inline struct objio_segment *\nOBJIO_LSEG(struct pnfs_layout_segment *lseg)\n{\n\treturn container_of(lseg, struct objio_segment, lseg);\n}"
  },
  {
    "function_name": "objio_free_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/objlayout/objio_osd.c",
    "lines": "53-61",
    "snippet": "static void\nobjio_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct objio_dev_ent *de = container_of(d, struct objio_dev_ent, id_node);\n\n\tdprintk(\"%s: free od=%p\\n\", __func__, de->od.od);\n\tosduld_put_device(de->od.od);\n\tkfree(de);\n}",
    "includes": [
      "#include \"../internal.h\"",
      "#include \"objlayout.h\"",
      "#include <scsi/osd_ore.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "de"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_put_device",
          "args": [
            "de->od.od"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: free od=%p\\n\"",
            "__func__",
            "de->od.od"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "d",
            "structobjio_dev_ent",
            "id_node"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../internal.h\"\n#include \"objlayout.h\"\n#include <scsi/osd_ore.h>\n#include <linux/module.h>\n\nstatic void\nobjio_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct objio_dev_ent *de = container_of(d, struct objio_dev_ent, id_node);\n\n\tdprintk(\"%s: free od=%p\\n\", __func__, de->od.od);\n\tosduld_put_device(de->od.od);\n\tkfree(de);\n}"
  }
]