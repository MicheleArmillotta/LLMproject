[
  {
    "function_name": "ufs_by_inode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "1120-1150",
    "snippet": "c_wbufs_by_inode(struct ubifs_info *c, struct inode *inode)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tif (i == GCHD)\n\t\t\t/*\n\t\t\t * GC head is special, do not look at it. Even if the\n\t\t\t * head contains something related to this inode, it is\n\t\t\t * a _copy_ of corresponding on-flash node which sits\n\t\t\t * somewhere else.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (!wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\n\t\tif (err) {\n\t\t\tubifs_ro_mode(c, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "(c, err);",
          "args": [
            "e",
            "rn"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\n\t\tif (err"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\t\tmut",
          "args": [
            "x_un"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf, inode-",
          "args": [
            "i_in",
            ")\n\t\t\terr = u"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "if (wbuf"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf, inode-",
          "args": [
            "i_in",
            ")\n\t\t\tcontinu"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nc_wbufs_by_inode(struct ubifs_info *c, struct inode *inode)\n{\n\tint i, err = 0;\n\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tif (i == GCHD)\n\t\t\t/*\n\t\t\t * GC head is special, do not look at it. Even if the\n\t\t\t * head contains something related to this inode, it is\n\t\t\t * a _copy_ of corresponding on-flash node which sits\n\t\t\t * somewhere else.\n\t\t\t */\n\t\t\tcontinue;\n\n\t\tif (!wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (wbuf_has_ino(wbuf, inode->i_ino))\n\t\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\n\t\tif (err) {\n\t\t\tubifs_ro_mode(c, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "1096-1109",
    "snippet": "uf_has_ino(struct ubifs_wbuf *wbuf, ino_t inum)\n{\n\tint i, ret = 0;\n\n\tspin_lock(&wbuf->lock);\n\tfor (i = 0; i < wbuf->next_ino; i++)\n\t\tif (inum == wbuf->inodes[i]) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&wbuf->lock);\n\n\treturn ret;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "return r"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "for (i ="
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nuf_has_ino(struct ubifs_wbuf *wbuf, ino_t inum)\n{\n\tint i, ret = 0;\n\n\tspin_lock(&wbuf->lock);\n\tfor (i = 0; i < wbuf->next_ino; i++)\n\t\tif (inum == wbuf->inodes[i]) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock(&wbuf->lock);\n\n\treturn ret;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "d_ino_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "1076-1086",
    "snippet": "uf_add_ino_nolock(struct ubifs_wbuf *wbuf, ino_t inum)\n{\n\tif (!wbuf->buf)\n\t\t/* NOR flash or something similar */\n\t\treturn;\n\n\tspin_lock(&wbuf->lock);\n\tif (wbuf->used)\n\t\twbuf->inodes[wbuf->next_ino++] = inum;\n\tspin_unlock(&wbuf->lock);\n}\n\n/**\n * wbuf",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "}\n\n/**\n *"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "if (wbuf-"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nuf_add_ino_nolock(struct ubifs_wbuf *wbuf, ino_t inum)\n{\n\tif (!wbuf->buf)\n\t\t/* NOR flash or something similar */\n\t\treturn;\n\n\tspin_lock(&wbuf->lock);\n\tif (wbuf->used)\n\t\twbuf->inodes[wbuf->next_ino++] = inum;\n\tspin_unlock(&wbuf->lock);\n}\n\n/**\n * wbuf"
  },
  {
    "function_name": "it(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "1028-1067",
    "snippet": "f_init(struct ubifs_info *c, struct ubifs_wbuf *wbuf)\n{\n\tsize_t size;\n\n\twbuf->buf = kmalloc(c->max_write_size, GFP_KERNEL);\n\tif (!wbuf->buf)\n\t\treturn -ENOMEM;\n\n\tsize = (c->max_write_size / UBIFS_CH_SZ + 1) * sizeof(ino_t);\n\twbuf->inodes = kmalloc(size, GFP_KERNEL);\n\tif (!wbuf->inodes) {\n\t\tkfree(wbuf->buf);\n\t\twbuf->buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\twbuf->used = 0;\n\twbuf->lnum = wbuf->offs = -1;\n\t/*\n\t * If the LEB starts at the max. write size aligned address, then\n\t * write-buffer size has to be set to @c->max_write_size. Otherwise,\n\t * set it to something smaller so that it ends at the closest max.\n\t * write size boundary.\n\t */\n\tsize = c->max_write_size - (c->leb_start % c->max_write_size);\n\twbuf->avail = wbuf->size = size;\n\twbuf->sync_callback = NULL;\n\tmutex_init(&wbuf->io_mutex);\n\tspin_lock_init(&wbuf->lock);\n\twbuf->c = c;\n\twbuf->next_ino = 0;\n\n\thrtimer_init(&wbuf->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\twbuf->timer.function = wbuf_timer_callback_nolock;\n\twbuf->softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);\n\twbuf->delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;\n\twbuf->delta *= 1000000000ULL;\n\tubifs_assert(wbuf->delta <= ULONG_MAX);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbuf->delta",
          "args": [
            "= ULONG_MAX);\n\treturn 0;"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F_TIMEOUT",
          "args": [
            "SOFTLIMIT, 0);\n\twbuf->",
            "l"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->timer",
          "args": [
            "CLOCK_MONOT",
            "IC, HRTIMER_MOD",
            "REL);\n\twbuf->tim"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(&wbuf->lock)",
          "args": [
            "wbuf->c ="
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->io_mu",
          "args": [
            "ex);\n\tspin_lock"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf);",
          "args": [
            "wbuf->bu"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_KE",
          "args": [
            "NEL)",
            "if (!wbuf"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_write",
          "args": [
            "size, GFP_KERNEL)",
            "if (!wbuf"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "603-624",
          "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nf_init(struct ubifs_info *c, struct ubifs_wbuf *wbuf)\n{\n\tsize_t size;\n\n\twbuf->buf = kmalloc(c->max_write_size, GFP_KERNEL);\n\tif (!wbuf->buf)\n\t\treturn -ENOMEM;\n\n\tsize = (c->max_write_size / UBIFS_CH_SZ + 1) * sizeof(ino_t);\n\twbuf->inodes = kmalloc(size, GFP_KERNEL);\n\tif (!wbuf->inodes) {\n\t\tkfree(wbuf->buf);\n\t\twbuf->buf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\twbuf->used = 0;\n\twbuf->lnum = wbuf->offs = -1;\n\t/*\n\t * If the LEB starts at the max. write size aligned address, then\n\t * write-buffer size has to be set to @c->max_write_size. Otherwise,\n\t * set it to something smaller so that it ends at the closest max.\n\t * write size boundary.\n\t */\n\tsize = c->max_write_size - (c->leb_start % c->max_write_size);\n\twbuf->avail = wbuf->size = size;\n\twbuf->sync_callback = NULL;\n\tmutex_init(&wbuf->io_mutex);\n\tspin_lock_init(&wbuf->lock);\n\twbuf->c = c;\n\twbuf->next_ino = 0;\n\n\thrtimer_init(&wbuf->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\twbuf->timer.function = wbuf_timer_callback_nolock;\n\twbuf->softlimit = ktime_set(WBUF_TIMEOUT_SOFTLIMIT, 0);\n\twbuf->delta = WBUF_TIMEOUT_HARDLIMIT - WBUF_TIMEOUT_SOFTLIMIT;\n\twbuf->delta *= 1000000000ULL;\n\tubifs_assert(wbuf->delta <= ULONG_MAX);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "de(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "974-1018",
    "snippet": "d_node(const struct ubifs_info *c, void *buf, int type, int len,\n\t\t    int lnum, int offs)\n{\n\tint err, l;\n\tstruct ubifs_ch *ch = buf;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d\", lnum, offs, dbg_ntype(type), len);\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(len >= UBIFS_CH_SZ && offs + len <= c->leb_size);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\n\tif (type != ch->node_type) {\n\t\tubifs_errc(c, \"bad node type (%d but expected %d)\",\n\t\t\t   ch->node_type, type);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_check_node(c, buf, lnum, offs, 0, 0);\n\tif (err) {\n\t\tubifs_errc(c, \"expected node type %d\", type);\n\t\treturn err;\n\t}\n\n\tl = le32_to_cpu(ch->len);\n\tif (l != len) {\n\t\tubifs_errc(c, \"bad node length %d, expected %d\", l, len);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_errc(c, \"bad node at LEB %d:%d, LEB mapping status %d\", lnum,\n\t\t   offs, ubi_is_mapped(c->ubi, lnum));\n\tif (!c->probing) {\n\t\tubifs_dump_node(c, buf);\n\t\tdump_stack();\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"bad node",
          "args": [
            "a",
            "LEB %d:%d, LEB mapping status %d\", lnum,",
            "fs,",
            "mapp",
            "(c->ubi, lnum));\n\tif (!c->p"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            ");\n\tif",
            "!c->"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"bad node",
          "args": [
            "l",
            "gth %d, expected %d\", l, len);",
            "t",
            "out"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ti",
          "args": [
            "(l !="
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"expected",
          "args": [
            "n",
            "e type %d\", type);\n\t\tre",
            "rn e"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf, lnum",
          "args": [
            "fs,",
            ", 0)",
            "if",
            "r"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"bad node",
          "args": [
            "t",
            "e (%d but expected %d)\",\n\t\t\t   ch->n",
            ", type);\n\t\tgo",
            "out"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "n,",
            ";\n\ti",
            "(er",
            "&"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type >= 0 &&",
          "args": [
            "type < UBIFS_NODE_TYPES_CNT);\n\n\terr = ub"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(offs & 7)",
          "args": [
            "& offs < c->leb_size);\n\tubifs_ass"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len >= UBIFS",
          "args": [
            "CH_SZ && offs + len <= c->leb_size);\n\tubifs_ass"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= 0 &&",
          "args": [
            "lnum < c->leb_cnt && offs >= 0);\n\tubifs_ass"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "s, length %d\", lnum, offs,",
            "bg_n",
            "pe(t",
            "e), len);\n\tubif",
            "ass"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e), len);",
          "args": [
            "ubi"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd_node(const struct ubifs_info *c, void *buf, int type, int len,\n\t\t    int lnum, int offs)\n{\n\tint err, l;\n\tstruct ubifs_ch *ch = buf;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d\", lnum, offs, dbg_ntype(type), len);\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(len >= UBIFS_CH_SZ && offs + len <= c->leb_size);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\n\tif (type != ch->node_type) {\n\t\tubifs_errc(c, \"bad node type (%d but expected %d)\",\n\t\t\t   ch->node_type, type);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_check_node(c, buf, lnum, offs, 0, 0);\n\tif (err) {\n\t\tubifs_errc(c, \"expected node type %d\", type);\n\t\treturn err;\n\t}\n\n\tl = le32_to_cpu(ch->len);\n\tif (l != len) {\n\t\tubifs_errc(c, \"bad node length %d, expected %d\", l, len);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_errc(c, \"bad node at LEB %d:%d, LEB mapping status %d\", lnum,\n\t\t   offs, ubi_is_mapped(c->ubi, lnum));\n\tif (!c->probing) {\n\t\tubifs_dump_node(c, buf);\n\t\tdump_stack();\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "de_wbuf(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "897-959",
    "snippet": "d_node_wbuf(struct ubifs_wbuf *wbuf, void *buf, int type, int len,\n\t\t\t int lnum, int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\tint err, rlen, overlap;\n\tstruct ubifs_ch *ch = buf;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d, jhead %s\", lnum, offs,\n\t       dbg_ntype(type), len, dbg_jhead(wbuf->jhead));\n\tubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);\n\n\tspin_lock(&wbuf->lock);\n\toverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\n\tif (!overlap) {\n\t\t/* We may safely unlock the write-buffer and read the data */\n\t\tspin_unlock(&wbuf->lock);\n\t\treturn ubifs_read_node(c, buf, type, len, lnum, offs);\n\t}\n\n\t/* Don't read under wbuf */\n\trlen = wbuf->offs - offs;\n\tif (rlen < 0)\n\t\trlen = 0;\n\n\t/* Copy the rest from the write-buffer */\n\tmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\n\tspin_unlock(&wbuf->lock);\n\n\tif (rlen > 0) {\n\t\t/* Read everything that goes before write-buffer */\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\n\t\tif (err && err != -EBADMSG)\n\t\t\treturn err;\n\t}\n\n\tif (type != ch->node_type) {\n\t\tubifs_err(\"bad node type (%d but expected %d)\",\n\t\t\t  ch->node_type, type);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_check_node(c, buf, lnum, offs, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"expected node type %d\", type);\n\t\treturn err;\n\t}\n\n\trlen = le32_to_cpu(ch->len);\n\tif (rlen != len) {\n\t\tubifs_err(\"bad node length %d, expected %d\", rlen, len);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(\"bad node at LEB %d:%d\", lnum, offs);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "return -",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf);\n\tdu",
          "args": [
            "p",
            "tac"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node at",
          "args": [
            "LEB %d:%d\", lnum, offs)",
            "ubi",
            "_dum"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node le",
          "args": [
            "gth %d, expected %d\", rlen, len);",
            "got",
            "out"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ti",
          "args": [
            "(rlen"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pected no",
          "args": [
            "e type %d\", type);\n\t\tre",
            "rn e"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf, lnum",
          "args": [
            "fs,",
            ", 0)",
            "if",
            "r"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e (%d but expected %d)\",\n\t\t\t  ch->no",
            ", type);\n\t\tgo",
            "out"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "en,",
            ");",
            "f (e"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "if (rlen"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlen,",
          "args": [
            "buf->buf +",
            "ffs + rlen - wbuf->offs, len - rlen)",
            "spin_unlo"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf, type",
          "args": [
            "n,",
            "um,",
            "fs)",
            "}",
            "* Do"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "return u"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "overlap ="
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type >= 0 &&",
          "args": [
            "type < UBIFS_NODE_TYPES_CNT);\n\n\tspin_loc"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(offs & 7)",
          "args": [
            "& offs < c->leb_size);\n\tubifs_ass"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf && lnum",
          "args": [
            ">= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_ass"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "s, length %d, jhead %s\", lnum, offs,",
            "dbg",
            "e), len, dbg_jh",
            "d(w",
            "f->jhead));\n\tubifs_ass"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            ";\n\tubifs_as"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e), len,",
          "args": [
            "bg_j"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd_node_wbuf(struct ubifs_wbuf *wbuf, void *buf, int type, int len,\n\t\t\t int lnum, int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\tint err, rlen, overlap;\n\tstruct ubifs_ch *ch = buf;\n\n\tdbg_io(\"LEB %d:%d, %s, length %d, jhead %s\", lnum, offs,\n\t       dbg_ntype(type), len, dbg_jhead(wbuf->jhead));\n\tubifs_assert(wbuf && lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\tubifs_assert(type >= 0 && type < UBIFS_NODE_TYPES_CNT);\n\n\tspin_lock(&wbuf->lock);\n\toverlap = (lnum == wbuf->lnum && offs + len > wbuf->offs);\n\tif (!overlap) {\n\t\t/* We may safely unlock the write-buffer and read the data */\n\t\tspin_unlock(&wbuf->lock);\n\t\treturn ubifs_read_node(c, buf, type, len, lnum, offs);\n\t}\n\n\t/* Don't read under wbuf */\n\trlen = wbuf->offs - offs;\n\tif (rlen < 0)\n\t\trlen = 0;\n\n\t/* Copy the rest from the write-buffer */\n\tmemcpy(buf + rlen, wbuf->buf + offs + rlen - wbuf->offs, len - rlen);\n\tspin_unlock(&wbuf->lock);\n\n\tif (rlen > 0) {\n\t\t/* Read everything that goes before write-buffer */\n\t\terr = ubifs_leb_read(c, lnum, buf, offs, rlen, 0);\n\t\tif (err && err != -EBADMSG)\n\t\t\treturn err;\n\t}\n\n\tif (type != ch->node_type) {\n\t\tubifs_err(\"bad node type (%d but expected %d)\",\n\t\t\t  ch->node_type, type);\n\t\tgoto out;\n\t}\n\n\terr = ubifs_check_node(c, buf, lnum, offs, 0, 0);\n\tif (err) {\n\t\tubifs_err(\"expected node type %d\", type);\n\t\treturn err;\n\t}\n\n\trlen = le32_to_cpu(ch->len);\n\tif (rlen != len) {\n\t\tubifs_err(\"bad node length %d, expected %d\", rlen, len);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tubifs_err(\"bad node at LEB %d:%d\", lnum, offs);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\treturn -EINVAL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "858-880",
    "snippet": "te_node(struct ubifs_info *c, void *buf, int len, int lnum,\n\t\t     int offs)\n{\n\tint err, buf_len = ALIGN(len, c->min_io_size);\n\n\tdbg_io(\"LEB %d:%d, %s, length %d (aligned %d)\",\n\t       lnum, offs, dbg_ntype(((struct ubifs_ch *)buf)->node_type), len,\n\t       buf_len);\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(offs % c->min_io_size == 0 && offs < c->leb_size);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tubifs_assert(!c->space_fixup);\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\tubifs_prepare_node(c, buf, len, 1);\n\terr = ubifs_leb_write(c, lnum, buf, offs, buf_len);\n\tif (err)\n\t\tubifs_dump_node(c, buf);\n\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, buf);\n\n\tr",
          "args": [
            "t",
            "n e"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, lnum, buf",
          "args": [
            "fs,",
            "f_l",
            ");",
            "(err)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, buf, len,",
          "args": [
            "1",
            "e",
            "=",
            "i"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->space_fi",
          "args": [
            "up);\n\n\tif (c->r"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tubifs_ass"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs % c->mi",
          "args": [
            "_io_size == 0 && offs < c->leb_size);\n\tubifs_ass"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= 0 &&",
          "args": [
            "lnum < c->leb_cnt && offs >= 0);\n\tubifs_ass"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "s, length %d (aligned %d)\",\n\t       lnu",
            "bg_n",
            "pe((",
            "truct ubifs_ch *)buf)->node_type), len,",
            "buf",
            "ifs_ass"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truct ubi",
          "args": [
            "s_ch *)buf)->node_type), len,"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "s_sync(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
          "lines": "603-657",
          "snippet": "wbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nwbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\n\tdbg_io(\""
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nte_node(struct ubifs_info *c, void *buf, int len, int lnum,\n\t\t     int offs)\n{\n\tint err, buf_len = ALIGN(len, c->min_io_size);\n\n\tdbg_io(\"LEB %d:%d, %s, length %d (aligned %d)\",\n\t       lnum, offs, dbg_ntype(((struct ubifs_ch *)buf)->node_type), len,\n\t       buf_len);\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(offs % c->min_io_size == 0 && offs < c->leb_size);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tubifs_assert(!c->space_fixup);\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\tubifs_prepare_node(c, buf, len, 1);\n\terr = ubifs_leb_write(c, lnum, buf, offs, buf_len);\n\tif (err)\n\t\tubifs_dump_node(c, buf);\n\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ite_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "675-842",
    "snippet": "f_write_nolock(struct ubifs_wbuf *wbuf, void *buf, int len)\n{\n\tstruct ubifs_info *c = wbuf->c;\n\tint err, written, n, aligned_len = ALIGN(len, 8);\n\n\tdbg_io(\"%d bytes (%s) to jhead %s wbuf at LEB %d:%d\", len,\n\t       dbg_ntype(((struct ubifs_ch *)buf)->node_type),\n\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs + wbuf->used);\n\tubifs_assert(len > 0 && wbuf->lnum >= 0 && wbuf->lnum < c->leb_cnt);\n\tubifs_assert(wbuf->offs >= 0 && wbuf->offs % c->min_io_size == 0);\n\tubifs_assert(!(wbuf->offs & 7) && wbuf->offs <= c->leb_size);\n\tubifs_assert(wbuf->avail > 0 && wbuf->avail <= wbuf->size);\n\tubifs_assert(wbuf->size >= c->min_io_size);\n\tubifs_assert(wbuf->size <= c->max_write_size);\n\tubifs_assert(wbuf->size % c->min_io_size == 0);\n\tubifs_assert(mutex_is_locked(&wbuf->io_mutex));\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tubifs_assert(!c->space_fixup);\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\tubifs_assert(!((wbuf->offs + wbuf->size) % c->max_write_size));\n\n\tif (c->leb_size - wbuf->offs - wbuf->used < aligned_len) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tcancel_wbuf_timer_nolock(wbuf);\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\tif (aligned_len <= wbuf->avail) {\n\t\t/*\n\t\t * The node is not very large and fits entirely within\n\t\t * write-buffer.\n\t\t */\n\t\tmemcpy(wbuf->buf + wbuf->used, buf, len);\n\n\t\tif (aligned_len == wbuf->avail) {\n\t\t\tdbg_io(\"flush jhead %s wbuf to LEB %d:%d\",\n\t\t\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);\n\t\t\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf,\n\t\t\t\t\t      wbuf->offs, wbuf->size);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&wbuf->lock);\n\t\t\twbuf->offs += wbuf->size;\n\t\t\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\t\t\twbuf->size = c->max_write_size;\n\t\t\telse\n\t\t\t\twbuf->size = c->leb_size - wbuf->offs;\n\t\t\twbuf->avail = wbuf->size;\n\t\t\twbuf->used = 0;\n\t\t\twbuf->next_ino = 0;\n\t\t\tspin_unlock(&wbuf->lock);\n\t\t} else {\n\t\t\tspin_lock(&wbuf->lock);\n\t\t\twbuf->avail -= aligned_len;\n\t\t\twbuf->used += aligned_len;\n\t\t\tspin_unlock(&wbuf->lock);\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\twritten = 0;\n\n\tif (wbuf->used) {\n\t\t/*\n\t\t * The node is large enough and does not fit entirely within\n\t\t * current available space. We have to fill and flush\n\t\t * write-buffer and switch to the next max. write unit.\n\t\t */\n\t\tdbg_io(\"flush jhead %s wbuf to LEB %d:%d\",\n\t\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);\n\t\tmemcpy(wbuf->buf + wbuf->used, buf, wbuf->avail);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf, wbuf->offs,\n\t\t\t\t      wbuf->size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twbuf->offs += wbuf->size;\n\t\tlen -= wbuf->avail;\n\t\taligned_len -= wbuf->avail;\n\t\twritten += wbuf->avail;\n\t} else if (wbuf->offs & (c->max_write_size - 1)) {\n\t\t/*\n\t\t * The write-buffer offset is not aligned to\n\t\t * @c->max_write_size and @wbuf->size is less than\n\t\t * @c->max_write_size. Write @wbuf->size bytes to make sure the\n\t\t * following writes are done in optimal @c->max_write_size\n\t\t * chunks.\n\t\t */\n\t\tdbg_io(\"write %d bytes to LEB %d:%d\",\n\t\t       wbuf->size, wbuf->lnum, wbuf->offs);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, buf, wbuf->offs,\n\t\t\t\t      wbuf->size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twbuf->offs += wbuf->size;\n\t\tlen -= wbuf->size;\n\t\taligned_len -= wbuf->size;\n\t\twritten += wbuf->size;\n\t}\n\n\t/*\n\t * The remaining data may take more whole max. write units, so write the\n\t * remains multiple to max. write unit size directly to the flash media.\n\t * We align node length to 8-byte boundary because we anyway flash wbuf\n\t * if the remaining space is less than 8 bytes.\n\t */\n\tn = aligned_len >> c->max_write_shift;\n\tif (n) {\n\t\tn <<= c->max_write_shift;\n\t\tdbg_io(\"write %d bytes to LEB %d:%d\", n, wbuf->lnum,\n\t\t       wbuf->offs);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, buf + written,\n\t\t\t\t      wbuf->offs, n);\n\t\tif (err)\n\t\t\tgoto out;\n\t\twbuf->offs += n;\n\t\taligned_len -= n;\n\t\tlen -= n;\n\t\twritten += n;\n\t}\n\n\tspin_lock(&wbuf->lock);\n\tif (aligned_len)\n\t\t/*\n\t\t * And now we have what's left and what does not take whole\n\t\t * max. write unit, so write it to the write-buffer and we are\n\t\t * done.\n\t\t */\n\t\tmemcpy(wbuf->buf, buf + written, len);\n\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\twbuf->size = c->max_write_size;\n\telse\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\twbuf->avail = wbuf->size - aligned_len;\n\twbuf->used = aligned_len;\n\twbuf->next_ino = 0;\n\tspin_unlock(&wbuf->lock);\n\nexit:\n\tif (wbuf->sync_callback) {\n\t\tint free = c->leb_size - wbuf->offs - wbuf->used;\n\n\t\terr = wbuf->sync_callback(c, wbuf->lnum, free, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (wbuf->used)\n\t\tnew_wbuf_timer_nolock(wbuf);\n\n\treturn 0;\n\nout:\n\tubifs_err(\"cannot write %d bytes to LEB %d:%d, error %d\",\n\t\t  len, wbuf->lnum, wbuf->offs, err);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\tubifs_dump_leb(c, wbuf->lnum);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "b(c, wbuf->lnu",
          "args": [
            ")",
            "return er"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_du",
          "args": [],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf);\n\tdu",
          "args": [
            "p",
            "tac"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot writ",
          "args": [
            "%d bytes to LEB %d:%d, error %d\",\n\t\t  len, wb",
            "um,",
            "buf->offs,",
            "rr);\n\tubif",
            "dum"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_nolock(wbuf);\n\n\tret",
          "args": [
            "rn 0"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llback",
          "args": [
            ",",
            "ree, 0);",
            "f (e",
            ")"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "999-1082",
          "snippet": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)",
            "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)\n\nstatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "exit:\n\tif"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf, b",
          "args": [
            "f + writt",
            ", len);\n\n\tif",
            "->l"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "if (align"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, wbuf->lnu",
          "args": [
            ",",
            "uf + writt",
            ",\n\t\t\t\t      w",
            ");\n\t\tif (e",
            ")"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d by",
          "args": [
            "es to LEB %d:%d\", n, wbuf->ln",
            ",",
            "wb",
            "err = ub"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, wbuf->lnu",
          "args": [
            ",",
            "uf, wbuf->",
            "fs,",
            "w",
            "if (err)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d by",
          "args": [
            "es to LEB %d:%d\",\n\t\t       wb",
            "buf->lnum,",
            "buf->offs)",
            "err = ub"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, wbuf->lnu",
          "args": [
            ",",
            "buf->buf,",
            "uf->offs,",
            "w",
            "if (err)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf +",
          "args": [
            "buf->used, buf, wbuf->",
            "ail",
            "err = ub"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhead",
          "args": [
            "%s wbuf to LEB %d:%d\",\n\t\t       db",
            "f->jhead), wbuf->lnum,",
            "buf->offs)",
            "memcpy(w"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            "wbuf->lnum"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "}\n\n\t\tgot"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "wbuf->a"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "} else {"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "wbuf->o"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, wbuf->lnu",
          "args": [
            ",",
            "buf->buf,",
            "buf->size)",
            "if (err"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhead",
          "args": [
            "%s wbuf to LEB %d:%d\",\n\t\t\t       d",
            "f->jhead), wbuf->lnum,",
            "buf->offs)",
            "err = u"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            "wbuf->lnum"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf +",
          "args": [
            "buf->used, buf, len);",
            "if",
            "ali"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imer_nolock(wbuf);\n\n\tif",
          "args": [
            "c->r"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!((wbuf->off",
          "args": [
            "+ wbuf->size) % c->max_write_size));\n\n\tif (c->l"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->space_fi",
          "args": [
            "up);\n\tif (c->le"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tubifs_ass"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&wbuf->io_mutex));\n\tubifs_ass"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&wbuf->io_mu",
          "args": [
            "ex));\n\tubifs_as"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size %",
          "args": [
            "c->min_io_size == 0);\n\tubifs_ass"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size <",
          "args": [
            "c->max_write_size);\n\tubifs_ass"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size >",
          "args": [
            "c->min_io_size);\n\tubifs_ass"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->avail",
          "args": [
            "0 && wbuf->avail <= wbuf->size);\n\tubifs_ass"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(wbuf->offs",
          "args": [
            "& 7) && wbuf->offs <= c->leb_size);\n\tubifs_ass"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->offs >",
          "args": [
            "0 && wbuf->offs % c->min_io_size == 0);\n\tubifs_ass"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len > 0 && w",
          "args": [
            "uf->lnum >= 0 && wbuf->lnum < c->leb_cnt);\n\tubifs_ass"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tes (%",
          "args": [
            ") to jhead %s wbuf at LEB %d:%d\", len,",
            "dbg",
            "truct ubifs_ch *)buf)->node_type),\n\t       dbg",
            "f->jhead), wbuf->lnum,",
            "buf->offs",
            "wbuf->used);\n\tubifs_ass"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            "wbuf->lnum"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truct ubi",
          "args": [
            "s_ch *)buf)->node_type),\n\t       db"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "s_sync(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
          "lines": "603-657",
          "snippet": "wbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nwbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": ";\n\n\td",
          "args": [
            "g_i",
            "\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nf_write_nolock(struct ubifs_wbuf *wbuf, void *buf, int len)\n{\n\tstruct ubifs_info *c = wbuf->c;\n\tint err, written, n, aligned_len = ALIGN(len, 8);\n\n\tdbg_io(\"%d bytes (%s) to jhead %s wbuf at LEB %d:%d\", len,\n\t       dbg_ntype(((struct ubifs_ch *)buf)->node_type),\n\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs + wbuf->used);\n\tubifs_assert(len > 0 && wbuf->lnum >= 0 && wbuf->lnum < c->leb_cnt);\n\tubifs_assert(wbuf->offs >= 0 && wbuf->offs % c->min_io_size == 0);\n\tubifs_assert(!(wbuf->offs & 7) && wbuf->offs <= c->leb_size);\n\tubifs_assert(wbuf->avail > 0 && wbuf->avail <= wbuf->size);\n\tubifs_assert(wbuf->size >= c->min_io_size);\n\tubifs_assert(wbuf->size <= c->max_write_size);\n\tubifs_assert(wbuf->size % c->min_io_size == 0);\n\tubifs_assert(mutex_is_locked(&wbuf->io_mutex));\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tubifs_assert(!c->space_fixup);\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\tubifs_assert(!((wbuf->offs + wbuf->size) % c->max_write_size));\n\n\tif (c->leb_size - wbuf->offs - wbuf->used < aligned_len) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tcancel_wbuf_timer_nolock(wbuf);\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\tif (aligned_len <= wbuf->avail) {\n\t\t/*\n\t\t * The node is not very large and fits entirely within\n\t\t * write-buffer.\n\t\t */\n\t\tmemcpy(wbuf->buf + wbuf->used, buf, len);\n\n\t\tif (aligned_len == wbuf->avail) {\n\t\t\tdbg_io(\"flush jhead %s wbuf to LEB %d:%d\",\n\t\t\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);\n\t\t\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf,\n\t\t\t\t\t      wbuf->offs, wbuf->size);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&wbuf->lock);\n\t\t\twbuf->offs += wbuf->size;\n\t\t\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\t\t\twbuf->size = c->max_write_size;\n\t\t\telse\n\t\t\t\twbuf->size = c->leb_size - wbuf->offs;\n\t\t\twbuf->avail = wbuf->size;\n\t\t\twbuf->used = 0;\n\t\t\twbuf->next_ino = 0;\n\t\t\tspin_unlock(&wbuf->lock);\n\t\t} else {\n\t\t\tspin_lock(&wbuf->lock);\n\t\t\twbuf->avail -= aligned_len;\n\t\t\twbuf->used += aligned_len;\n\t\t\tspin_unlock(&wbuf->lock);\n\t\t}\n\n\t\tgoto exit;\n\t}\n\n\twritten = 0;\n\n\tif (wbuf->used) {\n\t\t/*\n\t\t * The node is large enough and does not fit entirely within\n\t\t * current available space. We have to fill and flush\n\t\t * write-buffer and switch to the next max. write unit.\n\t\t */\n\t\tdbg_io(\"flush jhead %s wbuf to LEB %d:%d\",\n\t\t       dbg_jhead(wbuf->jhead), wbuf->lnum, wbuf->offs);\n\t\tmemcpy(wbuf->buf + wbuf->used, buf, wbuf->avail);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf, wbuf->offs,\n\t\t\t\t      wbuf->size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twbuf->offs += wbuf->size;\n\t\tlen -= wbuf->avail;\n\t\taligned_len -= wbuf->avail;\n\t\twritten += wbuf->avail;\n\t} else if (wbuf->offs & (c->max_write_size - 1)) {\n\t\t/*\n\t\t * The write-buffer offset is not aligned to\n\t\t * @c->max_write_size and @wbuf->size is less than\n\t\t * @c->max_write_size. Write @wbuf->size bytes to make sure the\n\t\t * following writes are done in optimal @c->max_write_size\n\t\t * chunks.\n\t\t */\n\t\tdbg_io(\"write %d bytes to LEB %d:%d\",\n\t\t       wbuf->size, wbuf->lnum, wbuf->offs);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, buf, wbuf->offs,\n\t\t\t\t      wbuf->size);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\twbuf->offs += wbuf->size;\n\t\tlen -= wbuf->size;\n\t\taligned_len -= wbuf->size;\n\t\twritten += wbuf->size;\n\t}\n\n\t/*\n\t * The remaining data may take more whole max. write units, so write the\n\t * remains multiple to max. write unit size directly to the flash media.\n\t * We align node length to 8-byte boundary because we anyway flash wbuf\n\t * if the remaining space is less than 8 bytes.\n\t */\n\tn = aligned_len >> c->max_write_shift;\n\tif (n) {\n\t\tn <<= c->max_write_shift;\n\t\tdbg_io(\"write %d bytes to LEB %d:%d\", n, wbuf->lnum,\n\t\t       wbuf->offs);\n\t\terr = ubifs_leb_write(c, wbuf->lnum, buf + written,\n\t\t\t\t      wbuf->offs, n);\n\t\tif (err)\n\t\t\tgoto out;\n\t\twbuf->offs += n;\n\t\taligned_len -= n;\n\t\tlen -= n;\n\t\twritten += n;\n\t}\n\n\tspin_lock(&wbuf->lock);\n\tif (aligned_len)\n\t\t/*\n\t\t * And now we have what's left and what does not take whole\n\t\t * max. write unit, so write it to the write-buffer and we are\n\t\t * done.\n\t\t */\n\t\tmemcpy(wbuf->buf, buf + written, len);\n\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\twbuf->size = c->max_write_size;\n\telse\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\twbuf->avail = wbuf->size - aligned_len;\n\twbuf->used = aligned_len;\n\twbuf->next_ino = 0;\n\tspin_unlock(&wbuf->lock);\n\nexit:\n\tif (wbuf->sync_callback) {\n\t\tint free = c->leb_size - wbuf->offs - wbuf->used;\n\n\t\terr = wbuf->sync_callback(c, wbuf->lnum, free, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (wbuf->used)\n\t\tnew_wbuf_timer_nolock(wbuf);\n\n\treturn 0;\n\nout:\n\tubifs_err(\"cannot write %d bytes to LEB %d:%d, error %d\",\n\t\t  len, wbuf->lnum, wbuf->offs, err);\n\tubifs_dump_node(c, buf);\n\tdump_stack();\n\tubifs_dump_leb(c, wbuf->lnum);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "s_sync(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "603-657",
    "snippet": "wbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\t}\n\treturn"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imer_nolock(wbuf);\n\t\tmut",
          "args": [
            "x_un"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "cancel_w"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);",
          "args": [
            "o",
            "ou"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot sync",
          "args": [
            "write-buffer, error %d\", err);\n\t\t\tub",
            "s_r"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\t\tif (err)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\t\tmut",
          "args": [
            "x_un"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\t\t\tcontinu"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "if (!wbu"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&wbuf->io_mu",
          "args": [
            "ex))\n\t\t\tcontinu"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\t/*",
          "args": [],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ronize",
          "args": [
            ");\n\tfor (i ="
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (!c->n"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nwbufs_sync(struct ubifs_info *c)\n{\n\tint err, i;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (!c->need_wbuf_sync)\n\t\treturn 0;\n\tc->need_wbuf_sync = 0;\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_timers;\n\t}\n\n\tdbg_io(\"synchronize\");\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * If the mutex is locked then wbuf is being changed, so\n\t\t * synchronization is not necessary.\n\t\t */\n\t\tif (mutex_is_locked(&wbuf->io_mutex))\n\t\t\tcontinue;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tif (!wbuf->need_sync) {\n\t\t\tmutex_unlock(&wbuf->io_mutex);\n\t\t\tcontinue;\n\t\t}\n\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t\tif (err) {\n\t\t\tubifs_err(\"cannot sync write-buffer, error %d\", err);\n\t\t\tubifs_ro_mode(c, err);\n\t\t\tgoto out_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_timers:\n\t/* Cancel all timers to prevent repeated errors */\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[i].wbuf;\n\n\t\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\t\tcancel_wbuf_timer_nolock(wbuf);\n\t\tmutex_unlock(&wbuf->io_mutex);\n\t}\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ek_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "568-593",
    "snippet": "f_seek_nolock(struct ubifs_wbuf *wbuf, int lnum, int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\n\tdbg_io(\"LEB %d:%d, jhead %s\", lnum, offs, dbg_jhead(wbuf->jhead));\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt);\n\tubifs_assert(offs >= 0 && offs <= c->leb_size);\n\tubifs_assert(offs % c->min_io_size == 0 && !(offs & 7));\n\tubifs_assert(lnum != wbuf->lnum);\n\tubifs_assert(wbuf->used == 0);\n\n\tspin_lock(&wbuf->lock);\n\twbuf->lnum = lnum;\n\twbuf->offs = offs;\n\tif (c->leb_size - wbuf->offs < c->max_write_size)\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\telse if (wbuf->offs & (c->max_write_size - 1))\n\t\twbuf->size = ALIGN(wbuf->offs, c->max_write_size) - wbuf->offs;\n\telse\n\t\twbuf->size = c->max_write_size;\n\twbuf->avail = wbuf->size;\n\twbuf->used = 0;\n\tspin_unlock(&wbuf->lock);\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "return 0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs,",
          "args": [
            "->max_writ",
            "size) - wbuf->off"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "wbuf->lnu"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->used =",
          "args": [
            "0);\n\n\tspin_loc"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum != wbuf",
          "args": [
            ">lnum);\n\tubifs_ass"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs % c->mi",
          "args": [
            "_io_size == 0 && !(offs & 7));\n\tubifs_ass"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offs >= 0 &&",
          "args": [
            "offs <= c->leb_size);\n\tubifs_ass"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= 0 &&",
          "args": [
            "lnum < c->leb_cnt);\n\tubifs_ass"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "head %s\", lnum, offs,",
            "bg_j",
            "ad(w",
            "f->jhead));\n\tubifs_ass"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            ";\n\tubifs_as"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nf_seek_nolock(struct ubifs_wbuf *wbuf, int lnum, int offs)\n{\n\tconst struct ubifs_info *c = wbuf->c;\n\n\tdbg_io(\"LEB %d:%d, jhead %s\", lnum, offs, dbg_jhead(wbuf->jhead));\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt);\n\tubifs_assert(offs >= 0 && offs <= c->leb_size);\n\tubifs_assert(offs % c->min_io_size == 0 && !(offs & 7));\n\tubifs_assert(lnum != wbuf->lnum);\n\tubifs_assert(wbuf->used == 0);\n\n\tspin_lock(&wbuf->lock);\n\twbuf->lnum = lnum;\n\twbuf->offs = offs;\n\tif (c->leb_size - wbuf->offs < c->max_write_size)\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\telse if (wbuf->offs & (c->max_write_size - 1))\n\t\twbuf->size = ALIGN(wbuf->offs, c->max_write_size) - wbuf->offs;\n\telse\n\t\twbuf->size = c->max_write_size;\n\twbuf->avail = wbuf->size;\n\twbuf->used = 0;\n\tspin_unlock(&wbuf->lock);\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "nc_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "493-556",
    "snippet": "f_sync_nolock(struct ubifs_wbuf *wbuf)\n{\n\tstruct ubifs_info *c = wbuf->c;\n\tint err, dirt, sync_len;\n\n\tcancel_wbuf_timer_nolock(wbuf);\n\tif (!wbuf->used || wbuf->lnum == -1)\n\t\t/* Write-buffer is empty or not seeked */\n\t\treturn 0;\n\n\tdbg_io(\"LEB %d:%d, %d bytes, jhead %s\",\n\t       wbuf->lnum, wbuf->offs, wbuf->used, dbg_jhead(wbuf->jhead));\n\tubifs_assert(!(wbuf->avail & 7));\n\tubifs_assert(wbuf->offs + wbuf->size <= c->leb_size);\n\tubifs_assert(wbuf->size >= c->min_io_size);\n\tubifs_assert(wbuf->size <= c->max_write_size);\n\tubifs_assert(wbuf->size % c->min_io_size == 0);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\tubifs_assert(!((wbuf->offs + wbuf->size) % c->max_write_size));\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\t/*\n\t * Do not write whole write buffer but write only the minimum necessary\n\t * amount of min. I/O units.\n\t */\n\tsync_len = ALIGN(wbuf->used, c->min_io_size);\n\tdirt = sync_len - wbuf->used;\n\tif (dirt)\n\t\tubifs_pad(c, wbuf->buf + wbuf->used, dirt);\n\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf, wbuf->offs, sync_len);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&wbuf->lock);\n\twbuf->offs += sync_len;\n\t/*\n\t * Now @wbuf->offs is not necessarily aligned to @c->max_write_size.\n\t * But our goal is to optimize writes and make sure we write in\n\t * @c->max_write_size chunks and to @c->max_write_size-aligned offset.\n\t * Thus, if @wbuf->offs is not aligned to @c->max_write_size now, make\n\t * sure that @wbuf->offs + @wbuf->size is aligned to\n\t * @c->max_write_size. This way we make sure that after next\n\t * write-buffer flush we are again at the optimal offset (aligned to\n\t * @c->max_write_size).\n\t */\n\tif (c->leb_size - wbuf->offs < c->max_write_size)\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\telse if (wbuf->offs & (c->max_write_size - 1))\n\t\twbuf->size = ALIGN(wbuf->offs, c->max_write_size) - wbuf->offs;\n\telse\n\t\twbuf->size = c->max_write_size;\n\twbuf->avail = wbuf->size;\n\twbuf->used = 0;\n\twbuf->next_ino = 0;\n\tspin_unlock(&wbuf->lock);\n\n\tif (wbuf->sync_callback)\n\t\terr = wbuf->sync_callback(c, wbuf->lnum,\n\t\t\t\t\t  c->leb_size - wbuf->offs, dirt);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "llback",
          "args": [
            ",",
            "c->l",
            "wbuf->offs, dirt);\n\tret",
            "n er"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "999-1082",
          "snippet": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)",
            "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)\n\nstatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbuf->lock)",
          "args": [
            "if (wbuf"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs,",
          "args": [
            "->max_writ",
            "size) - wbuf->off"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf->lock)",
          "args": [
            "wbuf->off"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, wbuf->lnu",
          "args": [
            ",",
            "buf->buf,",
            "uf->offs,",
            "ync_len);",
            "f (err)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->buf",
          "args": [
            "+",
            "buf->used, dirt);\n\terr",
            "ubi"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sed,",
          "args": [
            "->min_io_s",
            "e);\n\tdirt = sy"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!((wbuf->off",
          "args": [
            "+ wbuf->size) % c->max_write_size));\n\n\tif (c->r"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->le"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size %",
          "args": [
            "c->min_io_size == 0);\n\tubifs_ass"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size <",
          "args": [
            "c->max_write_size);\n\tubifs_ass"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->size >",
          "args": [
            "c->min_io_size);\n\tubifs_ass"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbuf->offs +",
          "args": [
            "wbuf->size <= c->leb_size);\n\tubifs_ass"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(wbuf->avai",
          "args": [
            "& 7));\n\tubifs_ass"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d:%d,",
          "args": [
            "d bytes, jhead %s\",\n\t       wbu",
            "buf->offs,",
            "buf->used,",
            "bg_jhead(w",
            "f->jhead));\n\tubifs_ass"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            ";\n\tubifs_as"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imer_nolock(wbuf);\n\tif (",
          "args": [
            "wbuf"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nf_sync_nolock(struct ubifs_wbuf *wbuf)\n{\n\tstruct ubifs_info *c = wbuf->c;\n\tint err, dirt, sync_len;\n\n\tcancel_wbuf_timer_nolock(wbuf);\n\tif (!wbuf->used || wbuf->lnum == -1)\n\t\t/* Write-buffer is empty or not seeked */\n\t\treturn 0;\n\n\tdbg_io(\"LEB %d:%d, %d bytes, jhead %s\",\n\t       wbuf->lnum, wbuf->offs, wbuf->used, dbg_jhead(wbuf->jhead));\n\tubifs_assert(!(wbuf->avail & 7));\n\tubifs_assert(wbuf->offs + wbuf->size <= c->leb_size);\n\tubifs_assert(wbuf->size >= c->min_io_size);\n\tubifs_assert(wbuf->size <= c->max_write_size);\n\tubifs_assert(wbuf->size % c->min_io_size == 0);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->leb_size - wbuf->offs >= c->max_write_size)\n\t\tubifs_assert(!((wbuf->offs + wbuf->size) % c->max_write_size));\n\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\n\t/*\n\t * Do not write whole write buffer but write only the minimum necessary\n\t * amount of min. I/O units.\n\t */\n\tsync_len = ALIGN(wbuf->used, c->min_io_size);\n\tdirt = sync_len - wbuf->used;\n\tif (dirt)\n\t\tubifs_pad(c, wbuf->buf + wbuf->used, dirt);\n\terr = ubifs_leb_write(c, wbuf->lnum, wbuf->buf, wbuf->offs, sync_len);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&wbuf->lock);\n\twbuf->offs += sync_len;\n\t/*\n\t * Now @wbuf->offs is not necessarily aligned to @c->max_write_size.\n\t * But our goal is to optimize writes and make sure we write in\n\t * @c->max_write_size chunks and to @c->max_write_size-aligned offset.\n\t * Thus, if @wbuf->offs is not aligned to @c->max_write_size now, make\n\t * sure that @wbuf->offs + @wbuf->size is aligned to\n\t * @c->max_write_size. This way we make sure that after next\n\t * write-buffer flush we are again at the optimal offset (aligned to\n\t * @c->max_write_size).\n\t */\n\tif (c->leb_size - wbuf->offs < c->max_write_size)\n\t\twbuf->size = c->leb_size - wbuf->offs;\n\telse if (wbuf->offs & (c->max_write_size - 1))\n\t\twbuf->size = ALIGN(wbuf->offs, c->max_write_size) - wbuf->offs;\n\telse\n\t\twbuf->size = c->max_write_size;\n\twbuf->avail = wbuf->size;\n\twbuf->used = 0;\n\twbuf->next_ino = 0;\n\tspin_unlock(&wbuf->lock);\n\n\tif (wbuf->sync_callback)\n\t\terr = wbuf->sync_callback(c, wbuf->lnum,\n\t\t\t\t\t  c->leb_size - wbuf->offs, dirt);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "imer_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "472-478",
    "snippet": "ancel_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)\n{\n\tif (wbuf->no_timer)\n\t\treturn;\n\twbuf->need_sync = 0;\n\thrtimer_cancel(&wbuf->timer);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l(&wbuf->timer",
          "args": [
            ";\n}\n\n/**\n *"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nancel_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)\n{\n\tif (wbuf->no_timer)\n\t\treturn;\n\twbuf->need_sync = 0;\n\thrtimer_cancel(&wbuf->timer);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "r_nolock(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "453-466",
    "snippet": "ew_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)\n{\n\tubifs_assert(!hrtimer_active(&wbuf->timer));\n\n\tif (wbuf->no_timer)\n\t\treturn;\n\tdbg_io(\"set timer for jhead %s, %llu-%llu millisecs\",\n\t       dbg_jhead(wbuf->jhead),\n\t       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),\n\t       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,\n\t\t       USEC_PER_SEC));\n\thrtimer_start_range_ns(&wbuf->timer, wbuf->softlimit, wbuf->delta,\n\t\t\t       HRTIMER_MODE_REL);\n}\n\n/**\n * canc",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_range_ns(&wbuf->timer",
          "args": [
            "wbuf->softl",
            "it, wbuf->delta",
            "H",
            "REL);\n}\n\n/**\n *"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imer f",
          "args": [
            "r jhead %s, %llu-%llu millisecs\",\n\t       dbg",
            "f->jhead),\n\t       div",
            "_to_ns(wbuf->softlimit), USEC_PER_SEC),\n\t       div",
            "_to_ns(wbuf->softlimit) + wbuf->delta,\n\t\t       USEC_PER_SEC));\n\thrtimer_s"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_ns(",
          "args": [
            "buf->softlimit) + wbuf->delta,\n\t\t       US",
            ");\n\thrtimer_"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->softli",
          "args": [
            "it) + wbuf->del"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_ns(",
          "args": [
            "buf->softlimit), USEC_PER_SE",
            ",\n\t       di"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->softli",
          "args": [
            "it), USEC_PER_S"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            "di"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!hrtimer_act",
          "args": [
            "ve(&wbuf->timer));\n\n\tif (wbuf"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(&wbuf->timer",
          "args": [
            ");\n\n\tif (wbu"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\new_wbuf_timer_nolock(struct ubifs_wbuf *wbuf)\n{\n\tubifs_assert(!hrtimer_active(&wbuf->timer));\n\n\tif (wbuf->no_timer)\n\t\treturn;\n\tdbg_io(\"set timer for jhead %s, %llu-%llu millisecs\",\n\t       dbg_jhead(wbuf->jhead),\n\t       div_u64(ktime_to_ns(wbuf->softlimit), USEC_PER_SEC),\n\t       div_u64(ktime_to_ns(wbuf->softlimit) + wbuf->delta,\n\t\t       USEC_PER_SEC));\n\thrtimer_start_range_ns(&wbuf->timer, wbuf->softlimit, wbuf->delta,\n\t\t\t       HRTIMER_MODE_REL);\n}\n\n/**\n * canc"
  },
  {
    "function_name": "llback_nolock(struct hrtim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "438-447",
    "snippet": "rtimer_restart wbuf_timer_callback_nolock(struct hrtimer *timer)\n{\n\tstruct ubifs_wbuf *wbuf = container_of(timer, struct ubifs_wbuf, timer);\n\n\tdbg_io(\"jhead %s\", dbg_jhead(wbuf->jhead));\n\twbuf->need_sync = 1;\n\twbuf->c->need_wbuf_sync = 1;\n\tubifs_wake_up_bgt(wbuf->c);\n\treturn HRTIMER_NORESTART;\n}\n\n/**\n * new_",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_bgt(wbuf->c);\n\tr",
          "args": [
            "turn HR"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%s\",",
          "args": [
            "bg_jhead(w",
            "f->jhead));\n\twbuf->nee"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->jhead)",
          "args": [
            ";\n\twbuf->ne"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer, struc",
          "args": [
            "ubif",
            "wbuf, imer);\n\n\td",
            "_io(\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nrtimer_restart wbuf_timer_callback_nolock(struct hrtimer *timer)\n{\n\tstruct ubifs_wbuf *wbuf = container_of(timer, struct ubifs_wbuf, timer);\n\n\tdbg_io(\"jhead %s\", dbg_jhead(wbuf->jhead));\n\twbuf->need_sync = 1;\n\twbuf->c->need_wbuf_sync = 1;\n\tubifs_wake_up_bgt(wbuf->c);\n\treturn HRTIMER_NORESTART;\n}\n\n/**\n * new_"
  },
  {
    "function_name": "p_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "412-430",
    "snippet": "ep_grp_node(struct ubifs_info *c, void *node, int len, int last)\n{\n\tuint32_t crc;\n\tstruct ubifs_ch *ch = node;\n\tunsigned long long sqnum = next_sqnum(c);\n\n\tubifs_assert(len >= UBIFS_CH_SZ);\n\n\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\tch->len = cpu_to_le32(len);\n\tif (last)\n\t\tch->group_type = UBIFS_LAST_OF_NODE_GROUP;\n\telse\n\t\tch->group_type = UBIFS_IN_NODE_GROUP;\n\tch->sqnum = cpu_to_le64(sqnum);\n\tch->padding[0] = ch->padding[1] = 0;\n\tcrc = crc32(UBIFS_CRC32_INIT, node + 8, len - 8);\n\tch->crc = cpu_to_le32(crc);\n}\n\n/**\n * wbuf",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rc);\n}\n\n/**",
          "args": [
            "*"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, node + 8, l",
            "- 8);",
            "->crc ="
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnum);\n\tch-",
          "args": [
            "paddi"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en);\n\tif (l",
          "args": [
            "st)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_NODE_M",
          "args": [
            "GIC);\n\tch->len ="
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len >= UBIFS",
          "args": [
            "CH_SZ);\n\n\tch->magi"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tubifs_",
          "args": [
            "s"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nep_grp_node(struct ubifs_info *c, void *node, int len, int last)\n{\n\tuint32_t crc;\n\tstruct ubifs_ch *ch = node;\n\tunsigned long long sqnum = next_sqnum(c);\n\n\tubifs_assert(len >= UBIFS_CH_SZ);\n\n\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\tch->len = cpu_to_le32(len);\n\tif (last)\n\t\tch->group_type = UBIFS_LAST_OF_NODE_GROUP;\n\telse\n\t\tch->group_type = UBIFS_IN_NODE_GROUP;\n\tch->sqnum = cpu_to_le64(sqnum);\n\tch->padding[0] = ch->padding[1] = 0;\n\tcrc = crc32(UBIFS_CRC32_INIT, node + 8, len - 8);\n\tch->crc = cpu_to_le32(crc);\n}\n\n/**\n * wbuf"
  },
  {
    "function_name": "_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "379-400",
    "snippet": "epare_node(struct ubifs_info *c, void *node, int len, int pad)\n{\n\tuint32_t crc;\n\tstruct ubifs_ch *ch = node;\n\tunsigned long long sqnum = next_sqnum(c);\n\n\tubifs_assert(len >= UBIFS_CH_SZ);\n\n\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\tch->len = cpu_to_le32(len);\n\tch->group_type = UBIFS_NO_NODE_GROUP;\n\tch->sqnum = cpu_to_le64(sqnum);\n\tch->padding[0] = ch->padding[1] = 0;\n\tcrc = crc32(UBIFS_CRC32_INIT, node + 8, len - 8);\n\tch->crc = cpu_to_le32(crc);\n\n\tif (pad) {\n\t\tlen = ALIGN(len, 8);\n\t\tpad = ALIGN(len, c->min_io_size) - len;\n\t\tubifs_pad(c, node + len, pad);\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node + le",
          "args": [
            ",",
            "ad);\n\t}\n}",
            "**"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e) - len;\n\t\tub"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tp",
          "args": [
            "d =",
            "L"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc);\n\n\tif (",
          "args": [
            "ad)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, node + 8, l",
            "- 8);",
            "->crc ="
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qnum);\n\tch-",
          "args": [
            "paddi"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en);\n\tch->g",
          "args": [
            "oup"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_NODE_M",
          "args": [
            "GIC);\n\tch->len ="
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len >= UBIFS",
          "args": [
            "CH_SZ);\n\n\tch->magi"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n\tubifs_",
          "args": [
            "s"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nepare_node(struct ubifs_info *c, void *node, int len, int pad)\n{\n\tuint32_t crc;\n\tstruct ubifs_ch *ch = node;\n\tunsigned long long sqnum = next_sqnum(c);\n\n\tubifs_assert(len >= UBIFS_CH_SZ);\n\n\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\tch->len = cpu_to_le32(len);\n\tch->group_type = UBIFS_NO_NODE_GROUP;\n\tch->sqnum = cpu_to_le64(sqnum);\n\tch->padding[0] = ch->padding[1] = 0;\n\tcrc = crc32(UBIFS_CRC32_INIT, node + 8, len - 8);\n\tch->crc = cpu_to_le32(crc);\n\n\tif (pad) {\n\t\tlen = ALIGN(len, 8);\n\t\tpad = ALIGN(len, c->min_io_size) - len;\n\t\tubifs_pad(c, node + len, pad);\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "348-366",
    "snippet": "ed long long next_sqnum(struct ubifs_info *c)\n{\n\tunsigned long long sqnum;\n\n\tspin_lock(&c->cnt_lock);\n\tsqnum = ++c->max_sqnum;\n\tspin_unlock(&c->cnt_lock);\n\n\tif (unlikely(sqnum >= SQNUM_WARN_WATERMARK)) {\n\t\tif (sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"sequence number overflow %llu, end of life\",\n\t\t\t\t  sqnum);\n\t\t\tubifs_ro_mode(c, -EINVAL);\n\t\t}\n\t\tubifs_warn(\"running out of sequence numbers, end of life soon\");\n\t}\n\n\treturn sqnum;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unning out",
          "args": [
            "of sequence numbers, end of life soon\");\n\t}\n\n\tretur"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, -EINVAL);",
          "args": [
            "ubif"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "quence nu",
          "args": [
            "ber overflow %llu, end of life\",\n\t\t\t\t  sqnum",
            "ifs_r"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m >= SQN",
          "args": [
            "M_WARN_WATERMARK)) {\n\t\tif (sq"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->cnt_lock",
          "args": [
            ";\n\n\tif (unli"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">cnt_lock",
          "args": [
            ";\n\tsqnum = +"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ned long long next_sqnum(struct ubifs_info *c)\n{\n\tunsigned long long sqnum;\n\n\tspin_lock(&c->cnt_lock);\n\tsqnum = ++c->max_sqnum;\n\tspin_unlock(&c->cnt_lock);\n\n\tif (unlikely(sqnum >= SQNUM_WARN_WATERMARK)) {\n\t\tif (sqnum >= SQNUM_WATERMARK) {\n\t\t\tubifs_err(\"sequence number overflow %llu, end of life\",\n\t\t\t\t  sqnum);\n\t\t\tubifs_ro_mode(c, -EINVAL);\n\t\t}\n\t\tubifs_warn(\"running out of sequence numbers, end of life soon\");\n\t}\n\n\treturn sqnum;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "st struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "318-342",
    "snippet": "d(const struct ubifs_info *c, void *buf, int pad)\n{\n\tuint32_t crc;\n\n\tubifs_assert(pad >= 0 && !(pad & 7));\n\n\tif (pad >= UBIFS_PAD_NODE_SZ) {\n\t\tstruct ubifs_ch *ch = buf;\n\t\tstruct ubifs_pad_node *pad_node = buf;\n\n\t\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\t\tch->node_type = UBIFS_PAD_NODE;\n\t\tch->group_type = UBIFS_NO_NODE_GROUP;\n\t\tch->padding[0] = ch->padding[1] = 0;\n\t\tch->sqnum = 0;\n\t\tch->len = cpu_to_le32(UBIFS_PAD_NODE_SZ);\n\t\tpad -= UBIFS_PAD_NODE_SZ;\n\t\tpad_node->pad_len = cpu_to_le32(pad);\n\t\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, UBIFS_PAD_NODE_SZ - 8);\n\t\tch->crc = cpu_to_le32(crc);\n\t\tmemset(buf + UBIFS_PAD_NODE_SZ, 0, pad);\n\t} else if (pad > 0)\n\t\t/* Too little space, padding node won't fit */\n\t\tmemset(buf, UBIFS_PADDING_BYTE, pad);\n}\n\n/**\n * next",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIFS_P",
          "args": [
            "DDI",
            "_BYTE, pad);\n}\n\n/*",
            "*"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS_",
          "args": [
            "AD_NODE_SZ, 0, pad);\n\t}",
            "l",
            "if"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc);\n\t\tmems",
          "args": [
            "t(b"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, buf + 8, UB",
            "S_PAD_N",
            "E_SZ - 8);\n\t\tch->crc"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad);\n\t\tcrc",
          "args": [
            "cr"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_PAD_NO",
          "args": [
            "E_SZ);\n\t\tpad -= U"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_NODE_M",
          "args": [
            "GIC);\n\t\tch->node"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pad >= 0 &&",
          "args": [
            "(pad & 7));\n\n\tif (pad"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd(const struct ubifs_info *c, void *buf, int pad)\n{\n\tuint32_t crc;\n\n\tubifs_assert(pad >= 0 && !(pad & 7));\n\n\tif (pad >= UBIFS_PAD_NODE_SZ) {\n\t\tstruct ubifs_ch *ch = buf;\n\t\tstruct ubifs_pad_node *pad_node = buf;\n\n\t\tch->magic = cpu_to_le32(UBIFS_NODE_MAGIC);\n\t\tch->node_type = UBIFS_PAD_NODE;\n\t\tch->group_type = UBIFS_NO_NODE_GROUP;\n\t\tch->padding[0] = ch->padding[1] = 0;\n\t\tch->sqnum = 0;\n\t\tch->len = cpu_to_le32(UBIFS_PAD_NODE_SZ);\n\t\tpad -= UBIFS_PAD_NODE_SZ;\n\t\tpad_node->pad_len = cpu_to_le32(pad);\n\t\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, UBIFS_PAD_NODE_SZ - 8);\n\t\tch->crc = cpu_to_le32(crc);\n\t\tmemset(buf + UBIFS_PAD_NODE_SZ, 0, pad);\n\t} else if (pad > 0)\n\t\t/* Too little space, padding node won't fit */\n\t\tmemset(buf, UBIFS_PADDING_BYTE, pad);\n}\n\n/**\n * next"
  },
  {
    "function_name": "ode(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "237-300",
    "snippet": "ck_node(const struct ubifs_info *c, const void *buf, int lnum,\n\t\t     int offs, int quiet, int must_chk_crc)\n{\n\tint err = -EINVAL, type, node_len;\n\tuint32_t crc, node_crc, magic;\n\tconst struct ubifs_ch *ch = buf;\n\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\n\tmagic = le32_to_cpu(ch->magic);\n\tif (magic != UBIFS_NODE_MAGIC) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad magic %#08x, expected %#08x\",\n\t\t\t\t  magic, UBIFS_NODE_MAGIC);\n\t\terr = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\ttype = ch->node_type;\n\tif (type < 0 || type >= UBIFS_NODE_TYPES_CNT) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad node type %d\", type);\n\t\tgoto out;\n\t}\n\n\tnode_len = le32_to_cpu(ch->len);\n\tif (node_len + offs > c->leb_size)\n\t\tgoto out_len;\n\n\tif (c->ranges[type].max_len == 0) {\n\t\tif (node_len != c->ranges[type].len)\n\t\t\tgoto out_len;\n\t} else if (node_len < c->ranges[type].min_len ||\n\t\t   node_len > c->ranges[type].max_len)\n\t\tgoto out_len;\n\n\tif (!must_chk_crc && type == UBIFS_DATA_NODE && !c->mounting &&\n\t    !c->remounting_rw && c->no_chk_data_crc)\n\t\treturn 0;\n\n\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\n\tnode_crc = le32_to_cpu(ch->crc);\n\tif (crc != node_crc) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad CRC: calculated %#08x, read %#08x\",\n\t\t\t\t  crc, node_crc);\n\t\terr = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout_len:\n\tif (!quiet)\n\t\tubifs_err(\"bad node length %d\", node_len);\nout:\n\tif (!quiet) {\n\t\tubifs_err(\"bad node at LEB %d:%d\", lnum, offs);\n\t\tubifs_dump_node(c, buf);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, buf);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node at",
          "args": [
            "LEB %d:%d\", lnum, offs)",
            "ub",
            "s_du"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node le",
          "args": [
            "gth %d\", node_len);",
            "t:\n\tif ("
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d CRC: ca",
          "args": [
            "culated %#08x, read %#08x\",\n\t\t\t\t  crc,",
            ");",
            "err = -E"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->crc);\n\ti",
          "args": [
            "(crc !"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, buf + 8, no",
            "_len -",
            ";\n\tnode_crc"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);\n\ti",
          "args": [
            "(node_"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d node ty",
          "args": [
            "e %d\", type);\n\t\tgo",
            "out"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d magic %",
          "args": [
            "08x, expected %#08x\",\n\t\t\t\t  magic",
            "NODE_",
            "GIC);\n\t\terr = -E"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->magic);",
          "args": [
            "if (magic"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(offs & 7)",
          "args": [
            "& offs < c->leb_size);\n\n\tmagic ="
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lnum >= 0 &&",
          "args": [
            "lnum < c->leb_cnt && offs >= 0);\n\tubifs_ass"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nck_node(const struct ubifs_info *c, const void *buf, int lnum,\n\t\t     int offs, int quiet, int must_chk_crc)\n{\n\tint err = -EINVAL, type, node_len;\n\tuint32_t crc, node_crc, magic;\n\tconst struct ubifs_ch *ch = buf;\n\n\tubifs_assert(lnum >= 0 && lnum < c->leb_cnt && offs >= 0);\n\tubifs_assert(!(offs & 7) && offs < c->leb_size);\n\n\tmagic = le32_to_cpu(ch->magic);\n\tif (magic != UBIFS_NODE_MAGIC) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad magic %#08x, expected %#08x\",\n\t\t\t\t  magic, UBIFS_NODE_MAGIC);\n\t\terr = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\ttype = ch->node_type;\n\tif (type < 0 || type >= UBIFS_NODE_TYPES_CNT) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad node type %d\", type);\n\t\tgoto out;\n\t}\n\n\tnode_len = le32_to_cpu(ch->len);\n\tif (node_len + offs > c->leb_size)\n\t\tgoto out_len;\n\n\tif (c->ranges[type].max_len == 0) {\n\t\tif (node_len != c->ranges[type].len)\n\t\t\tgoto out_len;\n\t} else if (node_len < c->ranges[type].min_len ||\n\t\t   node_len > c->ranges[type].max_len)\n\t\tgoto out_len;\n\n\tif (!must_chk_crc && type == UBIFS_DATA_NODE && !c->mounting &&\n\t    !c->remounting_rw && c->no_chk_data_crc)\n\t\treturn 0;\n\n\tcrc = crc32(UBIFS_CRC32_INIT, buf + 8, node_len - 8);\n\tnode_crc = le32_to_cpu(ch->crc);\n\tif (crc != node_crc) {\n\t\tif (!quiet)\n\t\t\tubifs_err(\"bad CRC: calculated %#08x, read %#08x\",\n\t\t\t\t  crc, node_crc);\n\t\terr = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout_len:\n\tif (!quiet)\n\t\tubifs_err(\"bad node length %d\", node_len);\nout:\n\tif (!quiet) {\n\t\tubifs_err(\"bad node at LEB %d:%d\", lnum, offs);\n\t\tubifs_dump_node(c, buf);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ed(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "196-207",
    "snippet": "mapped(const struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\terr = ubi_is_mapped(c->ubi, lnum);\n\tif (err < 0) {\n\t\tubifs_err(\"ubi_is_mapped failed for LEB %d, error %d\",\n\t\t\t  lnum, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_is_mapp",
          "args": [
            "d failed for LEB %d, error %d\",\n\t\t\t  lnum,",
            "dum",
            "sta"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            ";\n\tif",
            "rr <"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nmapped(const struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\terr = ubi_is_mapped(c->ubi, lnum);\n\tif (err < 0) {\n\t\tubifs_err(\"ubi_is_mapped failed for LEB %d, error %d\",\n\t\t\t  lnum, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "177-194",
    "snippet": "_map(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_map(c->ubi, lnum);\n\telse\n\t\terr = dbg_leb_map(c, lnum);\n\tif (err) {\n\t\tubifs_err(\"mapping LEB %d failed, error %d\", lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_i",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pping LEB",
          "args": [
            "%d failed, error %d\", lnum, err);",
            "ubi",
            "_ro"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", lnum);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ubi, lnum",
          "args": [
            ";\n\tels",
            "er"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vry(c))\n\t\terr =",
          "args": [
            "b"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->ro"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_map(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_map(c->ubi, lnum);\n\telse\n\t\terr = dbg_leb_map(c, lnum);\n\tif (err) {\n\t\tubifs_err(\"mapping LEB %d failed, error %d\", lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_i"
  },
  {
    "function_name": "ap(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "158-175",
    "snippet": "_unmap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_unmap(c->ubi, lnum);\n\telse\n\t\terr = dbg_leb_unmap(c, lnum);\n\tif (err) {\n\t\tubifs_err(\"unmap LEB %d failed, error %d\", lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map LEB %",
          "args": [
            "failed, error %d\", lnum, err);",
            "ubi",
            "_ro"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, lnum);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            ";\n\tels",
            "er"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vry(c))\n\t\terr =",
          "args": [
            "b"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->ro"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_unmap(struct ubifs_info *c, int lnum)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_unmap(c->ubi, lnum);\n\telse\n\t\terr = dbg_leb_unmap(c, lnum);\n\tif (err) {\n\t\tubifs_err(\"unmap LEB %d failed, error %d\", lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l"
  },
  {
    "function_name": "nge(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "138-156",
    "snippet": "_change(struct ubifs_info *c, int lnum, const void *buf, int len)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_change(c->ubi, lnum, buf, len);\n\telse\n\t\terr = dbg_leb_change(c, lnum, buf, len);\n\tif (err) {\n\t\tubifs_err(\"changing %d bytes in LEB %d failed, error %d\",\n\t\t\t  len, lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anging %d",
          "args": [
            "bytes in LEB %d failed, error %d\",\n\t\t\t  len, l",
            "r);",
            "ubi",
            "_ro"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c, lnum, buf",
          "args": [
            "n);",
            "f (",
            "r)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(c->ubi, lnum",
          "args": [
            "buf,",
            "n);",
            "lse",
            "er"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vry(c))\n\t\terr =",
          "args": [
            "b"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->ro"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_change(struct ubifs_info *c, int lnum, const void *buf, int len)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_change(c->ubi, lnum, buf, len);\n\telse\n\t\terr = dbg_leb_change(c, lnum, buf, len);\n\tif (err) {\n\t\tubifs_err(\"changing %d bytes in LEB %d failed, error %d\",\n\t\t\t  len, lnum, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l"
  },
  {
    "function_name": "te(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "117-136",
    "snippet": "_write(struct ubifs_info *c, int lnum, const void *buf, int offs,\n\t\t    int len)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_write(c->ubi, lnum, buf, offs, len);\n\telse\n\t\terr = dbg_leb_write(c, lnum, buf, offs, len);\n\tif (err) {\n\t\tubifs_err(\"writing %d bytes to LEB %d:%d failed, error %d\",\n\t\t\t  len, lnum, offs, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t\td",
          "args": [
            "m",
            "sta"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iting %d",
          "args": [
            "ytes to LEB %d:%d failed, error %d\",\n\t\t\t  len, l",
            "fs,",
            "rr);",
            "ubi",
            "_ro"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, lnum, buf",
          "args": [
            "fs,",
            "n);",
            "if (",
            "r)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c->ubi, lnum",
          "args": [
            "buf,",
            "fs,",
            "n);",
            "else",
            "er"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vry(c))\n\t\terr =",
          "args": [
            "b"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->ro"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_write(struct ubifs_info *c, int lnum, const void *buf, int offs,\n\t\t    int len)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error)\n\t\treturn -EROFS;\n\tif (!dbg_is_tst_rcvry(c))\n\t\terr = ubi_leb_write(c->ubi, lnum, buf, offs, len);\n\telse\n\t\terr = dbg_leb_write(c, lnum, buf, offs, len);\n\tif (err) {\n\t\tubifs_err(\"writing %d bytes to LEB %d:%d failed, error %d\",\n\t\t\t  len, lnum, offs, err);\n\t\tubifs_ro_mode(c, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l"
  },
  {
    "function_name": "d(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "99-115",
    "snippet": "_read(const struct ubifs_info *c, int lnum, void *buf, int offs,\n\t\t   int len, int even_ebadmsg)\n{\n\tint err;\n\n\terr = ubi_read(c->ubi, lnum, buf, offs, len);\n\t/*\n\t * In case of %-EBADMSG print the error message only if the\n\t * @even_ebadmsg is true.\n\t */\n\tif (err && (err != -EBADMSG || even_ebadmsg)) {\n\t\tubifs_err(\"reading %d bytes from LEB %d:%d failed, error %d\",\n\t\t\t  len, lnum, offs, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\tretur",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ading %d",
          "args": [
            "ytes from LEB %d:%d failed, error %d\",\n\t\t\t  len, l",
            "fs,",
            "rr);",
            "dum",
            "sta"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bi, lnum",
          "args": [
            "buf,",
            "fs,",
            "n);",
            "/*",
            "In"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_read(const struct ubifs_info *c, int lnum, void *buf, int offs,\n\t\t   int len, int even_ebadmsg)\n{\n\tint err;\n\n\terr = ubi_read(c->ubi, lnum, buf, offs, len);\n\t/*\n\t * In case of %-EBADMSG print the error message only if the\n\t * @even_ebadmsg is true.\n\t */\n\tif (err && (err != -EBADMSG || even_ebadmsg)) {\n\t\tubifs_err(\"reading %d bytes from LEB %d:%d failed, error %d\",\n\t\t\t  len, lnum, offs, err);\n\t\tdump_stack();\n\t}\n\treturn err;\n}\n\nint ubifs_l"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/io.c",
    "lines": "82-91",
    "snippet": "_mode(struct ubifs_info *c, int err)\n{\n\tif (!c->ro_error) {\n\t\tc->ro_error = 1;\n\t\tc->no_chk_data_crc = 0;\n\t\tc->vfs_sb->s_flags |= MS_RDONLY;\n\t\tubifs_warn(\"switched to read-only mode, error %d\", err);\n\t\tdump_stack();\n\t}\n}\n\n/*\n * Below",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n}\n\n/*",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "witched to",
          "args": [
            "read-only mode, error %d\", err);\n\t\tdum",
            "sta"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_mode(struct ubifs_info *c, int err)\n{\n\tif (!c->ro_error) {\n\t\tc->ro_error = 1;\n\t\tc->no_chk_data_crc = 0;\n\t\tc->vfs_sb->s_flags |= MS_RDONLY;\n\t\tubifs_warn(\"switched to read-only mode, error %d\", err);\n\t\tdump_stack();\n\t}\n}\n\n/*\n * Below"
  }
]