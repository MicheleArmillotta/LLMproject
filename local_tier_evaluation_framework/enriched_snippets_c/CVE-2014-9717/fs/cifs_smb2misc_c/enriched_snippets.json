[
  {
    "function_name": "smb2_is_valid_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "549-632",
    "snippet": "bool\nsmb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_oplock_break *rsp = (struct smb2_oplock_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break\\n\");\n\n\tif (rsp->hdr.Command != SMB2_OPLOCK_BREAK)\n\t\treturn false;\n\n\tif (rsp->StructureSize !=\n\t\t\t\tsmb2_rsp_struct_sizes[SMB2_OPLOCK_BREAK_HE]) {\n\t\tif (le16_to_cpu(rsp->StructureSize) == 44)\n\t\t\treturn smb2_is_valid_lease_break(buffer);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"oplock level 0x%x\\n\", rsp->OplockLevel);\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tlist_for_each(tmp1, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\n\n\t\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &tcon->openFileList) {\n\t\t\t\tcfile = list_entry(tmp2, struct cifsFileInfo,\n\t\t\t\t\t\t     tlist);\n\t\t\t\tif (rsp->PersistentFid !=\n\t\t\t\t    cfile->fid.persistent_fid ||\n\t\t\t\t    rsp->VolatileFid !=\n\t\t\t\t    cfile->fid.volatile_fid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\t\t\tif (!CIFS_CACHE_WRITE(cinode) &&\n\t\t\t\t    rsp->OplockLevel == SMB2_OPLOCK_LEVEL_NONE)\n\t\t\t\t\tcfile->oplock_break_cancelled = true;\n\t\t\t\telse\n\t\t\t\t\tcfile->oplock_break_cancelled = false;\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&cinode->flags);\n\n\t\t\t\t/*\n\t\t\t\t * Set flag if the server downgrades the oplock\n\t\t\t\t * to L2 else clear.\n\t\t\t\t */\n\t\t\t\tif (rsp->OplockLevel)\n\t\t\t\t\tset_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &cinode->flags);\n\t\t\t\telse\n\t\t\t\t\tclear_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &cinode->flags);\n\n\t\t\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tcifs_dbg(FYI, \"No matching file for oplock break\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process oplock break for non-existent connection\\n\");\n\treturn false;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const __le16 smb2_rsp_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(65),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(9),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(16),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(89),\n\t/* SMB2_CLOSE */ cpu_to_le16(60),\n\t/* SMB2_FLUSH */ cpu_to_le16(4),\n\t/* SMB2_READ */ cpu_to_le16(17),\n\t/* SMB2_WRITE */ cpu_to_le16(17),\n\t/* SMB2_LOCK */ cpu_to_le16(4),\n\t/* SMB2_IOCTL */ cpu_to_le16(49),\n\t/* BB CHECK this ... not listed in documentation */\n\t/* SMB2_CANCEL */ cpu_to_le16(0),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(9),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(9),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(9),\n\t/* SMB2_SET_INFO */ cpu_to_le16(2),\n\t/* BB FIXME can also be 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(24)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Can not process oplock break for non-existent connection\\n\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"No matching file for oplock break\\n\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&cfile->oplock_break"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2",
            "&cinode->flags"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2",
            "&cinode->flags"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"file id match, oplock break\\n\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp2",
            "structcifsFileInfo",
            "tlist"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp2",
            "&tcon->openFileList"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_oplock_brks"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp1",
            "structcifs_tcon",
            "tcon_list"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp1",
            "&ses->tcon_list"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifs_ses",
            "smb_ses_list"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&server->smb_ses_list"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"oplock level 0x%x\\n\"",
            "rsp->OplockLevel"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_is_valid_lease_break",
          "args": [
            "buffer"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_is_valid_lease_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "501-547",
          "snippet": "static bool\nsmb2_is_valid_lease_break(char *buffer)\n{\n\tstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct smb2_lease_break_work *lw;\n\n\tlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\n\tif (!lw)\n\t\treturn false;\n\n\tINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\n\tlw->lease_state = rsp->NewLeaseState;\n\n\tcifs_dbg(FYI, \"Checking for lease break\\n\");\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &cifs_tcp_ses_list) {\n\t\tserver = list_entry(tmp, struct TCP_Server_Info, tcp_ses_list);\n\n\t\tlist_for_each(tmp1, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp1, struct cifs_ses, smb_ses_list);\n\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\t\ttcon = list_entry(tmp2, struct cifs_tcon,\n\t\t\t\t\t\t  tcon_list);\n\t\t\t\tcifs_stats_inc(\n\t\t\t\t    &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\t\tif (smb2_tcon_has_lease(tcon, rsp, lw)) {\n\t\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tkfree(lw);\n\tcifs_dbg(FYI, \"Can not process lease break - no lease matched\\n\");\n\treturn false;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic bool\nsmb2_is_valid_lease_break(char *buffer)\n{\n\tstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct smb2_lease_break_work *lw;\n\n\tlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\n\tif (!lw)\n\t\treturn false;\n\n\tINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\n\tlw->lease_state = rsp->NewLeaseState;\n\n\tcifs_dbg(FYI, \"Checking for lease break\\n\");\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &cifs_tcp_ses_list) {\n\t\tserver = list_entry(tmp, struct TCP_Server_Info, tcp_ses_list);\n\n\t\tlist_for_each(tmp1, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp1, struct cifs_ses, smb_ses_list);\n\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\t\ttcon = list_entry(tmp2, struct cifs_tcon,\n\t\t\t\t\t\t  tcon_list);\n\t\t\t\tcifs_stats_inc(\n\t\t\t\t    &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\t\tif (smb2_tcon_has_lease(tcon, rsp, lw)) {\n\t\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tkfree(lw);\n\tcifs_dbg(FYI, \"Can not process lease break - no lease matched\\n\");\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rsp->StructureSize"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Checking for oplock break\\n\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic const __le16 smb2_rsp_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(65),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(9),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(16),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(89),\n\t/* SMB2_CLOSE */ cpu_to_le16(60),\n\t/* SMB2_FLUSH */ cpu_to_le16(4),\n\t/* SMB2_READ */ cpu_to_le16(17),\n\t/* SMB2_WRITE */ cpu_to_le16(17),\n\t/* SMB2_LOCK */ cpu_to_le16(4),\n\t/* SMB2_IOCTL */ cpu_to_le16(49),\n\t/* BB CHECK this ... not listed in documentation */\n\t/* SMB2_CANCEL */ cpu_to_le16(0),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(9),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(9),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(9),\n\t/* SMB2_SET_INFO */ cpu_to_le16(2),\n\t/* BB FIXME can also be 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(24)\n};\n\nbool\nsmb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)\n{\n\tstruct smb2_oplock_break *rsp = (struct smb2_oplock_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct cifsInodeInfo *cinode;\n\tstruct cifsFileInfo *cfile;\n\n\tcifs_dbg(FYI, \"Checking for oplock break\\n\");\n\n\tif (rsp->hdr.Command != SMB2_OPLOCK_BREAK)\n\t\treturn false;\n\n\tif (rsp->StructureSize !=\n\t\t\t\tsmb2_rsp_struct_sizes[SMB2_OPLOCK_BREAK_HE]) {\n\t\tif (le16_to_cpu(rsp->StructureSize) == 44)\n\t\t\treturn smb2_is_valid_lease_break(buffer);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tcifs_dbg(FYI, \"oplock level 0x%x\\n\", rsp->OplockLevel);\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifs_ses, smb_ses_list);\n\t\tlist_for_each(tmp1, &ses->tcon_list) {\n\t\t\ttcon = list_entry(tmp1, struct cifs_tcon, tcon_list);\n\n\t\t\tcifs_stats_inc(&tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &tcon->openFileList) {\n\t\t\t\tcfile = list_entry(tmp2, struct cifsFileInfo,\n\t\t\t\t\t\t     tlist);\n\t\t\t\tif (rsp->PersistentFid !=\n\t\t\t\t    cfile->fid.persistent_fid ||\n\t\t\t\t    rsp->VolatileFid !=\n\t\t\t\t    cfile->fid.volatile_fid)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tcifs_dbg(FYI, \"file id match, oplock break\\n\");\n\t\t\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\t\t\tif (!CIFS_CACHE_WRITE(cinode) &&\n\t\t\t\t    rsp->OplockLevel == SMB2_OPLOCK_LEVEL_NONE)\n\t\t\t\t\tcfile->oplock_break_cancelled = true;\n\t\t\t\telse\n\t\t\t\t\tcfile->oplock_break_cancelled = false;\n\n\t\t\t\tset_bit(CIFS_INODE_PENDING_OPLOCK_BREAK,\n\t\t\t\t\t&cinode->flags);\n\n\t\t\t\t/*\n\t\t\t\t * Set flag if the server downgrades the oplock\n\t\t\t\t * to L2 else clear.\n\t\t\t\t */\n\t\t\t\tif (rsp->OplockLevel)\n\t\t\t\t\tset_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &cinode->flags);\n\t\t\t\telse\n\t\t\t\t\tclear_bit(\n\t\t\t\t\t   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,\n\t\t\t\t\t   &cinode->flags);\n\n\t\t\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\n\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\tcifs_dbg(FYI, \"No matching file for oplock break\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tcifs_dbg(FYI, \"Can not process oplock break for non-existent connection\\n\");\n\treturn false;\n}"
  },
  {
    "function_name": "smb2_is_valid_lease_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "501-547",
    "snippet": "static bool\nsmb2_is_valid_lease_break(char *buffer)\n{\n\tstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct smb2_lease_break_work *lw;\n\n\tlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\n\tif (!lw)\n\t\treturn false;\n\n\tINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\n\tlw->lease_state = rsp->NewLeaseState;\n\n\tcifs_dbg(FYI, \"Checking for lease break\\n\");\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &cifs_tcp_ses_list) {\n\t\tserver = list_entry(tmp, struct TCP_Server_Info, tcp_ses_list);\n\n\t\tlist_for_each(tmp1, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp1, struct cifs_ses, smb_ses_list);\n\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\t\ttcon = list_entry(tmp2, struct cifs_tcon,\n\t\t\t\t\t\t  tcon_list);\n\t\t\t\tcifs_stats_inc(\n\t\t\t\t    &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\t\tif (smb2_tcon_has_lease(tcon, rsp, lw)) {\n\t\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tkfree(lw);\n\tcifs_dbg(FYI, \"Can not process lease break - no lease matched\\n\");\n\treturn false;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Can not process lease break - no lease matched\\n\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lw"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cifs_tcp_ses_lock"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smb2_tcon_has_lease",
          "args": [
            "tcon",
            "rsp",
            "lw"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_tcon_has_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "438-499",
          "snippet": "static bool\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,\n\t\t    struct smb2_lease_break_work *lw)\n{\n\tbool found;\n\t__u8 lease_state;\n\tstruct list_head *tmp;\n\tstruct cifsFileInfo *cfile;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_pending_open *open;\n\tstruct cifsInodeInfo *cinode;\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\n\tlease_state = le32_to_cpu(rsp->NewLeaseState);\n\n\tlist_for_each(tmp, &tcon->openFileList) {\n\t\tcfile = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\tif (memcmp(cinode->lease_key, rsp->LeaseKey,\n\t\t\t\t\t\t\tSMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tcifs_dbg(FYI, \"found in the open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\tserver->ops->set_oplock_level(cinode, lease_state, 0, NULL);\n\n\t\tif (ack_req)\n\t\t\tcfile->oplock_break_cancelled = false;\n\t\telse\n\t\t\tcfile->oplock_break_cancelled = true;\n\n\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\t\tkfree(lw);\n\t\treturn true;\n\t}\n\n\tfound = false;\n\tlist_for_each_entry(open, &tcon->pending_opens, olist) {\n\t\tif (memcmp(open->lease_key, rsp->LeaseKey,\n\t\t\t   SMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tif (!found && ack_req) {\n\t\t\tfound = true;\n\t\t\tmemcpy(lw->lease_key, open->lease_key,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlw->tlink = cifs_get_tlink(open->tlink);\n\t\t\tqueue_work(cifsiod_wq, &lw->lease_break);\n\t\t}\n\n\t\tcifs_dbg(FYI, \"found in the pending open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\topen->oplock = lease_state;\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic bool\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,\n\t\t    struct smb2_lease_break_work *lw)\n{\n\tbool found;\n\t__u8 lease_state;\n\tstruct list_head *tmp;\n\tstruct cifsFileInfo *cfile;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_pending_open *open;\n\tstruct cifsInodeInfo *cinode;\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\n\tlease_state = le32_to_cpu(rsp->NewLeaseState);\n\n\tlist_for_each(tmp, &tcon->openFileList) {\n\t\tcfile = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\tif (memcmp(cinode->lease_key, rsp->LeaseKey,\n\t\t\t\t\t\t\tSMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tcifs_dbg(FYI, \"found in the open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\tserver->ops->set_oplock_level(cinode, lease_state, 0, NULL);\n\n\t\tif (ack_req)\n\t\t\tcfile->oplock_break_cancelled = false;\n\t\telse\n\t\t\tcfile->oplock_break_cancelled = true;\n\n\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\t\tkfree(lw);\n\t\treturn true;\n\t}\n\n\tfound = false;\n\tlist_for_each_entry(open, &tcon->pending_opens, olist) {\n\t\tif (memcmp(open->lease_key, rsp->LeaseKey,\n\t\t\t   SMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tif (!found && ack_req) {\n\t\t\tfound = true;\n\t\t\tmemcpy(lw->lease_key, open->lease_key,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlw->tlink = cifs_get_tlink(open->tlink);\n\t\t\tqueue_work(cifsiod_wq, &lw->lease_break);\n\t\t}\n\n\t\tcifs_dbg(FYI, \"found in the pending open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\topen->oplock = lease_state;\n\t}\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_stats_inc",
          "args": [
            "&tcon->stats.cifs_stats.num_oplock_brks"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp2",
            "structcifs_tcon",
            "tcon_list"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp2",
            "&ses->tcon_list"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cifs_file_list_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp1",
            "structcifs_ses",
            "smb_ses_list"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp1",
            "&server->smb_ses_list"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structTCP_Server_Info",
            "tcp_ses_list"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&cifs_tcp_ses_list"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Checking for lease break\\n\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&lw->lease_break",
            "cifs_ses_oplock_break"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct smb2_lease_break_work)",
            "GFP_KERNEL"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic bool\nsmb2_is_valid_lease_break(char *buffer)\n{\n\tstruct smb2_lease_break *rsp = (struct smb2_lease_break *)buffer;\n\tstruct list_head *tmp, *tmp1, *tmp2;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon;\n\tstruct smb2_lease_break_work *lw;\n\n\tlw = kmalloc(sizeof(struct smb2_lease_break_work), GFP_KERNEL);\n\tif (!lw)\n\t\treturn false;\n\n\tINIT_WORK(&lw->lease_break, cifs_ses_oplock_break);\n\tlw->lease_state = rsp->NewLeaseState;\n\n\tcifs_dbg(FYI, \"Checking for lease break\\n\");\n\n\t/* look up tcon based on tid & uid */\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &cifs_tcp_ses_list) {\n\t\tserver = list_entry(tmp, struct TCP_Server_Info, tcp_ses_list);\n\n\t\tlist_for_each(tmp1, &server->smb_ses_list) {\n\t\t\tses = list_entry(tmp1, struct cifs_ses, smb_ses_list);\n\n\t\t\tspin_lock(&cifs_file_list_lock);\n\t\t\tlist_for_each(tmp2, &ses->tcon_list) {\n\t\t\t\ttcon = list_entry(tmp2, struct cifs_tcon,\n\t\t\t\t\t\t  tcon_list);\n\t\t\t\tcifs_stats_inc(\n\t\t\t\t    &tcon->stats.cifs_stats.num_oplock_brks);\n\t\t\t\tif (smb2_tcon_has_lease(tcon, rsp, lw)) {\n\t\t\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t\t\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&cifs_file_list_lock);\n\t\t}\n\t}\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tkfree(lw);\n\tcifs_dbg(FYI, \"Can not process lease break - no lease matched\\n\");\n\treturn false;\n}"
  },
  {
    "function_name": "smb2_tcon_has_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "438-499",
    "snippet": "static bool\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,\n\t\t    struct smb2_lease_break_work *lw)\n{\n\tbool found;\n\t__u8 lease_state;\n\tstruct list_head *tmp;\n\tstruct cifsFileInfo *cfile;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_pending_open *open;\n\tstruct cifsInodeInfo *cinode;\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\n\tlease_state = le32_to_cpu(rsp->NewLeaseState);\n\n\tlist_for_each(tmp, &tcon->openFileList) {\n\t\tcfile = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\tif (memcmp(cinode->lease_key, rsp->LeaseKey,\n\t\t\t\t\t\t\tSMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tcifs_dbg(FYI, \"found in the open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\tserver->ops->set_oplock_level(cinode, lease_state, 0, NULL);\n\n\t\tif (ack_req)\n\t\t\tcfile->oplock_break_cancelled = false;\n\t\telse\n\t\t\tcfile->oplock_break_cancelled = true;\n\n\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\t\tkfree(lw);\n\t\treturn true;\n\t}\n\n\tfound = false;\n\tlist_for_each_entry(open, &tcon->pending_opens, olist) {\n\t\tif (memcmp(open->lease_key, rsp->LeaseKey,\n\t\t\t   SMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tif (!found && ack_req) {\n\t\t\tfound = true;\n\t\t\tmemcpy(lw->lease_key, open->lease_key,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlw->tlink = cifs_get_tlink(open->tlink);\n\t\t\tqueue_work(cifsiod_wq, &lw->lease_break);\n\t\t}\n\n\t\tcifs_dbg(FYI, \"found in the pending open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\topen->oplock = lease_state;\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"lease key match, lease break 0x%x\\n\"",
            "le32_to_cpu(rsp->NewLeaseState)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rsp->NewLeaseState"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"found in the pending open list\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cifsiod_wq",
            "&lw->lease_break"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_get_tlink",
          "args": [
            "open->tlink"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_get_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "939-945",
          "snippet": "static inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct tcon_link *\ncifs_get_tlink(struct tcon_link *tlink)\n{\n\tif (tlink && !IS_ERR(tlink))\n\t\tatomic_inc(&tlink->tl_count);\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lw->lease_key",
            "open->lease_key",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "open->lease_key",
            "rsp->LeaseKey",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "open",
            "&tcon->pending_opens",
            "olist"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lw"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "server->ops->set_oplock_level",
          "args": [
            "cinode",
            "lease_state",
            "0",
            "NULL"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"lease key match, lease break 0x%x\\n\"",
            "le32_to_cpu(rsp->NewLeaseState)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"found in the open list\\n\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cinode->lease_key",
            "rsp->LeaseKey",
            "SMB2_LEASE_KEY_SIZE"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_I",
          "args": [
            "cfile->dentry->d_inode"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1159-1163",
          "snippet": "static inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifsInodeInfo *\nCIFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct cifsInodeInfo, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structcifsFileInfo",
            "tlist"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "tmp",
            "&tcon->openFileList"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic bool\nsmb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,\n\t\t    struct smb2_lease_break_work *lw)\n{\n\tbool found;\n\t__u8 lease_state;\n\tstruct list_head *tmp;\n\tstruct cifsFileInfo *cfile;\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct cifs_pending_open *open;\n\tstruct cifsInodeInfo *cinode;\n\tint ack_req = le32_to_cpu(rsp->Flags &\n\t\t\t\t  SMB2_NOTIFY_BREAK_LEASE_FLAG_ACK_REQUIRED);\n\n\tlease_state = le32_to_cpu(rsp->NewLeaseState);\n\n\tlist_for_each(tmp, &tcon->openFileList) {\n\t\tcfile = list_entry(tmp, struct cifsFileInfo, tlist);\n\t\tcinode = CIFS_I(cfile->dentry->d_inode);\n\n\t\tif (memcmp(cinode->lease_key, rsp->LeaseKey,\n\t\t\t\t\t\t\tSMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tcifs_dbg(FYI, \"found in the open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\tserver->ops->set_oplock_level(cinode, lease_state, 0, NULL);\n\n\t\tif (ack_req)\n\t\t\tcfile->oplock_break_cancelled = false;\n\t\telse\n\t\t\tcfile->oplock_break_cancelled = true;\n\n\t\tqueue_work(cifsiod_wq, &cfile->oplock_break);\n\t\tkfree(lw);\n\t\treturn true;\n\t}\n\n\tfound = false;\n\tlist_for_each_entry(open, &tcon->pending_opens, olist) {\n\t\tif (memcmp(open->lease_key, rsp->LeaseKey,\n\t\t\t   SMB2_LEASE_KEY_SIZE))\n\t\t\tcontinue;\n\n\t\tif (!found && ack_req) {\n\t\t\tfound = true;\n\t\t\tmemcpy(lw->lease_key, open->lease_key,\n\t\t\t       SMB2_LEASE_KEY_SIZE);\n\t\t\tlw->tlink = cifs_get_tlink(open->tlink);\n\t\t\tqueue_work(cifsiod_wq, &lw->lease_break);\n\t\t}\n\n\t\tcifs_dbg(FYI, \"found in the pending open list\\n\");\n\t\tcifs_dbg(FYI, \"lease key match, lease break 0x%x\\n\",\n\t\t\t le32_to_cpu(rsp->NewLeaseState));\n\n\t\topen->oplock = lease_state;\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "cifs_ses_oplock_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "424-436",
    "snippet": "static void\ncifs_ses_oplock_break(struct work_struct *work)\n{\n\tstruct smb2_lease_break_work *lw = container_of(work,\n\t\t\t\tstruct smb2_lease_break_work, lease_break);\n\tint rc;\n\n\trc = SMB2_lease_break(0, tlink_tcon(lw->tlink), lw->lease_key,\n\t\t\t      lw->lease_state);\n\tcifs_dbg(FYI, \"Lease release rc %d\\n\", rc);\n\tcifs_put_tlink(lw->tlink);\n\tkfree(lw);\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lw"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "lw->tlink"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Lease release rc %d\\n\"",
            "rc"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SMB2_lease_break",
          "args": [
            "0",
            "tlink_tcon(lw->tlink)",
            "lw->lease_key",
            "lw->lease_state"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "SMB2_lease_break",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2629-2658",
          "snippet": "int\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\n\t/* SMB2 buffer freed by function above */\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "lw->tlink"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsmb2_lease_break_work",
            "lease_break"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic void\ncifs_ses_oplock_break(struct work_struct *work)\n{\n\tstruct smb2_lease_break_work *lw = container_of(work,\n\t\t\t\tstruct smb2_lease_break_work, lease_break);\n\tint rc;\n\n\trc = SMB2_lease_break(0, tlink_tcon(lw->tlink), lw->lease_key,\n\t\t\t      lw->lease_state);\n\tcifs_dbg(FYI, \"Lease release rc %d\\n\", rc);\n\tcifs_put_tlink(lw->tlink);\n\tkfree(lw);\n}"
  },
  {
    "function_name": "smb2_get_lease_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "403-415",
    "snippet": "__le32\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\n{\n\t__le32 lease = 0;\n\n\tif (CIFS_CACHE_WRITE(cinode))\n\t\tlease |= SMB2_LEASE_WRITE_CACHING;\n\tif (CIFS_CACHE_HANDLE(cinode))\n\t\tlease |= SMB2_LEASE_HANDLE_CACHING;\n\tif (CIFS_CACHE_READ(cinode))\n\t\tlease |= SMB2_LEASE_READ_CACHING;\n\treturn lease;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIFS_CACHE_READ",
          "args": [
            "cinode"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_HANDLE",
          "args": [
            "cinode"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIFS_CACHE_WRITE",
          "args": [
            "cinode"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le32\nsmb2_get_lease_state(struct cifsInodeInfo *cinode)\n{\n\t__le32 lease = 0;\n\n\tif (CIFS_CACHE_WRITE(cinode))\n\t\tlease |= SMB2_LEASE_WRITE_CACHING;\n\tif (CIFS_CACHE_HANDLE(cinode))\n\t\tlease |= SMB2_LEASE_HANDLE_CACHING;\n\tif (CIFS_CACHE_READ(cinode))\n\t\tlease |= SMB2_LEASE_READ_CACHING;\n\treturn lease;\n}"
  },
  {
    "function_name": "cifs_convert_path_to_utf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "378-401",
    "snippet": "__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_strndup_to_utf16",
          "args": [
            "start_of_path",
            "PATH_MAX",
            "&len",
            "cifs_sb->local_nls",
            "map_type"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_strndup_to_utf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_unicode.c",
          "lines": "503-520",
          "snippet": "__le16 *\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\n\t\t      const struct nls_table *cp, int remap)\n{\n\tint len;\n\t__le16 *dst;\n\n\tlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\n\tlen += 2; /* NULL */\n\tdst = kmalloc(len, GFP_KERNEL);\n\tif (!dst) {\n\t\t*utf16_len = 0;\n\t\treturn NULL;\n\t}\n\tcifsConvertToUTF16(dst, src, strlen(src), cp, remap);\n\t*utf16_len = len;\n\treturn dst;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_uniupr.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_uniupr.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n__le16 *\ncifs_strndup_to_utf16(const char *src, const int maxlen, int *utf16_len,\n\t\t      const struct nls_table *cp, int remap)\n{\n\tint len;\n\t__le16 *dst;\n\n\tlen = cifs_local_to_utf16_bytes(src, maxlen, cp);\n\tlen += 2; /* NULL */\n\tdst = kmalloc(len, GFP_KERNEL);\n\tif (!dst) {\n\t\t*utf16_len = 0;\n\t\treturn NULL;\n\t}\n\tcifsConvertToUTF16(dst, src, strlen(src), cp, remap);\n\t*utf16_len = len;\n\treturn dst;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\n__le16 *\ncifs_convert_path_to_utf16(const char *from, struct cifs_sb_info *cifs_sb)\n{\n\tint len;\n\tconst char *start_of_path;\n\t__le16 *to;\n\tint map_type;\n\n\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SFM_CHR)\n\t\tmap_type = SFM_MAP_UNI_RSVD;\n\telse if (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR)\n\t\tmap_type = SFU_MAP_UNI_RSVD;\n\telse\n\t\tmap_type = NO_MAP_UNI_RSVD;\n\n\t/* Windows doesn't allow paths beginning with \\ */\n\tif (from[0] == '\\\\')\n\t\tstart_of_path = from + 1;\n\telse\n\t\tstart_of_path = from;\n\tto = cifs_strndup_to_utf16(start_of_path, PATH_MAX, &len,\n\t\t\t\t   cifs_sb->local_nls, map_type);\n\treturn to;\n}"
  },
  {
    "function_name": "smb2_calc_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "334-375",
    "snippet": "unsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2 len %d\\n\"",
            "len"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"data area offset %d overlaps SMB2 header %d\\n\"",
            "offset + 4 + 1",
            "len"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"SMB2 data length %d offset %d\\n\"",
            "data_length",
            "offset"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_get_data_area_len",
          "args": [
            "&offset",
            "&data_length",
            "hdr"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_get_data_area_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "237-328",
          "snippet": "char *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nchar *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "hdr->Command"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};\n\nunsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}"
  },
  {
    "function_name": "smb2_get_data_area_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "237-328",
    "snippet": "char *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"data area larger than 128K: %d\\n\"",
            "*len"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"negative data length %d invalid, data area ignored\\n\"",
            "*len"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"negative offset %d to data invalid ignore data area\\n\"",
            "*off"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"offset %d too large, data area ignored\\n\"",
            "*off"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"no length check for command\\n\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "((struct smb2_ioctl_rsp *)hdr)->OutputCount"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nchar *\nsmb2_get_data_area_len(int *off, int *len, struct smb2_hdr *hdr)\n{\n\t*off = 0;\n\t*len = 0;\n\n\t/* error responses do not have data area */\n\tif (hdr->Status && hdr->Status != STATUS_MORE_PROCESSING_REQUIRED &&\n\t    (((struct smb2_err_rsp *)hdr)->StructureSize) ==\n\t\t\t\t\t\tSMB2_ERROR_STRUCTURE_SIZE2)\n\t\treturn NULL;\n\n\t/*\n\t * Following commands have data areas so we have to get the location\n\t * of the data buffer offset and data buffer length for the particular\n\t * command.\n\t */\n\tswitch (hdr->Command) {\n\tcase SMB2_NEGOTIATE:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_negotiate_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_SESSION_SETUP:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferOffset);\n\t\t*len = le16_to_cpu(\n\t\t    ((struct smb2_sess_setup_rsp *)hdr)->SecurityBufferLength);\n\t\tbreak;\n\tcase SMB2_CREATE:\n\t\t*off = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_create_rsp *)hdr)->CreateContextsLength);\n\t\tbreak;\n\tcase SMB2_QUERY_INFO:\n\t\t*off = le16_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t    ((struct smb2_query_info_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = ((struct smb2_read_rsp *)hdr)->DataOffset;\n\t\t*len = le32_to_cpu(((struct smb2_read_rsp *)hdr)->DataLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferOffset);\n\t\t*len = le32_to_cpu(\n\t\t  ((struct smb2_query_directory_rsp *)hdr)->OutputBufferLength);\n\t\tbreak;\n\tcase SMB2_IOCTL:\n\t\t*off = le32_to_cpu(\n\t\t  ((struct smb2_ioctl_rsp *)hdr)->OutputOffset);\n\t\t*len = le32_to_cpu(((struct smb2_ioctl_rsp *)hdr)->OutputCount);\n\t\tbreak;\n\tcase SMB2_CHANGE_NOTIFY:\n\tdefault:\n\t\t/* BB FIXME for unimplemented cases above */\n\t\tcifs_dbg(VFS, \"no length check for command\\n\");\n\t\tbreak;\n\t}\n\n\t/*\n\t * Invalid length or offset probably means data area is invalid, but\n\t * we have little choice but to ignore the data area in this case.\n\t */\n\tif (*off > 4096) {\n\t\tcifs_dbg(VFS, \"offset %d too large, data area ignored\\n\", *off);\n\t\t*len = 0;\n\t\t*off = 0;\n\t} else if (*off < 0) {\n\t\tcifs_dbg(VFS, \"negative offset %d to data invalid ignore data area\\n\",\n\t\t\t *off);\n\t\t*off = 0;\n\t\t*len = 0;\n\t} else if (*len < 0) {\n\t\tcifs_dbg(VFS, \"negative data length %d invalid, data area ignored\\n\",\n\t\t\t *len);\n\t\t*len = 0;\n\t} else if (*len > 128 * 1024) {\n\t\tcifs_dbg(VFS, \"data area larger than 128K: %d\\n\", *len);\n\t\t*len = 0;\n\t}\n\n\t/* return pointer to beginning of data area, ie offset from SMB start */\n\tif ((*off != 0) && (*len != 0))\n\t\treturn hdr->ProtocolId + *off;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "smb2_check_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "95-204",
    "snippet": "int\nsmb2_check_message(char *buf, unsigned int length)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\t__u64 mid = le64_to_cpu(hdr->MessageId);\n\t__u32 len = get_rfc1002_length(buf);\n\t__u32 clc_len;  /* calculated length */\n\tint command;\n\n\t/* BB disable following printk later */\n\tcifs_dbg(FYI, \"%s length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t __func__, length, len);\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\n\tif (length < sizeof(struct smb2_pdu)) {\n\t\tif ((length >= sizeof(struct smb2_hdr)) && (hdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(hdr, mid))\n\t\treturn 1;\n\n\tif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Illegal structure size %u\\n\",\n\t\t\t le16_to_cpu(hdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(hdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Illegal SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Illegal response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Illegal response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (4 + len != length) {\n\t\tcifs_dbg(VFS, \"Total length %u RFC1002 length %u mismatch mid %llu\\n\",\n\t\t\t length, 4 + len, mid);\n\t\treturn 1;\n\t}\n\n\tclc_len = smb2_calc_size(hdr);\n\n\tif (4 + len != clc_len) {\n\t\tcifs_dbg(FYI, \"Calculated size %u length %u mismatch mid %llu\\n\",\n\t\t\t clc_len, 4 + len, mid);\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    hdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (clc_len + 20 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (clc_len == 4 + len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Log the server error (once), but allow it and continue\n\t\t * since the frame is parseable.\n\t\t */\n\t\tif (clc_len < 4 /* RFC1001 header size */ + len) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"SMB2 server sent bad RFC1001 len %d not %d\\n\",\n\t\t\t\tlen, clc_len - 4);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const __le16 smb2_rsp_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(65),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(9),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(16),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(89),\n\t/* SMB2_CLOSE */ cpu_to_le16(60),\n\t/* SMB2_FLUSH */ cpu_to_le16(4),\n\t/* SMB2_READ */ cpu_to_le16(17),\n\t/* SMB2_WRITE */ cpu_to_le16(17),\n\t/* SMB2_LOCK */ cpu_to_le16(4),\n\t/* SMB2_IOCTL */ cpu_to_le16(49),\n\t/* BB CHECK this ... not listed in documentation */\n\t/* SMB2_CANCEL */ cpu_to_le16(0),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(9),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(9),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(9),\n\t/* SMB2_SET_INFO */ cpu_to_le16(2),\n\t/* BB FIXME can also be 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(24)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"SMB2 server sent bad RFC1001 len %d not %d\\n\"",
            "len",
            "clc_len - 4"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"Calculated size %u length %u mismatch mid %llu\\n\"",
            "clc_len",
            "4 + len",
            "mid"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smb2_calc_size",
          "args": [
            "hdr"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "smb2_calc_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "334-375",
          "snippet": "unsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic const bool has_smb2_data_area[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ true,\n\t/* SMB2_SESSION_SETUP */ true,\n\t/* SMB2_LOGOFF */ false,\n\t/* SMB2_TREE_CONNECT */\tfalse,\n\t/* SMB2_TREE_DISCONNECT */ false,\n\t/* SMB2_CREATE */ true,\n\t/* SMB2_CLOSE */ false,\n\t/* SMB2_FLUSH */ false,\n\t/* SMB2_READ */\ttrue,\n\t/* SMB2_WRITE */ false,\n\t/* SMB2_LOCK */\tfalse,\n\t/* SMB2_IOCTL */ true,\n\t/* SMB2_CANCEL */ false, /* BB CHECK this not listed in documentation */\n\t/* SMB2_ECHO */ false,\n\t/* SMB2_QUERY_DIRECTORY */ true,\n\t/* SMB2_CHANGE_NOTIFY */ true,\n\t/* SMB2_QUERY_INFO */ true,\n\t/* SMB2_SET_INFO */ false,\n\t/* SMB2_OPLOCK_BREAK */ false\n};\n\nunsigned int\nsmb2_calc_size(void *buf)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\tint offset; /* the offset from the beginning of SMB to data area */\n\tint data_length; /* the length of the variable length data area */\n\t/* Structure Size has already been checked to make sure it is 64 */\n\tint len = 4 + le16_to_cpu(pdu->hdr.StructureSize);\n\n\t/*\n\t * StructureSize2, ie length of fixed parameter area has already\n\t * been checked to make sure it is the correct length.\n\t */\n\tlen += le16_to_cpu(pdu->StructureSize2);\n\n\tif (has_smb2_data_area[le16_to_cpu(hdr->Command)] == false)\n\t\tgoto calc_size_exit;\n\n\tsmb2_get_data_area_len(&offset, &data_length, hdr);\n\tcifs_dbg(FYI, \"SMB2 data length %d offset %d\\n\", data_length, offset);\n\n\tif (data_length > 0) {\n\t\t/*\n\t\t * Check to make sure that data area begins after fixed area,\n\t\t * Note that last byte of the fixed area is part of data area\n\t\t * for some commands, typically those with odd StructureSize,\n\t\t * so we must add one to the calculation (and 4 to account for\n\t\t * the size of the RFC1001 hdr.\n\t\t */\n\t\tif (offset + 4 + 1 < len) {\n\t\t\tcifs_dbg(VFS, \"data area offset %d overlaps SMB2 header %d\\n\",\n\t\t\t\t offset + 4 + 1, len);\n\t\t\tdata_length = 0;\n\t\t} else {\n\t\t\tlen = 4 + offset + data_length;\n\t\t}\n\t}\ncalc_size_exit:\n\tcifs_dbg(FYI, \"SMB2 len %d\\n\", len);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Total length %u RFC1002 length %u mismatch mid %llu\\n\"",
            "length",
            "4 + len",
            "mid"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal response size %d for oplock break\\n\"",
            "le16_to_cpu(pdu->StructureSize2)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "pdu->StructureSize2"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal response size %u for command %d\\n\"",
            "le16_to_cpu(pdu->StructureSize2)",
            "command"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal SMB2 command %d\\n\"",
            "command"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Illegal structure size %u\\n\"",
            "le16_to_cpu(hdr->StructureSize)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_smb2_hdr",
          "args": [
            "hdr",
            "mid"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "check_smb2_hdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
          "lines": "32-62",
          "snippet": "static int\ncheck_smb2_hdr(struct smb2_hdr *hdr, __u64 mid)\n{\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\t/*\n\t * Make sure that this really is an SMB, that it is a response,\n\t * and that the message ids match.\n\t */\n\tif ((*(__le32 *)hdr->ProtocolId == SMB2_PROTO_NUMBER) &&\n\t    (mid == wire_mid)) {\n\t\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/* only one valid case where server sends us request */\n\t\t\tif (hdr->Command == SMB2_OPLOCK_BREAK)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Received Request not response\\n\");\n\t\t}\n\t} else { /* bad signature or mid */\n\t\tif (*(__le32 *)hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\t\tcifs_dbg(VFS, \"Bad protocol string signature header %x\\n\",\n\t\t\t\t *(unsigned int *) hdr->ProtocolId);\n\t\tif (mid != wire_mid)\n\t\t\tcifs_dbg(VFS, \"Mids do not match: %llu and %llu\\n\",\n\t\t\t\t mid, wire_mid);\n\t}\n\tcifs_dbg(VFS, \"Bad SMB detected. The Mid=%llu\\n\", wire_mid);\n\treturn 1;\n}",
          "includes": [
            "#include \"smb2status.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic int\ncheck_smb2_hdr(struct smb2_hdr *hdr, __u64 mid)\n{\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\t/*\n\t * Make sure that this really is an SMB, that it is a response,\n\t * and that the message ids match.\n\t */\n\tif ((*(__le32 *)hdr->ProtocolId == SMB2_PROTO_NUMBER) &&\n\t    (mid == wire_mid)) {\n\t\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/* only one valid case where server sends us request */\n\t\t\tif (hdr->Command == SMB2_OPLOCK_BREAK)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Received Request not response\\n\");\n\t\t}\n\t} else { /* bad signature or mid */\n\t\tif (*(__le32 *)hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\t\tcifs_dbg(VFS, \"Bad protocol string signature header %x\\n\",\n\t\t\t\t *(unsigned int *) hdr->ProtocolId);\n\t\tif (mid != wire_mid)\n\t\t\tcifs_dbg(VFS, \"Mids do not match: %llu and %llu\\n\",\n\t\t\t\t mid, wire_mid);\n\t}\n\tcifs_dbg(VFS, \"Bad SMB detected. The Mid=%llu\\n\", wire_mid);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"SMB length greater than maximum, mid=%llu\\n\"",
            "mid"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Length less than SMB header size\\n\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s length: 0x%x, smb_buf_length: 0x%x\\n\"",
            "__func__",
            "length",
            "len"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_rfc1002_length",
          "args": [
            "buf"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "get_rfc1002_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "521-525",
          "snippet": "static inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline unsigned int\nget_rfc1002_length(void *buf)\n{\n\treturn be32_to_cpu(*((__be32 *)buf)) & 0xffffff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "hdr->MessageId"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic const __le16 smb2_rsp_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ cpu_to_le16(65),\n\t/* SMB2_SESSION_SETUP */ cpu_to_le16(9),\n\t/* SMB2_LOGOFF */ cpu_to_le16(4),\n\t/* SMB2_TREE_CONNECT */ cpu_to_le16(16),\n\t/* SMB2_TREE_DISCONNECT */ cpu_to_le16(4),\n\t/* SMB2_CREATE */ cpu_to_le16(89),\n\t/* SMB2_CLOSE */ cpu_to_le16(60),\n\t/* SMB2_FLUSH */ cpu_to_le16(4),\n\t/* SMB2_READ */ cpu_to_le16(17),\n\t/* SMB2_WRITE */ cpu_to_le16(17),\n\t/* SMB2_LOCK */ cpu_to_le16(4),\n\t/* SMB2_IOCTL */ cpu_to_le16(49),\n\t/* BB CHECK this ... not listed in documentation */\n\t/* SMB2_CANCEL */ cpu_to_le16(0),\n\t/* SMB2_ECHO */ cpu_to_le16(4),\n\t/* SMB2_QUERY_DIRECTORY */ cpu_to_le16(9),\n\t/* SMB2_CHANGE_NOTIFY */ cpu_to_le16(9),\n\t/* SMB2_QUERY_INFO */ cpu_to_le16(9),\n\t/* SMB2_SET_INFO */ cpu_to_le16(2),\n\t/* BB FIXME can also be 44 for lease break */\n\t/* SMB2_OPLOCK_BREAK */ cpu_to_le16(24)\n};\n\nint\nsmb2_check_message(char *buf, unsigned int length)\n{\n\tstruct smb2_hdr *hdr = (struct smb2_hdr *)buf;\n\tstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\n\t__u64 mid = le64_to_cpu(hdr->MessageId);\n\t__u32 len = get_rfc1002_length(buf);\n\t__u32 clc_len;  /* calculated length */\n\tint command;\n\n\t/* BB disable following printk later */\n\tcifs_dbg(FYI, \"%s length: 0x%x, smb_buf_length: 0x%x\\n\",\n\t\t __func__, length, len);\n\n\t/*\n\t * Add function to do table lookup of StructureSize by command\n\t * ie Validate the wct via smb2_struct_sizes table above\n\t */\n\n\tif (length < sizeof(struct smb2_pdu)) {\n\t\tif ((length >= sizeof(struct smb2_hdr)) && (hdr->Status != 0)) {\n\t\t\tpdu->StructureSize2 = 0;\n\t\t\t/*\n\t\t\t * As with SMB/CIFS, on some error cases servers may\n\t\t\t * not return wct properly\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcifs_dbg(VFS, \"Length less than SMB header size\\n\");\n\t\t}\n\t\treturn 1;\n\t}\n\tif (len > CIFSMaxBufSize + MAX_SMB2_HDR_SIZE - 4) {\n\t\tcifs_dbg(VFS, \"SMB length greater than maximum, mid=%llu\\n\",\n\t\t\t mid);\n\t\treturn 1;\n\t}\n\n\tif (check_smb2_hdr(hdr, mid))\n\t\treturn 1;\n\n\tif (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) {\n\t\tcifs_dbg(VFS, \"Illegal structure size %u\\n\",\n\t\t\t le16_to_cpu(hdr->StructureSize));\n\t\treturn 1;\n\t}\n\n\tcommand = le16_to_cpu(hdr->Command);\n\tif (command >= NUMBER_OF_SMB2_COMMANDS) {\n\t\tcifs_dbg(VFS, \"Illegal SMB2 command %d\\n\", command);\n\t\treturn 1;\n\t}\n\n\tif (smb2_rsp_struct_sizes[command] != pdu->StructureSize2) {\n\t\tif (command != SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0 ||\n\t\t    pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2)) {\n\t\t\t/* error packets have 9 byte structure size */\n\t\t\tcifs_dbg(VFS, \"Illegal response size %u for command %d\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2), command);\n\t\t\treturn 1;\n\t\t} else if (command == SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 44)\n\t\t\t   && (le16_to_cpu(pdu->StructureSize2) != 36)) {\n\t\t\t/* special case for SMB2.1 lease break message */\n\t\t\tcifs_dbg(VFS, \"Illegal response size %d for oplock break\\n\",\n\t\t\t\t le16_to_cpu(pdu->StructureSize2));\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (4 + len != length) {\n\t\tcifs_dbg(VFS, \"Total length %u RFC1002 length %u mismatch mid %llu\\n\",\n\t\t\t length, 4 + len, mid);\n\t\treturn 1;\n\t}\n\n\tclc_len = smb2_calc_size(hdr);\n\n\tif (4 + len != clc_len) {\n\t\tcifs_dbg(FYI, \"Calculated size %u length %u mismatch mid %llu\\n\",\n\t\t\t clc_len, 4 + len, mid);\n\t\t/* create failed on symlink */\n\t\tif (command == SMB2_CREATE_HE &&\n\t\t    hdr->Status == STATUS_STOPPED_ON_SYMLINK)\n\t\t\treturn 0;\n\t\t/* Windows 7 server returns 24 bytes more */\n\t\tif (clc_len + 20 == len && command == SMB2_OPLOCK_BREAK_HE)\n\t\t\treturn 0;\n\t\t/* server can return one byte more due to implied bcc[0] */\n\t\tif (clc_len == 4 + len + 1)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * MacOS server pads after SMB2.1 write response with 3 bytes\n\t\t * of junk. Other servers match RFC1001 len to actual\n\t\t * SMB2/SMB3 frame length (header + smb2 response specific data)\n\t\t * Log the server error (once), but allow it and continue\n\t\t * since the frame is parseable.\n\t\t */\n\t\tif (clc_len < 4 /* RFC1001 header size */ + len) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"SMB2 server sent bad RFC1001 len %d not %d\\n\",\n\t\t\t\tlen, clc_len - 4);\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "check_smb2_hdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2misc.c",
    "lines": "32-62",
    "snippet": "static int\ncheck_smb2_hdr(struct smb2_hdr *hdr, __u64 mid)\n{\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\t/*\n\t * Make sure that this really is an SMB, that it is a response,\n\t * and that the message ids match.\n\t */\n\tif ((*(__le32 *)hdr->ProtocolId == SMB2_PROTO_NUMBER) &&\n\t    (mid == wire_mid)) {\n\t\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/* only one valid case where server sends us request */\n\t\t\tif (hdr->Command == SMB2_OPLOCK_BREAK)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Received Request not response\\n\");\n\t\t}\n\t} else { /* bad signature or mid */\n\t\tif (*(__le32 *)hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\t\tcifs_dbg(VFS, \"Bad protocol string signature header %x\\n\",\n\t\t\t\t *(unsigned int *) hdr->ProtocolId);\n\t\tif (mid != wire_mid)\n\t\t\tcifs_dbg(VFS, \"Mids do not match: %llu and %llu\\n\",\n\t\t\t\t mid, wire_mid);\n\t}\n\tcifs_dbg(VFS, \"Bad SMB detected. The Mid=%llu\\n\", wire_mid);\n\treturn 1;\n}",
    "includes": [
      "#include \"smb2status.h\"",
      "#include \"cifs_unicode.h\"",
      "#include \"cifs_debug.h\"",
      "#include \"smb2proto.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include \"smb2pdu.h\"",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Bad SMB detected. The Mid=%llu\\n\"",
            "wire_mid"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Mids do not match: %llu and %llu\\n\"",
            "mid",
            "wire_mid"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Bad protocol string signature header %x\\n\"",
            "*(unsigned int *) hdr->ProtocolId"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"Received Request not response\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "hdr->MessageId"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smb2status.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/ctype.h>\n\nstatic int\ncheck_smb2_hdr(struct smb2_hdr *hdr, __u64 mid)\n{\n\t__u64 wire_mid = le64_to_cpu(hdr->MessageId);\n\n\t/*\n\t * Make sure that this really is an SMB, that it is a response,\n\t * and that the message ids match.\n\t */\n\tif ((*(__le32 *)hdr->ProtocolId == SMB2_PROTO_NUMBER) &&\n\t    (mid == wire_mid)) {\n\t\tif (hdr->Flags & SMB2_FLAGS_SERVER_TO_REDIR)\n\t\t\treturn 0;\n\t\telse {\n\t\t\t/* only one valid case where server sends us request */\n\t\t\tif (hdr->Command == SMB2_OPLOCK_BREAK)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tcifs_dbg(VFS, \"Received Request not response\\n\");\n\t\t}\n\t} else { /* bad signature or mid */\n\t\tif (*(__le32 *)hdr->ProtocolId != SMB2_PROTO_NUMBER)\n\t\t\tcifs_dbg(VFS, \"Bad protocol string signature header %x\\n\",\n\t\t\t\t *(unsigned int *) hdr->ProtocolId);\n\t\tif (mid != wire_mid)\n\t\t\tcifs_dbg(VFS, \"Mids do not match: %llu and %llu\\n\",\n\t\t\t\t mid, wire_mid);\n\t}\n\tcifs_dbg(VFS, \"Bad SMB detected. The Mid=%llu\\n\", wire_mid);\n\treturn 1;\n}"
  }
]