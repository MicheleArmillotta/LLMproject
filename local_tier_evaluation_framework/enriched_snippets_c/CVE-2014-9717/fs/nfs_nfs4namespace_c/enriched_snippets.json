[
  {
    "function_name": "nfs4_replace_transport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "487-523",
    "snippet": "int nfs4_replace_transport(struct nfs_server *server,\n\t\t\t   const struct nfs4_fs_locations *locations)\n{\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\terror = -ENOENT;\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location =\n\t\t\t\t\t\t&locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = nfs4_try_replacing_one_location(server, page,\n\t\t\t\t\t\t\tpage2, location);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long)page);\n\tfree_page((unsigned long)page2);\n\treturn error;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)page2"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_try_replacing_one_location",
          "args": [
            "server",
            "page",
            "page2",
            "location"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_try_replacing_one_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "428-473",
          "snippet": "static int nfs4_try_replacing_one_location(struct nfs_server *server,\n\t\tchar *page, char *page2,\n\t\tconst struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(server->client);\n\tstruct sockaddr *sap;\n\tunsigned int s;\n\tsize_t salen;\n\tint error;\n\n\tsap = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (sap == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -ENOENT;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tchar *hostname;\n\n\t\tif (buf->len <= 0 || buf->len > PAGE_SIZE)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\n\t\t\tcontinue;\n\n\t\tsalen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t\tsap, addr_bufsize, net);\n\t\tif (salen == 0)\n\t\t\tcontinue;\n\t\trpc_set_port(sap, NFS_PORT);\n\n\t\terror = -ENOMEM;\n\t\thostname = kstrndup(buf->data, buf->len, GFP_KERNEL);\n\t\tif (hostname == NULL)\n\t\t\tbreak;\n\n\t\terror = nfs4_update_server(server, hostname, sap, salen, net);\n\t\tkfree(hostname);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(sap);\n\treturn error;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic int nfs4_try_replacing_one_location(struct nfs_server *server,\n\t\tchar *page, char *page2,\n\t\tconst struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(server->client);\n\tstruct sockaddr *sap;\n\tunsigned int s;\n\tsize_t salen;\n\tint error;\n\n\tsap = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (sap == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -ENOENT;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tchar *hostname;\n\n\t\tif (buf->len <= 0 || buf->len > PAGE_SIZE)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\n\t\t\tcontinue;\n\n\t\tsalen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t\tsap, addr_bufsize, net);\n\t\tif (salen == 0)\n\t\t\tcontinue;\n\t\trpc_set_port(sap, NFS_PORT);\n\n\t\terror = -ENOMEM;\n\t\thostname = kstrndup(buf->data, buf->len, GFP_KERNEL);\n\t\tif (hostname == NULL)\n\t\t\tbreak;\n\n\t\terror = nfs4_update_server(server, hostname, sap, salen, net);\n\t\tkfree(hostname);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(sap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_USER"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_USER"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nint nfs4_replace_transport(struct nfs_server *server,\n\t\t\t   const struct nfs4_fs_locations *locations)\n{\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\terror = -ENOENT;\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\terror = -ENOMEM;\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location =\n\t\t\t\t\t\t&locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\terror = nfs4_try_replacing_one_location(server, page,\n\t\t\t\t\t\t\tpage2, location);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long)page);\n\tfree_page((unsigned long)page2);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs4_try_replacing_one_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "428-473",
    "snippet": "static int nfs4_try_replacing_one_location(struct nfs_server *server,\n\t\tchar *page, char *page2,\n\t\tconst struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(server->client);\n\tstruct sockaddr *sap;\n\tunsigned int s;\n\tsize_t salen;\n\tint error;\n\n\tsap = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (sap == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -ENOENT;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tchar *hostname;\n\n\t\tif (buf->len <= 0 || buf->len > PAGE_SIZE)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\n\t\t\tcontinue;\n\n\t\tsalen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t\tsap, addr_bufsize, net);\n\t\tif (salen == 0)\n\t\t\tcontinue;\n\t\trpc_set_port(sap, NFS_PORT);\n\n\t\terror = -ENOMEM;\n\t\thostname = kstrndup(buf->data, buf->len, GFP_KERNEL);\n\t\tif (hostname == NULL)\n\t\t\tbreak;\n\n\t\terror = nfs4_update_server(server, hostname, sap, salen, net);\n\t\tkfree(hostname);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(sap);\n\treturn error;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sap"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hostname"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_update_server",
          "args": [
            "server",
            "hostname",
            "sap",
            "salen",
            "net"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_update_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4client.c",
          "lines": "1164-1232",
          "snippet": "int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t       struct sockaddr *sap, size_t salen, struct net *net)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct xprt_create xargs = {\n\t\t.ident\t\t= clp->cl_proto,\n\t\t.net\t\t= net,\n\t\t.dstaddr\t= sap,\n\t\t.addrlen\t= salen,\n\t\t.servername\t= hostname,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *localaddr = (struct sockaddr *)&address;\n\tint error;\n\n\tdprintk(\"--> %s: move FSID %llx:%llx to \\\"%s\\\")\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\thostname);\n\n\terror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\n\tif (error != 0) {\n\t\tdprintk(\"<-- %s(): rpc_switch_client_transport returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\terror = rpc_localaddr(clnt, localaddr, sizeof(address));\n\tif (error != 0) {\n\t\tdprintk(\"<-- %s(): rpc_localaddr returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\terror = -EAFNOSUPPORT;\n\tif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0) {\n\t\tdprintk(\"<-- %s(): rpc_ntop returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\tnfs_server_remove_lists(server);\n\terror = nfs4_set_client(server, hostname, sap, salen, buf,\n\t\t\t\tclp->cl_rpcclient->cl_auth->au_flavor,\n\t\t\t\tclp->cl_proto, clnt->cl_timeout,\n\t\t\t\tclp->cl_minorversion, net);\n\tnfs_put_client(clp);\n\tif (error != 0) {\n\t\tnfs_server_insert_lists(server);\n\t\tdprintk(\"<-- %s(): nfs4_set_client returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\tif (server->nfs_client->cl_hostname == NULL)\n\t\tserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\n\tnfs_server_insert_lists(server);\n\n\terror = nfs_probe_destination(server);\n\tif (error < 0)\n\t\tgoto out;\n\n\tdprintk(\"<-- %s() succeeded\\n\", __func__);\n\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"internal.h\"",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/bc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/auth.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"internal.h\"\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n\nint nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t       struct sockaddr *sap, size_t salen, struct net *net)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct xprt_create xargs = {\n\t\t.ident\t\t= clp->cl_proto,\n\t\t.net\t\t= net,\n\t\t.dstaddr\t= sap,\n\t\t.addrlen\t= salen,\n\t\t.servername\t= hostname,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *localaddr = (struct sockaddr *)&address;\n\tint error;\n\n\tdprintk(\"--> %s: move FSID %llx:%llx to \\\"%s\\\")\\n\", __func__,\n\t\t\t(unsigned long long)server->fsid.major,\n\t\t\t(unsigned long long)server->fsid.minor,\n\t\t\thostname);\n\n\terror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\n\tif (error != 0) {\n\t\tdprintk(\"<-- %s(): rpc_switch_client_transport returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\terror = rpc_localaddr(clnt, localaddr, sizeof(address));\n\tif (error != 0) {\n\t\tdprintk(\"<-- %s(): rpc_localaddr returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\terror = -EAFNOSUPPORT;\n\tif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0) {\n\t\tdprintk(\"<-- %s(): rpc_ntop returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\tnfs_server_remove_lists(server);\n\terror = nfs4_set_client(server, hostname, sap, salen, buf,\n\t\t\t\tclp->cl_rpcclient->cl_auth->au_flavor,\n\t\t\t\tclp->cl_proto, clnt->cl_timeout,\n\t\t\t\tclp->cl_minorversion, net);\n\tnfs_put_client(clp);\n\tif (error != 0) {\n\t\tnfs_server_insert_lists(server);\n\t\tdprintk(\"<-- %s(): nfs4_set_client returned %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto out;\n\t}\n\n\tif (server->nfs_client->cl_hostname == NULL)\n\t\tserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\n\tnfs_server_insert_lists(server);\n\n\terror = nfs_probe_destination(server);\n\tif (error < 0)\n\t\tgoto out;\n\n\tdprintk(\"<-- %s() succeeded\\n\", __func__);\n\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "buf->data",
            "buf->len",
            "GFP_KERNEL"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_set_port",
          "args": [
            "sap",
            "NFS_PORT"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_parse_server_name",
          "args": [
            "buf->data",
            "buf->len",
            "sap",
            "addr_bufsize",
            "net"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_parse_server_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "123-135",
          "snippet": "static size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf->data",
            "IPV6_SCOPE_DELIMITER",
            "buf->len"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "addr_bufsize",
            "GFP_KERNEL"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_net_ns",
          "args": [
            "server->client"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic int nfs4_try_replacing_one_location(struct nfs_server *server,\n\t\tchar *page, char *page2,\n\t\tconst struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(server->client);\n\tstruct sockaddr *sap;\n\tunsigned int s;\n\tsize_t salen;\n\tint error;\n\n\tsap = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (sap == NULL)\n\t\treturn -ENOMEM;\n\n\terror = -ENOENT;\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\t\tchar *hostname;\n\n\t\tif (buf->len <= 0 || buf->len > PAGE_SIZE)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len) != NULL)\n\t\t\tcontinue;\n\n\t\tsalen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\t\t\tsap, addr_bufsize, net);\n\t\tif (salen == 0)\n\t\t\tcontinue;\n\t\trpc_set_port(sap, NFS_PORT);\n\n\t\terror = -ENOMEM;\n\t\thostname = kstrndup(buf->data, buf->len, GFP_KERNEL);\n\t\tif (hostname == NULL)\n\t\t\tbreak;\n\n\t\terror = nfs4_update_server(server, hostname, sap, salen, net);\n\t\tkfree(hostname);\n\t\tif (error == 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(sap);\n\treturn error;\n}"
  },
  {
    "function_name": "nfs4_submount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "394-421",
    "snippet": "struct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,\n\t\t\t       struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\trpc_authflavor_t flavor = server->client->cl_auth->au_flavor;\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct rpc_clnt *client;\n\tstruct vfsmount *mnt;\n\n\t/* Look it up again to get its attributes and sec flavor */\n\tclient = nfs4_proc_lookup_mountpoint(dir, name, fh, fattr);\n\tdput(parent);\n\tif (IS_ERR(client))\n\t\treturn ERR_CAST(client);\n\n\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tmnt = nfs_do_refmount(client, dentry);\n\t\tgoto out;\n\t}\n\n\tif (client->cl_auth->au_flavor != flavor)\n\t\tflavor = client->cl_auth->au_flavor;\n\tmnt = nfs_do_submount(dentry, fh, fattr, flavor);\nout:\n\trpc_shutdown_client(client);\n\treturn mnt;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "client"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_do_submount",
          "args": [
            "dentry",
            "fh",
            "fattr",
            "flavor"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_submount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
          "lines": "240-272",
          "snippet": "struct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nstruct vfsmount *nfs_do_submount(struct dentry *dentry, struct nfs_fh *fh,\n\t\t\t\t struct nfs_fattr *fattr, rpc_authflavor_t authflavor)\n{\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.fh = fh,\n\t\t.fattr = fattr,\n\t\t.authflavor = authflavor,\n\t};\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tchar *page = (char *) __get_free_page(GFP_USER);\n\tchar *devname;\n\n\tdprintk(\"--> nfs_do_submount()\\n\");\n\n\tdprintk(\"%s: submounting on %pd2\\n\", __func__,\n\t\t\tdentry);\n\tif (page == NULL)\n\t\tgoto out;\n\tdevname = nfs_devname(dentry, page, PAGE_SIZE);\n\tmnt = (struct vfsmount *)devname;\n\tif (IS_ERR(devname))\n\t\tgoto free_page;\n\tmnt = nfs_do_clone_mount(NFS_SB(dentry->d_sb), devname, &mountdata);\nfree_page:\n\tfree_page((unsigned long)page);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\n\tdprintk(\"<-- nfs_do_submount() = %p\\n\", mnt);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_do_refmount",
          "args": [
            "client",
            "dentry"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_do_refmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "352-392",
          "snippet": "static struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tstruct dentry *parent;\n\tstruct nfs4_fs_locations *fs_locations = NULL;\n\tstruct page *page;\n\tint err;\n\n\t/* BUG_ON(IS_ROOT(dentry)); */\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\n\tfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (fs_locations == NULL)\n\t\tgoto out_free;\n\n\t/* Get locations */\n\tmnt = ERR_PTR(-ENOENT);\n\n\tparent = dget_parent(dentry);\n\tdprintk(\"%s: getting locations for %pd2\\n\",\n\t\t__func__, dentry);\n\n\terr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\n\tdput(parent);\n\tif (err != 0 ||\n\t    fs_locations->nlocations <= 0 ||\n\t    fs_locations->fs_path.ncomponents <= 0)\n\t\tgoto out_free;\n\n\tmnt = nfs_follow_referral(dentry, fs_locations);\nout_free:\n\t__free_page(page);\n\tkfree(fs_locations);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tstruct dentry *parent;\n\tstruct nfs4_fs_locations *fs_locations = NULL;\n\tstruct page *page;\n\tint err;\n\n\t/* BUG_ON(IS_ROOT(dentry)); */\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\n\tfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (fs_locations == NULL)\n\t\tgoto out_free;\n\n\t/* Get locations */\n\tmnt = ERR_PTR(-ENOENT);\n\n\tparent = dget_parent(dentry);\n\tdprintk(\"%s: getting locations for %pd2\\n\",\n\t\t__func__, dentry);\n\n\terr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\n\tdput(parent);\n\tif (err != 0 ||\n\t    fs_locations->nlocations <= 0 ||\n\t    fs_locations->fs_path.ncomponents <= 0)\n\t\tgoto out_free;\n\n\tmnt = nfs_follow_referral(dentry, fs_locations);\nout_free:\n\t__free_page(page);\n\tkfree(fs_locations);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "client"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "client"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_lookup_mountpoint",
          "args": [
            "dir",
            "name",
            "fh",
            "fattr"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_lookup_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "3399-3410",
          "snippet": "struct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\tint status;\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr, NULL);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\treturn (client == NFS_CLIENT(dir)) ? rpc_clone_client(client) : client;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic void nfs_fixup_referral_attributes(struct nfs_fattr *fattr);\n\nstruct rpc_clnt *\nnfs4_proc_lookup_mountpoint(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tstruct rpc_clnt *client = NFS_CLIENT(dir);\n\tint status;\n\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr, NULL);\n\tif (status < 0)\n\t\treturn ERR_PTR(status);\n\treturn (client == NFS_CLIENT(dir)) ? rpc_clone_client(client) : client;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstruct vfsmount *nfs4_submount(struct nfs_server *server, struct dentry *dentry,\n\t\t\t       struct nfs_fh *fh, struct nfs_fattr *fattr)\n{\n\trpc_authflavor_t flavor = server->client->cl_auth->au_flavor;\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct qstr *name = &dentry->d_name;\n\tstruct rpc_clnt *client;\n\tstruct vfsmount *mnt;\n\n\t/* Look it up again to get its attributes and sec flavor */\n\tclient = nfs4_proc_lookup_mountpoint(dir, name, fh, fattr);\n\tdput(parent);\n\tif (IS_ERR(client))\n\t\treturn ERR_CAST(client);\n\n\tif (fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) {\n\t\tmnt = nfs_do_refmount(client, dentry);\n\t\tgoto out;\n\t}\n\n\tif (client->cl_auth->au_flavor != flavor)\n\t\tflavor = client->cl_auth->au_flavor;\n\tmnt = nfs_do_submount(dentry, fh, fattr, flavor);\nout:\n\trpc_shutdown_client(client);\n\treturn mnt;\n}"
  },
  {
    "function_name": "nfs_do_refmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "352-392",
    "snippet": "static struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tstruct dentry *parent;\n\tstruct nfs4_fs_locations *fs_locations = NULL;\n\tstruct page *page;\n\tint err;\n\n\t/* BUG_ON(IS_ROOT(dentry)); */\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\n\tfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (fs_locations == NULL)\n\t\tgoto out_free;\n\n\t/* Get locations */\n\tmnt = ERR_PTR(-ENOENT);\n\n\tparent = dget_parent(dentry);\n\tdprintk(\"%s: getting locations for %pd2\\n\",\n\t\t__func__, dentry);\n\n\terr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\n\tdput(parent);\n\tif (err != 0 ||\n\t    fs_locations->nlocations <= 0 ||\n\t    fs_locations->fs_path.ncomponents <= 0)\n\t\tgoto out_free;\n\n\tmnt = nfs_follow_referral(dentry, fs_locations);\nout_free:\n\t__free_page(page);\n\tkfree(fs_locations);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done\\n\"",
            "__func__"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fs_locations"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_follow_referral",
          "args": [
            "dentry",
            "fs_locations"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_follow_referral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "296-345",
          "snippet": "static struct vfsmount *nfs_follow_referral(struct dentry *dentry,\n\t\t\t\t\t    const struct nfs4_fs_locations *locations)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\n\t};\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\tdprintk(\"%s: referral at %pd2\\n\", __func__, dentry);\n\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\t/* Ensure fs path is a prefix of current dentry path */\n\terror = nfs4_validate_fspath(dentry, locations, page, page2);\n\tif (error < 0) {\n\t\tmnt = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location = &locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\tmnt = try_location(&mountdata, page, page2, location);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long) page);\n\tfree_page((unsigned long) page2);\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *nfs_follow_referral(struct dentry *dentry,\n\t\t\t\t\t    const struct nfs4_fs_locations *locations)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\n\t};\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\tdprintk(\"%s: referral at %pd2\\n\", __func__, dentry);\n\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\t/* Ensure fs path is a prefix of current dentry path */\n\terror = nfs4_validate_fspath(dentry, locations, page, page2);\n\tif (error < 0) {\n\t\tmnt = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location = &locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\tmnt = try_location(&mountdata, page, page2, location);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long) page);\n\tfree_page((unsigned long) page2);\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_proc_fs_locations",
          "args": [
            "client",
            "parent->d_inode",
            "&dentry->d_name",
            "fs_locations",
            "page"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_fs_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6247-6262",
          "snippet": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: getting locations for %pd2\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfs4_fs_locations)",
            "GFP_KERNEL"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: enter\\n\"",
            "__func__"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *nfs_do_refmount(struct rpc_clnt *client, struct dentry *dentry)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOMEM);\n\tstruct dentry *parent;\n\tstruct nfs4_fs_locations *fs_locations = NULL;\n\tstruct page *page;\n\tint err;\n\n\t/* BUG_ON(IS_ROOT(dentry)); */\n\tdprintk(\"%s: enter\\n\", __func__);\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (page == NULL)\n\t\tgoto out;\n\n\tfs_locations = kmalloc(sizeof(struct nfs4_fs_locations), GFP_KERNEL);\n\tif (fs_locations == NULL)\n\t\tgoto out_free;\n\n\t/* Get locations */\n\tmnt = ERR_PTR(-ENOENT);\n\n\tparent = dget_parent(dentry);\n\tdprintk(\"%s: getting locations for %pd2\\n\",\n\t\t__func__, dentry);\n\n\terr = nfs4_proc_fs_locations(client, parent->d_inode, &dentry->d_name, fs_locations, page);\n\tdput(parent);\n\tif (err != 0 ||\n\t    fs_locations->nlocations <= 0 ||\n\t    fs_locations->fs_path.ncomponents <= 0)\n\t\tgoto out_free;\n\n\tmnt = nfs_follow_referral(dentry, fs_locations);\nout_free:\n\t__free_page(page);\n\tkfree(fs_locations);\nout:\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}"
  },
  {
    "function_name": "nfs_follow_referral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "296-345",
    "snippet": "static struct vfsmount *nfs_follow_referral(struct dentry *dentry,\n\t\t\t\t\t    const struct nfs4_fs_locations *locations)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\n\t};\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\tdprintk(\"%s: referral at %pd2\\n\", __func__, dentry);\n\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\t/* Ensure fs path is a prefix of current dentry path */\n\terror = nfs4_validate_fspath(dentry, locations, page, page2);\n\tif (error < 0) {\n\t\tmnt = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location = &locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\tmnt = try_location(&mountdata, page, page2, location);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long) page);\n\tfree_page((unsigned long) page2);\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done\\n\"",
            "__func__"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page2"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_location",
          "args": [
            "&mountdata",
            "page",
            "page2",
            "location"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "try_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "237-288",
          "snippet": "static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\n\t\t\t\t     char *page, char *page2,\n\t\t\t\t     const struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tchar *mnt_path;\n\tunsigned int maxbuflen;\n\tunsigned int s;\n\n\tmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\n\tif (IS_ERR(mnt_path))\n\t\treturn ERR_CAST(mnt_path);\n\tmountdata->mnt_path = mnt_path;\n\tmaxbuflen = mnt_path - 1 - page2;\n\n\tmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (mountdata->addr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\n\t\tif (buf->len <= 0 || buf->len >= maxbuflen)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\n\t\t\tcontinue;\n\n\t\tmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\tmountdata->addr, addr_bufsize, net);\n\t\tif (mountdata->addrlen == 0)\n\t\t\tcontinue;\n\n\t\trpc_set_port(mountdata->addr, NFS_PORT);\n\n\t\tmemcpy(page2, buf->data, buf->len);\n\t\tpage2[buf->len] = '\\0';\n\t\tmountdata->hostname = page2;\n\n\t\tsnprintf(page, PAGE_SIZE, \"%s:%s\",\n\t\t\t\tmountdata->hostname,\n\t\t\t\tmountdata->mnt_path);\n\n\t\tmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\tkfree(mountdata->addr);\n\treturn mnt;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\n\t\t\t\t     char *page, char *page2,\n\t\t\t\t     const struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tchar *mnt_path;\n\tunsigned int maxbuflen;\n\tunsigned int s;\n\n\tmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\n\tif (IS_ERR(mnt_path))\n\t\treturn ERR_CAST(mnt_path);\n\tmountdata->mnt_path = mnt_path;\n\tmaxbuflen = mnt_path - 1 - page2;\n\n\tmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (mountdata->addr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\n\t\tif (buf->len <= 0 || buf->len >= maxbuflen)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\n\t\t\tcontinue;\n\n\t\tmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\tmountdata->addr, addr_bufsize, net);\n\t\tif (mountdata->addrlen == 0)\n\t\t\tcontinue;\n\n\t\trpc_set_port(mountdata->addr, NFS_PORT);\n\n\t\tmemcpy(page2, buf->data, buf->len);\n\t\tpage2[buf->len] = '\\0';\n\t\tmountdata->hostname = page2;\n\n\t\tsnprintf(page, PAGE_SIZE, \"%s:%s\",\n\t\t\t\tmountdata->hostname,\n\t\t\t\tmountdata->mnt_path);\n\n\t\tmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\tkfree(mountdata->addr);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_validate_fspath",
          "args": [
            "dentry",
            "locations",
            "page",
            "page2"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_validate_fspath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "100-121",
          "snippet": "static int nfs4_validate_fspath(struct dentry *dentry,\n\t\t\t\tconst struct nfs4_fs_locations *locations,\n\t\t\t\tchar *page, char *page2)\n{\n\tconst char *path, *fs_path;\n\n\tpath = nfs4_path(dentry, page, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\n\tif (IS_ERR(fs_path))\n\t\treturn PTR_ERR(fs_path);\n\n\tif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\n\t\tdprintk(\"%s: path %s does not begin with fsroot %s\\n\",\n\t\t\t__func__, path, fs_path);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic int nfs4_validate_fspath(struct dentry *dentry,\n\t\t\t\tconst struct nfs4_fs_locations *locations,\n\t\t\t\tchar *page, char *page2)\n{\n\tconst char *path, *fs_path;\n\n\tpath = nfs4_path(dentry, page, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\n\tif (IS_ERR(fs_path))\n\t\treturn PTR_ERR(fs_path);\n\n\tif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\n\t\tdprintk(\"%s: path %s does not begin with fsroot %s\\n\",\n\t\t\t__func__, path, fs_path);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_USER"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_USER"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: referral at %pd2\\n\"",
            "__func__",
            "dentry"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *nfs_follow_referral(struct dentry *dentry,\n\t\t\t\t\t    const struct nfs4_fs_locations *locations)\n{\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tstruct nfs_clone_mount mountdata = {\n\t\t.sb = dentry->d_sb,\n\t\t.dentry = dentry,\n\t\t.authflavor = NFS_SB(dentry->d_sb)->client->cl_auth->au_flavor,\n\t};\n\tchar *page = NULL, *page2 = NULL;\n\tint loc, error;\n\n\tif (locations == NULL || locations->nlocations <= 0)\n\t\tgoto out;\n\n\tdprintk(\"%s: referral at %pd2\\n\", __func__, dentry);\n\n\tpage = (char *) __get_free_page(GFP_USER);\n\tif (!page)\n\t\tgoto out;\n\n\tpage2 = (char *) __get_free_page(GFP_USER);\n\tif (!page2)\n\t\tgoto out;\n\n\t/* Ensure fs path is a prefix of current dentry path */\n\terror = nfs4_validate_fspath(dentry, locations, page, page2);\n\tif (error < 0) {\n\t\tmnt = ERR_PTR(error);\n\t\tgoto out;\n\t}\n\n\tfor (loc = 0; loc < locations->nlocations; loc++) {\n\t\tconst struct nfs4_fs_location *location = &locations->locations[loc];\n\n\t\tif (location == NULL || location->nservers <= 0 ||\n\t\t    location->rootpath.ncomponents == 0)\n\t\t\tcontinue;\n\n\t\tmnt = try_location(&mountdata, page, page2, location);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\nout:\n\tfree_page((unsigned long) page);\n\tfree_page((unsigned long) page2);\n\tdprintk(\"%s: done\\n\", __func__);\n\treturn mnt;\n}"
  },
  {
    "function_name": "try_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "237-288",
    "snippet": "static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\n\t\t\t\t     char *page, char *page2,\n\t\t\t\t     const struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tchar *mnt_path;\n\tunsigned int maxbuflen;\n\tunsigned int s;\n\n\tmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\n\tif (IS_ERR(mnt_path))\n\t\treturn ERR_CAST(mnt_path);\n\tmountdata->mnt_path = mnt_path;\n\tmaxbuflen = mnt_path - 1 - page2;\n\n\tmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (mountdata->addr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\n\t\tif (buf->len <= 0 || buf->len >= maxbuflen)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\n\t\t\tcontinue;\n\n\t\tmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\tmountdata->addr, addr_bufsize, net);\n\t\tif (mountdata->addrlen == 0)\n\t\t\tcontinue;\n\n\t\trpc_set_port(mountdata->addr, NFS_PORT);\n\n\t\tmemcpy(page2, buf->data, buf->len);\n\t\tpage2[buf->len] = '\\0';\n\t\tmountdata->hostname = page2;\n\n\t\tsnprintf(page, PAGE_SIZE, \"%s:%s\",\n\t\t\t\tmountdata->hostname,\n\t\t\t\tmountdata->mnt_path);\n\n\t\tmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\tkfree(mountdata->addr);\n\treturn mnt;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mountdata->addr"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "&nfs4_referral_fs_type",
            "0",
            "page",
            "mountdata"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "page",
            "PAGE_SIZE",
            "\"%s:%s\"",
            "mountdata->hostname",
            "mountdata->mnt_path"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page2",
            "buf->data",
            "buf->len"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_set_port",
          "args": [
            "mountdata->addr",
            "NFS_PORT"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_parse_server_name",
          "args": [
            "buf->data",
            "buf->len",
            "mountdata->addr",
            "addr_bufsize",
            "net"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_parse_server_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "123-135",
          "snippet": "static size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf->data",
            "IPV6_SCOPE_DELIMITER",
            "buf->len"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "addr_bufsize",
            "GFP_KERNEL"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "mnt_path"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt_path"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pathname_string",
          "args": [
            "&location->rootpath",
            "page2",
            "PAGE_SIZE"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pathname_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "32-54",
          "snippet": "static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_net_ns",
          "args": [
            "NFS_SB(mountdata->sb)->client"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "mountdata->sb"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *try_location(struct nfs_clone_mount *mountdata,\n\t\t\t\t     char *page, char *page2,\n\t\t\t\t     const struct nfs4_fs_location *location)\n{\n\tconst size_t addr_bufsize = sizeof(struct sockaddr_storage);\n\tstruct net *net = rpc_net_ns(NFS_SB(mountdata->sb)->client);\n\tstruct vfsmount *mnt = ERR_PTR(-ENOENT);\n\tchar *mnt_path;\n\tunsigned int maxbuflen;\n\tunsigned int s;\n\n\tmnt_path = nfs4_pathname_string(&location->rootpath, page2, PAGE_SIZE);\n\tif (IS_ERR(mnt_path))\n\t\treturn ERR_CAST(mnt_path);\n\tmountdata->mnt_path = mnt_path;\n\tmaxbuflen = mnt_path - 1 - page2;\n\n\tmountdata->addr = kmalloc(addr_bufsize, GFP_KERNEL);\n\tif (mountdata->addr == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (s = 0; s < location->nservers; s++) {\n\t\tconst struct nfs4_string *buf = &location->servers[s];\n\n\t\tif (buf->len <= 0 || buf->len >= maxbuflen)\n\t\t\tcontinue;\n\n\t\tif (memchr(buf->data, IPV6_SCOPE_DELIMITER, buf->len))\n\t\t\tcontinue;\n\n\t\tmountdata->addrlen = nfs_parse_server_name(buf->data, buf->len,\n\t\t\t\tmountdata->addr, addr_bufsize, net);\n\t\tif (mountdata->addrlen == 0)\n\t\t\tcontinue;\n\n\t\trpc_set_port(mountdata->addr, NFS_PORT);\n\n\t\tmemcpy(page2, buf->data, buf->len);\n\t\tpage2[buf->len] = '\\0';\n\t\tmountdata->hostname = page2;\n\n\t\tsnprintf(page, PAGE_SIZE, \"%s:%s\",\n\t\t\t\tmountdata->hostname,\n\t\t\t\tmountdata->mnt_path);\n\n\t\tmnt = vfs_kern_mount(&nfs4_referral_fs_type, 0, page, mountdata);\n\t\tif (!IS_ERR(mnt))\n\t\t\tbreak;\n\t}\n\tkfree(mountdata->addr);\n\treturn mnt;\n}"
  },
  {
    "function_name": "nfs4_negotiate_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "209-235",
    "snippet": "struct rpc_clnt *\nnfs4_negotiate_security(struct rpc_clnt *clnt, struct inode *inode,\n\t\t\t\t\tstruct qstr *name)\n{\n\tstruct page *page;\n\tstruct nfs4_secinfo_flavors *flavors;\n\tstruct rpc_clnt *new;\n\tint err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tflavors = page_address(page);\n\n\terr = nfs4_proc_secinfo(inode, name, flavors);\n\tif (err < 0) {\n\t\tnew = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tnew = nfs_find_best_sec(clnt, NFS_SERVER(inode), flavors);\n\nout:\n\tput_page(page);\n\treturn new;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_find_best_sec",
          "args": [
            "clnt",
            "NFS_SERVER(inode)",
            "flavors"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_find_best_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "153-196",
          "snippet": "static struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\n\t\t\t\t\t  struct nfs_server *server,\n\t\t\t\t\t  struct nfs4_secinfo_flavors *flavors)\n{\n\trpc_authflavor_t pflavor;\n\tstruct nfs4_secinfo4 *secinfo;\n\tunsigned int i;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tpflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t\t\t&secinfo->flavor_info);\n\t\t\t/* does the pseudoflavor match a sec= mount opt? */\n\t\t\tif (pflavor != RPC_AUTH_MAXFLAVOR &&\n\t\t\t    nfs_auth_info_match(&server->auth_info, pflavor)) {\n\t\t\t\tstruct rpc_clnt *new;\n\t\t\t\tstruct rpc_cred *cred;\n\n\t\t\t\t/* Cloning creates an rpc_auth for the flavor */\n\t\t\t\tnew = rpc_clone_client_set_auth(clnt, pflavor);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\tcontinue;\n\t\t\t\t/**\n\t\t\t\t* Check that the user actually can use the\n\t\t\t\t* flavor. This is mostly for RPC_AUTH_GSS\n\t\t\t\t* where cr_init obtains a gss context\n\t\t\t\t*/\n\t\t\t\tcred = rpcauth_lookupcred(new->cl_auth, 0);\n\t\t\t\tif (IS_ERR(cred)) {\n\t\t\t\t\trpc_shutdown_client(new);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tput_rpccred(cred);\n\t\t\t\treturn new;\n\t\t\t}\n\t\t}\n\t}\n\treturn ERR_PTR(-EPERM);\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\n\t\t\t\t\t  struct nfs_server *server,\n\t\t\t\t\t  struct nfs4_secinfo_flavors *flavors)\n{\n\trpc_authflavor_t pflavor;\n\tstruct nfs4_secinfo4 *secinfo;\n\tunsigned int i;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tpflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t\t\t&secinfo->flavor_info);\n\t\t\t/* does the pseudoflavor match a sec= mount opt? */\n\t\t\tif (pflavor != RPC_AUTH_MAXFLAVOR &&\n\t\t\t    nfs_auth_info_match(&server->auth_info, pflavor)) {\n\t\t\t\tstruct rpc_clnt *new;\n\t\t\t\tstruct rpc_cred *cred;\n\n\t\t\t\t/* Cloning creates an rpc_auth for the flavor */\n\t\t\t\tnew = rpc_clone_client_set_auth(clnt, pflavor);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\tcontinue;\n\t\t\t\t/**\n\t\t\t\t* Check that the user actually can use the\n\t\t\t\t* flavor. This is mostly for RPC_AUTH_GSS\n\t\t\t\t* where cr_init obtains a gss context\n\t\t\t\t*/\n\t\t\t\tcred = rpcauth_lookupcred(new->cl_auth, 0);\n\t\t\t\tif (IS_ERR(cred)) {\n\t\t\t\t\trpc_shutdown_client(new);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tput_rpccred(cred);\n\t\t\t\treturn new;\n\t\t\t}\n\t\t}\n\t}\n\treturn ERR_PTR(-EPERM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NFS_SERVER",
          "args": [
            "inode"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_proc_secinfo",
          "args": [
            "inode",
            "name",
            "flavors"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_proc_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "6587-6613",
          "snippet": "int nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t/* try to use integrity protection with machine cred */\n\t\tif (_nfs4_is_integrity_protected(NFS_SERVER(dir)->nfs_client))\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, true);\n\n\t\t/*\n\t\t * if unable to use integrity protection, or SECINFO with\n\t\t * integrity protection returns NFS4ERR_WRONGSEC (which is\n\t\t * disallowed by spec, but exists in deployed servers) use\n\t\t * the current filesystem's rpc_client and the user cred.\n\t\t */\n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, false);\n\n\t\ttrace_nfs4_secinfo(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nint nfs4_proc_secinfo(struct inode *dir, const struct qstr *name,\n\t\t      struct nfs4_secinfo_flavors *flavors)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = -NFS4ERR_WRONGSEC;\n\n\t\t/* try to use integrity protection with machine cred */\n\t\tif (_nfs4_is_integrity_protected(NFS_SERVER(dir)->nfs_client))\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, true);\n\n\t\t/*\n\t\t * if unable to use integrity protection, or SECINFO with\n\t\t * integrity protection returns NFS4ERR_WRONGSEC (which is\n\t\t * disallowed by spec, but exists in deployed servers) use\n\t\t * the current filesystem's rpc_client and the user cred.\n\t\t */\n\t\tif (err == -NFS4ERR_WRONGSEC)\n\t\t\terr = _nfs4_proc_secinfo(dir, name, flavors, false);\n\n\t\ttrace_nfs4_secinfo(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstruct rpc_clnt *\nnfs4_negotiate_security(struct rpc_clnt *clnt, struct inode *inode,\n\t\t\t\t\tstruct qstr *name)\n{\n\tstruct page *page;\n\tstruct nfs4_secinfo_flavors *flavors;\n\tstruct rpc_clnt *new;\n\tint err;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tflavors = page_address(page);\n\n\terr = nfs4_proc_secinfo(inode, name, flavors);\n\tif (err < 0) {\n\t\tnew = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tnew = nfs_find_best_sec(clnt, NFS_SERVER(inode), flavors);\n\nout:\n\tput_page(page);\n\treturn new;\n}"
  },
  {
    "function_name": "nfs_find_best_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "153-196",
    "snippet": "static struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\n\t\t\t\t\t  struct nfs_server *server,\n\t\t\t\t\t  struct nfs4_secinfo_flavors *flavors)\n{\n\trpc_authflavor_t pflavor;\n\tstruct nfs4_secinfo4 *secinfo;\n\tunsigned int i;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tpflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t\t\t&secinfo->flavor_info);\n\t\t\t/* does the pseudoflavor match a sec= mount opt? */\n\t\t\tif (pflavor != RPC_AUTH_MAXFLAVOR &&\n\t\t\t    nfs_auth_info_match(&server->auth_info, pflavor)) {\n\t\t\t\tstruct rpc_clnt *new;\n\t\t\t\tstruct rpc_cred *cred;\n\n\t\t\t\t/* Cloning creates an rpc_auth for the flavor */\n\t\t\t\tnew = rpc_clone_client_set_auth(clnt, pflavor);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\tcontinue;\n\t\t\t\t/**\n\t\t\t\t* Check that the user actually can use the\n\t\t\t\t* flavor. This is mostly for RPC_AUTH_GSS\n\t\t\t\t* where cr_init obtains a gss context\n\t\t\t\t*/\n\t\t\t\tcred = rpcauth_lookupcred(new->cl_auth, 0);\n\t\t\t\tif (IS_ERR(cred)) {\n\t\t\t\t\trpc_shutdown_client(new);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tput_rpccred(cred);\n\t\t\t\treturn new;\n\t\t\t}\n\t\t}\n\t}\n\treturn ERR_PTR(-EPERM);\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_rpccred",
          "args": [
            "cred"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "new"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cred"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcauth_lookupcred",
          "args": [
            "new->cl_auth",
            "0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_clone_client_set_auth",
          "args": [
            "clnt",
            "pflavor"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_auth_info_match",
          "args": [
            "&server->auth_info",
            "pflavor"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_auth_info_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "1053-1066",
          "snippet": "bool nfs_auth_info_match(const struct nfs_auth_info *auth_info,\n\t\t\t rpc_authflavor_t match)\n{\n\tint i;\n\n\tif (!auth_info->flavor_len)\n\t\treturn true;\n\n\tfor (i = 0; i < auth_info->flavor_len; i++) {\n\t\tif (auth_info->flavors[i] == match)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nbool nfs_auth_info_match(const struct nfs_auth_info *auth_info,\n\t\t\t rpc_authflavor_t match)\n{\n\tint i;\n\n\tif (!auth_info->flavor_len)\n\t\treturn true;\n\n\tfor (i = 0; i < auth_info->flavor_len; i++) {\n\t\tif (auth_info->flavors[i] == match)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpcauth_get_pseudoflavor",
          "args": [
            "secinfo->flavor",
            "&secinfo->flavor_info"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct rpc_clnt *nfs_find_best_sec(struct rpc_clnt *clnt,\n\t\t\t\t\t  struct nfs_server *server,\n\t\t\t\t\t  struct nfs4_secinfo_flavors *flavors)\n{\n\trpc_authflavor_t pflavor;\n\tstruct nfs4_secinfo4 *secinfo;\n\tunsigned int i;\n\n\tfor (i = 0; i < flavors->num_flavors; i++) {\n\t\tsecinfo = &flavors->flavors[i];\n\n\t\tswitch (secinfo->flavor) {\n\t\tcase RPC_AUTH_NULL:\n\t\tcase RPC_AUTH_UNIX:\n\t\tcase RPC_AUTH_GSS:\n\t\t\tpflavor = rpcauth_get_pseudoflavor(secinfo->flavor,\n\t\t\t\t\t\t\t&secinfo->flavor_info);\n\t\t\t/* does the pseudoflavor match a sec= mount opt? */\n\t\t\tif (pflavor != RPC_AUTH_MAXFLAVOR &&\n\t\t\t    nfs_auth_info_match(&server->auth_info, pflavor)) {\n\t\t\t\tstruct rpc_clnt *new;\n\t\t\t\tstruct rpc_cred *cred;\n\n\t\t\t\t/* Cloning creates an rpc_auth for the flavor */\n\t\t\t\tnew = rpc_clone_client_set_auth(clnt, pflavor);\n\t\t\t\tif (IS_ERR(new))\n\t\t\t\t\tcontinue;\n\t\t\t\t/**\n\t\t\t\t* Check that the user actually can use the\n\t\t\t\t* flavor. This is mostly for RPC_AUTH_GSS\n\t\t\t\t* where cr_init obtains a gss context\n\t\t\t\t*/\n\t\t\t\tcred = rpcauth_lookupcred(new->cl_auth, 0);\n\t\t\t\tif (IS_ERR(cred)) {\n\t\t\t\t\trpc_shutdown_client(new);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tput_rpccred(cred);\n\t\t\t\treturn new;\n\t\t\t}\n\t\t}\n\t}\n\treturn ERR_PTR(-EPERM);\n}"
  },
  {
    "function_name": "nfs_parse_server_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "123-135",
    "snippet": "static size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_dns_resolve_name",
          "args": [
            "net",
            "string",
            "len",
            "sa",
            "salen"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_dns_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/dns_resolve.c",
          "lines": "332-354",
          "snippet": "ssize_t nfs_dns_resolve_name(struct net *net, char *name,\n\t\tsize_t namelen, struct sockaddr *sa, size_t salen)\n{\n\tstruct nfs_dns_ent key = {\n\t\t.hostname = name,\n\t\t.namelen = namelen,\n\t};\n\tstruct nfs_dns_ent *item = NULL;\n\tssize_t ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = do_cache_lookup_wait(nn->nfs_dns_resolve, &key, &item);\n\tif (ret == 0) {\n\t\tif (salen >= item->addrlen) {\n\t\t\tmemcpy(sa, &item->addr, item->addrlen);\n\t\t\tret = item->addrlen;\n\t\t} else\n\t\t\tret = -EOVERFLOW;\n\t\tcache_put(&item->h, nn->nfs_dns_resolve);\n\t} else if (ret == -ENOENT)\n\t\tret = -ESRCH;\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"cache_lib.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/svcauth.h>",
            "#include <linux/sunrpc/cache.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/inet.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/socket.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/string.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include \"dns_resolve.h\"",
            "#include <linux/dns_resolver.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"cache_lib.h\"\n#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/svcauth.h>\n#include <linux/sunrpc/cache.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/inet.h>\n#include <linux/seq_file.h>\n#include <linux/socket.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/string.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include \"dns_resolve.h\"\n#include <linux/dns_resolver.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/module.h>\n\nssize_t nfs_dns_resolve_name(struct net *net, char *name,\n\t\tsize_t namelen, struct sockaddr *sa, size_t salen)\n{\n\tstruct nfs_dns_ent key = {\n\t\t.hostname = name,\n\t\t.namelen = namelen,\n\t};\n\tstruct nfs_dns_ent *item = NULL;\n\tssize_t ret;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tret = do_cache_lookup_wait(nn->nfs_dns_resolve, &key, &item);\n\tif (ret == 0) {\n\t\tif (salen >= item->addrlen) {\n\t\t\tmemcpy(sa, &item->addr, item->addrlen);\n\t\t\tret = item->addrlen;\n\t\t} else\n\t\t\tret = -EOVERFLOW;\n\t\tcache_put(&item->h, nn->nfs_dns_resolve);\n\t} else if (ret == -ENOENT)\n\t\tret = -ESRCH;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_pton",
          "args": [
            "net",
            "string",
            "len",
            "sa",
            "salen"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic size_t nfs_parse_server_name(char *string, size_t len,\n\t\tstruct sockaddr *sa, size_t salen, struct net *net)\n{\n\tssize_t ret;\n\n\tret = rpc_pton(net, string, len, sa, salen);\n\tif (ret == 0) {\n\t\tret = nfs_dns_resolve_name(net, string, len, sa, salen);\n\t\tif (ret < 0)\n\t\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_validate_fspath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "100-121",
    "snippet": "static int nfs4_validate_fspath(struct dentry *dentry,\n\t\t\t\tconst struct nfs4_fs_locations *locations,\n\t\t\t\tchar *page, char *page2)\n{\n\tconst char *path, *fs_path;\n\n\tpath = nfs4_path(dentry, page, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\n\tif (IS_ERR(fs_path))\n\t\treturn PTR_ERR(fs_path);\n\n\tif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\n\t\tdprintk(\"%s: path %s does not begin with fsroot %s\\n\",\n\t\t\t__func__, path, fs_path);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: path %s does not begin with fsroot %s\\n\"",
            "__func__",
            "path",
            "fs_path"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "path",
            "fs_path",
            "strlen(fs_path)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fs_path"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_path"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_path"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_pathname_string",
          "args": [
            "&locations->fs_path",
            "page2",
            "PAGE_SIZE"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_pathname_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "32-54",
          "snippet": "static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_path",
          "args": [
            "dentry",
            "page",
            "PAGE_SIZE"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "83-94",
          "snippet": "static char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\n{\n\tchar *limit;\n\tchar *path = nfs_path(&limit, dentry, buffer, buflen,\n\t\t\t      NFS_PATH_CANONICAL);\n\tif (!IS_ERR(path)) {\n\t\tchar *path_component = nfs_path_component(path, limit);\n\t\tif (path_component)\n\t\t\treturn path_component;\n\t}\n\treturn path;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\n{\n\tchar *limit;\n\tchar *path = nfs_path(&limit, dentry, buffer, buflen,\n\t\t\t      NFS_PATH_CANONICAL);\n\tif (!IS_ERR(path)) {\n\t\tchar *path_component = nfs_path_component(path, limit);\n\t\tif (path_component)\n\t\t\treturn path_component;\n\t}\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic int nfs4_validate_fspath(struct dentry *dentry,\n\t\t\t\tconst struct nfs4_fs_locations *locations,\n\t\t\t\tchar *page, char *page2)\n{\n\tconst char *path, *fs_path;\n\n\tpath = nfs4_path(dentry, page, PAGE_SIZE);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\n\tfs_path = nfs4_pathname_string(&locations->fs_path, page2, PAGE_SIZE);\n\tif (IS_ERR(fs_path))\n\t\treturn PTR_ERR(fs_path);\n\n\tif (strncmp(path, fs_path, strlen(fs_path)) != 0) {\n\t\tdprintk(\"%s: path %s does not begin with fsroot %s\\n\",\n\t\t\t__func__, path, fs_path);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "83-94",
    "snippet": "static char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\n{\n\tchar *limit;\n\tchar *path = nfs_path(&limit, dentry, buffer, buflen,\n\t\t\t      NFS_PATH_CANONICAL);\n\tif (!IS_ERR(path)) {\n\t\tchar *path_component = nfs_path_component(path, limit);\n\t\tif (path_component)\n\t\t\treturn path_component;\n\t}\n\treturn path;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_path_component",
          "args": [
            "path",
            "limit"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
          "lines": "62-78",
          "snippet": "static char *nfs_path_component(const char *nfspath, const char *end)\n{\n\tchar *p;\n\n\tif (*nfspath == '[') {\n\t\t/* parse [] escaped IPv6 addrs */\n\t\tp = strchr(nfspath, ']');\n\t\tif (p != NULL && ++p < end && *p == ':')\n\t\t\treturn p + 1;\n\t} else {\n\t\t/* otherwise split on first colon */\n\t\tp = strchr(nfspath, ':');\n\t\tif (p != NULL && p < end)\n\t\t\treturn p + 1;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"dns_resolve.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *nfs_path_component(const char *nfspath, const char *end)\n{\n\tchar *p;\n\n\tif (*nfspath == '[') {\n\t\t/* parse [] escaped IPv6 addrs */\n\t\tp = strchr(nfspath, ']');\n\t\tif (p != NULL && ++p < end && *p == ':')\n\t\t\treturn p + 1;\n\t} else {\n\t\t/* otherwise split on first colon */\n\t\tp = strchr(nfspath, ':');\n\t\tif (p != NULL && p < end)\n\t\t\treturn p + 1;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs_path",
          "args": [
            "&limit",
            "dentry",
            "buffer",
            "buflen",
            "NFS_PATH_CANONICAL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
          "lines": "50-124",
          "snippet": "char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nchar *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *nfs4_path(struct dentry *dentry, char *buffer, ssize_t buflen)\n{\n\tchar *limit;\n\tchar *path = nfs_path(&limit, dentry, buffer, buflen,\n\t\t\t      NFS_PATH_CANONICAL);\n\tif (!IS_ERR(path)) {\n\t\tchar *path_component = nfs_path_component(path, limit);\n\t\tif (path_component)\n\t\t\treturn path_component;\n\t}\n\treturn path;\n}"
  },
  {
    "function_name": "nfs_path_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "62-78",
    "snippet": "static char *nfs_path_component(const char *nfspath, const char *end)\n{\n\tchar *p;\n\n\tif (*nfspath == '[') {\n\t\t/* parse [] escaped IPv6 addrs */\n\t\tp = strchr(nfspath, ']');\n\t\tif (p != NULL && ++p < end && *p == ':')\n\t\t\treturn p + 1;\n\t} else {\n\t\t/* otherwise split on first colon */\n\t\tp = strchr(nfspath, ':');\n\t\tif (p != NULL && p < end)\n\t\t\treturn p + 1;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nfspath",
            "':'"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "nfspath",
            "']'"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *nfs_path_component(const char *nfspath, const char *end)\n{\n\tchar *p;\n\n\tif (*nfspath == '[') {\n\t\t/* parse [] escaped IPv6 addrs */\n\t\tp = strchr(nfspath, ']');\n\t\tif (p != NULL && ++p < end && *p == ':')\n\t\t\treturn p + 1;\n\t} else {\n\t\t/* otherwise split on first colon */\n\t\tp = strchr(nfspath, ':');\n\t\tif (p != NULL && p < end)\n\t\t\treturn p + 1;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_pathname_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4namespace.c",
    "lines": "32-54",
    "snippet": "static inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
    "includes": [
      "#include \"dns_resolve.h\"",
      "#include \"nfs4_fs.h\"",
      "#include \"internal.h\"",
      "#include <linux/inet.h>",
      "#include <linux/vfs.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/nfs_mount.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "end",
            "component->data",
            "component->len"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dns_resolve.h\"\n#include \"nfs4_fs.h\"\n#include \"internal.h\"\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic inline char *nfs4_pathname_string(const struct nfs4_pathname *pathname,\n\t\t\t\t\t char *buffer, ssize_t buflen)\n{\n\tchar *end = buffer + buflen;\n\tint n;\n\n\t*--end = '\\0';\n\tbuflen--;\n\n\tn = pathname->ncomponents;\n\twhile (--n >= 0) {\n\t\tconst struct nfs4_string *component = &pathname->components[n];\n\t\tbuflen -= component->len + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong;\n\t\tend -= component->len;\n\t\tmemcpy(end, component->data, component->len);\n\t\t*--end = '/';\n\t}\n\treturn end;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
  }
]