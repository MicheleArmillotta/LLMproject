[
  {
    "function_name": "ntfs_empty_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "726-861",
    "snippet": "bool ntfs_empty_logfile(struct inode *log_vi)\n{\n\tVCN vcn, end_vcn;\n\tntfs_inode *log_ni = NTFS_I(log_vi);\n\tntfs_volume *vol = log_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags;\n\tunsigned block_size, block_size_bits;\n\tint err;\n\tbool should_wait = true;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn true;\n\t}\n\t/*\n\t * We cannot use ntfs_attr_set() because we may be still in the middle\n\t * of a mount operation.  Thus we do the emptying by hand by first\n\t * zapping the page cache pages for the $LogFile/$DATA attribute and\n\t * then emptying each of the buffers in each of the clusters specified\n\t * by the runlist by hand.\n\t */\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tvcn = 0;\n\tread_lock_irqsave(&log_ni->size_lock, flags);\n\tend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\tread_unlock_irqrestore(&log_ni->size_lock, flags);\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\tdown_write(&log_ni->runlist.lock);\n\trl = log_ni->runlist.rl;\n\tif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\nmap_vcn:\n\t\terr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\n\t\tif (err) {\n\t\t\tntfs_error(sb, \"Failed to map runlist fragment (error \"\n\t\t\t\t\t\"%d).\", -err);\n\t\t\tgoto err;\n\t\t}\n\t\trl = log_ni->runlist.rl;\n\t\tBUG_ON(!rl || vcn < rl->vcn || !rl->length);\n\t}\n\t/* Seek to the runlist element containing @vcn. */\n\twhile (rl->length && vcn >= rl[1].vcn)\n\t\trl++;\n\tdo {\n\t\tLCN lcn;\n\t\tsector_t block, end_block;\n\t\ts64 len;\n\n\t\t/*\n\t\t * If this run is not mapped map it now and start again as the\n\t\t * runlist will have been updated.\n\t\t */\n\t\tlcn = rl->lcn;\n\t\tif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\tvcn = rl->vcn;\n\t\t\tgoto map_vcn;\n\t\t}\n\t\t/* If this run is not valid abort with an error. */\n\t\tif (unlikely(!rl->length || lcn < LCN_HOLE))\n\t\t\tgoto rl_err;\n\t\t/* Skip holes. */\n\t\tif (lcn == LCN_HOLE)\n\t\t\tcontinue;\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\tlen = rl->length;\n\t\tif (rl[1].vcn > end_vcn)\n\t\t\tlen = end_vcn - rl->vcn;\n\t\tend_block = (lcn + len) << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits;\n\t\t/* Iterate over the blocks in the run and empty them. */\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t/* Obtain the buffer, possibly not uptodate. */\n\t\t\tbh = sb_getblk(sb, block);\n\t\t\tBUG_ON(!bh);\n\t\t\t/* Setup buffer i/o submission. */\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tget_bh(bh);\n\t\t\t/* Set the entire contents of the buffer to 0xff. */\n\t\t\tmemset(bh->b_data, -1, block_size);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (buffer_dirty(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t/*\n\t\t\t * Submit the buffer and wait for i/o to complete but\n\t\t\t * only for the first buffer so we do not miss really\n\t\t\t * serious i/o errors.  Once the first buffer has\n\t\t\t * completed ignore errors afterwards as we can assume\n\t\t\t * that if one buffer worked all of them will work.\n\t\t\t */\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tif (should_wait) {\n\t\t\t\tshould_wait = false;\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t} while (++block < end_block);\n\t} while ((++rl)->vcn < end_vcn);\n\tup_write(&log_ni->runlist.lock);\n\t/*\n\t * Zap the pages again just in case any got instantiated whilst we were\n\t * emptying the blocks by hand.  FIXME: We may not have completed\n\t * writing to all the buffer heads yet so this may happen too early.\n\t * We really should use a kernel thread to do the emptying\n\t * asynchronously and then we can also set the volume dirty and output\n\t * an error message if emptying should fail.\n\t */\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\t/* Set the flag so we do not have to do it again on remount. */\n\tNVolSetLogFileEmpty(vol);\n\tntfs_debug(\"Done.\");\n\treturn true;\nio_err:\n\tntfs_error(sb, \"Failed to write buffer.  Unmount and run chkdsk.\");\n\tgoto dirty_err;\nrl_err:\n\tntfs_error(sb, \"Runlist is corrupt.  Unmount and run chkdsk.\");\ndirty_err:\n\tNVolSetErrors(vol);\n\terr = -EIO;\nerr:\n\tup_write(&log_ni->runlist.lock);\n\tntfs_error(sb, \"Failed to fill $LogFile with 0xff bytes (error %d).\",\n\t\t\t-err);\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to fill $LogFile with 0xff bytes (error %d).\"",
            "-err"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&log_ni->runlist.lock"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Runlist is corrupt.  Unmount and run chkdsk.\""
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "sb",
            "\"Failed to write buffer.  Unmount and run chkdsk.\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetLogFileEmpty",
          "args": [
            "vol"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "log_vi->i_mapping",
            "0"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&log_ni->runlist.lock"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "WRITE",
            "bh"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "-1",
            "block_size"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bh"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "block"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl->length || lcn < LCN_HOLE"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn == LCN_RL_NOT_MAPPED"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl || vcn < rl->vcn || !rl->length"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist_nolock",
          "args": [
            "log_ni",
            "vcn",
            "NULL"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "84-281",
          "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl || vcn < rl->vcn || !rl->length"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&log_ni->runlist.lock"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "log_vi->i_mapping",
            "0"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&log_ni->size_lock",
            "flags"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&log_ni->size_lock",
            "flags"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolLogFileEmpty",
          "args": [
            "vol"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "log_vi"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nbool ntfs_empty_logfile(struct inode *log_vi)\n{\n\tVCN vcn, end_vcn;\n\tntfs_inode *log_ni = NTFS_I(log_vi);\n\tntfs_volume *vol = log_ni->vol;\n\tstruct super_block *sb = vol->sb;\n\trunlist_element *rl;\n\tunsigned long flags;\n\tunsigned block_size, block_size_bits;\n\tint err;\n\tbool should_wait = true;\n\n\tntfs_debug(\"Entering.\");\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn true;\n\t}\n\t/*\n\t * We cannot use ntfs_attr_set() because we may be still in the middle\n\t * of a mount operation.  Thus we do the emptying by hand by first\n\t * zapping the page cache pages for the $LogFile/$DATA attribute and\n\t * then emptying each of the buffers in each of the clusters specified\n\t * by the runlist by hand.\n\t */\n\tblock_size = sb->s_blocksize;\n\tblock_size_bits = sb->s_blocksize_bits;\n\tvcn = 0;\n\tread_lock_irqsave(&log_ni->size_lock, flags);\n\tend_vcn = (log_ni->initialized_size + vol->cluster_size_mask) >>\n\t\t\tvol->cluster_size_bits;\n\tread_unlock_irqrestore(&log_ni->size_lock, flags);\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\tdown_write(&log_ni->runlist.lock);\n\trl = log_ni->runlist.rl;\n\tif (unlikely(!rl || vcn < rl->vcn || !rl->length)) {\nmap_vcn:\n\t\terr = ntfs_map_runlist_nolock(log_ni, vcn, NULL);\n\t\tif (err) {\n\t\t\tntfs_error(sb, \"Failed to map runlist fragment (error \"\n\t\t\t\t\t\"%d).\", -err);\n\t\t\tgoto err;\n\t\t}\n\t\trl = log_ni->runlist.rl;\n\t\tBUG_ON(!rl || vcn < rl->vcn || !rl->length);\n\t}\n\t/* Seek to the runlist element containing @vcn. */\n\twhile (rl->length && vcn >= rl[1].vcn)\n\t\trl++;\n\tdo {\n\t\tLCN lcn;\n\t\tsector_t block, end_block;\n\t\ts64 len;\n\n\t\t/*\n\t\t * If this run is not mapped map it now and start again as the\n\t\t * runlist will have been updated.\n\t\t */\n\t\tlcn = rl->lcn;\n\t\tif (unlikely(lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\tvcn = rl->vcn;\n\t\t\tgoto map_vcn;\n\t\t}\n\t\t/* If this run is not valid abort with an error. */\n\t\tif (unlikely(!rl->length || lcn < LCN_HOLE))\n\t\t\tgoto rl_err;\n\t\t/* Skip holes. */\n\t\tif (lcn == LCN_HOLE)\n\t\t\tcontinue;\n\t\tblock = lcn << vol->cluster_size_bits >> block_size_bits;\n\t\tlen = rl->length;\n\t\tif (rl[1].vcn > end_vcn)\n\t\t\tlen = end_vcn - rl->vcn;\n\t\tend_block = (lcn + len) << vol->cluster_size_bits >>\n\t\t\t\tblock_size_bits;\n\t\t/* Iterate over the blocks in the run and empty them. */\n\t\tdo {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\t/* Obtain the buffer, possibly not uptodate. */\n\t\t\tbh = sb_getblk(sb, block);\n\t\t\tBUG_ON(!bh);\n\t\t\t/* Setup buffer i/o submission. */\n\t\t\tlock_buffer(bh);\n\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\tget_bh(bh);\n\t\t\t/* Set the entire contents of the buffer to 0xff. */\n\t\t\tmemset(bh->b_data, -1, block_size);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tif (buffer_dirty(bh))\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t/*\n\t\t\t * Submit the buffer and wait for i/o to complete but\n\t\t\t * only for the first buffer so we do not miss really\n\t\t\t * serious i/o errors.  Once the first buffer has\n\t\t\t * completed ignore errors afterwards as we can assume\n\t\t\t * that if one buffer worked all of them will work.\n\t\t\t */\n\t\t\tsubmit_bh(WRITE, bh);\n\t\t\tif (should_wait) {\n\t\t\t\tshould_wait = false;\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\t\t\tgoto io_err;\n\t\t\t}\n\t\t\tbrelse(bh);\n\t\t} while (++block < end_block);\n\t} while ((++rl)->vcn < end_vcn);\n\tup_write(&log_ni->runlist.lock);\n\t/*\n\t * Zap the pages again just in case any got instantiated whilst we were\n\t * emptying the blocks by hand.  FIXME: We may not have completed\n\t * writing to all the buffer heads yet so this may happen too early.\n\t * We really should use a kernel thread to do the emptying\n\t * asynchronously and then we can also set the volume dirty and output\n\t * an error message if emptying should fail.\n\t */\n\ttruncate_inode_pages(log_vi->i_mapping, 0);\n\t/* Set the flag so we do not have to do it again on remount. */\n\tNVolSetLogFileEmpty(vol);\n\tntfs_debug(\"Done.\");\n\treturn true;\nio_err:\n\tntfs_error(sb, \"Failed to write buffer.  Unmount and run chkdsk.\");\n\tgoto dirty_err;\nrl_err:\n\tntfs_error(sb, \"Runlist is corrupt.  Unmount and run chkdsk.\");\ndirty_err:\n\tNVolSetErrors(vol);\n\terr = -EIO;\nerr:\n\tup_write(&log_ni->runlist.lock);\n\tntfs_error(sb, \"Failed to fill $LogFile with 0xff bytes (error %d).\",\n\t\t\t-err);\n\treturn false;\n}"
  },
  {
    "function_name": "ntfs_is_logfile_clean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "679-713",
    "snippet": "bool ntfs_is_logfile_clean(struct inode *log_vi, const RESTART_PAGE_HEADER *rp)\n{\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tRESTART_AREA *ra;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tBUG_ON(!rp);\n\tif (!ntfs_is_rstr_record(rp->magic) &&\n\t\t\t!ntfs_is_chkd_record(rp->magic)) {\n\t\tntfs_error(vol->sb, \"Restart page buffer is invalid.  This is \"\n\t\t\t\t\"probably a bug in that the $LogFile should \"\n\t\t\t\t\"have been consistency checked before calling \"\n\t\t\t\t\"this function.\");\n\t\treturn false;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * If the $LogFile has active clients, i.e. it is open, and we do not\n\t * have the RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,\n\t * we assume there was an unclean shutdown.\n\t */\n\tif (ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\t!(ra->flags & RESTART_VOLUME_IS_CLEAN)) {\n\t\tntfs_debug(\"Done.  $LogFile indicates a dirty shutdown.\");\n\t\treturn false;\n\t}\n\t/* $LogFile indicates a clean shutdown. */\n\tntfs_debug(\"Done.  $LogFile indicates a clean shutdown.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.  $LogFile indicates a clean shutdown.\""
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rp->restart_area_offset"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Restart page buffer is invalid.  This is \"\n\t\t\t\t\"probably a bug in that the $LogFile should \"\n\t\t\t\t\"have been consistency checked before calling \"\n\t\t\t\t\"this function.\""
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_chkd_record",
          "args": [
            "rp->magic"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_rstr_record",
          "args": [
            "rp->magic"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rp"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolLogFileEmpty",
          "args": [
            "vol"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "log_vi->i_sb"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nbool ntfs_is_logfile_clean(struct inode *log_vi, const RESTART_PAGE_HEADER *rp)\n{\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tRESTART_AREA *ra;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol)) {\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tBUG_ON(!rp);\n\tif (!ntfs_is_rstr_record(rp->magic) &&\n\t\t\t!ntfs_is_chkd_record(rp->magic)) {\n\t\tntfs_error(vol->sb, \"Restart page buffer is invalid.  This is \"\n\t\t\t\t\"probably a bug in that the $LogFile should \"\n\t\t\t\t\"have been consistency checked before calling \"\n\t\t\t\t\"this function.\");\n\t\treturn false;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * If the $LogFile has active clients, i.e. it is open, and we do not\n\t * have the RESTART_VOLUME_IS_CLEAN bit set in the restart area flags,\n\t * we assume there was an unclean shutdown.\n\t */\n\tif (ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\t!(ra->flags & RESTART_VOLUME_IS_CLEAN)) {\n\t\tntfs_debug(\"Done.  $LogFile indicates a dirty shutdown.\");\n\t\treturn false;\n\t}\n\t/* $LogFile indicates a clean shutdown. */\n\tntfs_debug(\"Done.  $LogFile indicates a clean shutdown.\");\n\treturn true;\n}"
  },
  {
    "function_name": "ntfs_check_logfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "484-657",
    "snippet": "bool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\n{\n\ts64 size, pos;\n\tLSN rstr1_lsn, rstr2_lsn;\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tstruct address_space *mapping = log_vi->i_mapping;\n\tstruct page *page = NULL;\n\tu8 *kaddr = NULL;\n\tRESTART_PAGE_HEADER *rstr1_ph = NULL;\n\tRESTART_PAGE_HEADER *rstr2_ph = NULL;\n\tint log_page_size, log_page_mask, err;\n\tbool logfile_is_empty = true;\n\tu8 log_page_bits;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol))\n\t\tgoto is_empty;\n\tsize = i_size_read(log_vi);\n\t/* Make sure the file doesn't exceed the maximum allowed size. */\n\tif (size > MaxLogFileSize)\n\t\tsize = MaxLogFileSize;\n\t/*\n\t * Truncate size to a multiple of the page cache size or the default\n\t * log page size if the page cache size is between the default log page\n\t * log page size if the page cache size is between the default log page\n\t * size and twice that.\n\t */\n\tif (PAGE_CACHE_SIZE >= DefaultLogPageSize && PAGE_CACHE_SIZE <=\n\t\t\tDefaultLogPageSize * 2)\n\t\tlog_page_size = DefaultLogPageSize;\n\telse\n\t\tlog_page_size = PAGE_CACHE_SIZE;\n\tlog_page_mask = log_page_size - 1;\n\t/*\n\t * Use ntfs_ffs() instead of ffs() to enable the compiler to\n\t * optimize log_page_size and log_page_bits into constants.\n\t */\n\tlog_page_bits = ntfs_ffs(log_page_size) - 1;\n\tsize &= ~(s64)(log_page_size - 1);\n\t/*\n\t * Ensure the log file is big enough to store at least the two restart\n\t * pages and the minimum number of log record pages.\n\t */\n\tif (size < log_page_size * 2 || (size - log_page_size * 2) >>\n\t\t\tlog_page_bits < MinLogRecordPages) {\n\t\tntfs_error(vol->sb, \"$LogFile is too small.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Read through the file looking for a restart page.  Since the restart\n\t * page header is at the beginning of a page we only need to search at\n\t * what could be the beginning of a page (for each page size) rather\n\t * than scanning the whole file byte by byte.  If all potential places\n\t * contain empty and uninitialzed records, the log file can be assumed\n\t * to be empty.\n\t */\n\tfor (pos = 0; pos < size; pos <<= 1) {\n\t\tpgoff_t idx = pos >> PAGE_CACHE_SHIFT;\n\t\tif (!page || page->index != idx) {\n\t\t\tif (page)\n\t\t\t\tntfs_unmap_page(page);\n\t\t\tpage = ntfs_map_page(mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tkaddr = (u8*)page_address(page) + (pos & ~PAGE_CACHE_MASK);\n\t\t/*\n\t\t * A non-empty block means the logfile is not empty while an\n\t\t * empty block after a non-empty block has been encountered\n\t\t * means we are done.\n\t\t */\n\t\tif (!ntfs_is_empty_recordp((le32*)kaddr))\n\t\t\tlogfile_is_empty = false;\n\t\telse if (!logfile_is_empty)\n\t\t\tbreak;\n\t\t/*\n\t\t * A log record page means there cannot be a restart page after\n\t\t * this so no need to continue searching.\n\t\t */\n\t\tif (ntfs_is_rcrd_recordp((le32*)kaddr))\n\t\t\tbreak;\n\t\t/* If not a (modified by chkdsk) restart page, continue. */\n\t\tif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\n\t\t\t\t!ntfs_is_chkd_recordp((le32*)kaddr)) {\n\t\t\tif (!pos)\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check the (modified by chkdsk) restart page for consistency\n\t\t * and get a copy of the complete multi sector transfer\n\t\t * deprotected restart page.\n\t\t */\n\t\terr = ntfs_check_and_load_restart_page(log_vi,\n\t\t\t\t(RESTART_PAGE_HEADER*)kaddr, pos,\n\t\t\t\t!rstr1_ph ? &rstr1_ph : &rstr2_ph,\n\t\t\t\t!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * If we have now found the first (modified by chkdsk)\n\t\t\t * restart page, continue looking for the second one.\n\t\t\t */\n\t\t\tif (!pos) {\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have now found the second (modified by chkdsk)\n\t\t\t * restart page, so we can stop looking.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Error output already done inside the function.  Note, we do\n\t\t * not abort if the restart page was invalid as we might still\n\t\t * find a valid one further in the file.\n\t\t */\n\t\tif (err != -EINVAL) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Continue looking. */\n\t\tif (!pos)\n\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t}\n\tif (page)\n\t\tntfs_unmap_page(page);\n\tif (logfile_is_empty) {\n\t\tNVolSetLogFileEmpty(vol);\nis_empty:\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tif (!rstr1_ph) {\n\t\tBUG_ON(rstr2_ph);\n\t\tntfs_error(vol->sb, \"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\");\n\t\treturn false;\n\t}\n\t/* If both restart pages were found, use the more recent one. */\n\tif (rstr2_ph) {\n\t\t/*\n\t\t * If the second restart area is more recent, switch to it.\n\t\t * Otherwise just throw it away.\n\t\t */\n\t\tif (rstr2_lsn > rstr1_lsn) {\n\t\t\tntfs_debug(\"Using second restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr1_ph);\n\t\t\trstr1_ph = rstr2_ph;\n\t\t\t/* rstr1_lsn = rstr2_lsn; */\n\t\t} else {\n\t\t\tntfs_debug(\"Using first restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr2_ph);\n\t\t}\n\t\trstr2_ph = NULL;\n\t}\n\t/* All consistency checks passed. */\n\tif (rp)\n\t\t*rp = rstr1_ph;\n\telse\n\t\tntfs_free(rstr1_ph);\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (rstr1_ph)\n\t\tntfs_free(rstr1_ph);\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rstr1_ph"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rstr2_ph"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetLogFileEmpty",
          "args": [
            "vol"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_check_and_load_restart_page",
          "args": [
            "log_vi",
            "(RESTART_PAGE_HEADER*)kaddr",
            "pos",
            "!rstr1_ph ? &rstr1_ph : &rstr2_ph",
            "!rstr1_ph ? &rstr1_lsn : &rstr2_lsn"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_check_and_load_restart_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "349-465",
          "snippet": "static int ntfs_check_and_load_restart_page(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\n\t\tLSN *lsn)\n{\n\tRESTART_AREA *ra;\n\tRESTART_PAGE_HEADER *trp;\n\tint size, err;\n\n\tntfs_debug(\"Entering.\");\n\t/* Check the restart page header for consistency. */\n\tif (!ntfs_check_restart_page_header(vi, rp, pos)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\t/* Check the restart area for consistency. */\n\tif (!ntfs_check_restart_area(vi, rp)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * Allocate a buffer to store the whole restart page so we can multi\n\t * sector transfer deprotect it.\n\t */\n\ttrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\n\tif (!trp) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Read the whole of the restart page into the buffer.  If it fits\n\t * completely inside @rp, just copy it from there.  Otherwise map all\n\t * the required pages and copy the data from them.\n\t */\n\tsize = PAGE_CACHE_SIZE - (pos & ~PAGE_CACHE_MASK);\n\tif (size >= le32_to_cpu(rp->system_page_size)) {\n\t\tmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\n\t} else {\n\t\tpgoff_t idx;\n\t\tstruct page *page;\n\t\tint have_read, to_read;\n\n\t\t/* First copy what we already have in @rp. */\n\t\tmemcpy(trp, rp, size);\n\t\t/* Copy the remaining data one page at a time. */\n\t\thave_read = size;\n\t\tto_read = le32_to_cpu(rp->system_page_size) - size;\n\t\tidx = (pos + size) >> PAGE_CACHE_SHIFT;\n\t\tBUG_ON((pos + size) & ~PAGE_CACHE_MASK);\n\t\tdo {\n\t\t\tpage = ntfs_map_page(vi->i_mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tif (err != -EIO && err != -ENOMEM)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsize = min_t(int, to_read, PAGE_CACHE_SIZE);\n\t\t\tmemcpy((u8*)trp + have_read, page_address(page), size);\n\t\t\tntfs_unmap_page(page);\n\t\t\thave_read += size;\n\t\t\tto_read -= size;\n\t\t\tidx++;\n\t\t} while (to_read > 0);\n\t}\n\t/*\n\t * Perform the multi sector transfer deprotection on the buffer if the\n\t * restart page is protected.\n\t */\n\tif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\n\t\t\t&& post_read_mst_fixup((NTFS_RECORD*)trp,\n\t\t\tle32_to_cpu(rp->system_page_size))) {\n\t\t/*\n\t\t * A multi sector tranfer error was detected.  We only need to\n\t\t * abort if the restart page contents exceed the multi sector\n\t\t * transfer fixup of the first sector.\n\t\t */\n\t\tif (le16_to_cpu(rp->restart_area_offset) +\n\t\t\t\tle16_to_cpu(ra->restart_area_length) >\n\t\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\t\tntfs_error(vi->i_sb, \"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * If the restart page is modified by chkdsk or there are no active\n\t * logfile clients, the logfile is consistent.  Otherwise, need to\n\t * check the log client records for consistency, too.\n\t */\n\terr = 0;\n\tif (ntfs_is_rstr_record(rp->magic) &&\n\t\t\tra->client_in_use_list != LOGFILE_NO_CLIENT) {\n\t\tif (!ntfs_check_log_client_array(vi, trp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (lsn) {\n\t\tif (ntfs_is_rstr_record(rp->magic))\n\t\t\t*lsn = sle64_to_cpu(ra->current_lsn);\n\t\telse /* if (ntfs_is_chkd_record(rp->magic)) */\n\t\t\t*lsn = sle64_to_cpu(rp->chkdsk_lsn);\n\t}\n\tntfs_debug(\"Done.\");\n\tif (wrp)\n\t\t*wrp = trp;\n\telse {\nerr_out:\n\t\tntfs_free(trp);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic int ntfs_check_and_load_restart_page(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\n\t\tLSN *lsn)\n{\n\tRESTART_AREA *ra;\n\tRESTART_PAGE_HEADER *trp;\n\tint size, err;\n\n\tntfs_debug(\"Entering.\");\n\t/* Check the restart page header for consistency. */\n\tif (!ntfs_check_restart_page_header(vi, rp, pos)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\t/* Check the restart area for consistency. */\n\tif (!ntfs_check_restart_area(vi, rp)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * Allocate a buffer to store the whole restart page so we can multi\n\t * sector transfer deprotect it.\n\t */\n\ttrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\n\tif (!trp) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Read the whole of the restart page into the buffer.  If it fits\n\t * completely inside @rp, just copy it from there.  Otherwise map all\n\t * the required pages and copy the data from them.\n\t */\n\tsize = PAGE_CACHE_SIZE - (pos & ~PAGE_CACHE_MASK);\n\tif (size >= le32_to_cpu(rp->system_page_size)) {\n\t\tmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\n\t} else {\n\t\tpgoff_t idx;\n\t\tstruct page *page;\n\t\tint have_read, to_read;\n\n\t\t/* First copy what we already have in @rp. */\n\t\tmemcpy(trp, rp, size);\n\t\t/* Copy the remaining data one page at a time. */\n\t\thave_read = size;\n\t\tto_read = le32_to_cpu(rp->system_page_size) - size;\n\t\tidx = (pos + size) >> PAGE_CACHE_SHIFT;\n\t\tBUG_ON((pos + size) & ~PAGE_CACHE_MASK);\n\t\tdo {\n\t\t\tpage = ntfs_map_page(vi->i_mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tif (err != -EIO && err != -ENOMEM)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsize = min_t(int, to_read, PAGE_CACHE_SIZE);\n\t\t\tmemcpy((u8*)trp + have_read, page_address(page), size);\n\t\t\tntfs_unmap_page(page);\n\t\t\thave_read += size;\n\t\t\tto_read -= size;\n\t\t\tidx++;\n\t\t} while (to_read > 0);\n\t}\n\t/*\n\t * Perform the multi sector transfer deprotection on the buffer if the\n\t * restart page is protected.\n\t */\n\tif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\n\t\t\t&& post_read_mst_fixup((NTFS_RECORD*)trp,\n\t\t\tle32_to_cpu(rp->system_page_size))) {\n\t\t/*\n\t\t * A multi sector tranfer error was detected.  We only need to\n\t\t * abort if the restart page contents exceed the multi sector\n\t\t * transfer fixup of the first sector.\n\t\t */\n\t\tif (le16_to_cpu(rp->restart_area_offset) +\n\t\t\t\tle16_to_cpu(ra->restart_area_length) >\n\t\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\t\tntfs_error(vi->i_sb, \"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * If the restart page is modified by chkdsk or there are no active\n\t * logfile clients, the logfile is consistent.  Otherwise, need to\n\t * check the log client records for consistency, too.\n\t */\n\terr = 0;\n\tif (ntfs_is_rstr_record(rp->magic) &&\n\t\t\tra->client_in_use_list != LOGFILE_NO_CLIENT) {\n\t\tif (!ntfs_check_log_client_array(vi, trp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (lsn) {\n\t\tif (ntfs_is_rstr_record(rp->magic))\n\t\t\t*lsn = sle64_to_cpu(ra->current_lsn);\n\t\telse /* if (ntfs_is_chkd_record(rp->magic)) */\n\t\t\t*lsn = sle64_to_cpu(rp->chkdsk_lsn);\n\t}\n\tntfs_debug(\"Done.\");\n\tif (wrp)\n\t\t*wrp = trp;\n\telse {\nerr_out:\n\t\tntfs_free(trp);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_chkd_recordp",
          "args": [
            "(le32*)kaddr"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_rstr_recordp",
          "args": [
            "(le32*)kaddr"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_rcrd_recordp",
          "args": [
            "(le32*)kaddr"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_empty_recordp",
          "args": [
            "(le32*)kaddr"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\"",
            "idx"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mapping",
            "idx"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"$LogFile is too small.\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "log_page_size - 1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_ffs",
          "args": [
            "log_page_size"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_ffs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "135-162",
          "snippet": "static inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline int ntfs_ffs(int x)\n{\n\tint r = 1;\n\n\tif (!x)\n\t\treturn 0;\n\tif (!(x & 0xffff)) {\n\t\tx >>= 16;\n\t\tr += 16;\n\t}\n\tif (!(x & 0xff)) {\n\t\tx >>= 8;\n\t\tr += 8;\n\t}\n\tif (!(x & 0xf)) {\n\t\tx >>= 4;\n\t\tr += 4;\n\t}\n\tif (!(x & 3)) {\n\t\tx >>= 2;\n\t\tr += 2;\n\t}\n\tif (!(x & 1)) {\n\t\tx >>= 1;\n\t\tr += 1;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "log_vi"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolLogFileEmpty",
          "args": [
            "vol"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_SB",
          "args": [
            "log_vi->i_sb"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/ntfs.h",
          "lines": "80-83",
          "snippet": "static inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"layout.h\"",
            "#include \"volume.h\"",
            "#include \"types.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/smp.h>",
            "#include <linux/nls.h>",
            "#include <linux/fs.h>",
            "#include <linux/compiler.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"layout.h\"\n#include \"volume.h\"\n#include \"types.h\"\n#include <linux/pagemap.h>\n#include <linux/smp.h>\n#include <linux/nls.h>\n#include <linux/fs.h>\n#include <linux/compiler.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nstatic inline ntfs_volume *NTFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nbool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)\n{\n\ts64 size, pos;\n\tLSN rstr1_lsn, rstr2_lsn;\n\tntfs_volume *vol = NTFS_SB(log_vi->i_sb);\n\tstruct address_space *mapping = log_vi->i_mapping;\n\tstruct page *page = NULL;\n\tu8 *kaddr = NULL;\n\tRESTART_PAGE_HEADER *rstr1_ph = NULL;\n\tRESTART_PAGE_HEADER *rstr2_ph = NULL;\n\tint log_page_size, log_page_mask, err;\n\tbool logfile_is_empty = true;\n\tu8 log_page_bits;\n\n\tntfs_debug(\"Entering.\");\n\t/* An empty $LogFile must have been clean before it got emptied. */\n\tif (NVolLogFileEmpty(vol))\n\t\tgoto is_empty;\n\tsize = i_size_read(log_vi);\n\t/* Make sure the file doesn't exceed the maximum allowed size. */\n\tif (size > MaxLogFileSize)\n\t\tsize = MaxLogFileSize;\n\t/*\n\t * Truncate size to a multiple of the page cache size or the default\n\t * log page size if the page cache size is between the default log page\n\t * log page size if the page cache size is between the default log page\n\t * size and twice that.\n\t */\n\tif (PAGE_CACHE_SIZE >= DefaultLogPageSize && PAGE_CACHE_SIZE <=\n\t\t\tDefaultLogPageSize * 2)\n\t\tlog_page_size = DefaultLogPageSize;\n\telse\n\t\tlog_page_size = PAGE_CACHE_SIZE;\n\tlog_page_mask = log_page_size - 1;\n\t/*\n\t * Use ntfs_ffs() instead of ffs() to enable the compiler to\n\t * optimize log_page_size and log_page_bits into constants.\n\t */\n\tlog_page_bits = ntfs_ffs(log_page_size) - 1;\n\tsize &= ~(s64)(log_page_size - 1);\n\t/*\n\t * Ensure the log file is big enough to store at least the two restart\n\t * pages and the minimum number of log record pages.\n\t */\n\tif (size < log_page_size * 2 || (size - log_page_size * 2) >>\n\t\t\tlog_page_bits < MinLogRecordPages) {\n\t\tntfs_error(vol->sb, \"$LogFile is too small.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Read through the file looking for a restart page.  Since the restart\n\t * page header is at the beginning of a page we only need to search at\n\t * what could be the beginning of a page (for each page size) rather\n\t * than scanning the whole file byte by byte.  If all potential places\n\t * contain empty and uninitialzed records, the log file can be assumed\n\t * to be empty.\n\t */\n\tfor (pos = 0; pos < size; pos <<= 1) {\n\t\tpgoff_t idx = pos >> PAGE_CACHE_SHIFT;\n\t\tif (!page || page->index != idx) {\n\t\t\tif (page)\n\t\t\t\tntfs_unmap_page(page);\n\t\t\tpage = ntfs_map_page(mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vol->sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tkaddr = (u8*)page_address(page) + (pos & ~PAGE_CACHE_MASK);\n\t\t/*\n\t\t * A non-empty block means the logfile is not empty while an\n\t\t * empty block after a non-empty block has been encountered\n\t\t * means we are done.\n\t\t */\n\t\tif (!ntfs_is_empty_recordp((le32*)kaddr))\n\t\t\tlogfile_is_empty = false;\n\t\telse if (!logfile_is_empty)\n\t\t\tbreak;\n\t\t/*\n\t\t * A log record page means there cannot be a restart page after\n\t\t * this so no need to continue searching.\n\t\t */\n\t\tif (ntfs_is_rcrd_recordp((le32*)kaddr))\n\t\t\tbreak;\n\t\t/* If not a (modified by chkdsk) restart page, continue. */\n\t\tif (!ntfs_is_rstr_recordp((le32*)kaddr) &&\n\t\t\t\t!ntfs_is_chkd_recordp((le32*)kaddr)) {\n\t\t\tif (!pos)\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Check the (modified by chkdsk) restart page for consistency\n\t\t * and get a copy of the complete multi sector transfer\n\t\t * deprotected restart page.\n\t\t */\n\t\terr = ntfs_check_and_load_restart_page(log_vi,\n\t\t\t\t(RESTART_PAGE_HEADER*)kaddr, pos,\n\t\t\t\t!rstr1_ph ? &rstr1_ph : &rstr2_ph,\n\t\t\t\t!rstr1_ph ? &rstr1_lsn : &rstr2_lsn);\n\t\tif (!err) {\n\t\t\t/*\n\t\t\t * If we have now found the first (modified by chkdsk)\n\t\t\t * restart page, continue looking for the second one.\n\t\t\t */\n\t\t\tif (!pos) {\n\t\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have now found the second (modified by chkdsk)\n\t\t\t * restart page, so we can stop looking.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Error output already done inside the function.  Note, we do\n\t\t * not abort if the restart page was invalid as we might still\n\t\t * find a valid one further in the file.\n\t\t */\n\t\tif (err != -EINVAL) {\n\t\t\tntfs_unmap_page(page);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* Continue looking. */\n\t\tif (!pos)\n\t\t\tpos = NTFS_BLOCK_SIZE >> 1;\n\t}\n\tif (page)\n\t\tntfs_unmap_page(page);\n\tif (logfile_is_empty) {\n\t\tNVolSetLogFileEmpty(vol);\nis_empty:\n\t\tntfs_debug(\"Done.  ($LogFile is empty.)\");\n\t\treturn true;\n\t}\n\tif (!rstr1_ph) {\n\t\tBUG_ON(rstr2_ph);\n\t\tntfs_error(vol->sb, \"Did not find any restart pages in \"\n\t\t\t\t\"$LogFile and it was not empty.\");\n\t\treturn false;\n\t}\n\t/* If both restart pages were found, use the more recent one. */\n\tif (rstr2_ph) {\n\t\t/*\n\t\t * If the second restart area is more recent, switch to it.\n\t\t * Otherwise just throw it away.\n\t\t */\n\t\tif (rstr2_lsn > rstr1_lsn) {\n\t\t\tntfs_debug(\"Using second restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr1_ph);\n\t\t\trstr1_ph = rstr2_ph;\n\t\t\t/* rstr1_lsn = rstr2_lsn; */\n\t\t} else {\n\t\t\tntfs_debug(\"Using first restart page as it is more \"\n\t\t\t\t\t\"recent.\");\n\t\t\tntfs_free(rstr2_ph);\n\t\t}\n\t\trstr2_ph = NULL;\n\t}\n\t/* All consistency checks passed. */\n\tif (rp)\n\t\t*rp = rstr1_ph;\n\telse\n\t\tntfs_free(rstr1_ph);\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tif (rstr1_ph)\n\t\tntfs_free(rstr1_ph);\n\treturn false;\n}"
  },
  {
    "function_name": "ntfs_check_and_load_restart_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "349-465",
    "snippet": "static int ntfs_check_and_load_restart_page(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\n\t\tLSN *lsn)\n{\n\tRESTART_AREA *ra;\n\tRESTART_PAGE_HEADER *trp;\n\tint size, err;\n\n\tntfs_debug(\"Entering.\");\n\t/* Check the restart page header for consistency. */\n\tif (!ntfs_check_restart_page_header(vi, rp, pos)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\t/* Check the restart area for consistency. */\n\tif (!ntfs_check_restart_area(vi, rp)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * Allocate a buffer to store the whole restart page so we can multi\n\t * sector transfer deprotect it.\n\t */\n\ttrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\n\tif (!trp) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Read the whole of the restart page into the buffer.  If it fits\n\t * completely inside @rp, just copy it from there.  Otherwise map all\n\t * the required pages and copy the data from them.\n\t */\n\tsize = PAGE_CACHE_SIZE - (pos & ~PAGE_CACHE_MASK);\n\tif (size >= le32_to_cpu(rp->system_page_size)) {\n\t\tmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\n\t} else {\n\t\tpgoff_t idx;\n\t\tstruct page *page;\n\t\tint have_read, to_read;\n\n\t\t/* First copy what we already have in @rp. */\n\t\tmemcpy(trp, rp, size);\n\t\t/* Copy the remaining data one page at a time. */\n\t\thave_read = size;\n\t\tto_read = le32_to_cpu(rp->system_page_size) - size;\n\t\tidx = (pos + size) >> PAGE_CACHE_SHIFT;\n\t\tBUG_ON((pos + size) & ~PAGE_CACHE_MASK);\n\t\tdo {\n\t\t\tpage = ntfs_map_page(vi->i_mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tif (err != -EIO && err != -ENOMEM)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsize = min_t(int, to_read, PAGE_CACHE_SIZE);\n\t\t\tmemcpy((u8*)trp + have_read, page_address(page), size);\n\t\t\tntfs_unmap_page(page);\n\t\t\thave_read += size;\n\t\t\tto_read -= size;\n\t\t\tidx++;\n\t\t} while (to_read > 0);\n\t}\n\t/*\n\t * Perform the multi sector transfer deprotection on the buffer if the\n\t * restart page is protected.\n\t */\n\tif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\n\t\t\t&& post_read_mst_fixup((NTFS_RECORD*)trp,\n\t\t\tle32_to_cpu(rp->system_page_size))) {\n\t\t/*\n\t\t * A multi sector tranfer error was detected.  We only need to\n\t\t * abort if the restart page contents exceed the multi sector\n\t\t * transfer fixup of the first sector.\n\t\t */\n\t\tif (le16_to_cpu(rp->restart_area_offset) +\n\t\t\t\tle16_to_cpu(ra->restart_area_length) >\n\t\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\t\tntfs_error(vi->i_sb, \"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * If the restart page is modified by chkdsk or there are no active\n\t * logfile clients, the logfile is consistent.  Otherwise, need to\n\t * check the log client records for consistency, too.\n\t */\n\terr = 0;\n\tif (ntfs_is_rstr_record(rp->magic) &&\n\t\t\tra->client_in_use_list != LOGFILE_NO_CLIENT) {\n\t\tif (!ntfs_check_log_client_array(vi, trp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (lsn) {\n\t\tif (ntfs_is_rstr_record(rp->magic))\n\t\t\t*lsn = sle64_to_cpu(ra->current_lsn);\n\t\telse /* if (ntfs_is_chkd_record(rp->magic)) */\n\t\t\t*lsn = sle64_to_cpu(rp->chkdsk_lsn);\n\t}\n\tntfs_debug(\"Done.\");\n\tif (wrp)\n\t\t*wrp = trp;\n\telse {\nerr_out:\n\t\tntfs_free(trp);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "trp"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "rp->chkdsk_lsn"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_rstr_record",
          "args": [
            "rp->magic"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_check_log_client_array",
          "args": [
            "vi",
            "trp"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_check_log_client_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "272-320",
          "snippet": "static bool ntfs_check_log_client_array(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp)\n{\n\tRESTART_AREA *ra;\n\tLOG_CLIENT_RECORD *ca, *cr;\n\tu16 nr_clients, idx;\n\tbool in_free_list, idx_is_first;\n\n\tntfs_debug(\"Entering.\");\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\tca = (LOG_CLIENT_RECORD*)((u8*)ra +\n\t\t\tle16_to_cpu(ra->client_array_offset));\n\t/*\n\t * Check the ra->client_free_list first and then check the\n\t * ra->client_in_use_list.  Check each of the log client records in\n\t * each of the lists and check that the array does not overflow the\n\t * ra->log_clients value.  Also keep track of the number of records\n\t * visited as there cannot be more than ra->log_clients records and\n\t * that way we detect eventual loops in within a list.\n\t */\n\tnr_clients = le16_to_cpu(ra->log_clients);\n\tidx = le16_to_cpu(ra->client_free_list);\n\tin_free_list = true;\ncheck_list:\n\tfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\n\t\t\tidx = le16_to_cpu(cr->next_client)) {\n\t\tif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\n\t\t\tgoto err_out;\n\t\t/* Set @cr to the current log client record. */\n\t\tcr = ca + idx;\n\t\t/* The first log client record must not have a prev_client. */\n\t\tif (idx_is_first) {\n\t\t\tif (cr->prev_client != LOGFILE_NO_CLIENT)\n\t\t\t\tgoto err_out;\n\t\t\tidx_is_first = false;\n\t\t}\n\t}\n\t/* Switch to and check the in use list if we just did the free list. */\n\tif (in_free_list) {\n\t\tin_free_list = false;\n\t\tidx = le16_to_cpu(ra->client_in_use_list);\n\t\tgoto check_list;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tntfs_error(vi->i_sb, \"$LogFile log client array is corrupt.\");\n\treturn false;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_log_client_array(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp)\n{\n\tRESTART_AREA *ra;\n\tLOG_CLIENT_RECORD *ca, *cr;\n\tu16 nr_clients, idx;\n\tbool in_free_list, idx_is_first;\n\n\tntfs_debug(\"Entering.\");\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\tca = (LOG_CLIENT_RECORD*)((u8*)ra +\n\t\t\tle16_to_cpu(ra->client_array_offset));\n\t/*\n\t * Check the ra->client_free_list first and then check the\n\t * ra->client_in_use_list.  Check each of the log client records in\n\t * each of the lists and check that the array does not overflow the\n\t * ra->log_clients value.  Also keep track of the number of records\n\t * visited as there cannot be more than ra->log_clients records and\n\t * that way we detect eventual loops in within a list.\n\t */\n\tnr_clients = le16_to_cpu(ra->log_clients);\n\tidx = le16_to_cpu(ra->client_free_list);\n\tin_free_list = true;\ncheck_list:\n\tfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\n\t\t\tidx = le16_to_cpu(cr->next_client)) {\n\t\tif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\n\t\t\tgoto err_out;\n\t\t/* Set @cr to the current log client record. */\n\t\tcr = ca + idx;\n\t\t/* The first log client record must not have a prev_client. */\n\t\tif (idx_is_first) {\n\t\t\tif (cr->prev_client != LOGFILE_NO_CLIENT)\n\t\t\t\tgoto err_out;\n\t\t\tidx_is_first = false;\n\t\t}\n\t}\n\t/* Switch to and check the in use list if we just did the free list. */\n\tif (in_free_list) {\n\t\tin_free_list = false;\n\t\tidx = le16_to_cpu(ra->client_in_use_list);\n\t\tgoto check_list;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tntfs_error(vi->i_sb, \"$LogFile log client array is corrupt.\");\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_rstr_record",
          "args": [
            "rp->magic"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ra->restart_area_length"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "post_read_mst_fixup",
          "args": [
            "(NTFS_RECORD*)trp",
            "le32_to_cpu(rp->system_page_size)"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "post_read_mst_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mst.c",
          "lines": "42-100",
          "snippet": "int post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ntfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n\nint post_read_mst_fixup(NTFS_RECORD *b, const u32 size)\n{\n\tu16 usa_ofs, usa_count, usn;\n\tu16 *usa_pos, *data_pos;\n\n\t/* Setup the variables. */\n\tusa_ofs = le16_to_cpu(b->usa_ofs);\n\t/* Decrement usa_count to get number of fixups. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\t/* Size and alignment checks. */\n\tif ( size & (NTFS_BLOCK_SIZE - 1)\t||\n\t     usa_ofs & 1\t\t\t||\n\t     usa_ofs + (usa_count * 2) > size\t||\n\t     (size >> NTFS_BLOCK_SIZE_BITS) != usa_count)\n\t\treturn 0;\n\t/* Position of usn in update sequence array. */\n\tusa_pos = (u16*)b + usa_ofs/sizeof(u16);\n\t/*\n\t * The update sequence number which has to be equal to each of the\n\t * u16 values before they are fixed up. Note no need to care for\n\t * endianness since we are comparing and moving data for on disk\n\t * structures which means the data is consistent. - If it is\n\t * consistenty the wrong endianness it doesn't make any difference.\n\t */\n\tusn = *usa_pos;\n\t/*\n\t * Position in protected data of first u16 that needs fixing up.\n\t */\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/*\n\t * Check for incomplete multi sector transfer(s).\n\t */\n\twhile (usa_count--) {\n\t\tif (*data_pos != usn) {\n\t\t\t/*\n\t\t\t * Incomplete multi sector transfer detected! )-:\n\t\t\t * Set the magic to \"BAAD\" and return failure.\n\t\t\t * Note that magic_BAAD is already converted to le32.\n\t\t\t */\n\t\t\tb->magic = magic_BAAD;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\t/* Re-setup the variables. */\n\tusa_count = le16_to_cpu(b->usa_count) - 1;\n\tdata_pos = (u16*)b + NTFS_BLOCK_SIZE/sizeof(u16) - 1;\n\t/* Fixup all sectors. */\n\twhile (usa_count--) {\n\t\t/*\n\t\t * Increment position in usa and restore original data from\n\t\t * the usa into the data buffer.\n\t\t */\n\t\t*data_pos = *(++usa_pos);\n\t\t/* Increment position in data as well. */\n\t\tdata_pos += NTFS_BLOCK_SIZE/sizeof(u16);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rp->system_page_size"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_chkd_record",
          "args": [
            "trp->magic"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(u8*)trp + have_read",
            "page_address(page)",
            "size"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "to_read",
            "PAGE_CACHE_SIZE"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\"",
            "idx"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "vi->i_mapping",
            "idx"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(pos + size) & ~PAGE_CACHE_MASK"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "trp",
            "rp",
            "size"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "trp",
            "rp",
            "le32_to_cpu(rp->system_page_size)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "le32_to_cpu(rp->system_page_size)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_check_restart_area",
          "args": [
            "vi",
            "rp"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_check_restart_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "157-255",
          "snippet": "static bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\n{\n\tu64 file_size;\n\tRESTART_AREA *ra;\n\tu16 ra_ofs, ra_len, ca_ofs;\n\tu8 fs_bits;\n\n\tntfs_debug(\"Entering.\");\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tra = (RESTART_AREA*)((u8*)rp + ra_ofs);\n\t/*\n\t * Everything before ra->file_size must be before the first word\n\t * protected by an update sequence number.  This ensures that it is\n\t * safe to access ra->client_array_offset.\n\t */\n\tif (ra_ofs + offsetof(RESTART_AREA, file_size) >\n\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Now that we can access ra->client_array_offset, make sure everything\n\t * up to the log client array is before the first word protected by an\n\t * update sequence number.  This ensures we can access all of the\n\t * restart area elements safely.  Also, the client array offset must be\n\t * aligned to an 8-byte boundary.\n\t */\n\tca_ofs = le16_to_cpu(ra->client_array_offset);\n\tif (((ca_ofs + 7) & ~7) != ca_ofs ||\n\t\t\tra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The restart area must end within the system page size both when\n\t * calculated manually and as specified by ra->restart_area_length.\n\t * Also, the calculated length must not exceed the specified length.\n\t */\n\tra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\n\t\t\tsizeof(LOG_CLIENT_RECORD);\n\tif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\n\t\t\tra_ofs + le16_to_cpu(ra->restart_area_length) >\n\t\t\tle32_to_cpu(rp->system_page_size) ||\n\t\t\tra_len > le16_to_cpu(ra->restart_area_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The ra->client_free_list and ra->client_in_use_list must be either\n\t * LOGFILE_NO_CLIENT or less than ra->log_clients or they are\n\t * overflowing the client array.\n\t */\n\tif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_free_list) >=\n\t\t\tle16_to_cpu(ra->log_clients)) ||\n\t\t\t(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_in_use_list) >=\n\t\t\tle16_to_cpu(ra->log_clients))) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Check ra->seq_number_bits against ra->file_size for consistency.\n\t * We cannot just use ffs() because the file size is not a power of 2.\n\t */\n\tfile_size = (u64)sle64_to_cpu(ra->file_size);\n\tfs_bits = 0;\n\twhile (file_size) {\n\t\tfile_size >>= 1;\n\t\tfs_bits++;\n\t}\n\tif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\");\n\t\treturn false;\n\t}\n\t/* The log record header length must be a multiple of 8. */\n\tif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_record_header_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\");\n\t\treturn false;\n\t}\n\t/* Dito for the log page data offset. */\n\tif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_page_data_offset)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\n{\n\tu64 file_size;\n\tRESTART_AREA *ra;\n\tu16 ra_ofs, ra_len, ca_ofs;\n\tu8 fs_bits;\n\n\tntfs_debug(\"Entering.\");\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tra = (RESTART_AREA*)((u8*)rp + ra_ofs);\n\t/*\n\t * Everything before ra->file_size must be before the first word\n\t * protected by an update sequence number.  This ensures that it is\n\t * safe to access ra->client_array_offset.\n\t */\n\tif (ra_ofs + offsetof(RESTART_AREA, file_size) >\n\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Now that we can access ra->client_array_offset, make sure everything\n\t * up to the log client array is before the first word protected by an\n\t * update sequence number.  This ensures we can access all of the\n\t * restart area elements safely.  Also, the client array offset must be\n\t * aligned to an 8-byte boundary.\n\t */\n\tca_ofs = le16_to_cpu(ra->client_array_offset);\n\tif (((ca_ofs + 7) & ~7) != ca_ofs ||\n\t\t\tra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The restart area must end within the system page size both when\n\t * calculated manually and as specified by ra->restart_area_length.\n\t * Also, the calculated length must not exceed the specified length.\n\t */\n\tra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\n\t\t\tsizeof(LOG_CLIENT_RECORD);\n\tif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\n\t\t\tra_ofs + le16_to_cpu(ra->restart_area_length) >\n\t\t\tle32_to_cpu(rp->system_page_size) ||\n\t\t\tra_len > le16_to_cpu(ra->restart_area_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The ra->client_free_list and ra->client_in_use_list must be either\n\t * LOGFILE_NO_CLIENT or less than ra->log_clients or they are\n\t * overflowing the client array.\n\t */\n\tif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_free_list) >=\n\t\t\tle16_to_cpu(ra->log_clients)) ||\n\t\t\t(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_in_use_list) >=\n\t\t\tle16_to_cpu(ra->log_clients))) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Check ra->seq_number_bits against ra->file_size for consistency.\n\t * We cannot just use ffs() because the file size is not a power of 2.\n\t */\n\tfile_size = (u64)sle64_to_cpu(ra->file_size);\n\tfs_bits = 0;\n\twhile (file_size) {\n\t\tfile_size >>= 1;\n\t\tfs_bits++;\n\t}\n\tif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\");\n\t\treturn false;\n\t}\n\t/* The log record header length must be a multiple of 8. */\n\tif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_record_header_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\");\n\t\treturn false;\n\t}\n\t/* Dito for the log page data offset. */\n\tif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_page_data_offset)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_check_restart_page_header",
          "args": [
            "vi",
            "rp",
            "pos"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_check_restart_page_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
          "lines": "51-141",
          "snippet": "static bool ntfs_check_restart_page_header(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos)\n{\n\tu32 logfile_system_page_size, logfile_log_page_size;\n\tu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\n\tbool have_usa = true;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * If the system or log page sizes are smaller than the ntfs block size\n\t * or either is not a power of 2 we cannot handle this log file.\n\t */\n\tlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\n\tlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\n\tif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_log_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_system_page_size &\n\t\t\t(logfile_system_page_size - 1) ||\n\t\t\t!is_power_of_2(logfile_log_page_size)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile uses unsupported page size.\");\n\t\treturn false;\n\t}\n\t/*\n\t * We must be either at !pos (1st restart page) or at pos = system page\n\t * size (2nd restart page).\n\t */\n\tif (pos && pos != logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\");\n\t\treturn false;\n\t}\n\t/* We only know how to handle version 1.1. */\n\tif (sle16_to_cpu(rp->major_ver) != 1 ||\n\t\t\tsle16_to_cpu(rp->minor_ver) != 1) {\n\t\tntfs_error(vi->i_sb, \"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\", (int)sle16_to_cpu(rp->major_ver),\n\t\t\t\t(int)sle16_to_cpu(rp->minor_ver));\n\t\treturn false;\n\t}\n\t/*\n\t * If chkdsk has been run the restart page may not be protected by an\n\t * update sequence array.\n\t */\n\tif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\n\t\thave_usa = false;\n\t\tgoto skip_usa_checks;\n\t}\n\t/* Verify the size of the update sequence array. */\n\tusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\n\tif (usa_count != le16_to_cpu(rp->usa_count)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\");\n\t\treturn false;\n\t}\n\t/* Verify the position of the update sequence array. */\n\tusa_ofs = le16_to_cpu(rp->usa_ofs);\n\tusa_end = usa_ofs + usa_count * sizeof(u16);\n\tif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\n\t\t\tusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\");\n\t\treturn false;\n\t}\nskip_usa_checks:\n\t/*\n\t * Verify the position of the restart area.  It must be:\n\t *\t- aligned to 8-byte boundary,\n\t *\t- after the update sequence array, and\n\t *\t- within the system page size.\n\t */\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\n\t\t\tra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\n\t\t\tra_ofs > logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn\n\t * set.\n\t */\n\tif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"volume.h\"",
            "#include \"malloc.h\"",
            "#include \"logfile.h\"",
            "#include \"debug.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/log2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_restart_page_header(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos)\n{\n\tu32 logfile_system_page_size, logfile_log_page_size;\n\tu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\n\tbool have_usa = true;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * If the system or log page sizes are smaller than the ntfs block size\n\t * or either is not a power of 2 we cannot handle this log file.\n\t */\n\tlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\n\tlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\n\tif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_log_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_system_page_size &\n\t\t\t(logfile_system_page_size - 1) ||\n\t\t\t!is_power_of_2(logfile_log_page_size)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile uses unsupported page size.\");\n\t\treturn false;\n\t}\n\t/*\n\t * We must be either at !pos (1st restart page) or at pos = system page\n\t * size (2nd restart page).\n\t */\n\tif (pos && pos != logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\");\n\t\treturn false;\n\t}\n\t/* We only know how to handle version 1.1. */\n\tif (sle16_to_cpu(rp->major_ver) != 1 ||\n\t\t\tsle16_to_cpu(rp->minor_ver) != 1) {\n\t\tntfs_error(vi->i_sb, \"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\", (int)sle16_to_cpu(rp->major_ver),\n\t\t\t\t(int)sle16_to_cpu(rp->minor_ver));\n\t\treturn false;\n\t}\n\t/*\n\t * If chkdsk has been run the restart page may not be protected by an\n\t * update sequence array.\n\t */\n\tif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\n\t\thave_usa = false;\n\t\tgoto skip_usa_checks;\n\t}\n\t/* Verify the size of the update sequence array. */\n\tusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\n\tif (usa_count != le16_to_cpu(rp->usa_count)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\");\n\t\treturn false;\n\t}\n\t/* Verify the position of the update sequence array. */\n\tusa_ofs = le16_to_cpu(rp->usa_ofs);\n\tusa_end = usa_ofs + usa_count * sizeof(u16);\n\tif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\n\t\t\tusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\");\n\t\treturn false;\n\t}\nskip_usa_checks:\n\t/*\n\t * Verify the position of the restart area.  It must be:\n\t *\t- aligned to 8-byte boundary,\n\t *\t- after the update sequence array, and\n\t *\t- within the system page size.\n\t */\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\n\t\t\tra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\n\t\t\tra_ofs > logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn\n\t * set.\n\t */\n\tif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic int ntfs_check_and_load_restart_page(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos, RESTART_PAGE_HEADER **wrp,\n\t\tLSN *lsn)\n{\n\tRESTART_AREA *ra;\n\tRESTART_PAGE_HEADER *trp;\n\tint size, err;\n\n\tntfs_debug(\"Entering.\");\n\t/* Check the restart page header for consistency. */\n\tif (!ntfs_check_restart_page_header(vi, rp, pos)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\t/* Check the restart area for consistency. */\n\tif (!ntfs_check_restart_area(vi, rp)) {\n\t\t/* Error output already done inside the function. */\n\t\treturn -EINVAL;\n\t}\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\t/*\n\t * Allocate a buffer to store the whole restart page so we can multi\n\t * sector transfer deprotect it.\n\t */\n\ttrp = ntfs_malloc_nofs(le32_to_cpu(rp->system_page_size));\n\tif (!trp) {\n\t\tntfs_error(vi->i_sb, \"Failed to allocate memory for $LogFile \"\n\t\t\t\t\"restart page buffer.\");\n\t\treturn -ENOMEM;\n\t}\n\t/*\n\t * Read the whole of the restart page into the buffer.  If it fits\n\t * completely inside @rp, just copy it from there.  Otherwise map all\n\t * the required pages and copy the data from them.\n\t */\n\tsize = PAGE_CACHE_SIZE - (pos & ~PAGE_CACHE_MASK);\n\tif (size >= le32_to_cpu(rp->system_page_size)) {\n\t\tmemcpy(trp, rp, le32_to_cpu(rp->system_page_size));\n\t} else {\n\t\tpgoff_t idx;\n\t\tstruct page *page;\n\t\tint have_read, to_read;\n\n\t\t/* First copy what we already have in @rp. */\n\t\tmemcpy(trp, rp, size);\n\t\t/* Copy the remaining data one page at a time. */\n\t\thave_read = size;\n\t\tto_read = le32_to_cpu(rp->system_page_size) - size;\n\t\tidx = (pos + size) >> PAGE_CACHE_SHIFT;\n\t\tBUG_ON((pos + size) & ~PAGE_CACHE_MASK);\n\t\tdo {\n\t\t\tpage = ntfs_map_page(vi->i_mapping, idx);\n\t\t\tif (IS_ERR(page)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Error mapping $LogFile \"\n\t\t\t\t\t\t\"page (index %lu).\", idx);\n\t\t\t\terr = PTR_ERR(page);\n\t\t\t\tif (err != -EIO && err != -ENOMEM)\n\t\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tsize = min_t(int, to_read, PAGE_CACHE_SIZE);\n\t\t\tmemcpy((u8*)trp + have_read, page_address(page), size);\n\t\t\tntfs_unmap_page(page);\n\t\t\thave_read += size;\n\t\t\tto_read -= size;\n\t\t\tidx++;\n\t\t} while (to_read > 0);\n\t}\n\t/*\n\t * Perform the multi sector transfer deprotection on the buffer if the\n\t * restart page is protected.\n\t */\n\tif ((!ntfs_is_chkd_record(trp->magic) || le16_to_cpu(trp->usa_count))\n\t\t\t&& post_read_mst_fixup((NTFS_RECORD*)trp,\n\t\t\tle32_to_cpu(rp->system_page_size))) {\n\t\t/*\n\t\t * A multi sector tranfer error was detected.  We only need to\n\t\t * abort if the restart page contents exceed the multi sector\n\t\t * transfer fixup of the first sector.\n\t\t */\n\t\tif (le16_to_cpu(rp->restart_area_offset) +\n\t\t\t\tle16_to_cpu(ra->restart_area_length) >\n\t\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\t\tntfs_error(vi->i_sb, \"Multi sector transfer error \"\n\t\t\t\t\t\"detected in $LogFile restart page.\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * If the restart page is modified by chkdsk or there are no active\n\t * logfile clients, the logfile is consistent.  Otherwise, need to\n\t * check the log client records for consistency, too.\n\t */\n\terr = 0;\n\tif (ntfs_is_rstr_record(rp->magic) &&\n\t\t\tra->client_in_use_list != LOGFILE_NO_CLIENT) {\n\t\tif (!ntfs_check_log_client_array(vi, trp)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\tif (lsn) {\n\t\tif (ntfs_is_rstr_record(rp->magic))\n\t\t\t*lsn = sle64_to_cpu(ra->current_lsn);\n\t\telse /* if (ntfs_is_chkd_record(rp->magic)) */\n\t\t\t*lsn = sle64_to_cpu(rp->chkdsk_lsn);\n\t}\n\tntfs_debug(\"Done.\");\n\tif (wrp)\n\t\t*wrp = trp;\n\telse {\nerr_out:\n\t\tntfs_free(trp);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_check_log_client_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "272-320",
    "snippet": "static bool ntfs_check_log_client_array(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp)\n{\n\tRESTART_AREA *ra;\n\tLOG_CLIENT_RECORD *ca, *cr;\n\tu16 nr_clients, idx;\n\tbool in_free_list, idx_is_first;\n\n\tntfs_debug(\"Entering.\");\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\tca = (LOG_CLIENT_RECORD*)((u8*)ra +\n\t\t\tle16_to_cpu(ra->client_array_offset));\n\t/*\n\t * Check the ra->client_free_list first and then check the\n\t * ra->client_in_use_list.  Check each of the log client records in\n\t * each of the lists and check that the array does not overflow the\n\t * ra->log_clients value.  Also keep track of the number of records\n\t * visited as there cannot be more than ra->log_clients records and\n\t * that way we detect eventual loops in within a list.\n\t */\n\tnr_clients = le16_to_cpu(ra->log_clients);\n\tidx = le16_to_cpu(ra->client_free_list);\n\tin_free_list = true;\ncheck_list:\n\tfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\n\t\t\tidx = le16_to_cpu(cr->next_client)) {\n\t\tif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\n\t\t\tgoto err_out;\n\t\t/* Set @cr to the current log client record. */\n\t\tcr = ca + idx;\n\t\t/* The first log client record must not have a prev_client. */\n\t\tif (idx_is_first) {\n\t\t\tif (cr->prev_client != LOGFILE_NO_CLIENT)\n\t\t\t\tgoto err_out;\n\t\t\tidx_is_first = false;\n\t\t}\n\t}\n\t/* Switch to and check the in use list if we just did the free list. */\n\tif (in_free_list) {\n\t\tin_free_list = false;\n\t\tidx = le16_to_cpu(ra->client_in_use_list);\n\t\tgoto check_list;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tntfs_error(vi->i_sb, \"$LogFile log client array is corrupt.\");\n\treturn false;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile log client array is corrupt.\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ra->client_in_use_list"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_log_client_array(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp)\n{\n\tRESTART_AREA *ra;\n\tLOG_CLIENT_RECORD *ca, *cr;\n\tu16 nr_clients, idx;\n\tbool in_free_list, idx_is_first;\n\n\tntfs_debug(\"Entering.\");\n\tra = (RESTART_AREA*)((u8*)rp + le16_to_cpu(rp->restart_area_offset));\n\tca = (LOG_CLIENT_RECORD*)((u8*)ra +\n\t\t\tle16_to_cpu(ra->client_array_offset));\n\t/*\n\t * Check the ra->client_free_list first and then check the\n\t * ra->client_in_use_list.  Check each of the log client records in\n\t * each of the lists and check that the array does not overflow the\n\t * ra->log_clients value.  Also keep track of the number of records\n\t * visited as there cannot be more than ra->log_clients records and\n\t * that way we detect eventual loops in within a list.\n\t */\n\tnr_clients = le16_to_cpu(ra->log_clients);\n\tidx = le16_to_cpu(ra->client_free_list);\n\tin_free_list = true;\ncheck_list:\n\tfor (idx_is_first = true; idx != LOGFILE_NO_CLIENT_CPU; nr_clients--,\n\t\t\tidx = le16_to_cpu(cr->next_client)) {\n\t\tif (!nr_clients || idx >= le16_to_cpu(ra->log_clients))\n\t\t\tgoto err_out;\n\t\t/* Set @cr to the current log client record. */\n\t\tcr = ca + idx;\n\t\t/* The first log client record must not have a prev_client. */\n\t\tif (idx_is_first) {\n\t\t\tif (cr->prev_client != LOGFILE_NO_CLIENT)\n\t\t\t\tgoto err_out;\n\t\t\tidx_is_first = false;\n\t\t}\n\t}\n\t/* Switch to and check the in use list if we just did the free list. */\n\tif (in_free_list) {\n\t\tin_free_list = false;\n\t\tidx = le16_to_cpu(ra->client_in_use_list);\n\t\tgoto check_list;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\nerr_out:\n\tntfs_error(vi->i_sb, \"$LogFile log client array is corrupt.\");\n\treturn false;\n}"
  },
  {
    "function_name": "ntfs_check_restart_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "157-255",
    "snippet": "static bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\n{\n\tu64 file_size;\n\tRESTART_AREA *ra;\n\tu16 ra_ofs, ra_len, ca_ofs;\n\tu8 fs_bits;\n\n\tntfs_debug(\"Entering.\");\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tra = (RESTART_AREA*)((u8*)rp + ra_ofs);\n\t/*\n\t * Everything before ra->file_size must be before the first word\n\t * protected by an update sequence number.  This ensures that it is\n\t * safe to access ra->client_array_offset.\n\t */\n\tif (ra_ofs + offsetof(RESTART_AREA, file_size) >\n\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Now that we can access ra->client_array_offset, make sure everything\n\t * up to the log client array is before the first word protected by an\n\t * update sequence number.  This ensures we can access all of the\n\t * restart area elements safely.  Also, the client array offset must be\n\t * aligned to an 8-byte boundary.\n\t */\n\tca_ofs = le16_to_cpu(ra->client_array_offset);\n\tif (((ca_ofs + 7) & ~7) != ca_ofs ||\n\t\t\tra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The restart area must end within the system page size both when\n\t * calculated manually and as specified by ra->restart_area_length.\n\t * Also, the calculated length must not exceed the specified length.\n\t */\n\tra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\n\t\t\tsizeof(LOG_CLIENT_RECORD);\n\tif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\n\t\t\tra_ofs + le16_to_cpu(ra->restart_area_length) >\n\t\t\tle32_to_cpu(rp->system_page_size) ||\n\t\t\tra_len > le16_to_cpu(ra->restart_area_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The ra->client_free_list and ra->client_in_use_list must be either\n\t * LOGFILE_NO_CLIENT or less than ra->log_clients or they are\n\t * overflowing the client array.\n\t */\n\tif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_free_list) >=\n\t\t\tle16_to_cpu(ra->log_clients)) ||\n\t\t\t(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_in_use_list) >=\n\t\t\tle16_to_cpu(ra->log_clients))) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Check ra->seq_number_bits against ra->file_size for consistency.\n\t * We cannot just use ffs() because the file size is not a power of 2.\n\t */\n\tfile_size = (u64)sle64_to_cpu(ra->file_size);\n\tfs_bits = 0;\n\twhile (file_size) {\n\t\tfile_size >>= 1;\n\t\tfs_bits++;\n\t}\n\tif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\");\n\t\treturn false;\n\t}\n\t/* The log record header length must be a multiple of 8. */\n\tif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_record_header_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\");\n\t\treturn false;\n\t}\n\t/* Dito for the log page data offset. */\n\tif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_page_data_offset)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "ra->log_page_data_offset"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ra->seq_number_bits"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "ra->file_size"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)\n{\n\tu64 file_size;\n\tRESTART_AREA *ra;\n\tu16 ra_ofs, ra_len, ca_ofs;\n\tu8 fs_bits;\n\n\tntfs_debug(\"Entering.\");\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tra = (RESTART_AREA*)((u8*)rp + ra_ofs);\n\t/*\n\t * Everything before ra->file_size must be before the first word\n\t * protected by an update sequence number.  This ensures that it is\n\t * safe to access ra->client_array_offset.\n\t */\n\tif (ra_ofs + offsetof(RESTART_AREA, file_size) >\n\t\t\tNTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent file offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Now that we can access ra->client_array_offset, make sure everything\n\t * up to the log client array is before the first word protected by an\n\t * update sequence number.  This ensures we can access all of the\n\t * restart area elements safely.  Also, the client array offset must be\n\t * aligned to an 8-byte boundary.\n\t */\n\tca_ofs = le16_to_cpu(ra->client_array_offset);\n\tif (((ca_ofs + 7) & ~7) != ca_ofs ||\n\t\t\tra_ofs + ca_ofs > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent client array offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The restart area must end within the system page size both when\n\t * calculated manually and as specified by ra->restart_area_length.\n\t * Also, the calculated length must not exceed the specified length.\n\t */\n\tra_len = ca_ofs + le16_to_cpu(ra->log_clients) *\n\t\t\tsizeof(LOG_CLIENT_RECORD);\n\tif (ra_ofs + ra_len > le32_to_cpu(rp->system_page_size) ||\n\t\t\tra_ofs + le16_to_cpu(ra->restart_area_length) >\n\t\t\tle32_to_cpu(rp->system_page_size) ||\n\t\t\tra_len > le16_to_cpu(ra->restart_area_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area is out of bounds \"\n\t\t\t\t\"of the system page size specified by the \"\n\t\t\t\t\"restart page header and/or the specified \"\n\t\t\t\t\"restart area length is inconsistent.\");\n\t\treturn false;\n\t}\n\t/*\n\t * The ra->client_free_list and ra->client_in_use_list must be either\n\t * LOGFILE_NO_CLIENT or less than ra->log_clients or they are\n\t * overflowing the client array.\n\t */\n\tif ((ra->client_free_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_free_list) >=\n\t\t\tle16_to_cpu(ra->log_clients)) ||\n\t\t\t(ra->client_in_use_list != LOGFILE_NO_CLIENT &&\n\t\t\tle16_to_cpu(ra->client_in_use_list) >=\n\t\t\tle16_to_cpu(ra->log_clients))) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"overflowing client free and/or in use lists.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Check ra->seq_number_bits against ra->file_size for consistency.\n\t * We cannot just use ffs() because the file size is not a power of 2.\n\t */\n\tfile_size = (u64)sle64_to_cpu(ra->file_size);\n\tfs_bits = 0;\n\twhile (file_size) {\n\t\tfile_size >>= 1;\n\t\tfs_bits++;\n\t}\n\tif (le32_to_cpu(ra->seq_number_bits) != 67 - fs_bits) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent sequence number bits.\");\n\t\treturn false;\n\t}\n\t/* The log record header length must be a multiple of 8. */\n\tif (((le16_to_cpu(ra->log_record_header_length) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_record_header_length)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log record header length.\");\n\t\treturn false;\n\t}\n\t/* Dito for the log page data offset. */\n\tif (((le16_to_cpu(ra->log_page_data_offset) + 7) & ~7) !=\n\t\t\tle16_to_cpu(ra->log_page_data_offset)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart area specifies \"\n\t\t\t\t\"inconsistent log page data offset.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  },
  {
    "function_name": "ntfs_check_restart_page_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/logfile.c",
    "lines": "51-141",
    "snippet": "static bool ntfs_check_restart_page_header(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos)\n{\n\tu32 logfile_system_page_size, logfile_log_page_size;\n\tu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\n\tbool have_usa = true;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * If the system or log page sizes are smaller than the ntfs block size\n\t * or either is not a power of 2 we cannot handle this log file.\n\t */\n\tlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\n\tlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\n\tif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_log_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_system_page_size &\n\t\t\t(logfile_system_page_size - 1) ||\n\t\t\t!is_power_of_2(logfile_log_page_size)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile uses unsupported page size.\");\n\t\treturn false;\n\t}\n\t/*\n\t * We must be either at !pos (1st restart page) or at pos = system page\n\t * size (2nd restart page).\n\t */\n\tif (pos && pos != logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\");\n\t\treturn false;\n\t}\n\t/* We only know how to handle version 1.1. */\n\tif (sle16_to_cpu(rp->major_ver) != 1 ||\n\t\t\tsle16_to_cpu(rp->minor_ver) != 1) {\n\t\tntfs_error(vi->i_sb, \"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\", (int)sle16_to_cpu(rp->major_ver),\n\t\t\t\t(int)sle16_to_cpu(rp->minor_ver));\n\t\treturn false;\n\t}\n\t/*\n\t * If chkdsk has been run the restart page may not be protected by an\n\t * update sequence array.\n\t */\n\tif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\n\t\thave_usa = false;\n\t\tgoto skip_usa_checks;\n\t}\n\t/* Verify the size of the update sequence array. */\n\tusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\n\tif (usa_count != le16_to_cpu(rp->usa_count)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\");\n\t\treturn false;\n\t}\n\t/* Verify the position of the update sequence array. */\n\tusa_ofs = le16_to_cpu(rp->usa_ofs);\n\tusa_end = usa_ofs + usa_count * sizeof(u16);\n\tif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\n\t\t\tusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\");\n\t\treturn false;\n\t}\nskip_usa_checks:\n\t/*\n\t * Verify the position of the restart area.  It must be:\n\t *\t- aligned to 8-byte boundary,\n\t *\t- after the update sequence array, and\n\t *\t- within the system page size.\n\t */\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\n\t\t\tra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\n\t\t\tra_ofs > logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn\n\t * set.\n\t */\n\tif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"volume.h\"",
      "#include \"malloc.h\"",
      "#include \"logfile.h\"",
      "#include \"debug.h\"",
      "#include \"aops.h\"",
      "#include \"attrib.h\"",
      "#include <linux/log2.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/highmem.h>",
      "#include <linux/fs.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "rp->chkdsk_lsn"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_is_chkd_record",
          "args": [
            "rp->magic"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rp->restart_area_offset"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_is_chkd_record",
          "args": [
            "rp->magic"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\"",
            "(int)sle16_to_cpu(rp->major_ver)",
            "(int)sle16_to_cpu(rp->minor_ver)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"$LogFile uses unsupported page size.\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "logfile_log_page_size"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rp->log_page_size"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"volume.h\"\n#include \"malloc.h\"\n#include \"logfile.h\"\n#include \"debug.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/log2.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nstatic bool ntfs_check_restart_page_header(struct inode *vi,\n\t\tRESTART_PAGE_HEADER *rp, s64 pos)\n{\n\tu32 logfile_system_page_size, logfile_log_page_size;\n\tu16 ra_ofs, usa_count, usa_ofs, usa_end = 0;\n\tbool have_usa = true;\n\n\tntfs_debug(\"Entering.\");\n\t/*\n\t * If the system or log page sizes are smaller than the ntfs block size\n\t * or either is not a power of 2 we cannot handle this log file.\n\t */\n\tlogfile_system_page_size = le32_to_cpu(rp->system_page_size);\n\tlogfile_log_page_size = le32_to_cpu(rp->log_page_size);\n\tif (logfile_system_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_log_page_size < NTFS_BLOCK_SIZE ||\n\t\t\tlogfile_system_page_size &\n\t\t\t(logfile_system_page_size - 1) ||\n\t\t\t!is_power_of_2(logfile_log_page_size)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile uses unsupported page size.\");\n\t\treturn false;\n\t}\n\t/*\n\t * We must be either at !pos (1st restart page) or at pos = system page\n\t * size (2nd restart page).\n\t */\n\tif (pos && pos != logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"Found restart area in incorrect \"\n\t\t\t\t\"position in $LogFile.\");\n\t\treturn false;\n\t}\n\t/* We only know how to handle version 1.1. */\n\tif (sle16_to_cpu(rp->major_ver) != 1 ||\n\t\t\tsle16_to_cpu(rp->minor_ver) != 1) {\n\t\tntfs_error(vi->i_sb, \"$LogFile version %i.%i is not \"\n\t\t\t\t\"supported.  (This driver supports version \"\n\t\t\t\t\"1.1 only.)\", (int)sle16_to_cpu(rp->major_ver),\n\t\t\t\t(int)sle16_to_cpu(rp->minor_ver));\n\t\treturn false;\n\t}\n\t/*\n\t * If chkdsk has been run the restart page may not be protected by an\n\t * update sequence array.\n\t */\n\tif (ntfs_is_chkd_record(rp->magic) && !le16_to_cpu(rp->usa_count)) {\n\t\thave_usa = false;\n\t\tgoto skip_usa_checks;\n\t}\n\t/* Verify the size of the update sequence array. */\n\tusa_count = 1 + (logfile_system_page_size >> NTFS_BLOCK_SIZE_BITS);\n\tif (usa_count != le16_to_cpu(rp->usa_count)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array count.\");\n\t\treturn false;\n\t}\n\t/* Verify the position of the update sequence array. */\n\tusa_ofs = le16_to_cpu(rp->usa_ofs);\n\tusa_end = usa_ofs + usa_count * sizeof(u16);\n\tif (usa_ofs < sizeof(RESTART_PAGE_HEADER) ||\n\t\t\tusa_end > NTFS_BLOCK_SIZE - sizeof(u16)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent update sequence array offset.\");\n\t\treturn false;\n\t}\nskip_usa_checks:\n\t/*\n\t * Verify the position of the restart area.  It must be:\n\t *\t- aligned to 8-byte boundary,\n\t *\t- after the update sequence array, and\n\t *\t- within the system page size.\n\t */\n\tra_ofs = le16_to_cpu(rp->restart_area_offset);\n\tif (ra_ofs & 7 || (have_usa ? ra_ofs < usa_end :\n\t\t\tra_ofs < sizeof(RESTART_PAGE_HEADER)) ||\n\t\t\tra_ofs > logfile_system_page_size) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page specifies \"\n\t\t\t\t\"inconsistent restart area offset.\");\n\t\treturn false;\n\t}\n\t/*\n\t * Only restart pages modified by chkdsk are allowed to have chkdsk_lsn\n\t * set.\n\t */\n\tif (!ntfs_is_chkd_record(rp->magic) && sle64_to_cpu(rp->chkdsk_lsn)) {\n\t\tntfs_error(vi->i_sb, \"$LogFile restart page is not modified \"\n\t\t\t\t\"by chkdsk but a chkdsk LSN is specified.\");\n\t\treturn false;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn true;\n}"
  }
]