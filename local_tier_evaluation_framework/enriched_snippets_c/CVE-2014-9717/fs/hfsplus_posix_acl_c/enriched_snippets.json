[
  {
    "function_name": "hfsplus_init_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/posix_acl.c",
    "lines": "111-140",
    "snippet": "int hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_set_posix_acl",
          "args": [
            "inode",
            "acl",
            "ACL_TYPE_ACCESS"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_set_posix_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/posix_acl.c",
          "lines": "57-109",
          "snippet": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ACL_MOD",
            "\"[%s]: ino %lu, dir->ino %lu\\n\"",
            "__func__",
            "inode->i_ino",
            "dir->i_ino"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_init_posix_acl(struct inode *inode, struct inode *dir)\n{\n\tint err = 0;\n\tstruct posix_acl *default_acl, *acl;\n\n\thfs_dbg(ACL_MOD,\n\t\t\"[%s]: ino %lu, dir->ino %lu\\n\",\n\t\t__func__, inode->i_ino, dir->i_ino);\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn 0;\n\n\terr = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (err)\n\t\treturn err;\n\n\tif (default_acl) {\n\t\terr = hfsplus_set_posix_acl(inode, default_acl,\n\t\t\t\t\t    ACL_TYPE_DEFAULT);\n\t\tposix_acl_release(default_acl);\n\t}\n\n\tif (acl) {\n\t\tif (!err)\n\t\t\terr = hfsplus_set_posix_acl(inode, acl,\n\t\t\t\t\t\t    ACL_TYPE_ACCESS);\n\t\tposix_acl_release(acl);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_set_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/posix_acl.c",
    "lines": "57-109",
    "snippet": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_entry",
          "args": [
            "(hfsplus_attr_entry *)value"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "87-91",
          "snippet": "void hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_setxattr",
          "args": [
            "inode",
            "xattr_name",
            "value",
            "size",
            "0"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "263-397",
          "snippet": "int __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_to_xattr",
          "args": [
            "&init_user_ns",
            "acl",
            "value",
            "size"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_to_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "731-767",
          "snippet": "int\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\n\t\t   void *buffer, size_t size)\n{\n\tposix_acl_xattr_header *ext_acl = (posix_acl_xattr_header *)buffer;\n\tposix_acl_xattr_entry *ext_entry;\n\tint real_size, n;\n\n\treal_size = posix_acl_xattr_size(acl->a_count);\n\tif (!buffer)\n\t\treturn real_size;\n\tif (real_size > size)\n\t\treturn -ERANGE;\n\n\text_entry = ext_acl->a_entries;\n\text_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\n\n\tfor (n=0; n < acl->a_count; n++, ext_entry++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text_entry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\text_entry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch(acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\text_entry->e_id =\n\t\t\t\tcpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\text_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn real_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!value"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_alloc_attr_entry",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_alloc_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "82-85",
          "snippet": "hfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "size > HFSPLUS_MAX_INLINE_DATA_SIZE"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_xattr_size",
          "args": [
            "acl->a_count"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ACL_MOD",
            "\"[%s]: ino %lu\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n\nint hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\n\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn err;\n}"
  },
  {
    "function_name": "hfsplus_get_posix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/posix_acl.c",
    "lines": "13-55",
    "snippet": "struct posix_acl *hfsplus_get_posix_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *xattr_name;\n\tchar *value = NULL;\n\tssize_t size;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __hfsplus_getxattr(inode, xattr_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __hfsplus_getxattr(inode, xattr_name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(size);\n\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"hfsplus_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "58-68",
          "snippet": "void set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct posix_acl **p = acl_by_type(inode, type);\n\tstruct posix_acl *old;\n\tspin_lock(&inode->i_lock);\n\told = *p;\n\trcu_assign_pointer(*p, posix_acl_dup(acl));\n\tspin_unlock(&inode->i_lock);\n\tif (old != ACL_NOT_CACHED)\n\t\tposix_acl_release(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_destroy_attr_entry",
          "args": [
            "(hfsplus_attr_entry *)value"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_destroy_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "87-91",
          "snippet": "void hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nvoid hfsplus_destroy_attr_entry(hfsplus_attr_entry *entry)\n{\n\tif (entry)\n\t\tkmem_cache_free(hfsplus_attr_tree_cachep, entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "size"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_xattr",
          "args": [
            "&init_user_ns",
            "value",
            "size"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_from_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "662-725",
          "snippet": "struct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_from_xattr(struct user_namespace *user_ns,\n\t\t     const void *value, size_t size)\n{\n\tposix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n\tposix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n\tint count;\n\tstruct posix_acl *acl;\n\tstruct posix_acl_entry *acl_e;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(posix_acl_xattr_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tcount = posix_acl_xattr_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\t\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tacl_e = acl->a_entries;\n\t\n\tfor (end = entry + count; entry != end; acl_e++, entry++) {\n\t\tacl_e->e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl_e->e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch(acl_e->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\tcase ACL_MASK:\n\t\t\tcase ACL_OTHER:\n\t\t\t\tbreak;\n\n\t\t\tcase ACL_USER:\n\t\t\t\tacl_e->e_uid =\n\t\t\t\t\tmake_kuid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!uid_valid(acl_e->e_uid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP:\n\t\t\t\tacl_e->e_gid =\n\t\t\t\t\tmake_kgid(user_ns,\n\t\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\t\tif (!gid_valid(acl_e->e_gid))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hfsplus_getxattr",
          "args": [
            "inode",
            "xattr_name",
            "value",
            "size"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "477-561",
          "snippet": "ssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!value"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfsplus_alloc_attr_entry",
          "args": [],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "hfsplus_alloc_attr_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/attributes.c",
          "lines": "82-85",
          "snippet": "hfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *hfsplus_attr_tree_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n\nstatic struct kmem_cache *hfsplus_attr_tree_cachep;\n\nhfsplus_attr_entry *hfsplus_alloc_attr_entry(void)\n{\n\treturn kmem_cache_alloc(hfsplus_attr_tree_cachep, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "ACL_MOD",
            "\"[%s]: ino %lu\\n\"",
            "__func__",
            "inode->i_ino"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"hfsplus_fs.h\"\n\nstruct posix_acl *hfsplus_get_posix_acl(struct inode *inode, int type)\n{\n\tstruct posix_acl *acl;\n\tchar *xattr_name;\n\tchar *value = NULL;\n\tssize_t size;\n\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = POSIX_ACL_XATTR_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = POSIX_ACL_XATTR_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tsize = __hfsplus_getxattr(inode, xattr_name, NULL, 0);\n\n\tif (size > 0) {\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tsize = __hfsplus_getxattr(inode, xattr_name, value, size);\n\t}\n\n\tif (size > 0)\n\t\tacl = posix_acl_from_xattr(&init_user_ns, value, size);\n\telse if (size == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(size);\n\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
  }
]