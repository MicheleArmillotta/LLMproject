[
  {
    "function_name": "d_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "458-494",
    "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, node);",
          "args": [
            "e",
            "rn -"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1, \"but",
          "args": [
            "ound",
            "de's key \");\n\t\tubifs_du"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"looked",
          "args": [
            "for",
            "ey \");\n\t\tdbg_tnck"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d key in",
          "args": [
            "ode at LEB %d:%d\",\n\t\t\t  zbr->l",
            "r->offs);",
            "dbg_tnck"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y, &key",
          "args": [
            ")",
            "{",
            "bifs_"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode + UB",
          "args": [
            "F",
            "KEY_OFFSET, &key1);\n\tif",
            "!keys"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"key \")",
          "args": [
            "turn e"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, node, typ",
          "args": [
            ",",
            "br->",
            "n, z",
            "->lnum,",
            "z",
            "if (err)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_wbuf(wbuf, node,",
          "args": [
            "ype,",
            "br->",
            "n,",
            "zbr",
            "r->offs);",
            "else\n\t\ter"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(c, zbr->lnum",
          "args": [
            ";",
            "if (wbuf)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey);\n\tst",
          "args": [
            "u",
            "ub"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "406-446",
    "snippet": "znode *ubifs_load_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_zbranch *zbr,\n\t\t\t\t     struct ubifs_znode *parent, int iip)\n{\n\tint err;\n\tstruct ubifs_znode *znode;\n\n\tubifs_assert(!zbr->znode);\n\t/*\n\t * A slab cache is not presently used for znodes because the znode size\n\t * depends on the fanout which is stored in the superblock.\n\t */\n\tznode = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!znode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_znode(c, zbr->lnum, zbr->offs, zbr->len, znode);\n\tif (err)\n\t\tgoto out;\n\n\tatomic_long_inc(&c->clean_zn_cnt);\n\n\t/*\n\t * Increment the global clean znode counter as well. It is OK that\n\t * global and per-FS clean znode counters may be inconsistent for some\n\t * short time (because we might be preempted at this point), the global\n\t * one is only used in shrinker.\n\t */\n\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\n\tzbr->znode = znode;\n\tznode->parent = parent;\n\tznode->time = get_seconds();\n\tznode->iip = iip;\n\n\treturn znode;\n\nout:\n\tkfree(znode);\n\treturn ERR_PTR(err);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/**",
          "args": [
            "*"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn ER"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\tznode->i",
          "args": [],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&ubifs_clean",
          "args": [
            "zn_cnt);\n\n\tzbr->zno"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->clean_zn",
          "args": [
            "cnt);\n\n\t/*\n\t * I"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->lnum",
          "args": [
            "r->offs,",
            "r->len, z",
            "de);\n\tif",
            "err)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EM);",
          "args": [
            "rr = re"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_znode",
          "args": [
            "sz, GFP_NOFS);",
            "f (!znod"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dx_znode(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc.c",
          "lines": "140-167",
          "snippet": "s_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest",
          "includes": [
            "fs.h\"\n\n/*\n * Return",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/*\n * Return\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ns_clr_old_idx_znode(struct ubifs_info *c,\n\t\t\t\t struct ubifs_znode *znode)\n{\n\tint err;\n\n\tif (znode->parent) {\n\t\tstruct ubifs_zbranch *zbr;\n\n\t\tzbr = &znode->parent->zbranch[znode->iip];\n\t\tif (zbr->len) {\n\t\t\terr = insert_old_idx(c, zbr->lnum, zbr->offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tzbr->lnum = 0;\n\t\t\tzbr->offs = 0;\n\t\t\tzbr->len = 0;\n\t\t}\n\t} else\n\t\tif (c->zroot.len) {\n\t\t\terr = insert_old_idx(c, c->zroot.lnum, c->zroot.offs);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tc->zroot.lnum = 0;\n\t\t\tc->zroot.offs = 0;\n\t\t\tc->zroot.len = 0;\n\t\t}\n\treturn 0;\n}\n\n/**\n * dest"
        }
      },
      {
        "call_info": {
          "callee": "!zbr->znode)",
          "args": [
            "/*\n\t * A"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_load_znode(struct ubifs_info *c,\n\t\t\t\t     struct ubifs_zbranch *zbr,\n\t\t\t\t     struct ubifs_znode *parent, int iip)\n{\n\tint err;\n\tstruct ubifs_znode *znode;\n\n\tubifs_assert(!zbr->znode);\n\t/*\n\t * A slab cache is not presently used for znodes because the znode size\n\t * depends on the fanout which is stored in the superblock.\n\t */\n\tznode = kzalloc(c->max_znode_sz, GFP_NOFS);\n\tif (!znode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = read_znode(c, zbr->lnum, zbr->offs, zbr->len, znode);\n\tif (err)\n\t\tgoto out;\n\n\tatomic_long_inc(&c->clean_zn_cnt);\n\n\t/*\n\t * Increment the global clean znode counter as well. It is OK that\n\t * global and per-FS clean znode counters may be inconsistent for some\n\t * short time (because we might be preempted at this point), the global\n\t * one is only used in shrinker.\n\t */\n\tatomic_long_inc(&ubifs_clean_zn_cnt);\n\n\tzbr->znode = znode;\n\tznode->parent = parent;\n\tznode->time = get_seconds();\n\tznode->iip = iip;\n\n\treturn znode;\n\nout:\n\tkfree(znode);\n\treturn ERR_PTR(err);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "273-393",
    "snippet": "ad_znode(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t      struct ubifs_znode *znode)\n{\n\tint i, err, type, cmp;\n\tstruct ubifs_idx_node *idx;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err < 0) {\n\t\tkfree(idx);\n\t\treturn err;\n\t}\n\n\tznode->child_cnt = le16_to_cpu(idx->child_cnt);\n\tznode->level = le16_to_cpu(idx->level);\n\n\tdbg_tnc(\"LEB %d:%d, level %d, %d branch\",\n\t\tlnum, offs, znode->level, znode->child_cnt);\n\n\tif (znode->child_cnt > c->fanout || znode->level > UBIFS_MAX_LEVELS) {\n\t\tubifs_err(\"current fanout %d, branch count %d\",\n\t\t\t  c->fanout, znode->child_cnt);\n\t\tubifs_err(\"max levels %d, znode level %d\",\n\t\t\t  UBIFS_MAX_LEVELS, znode->level);\n\t\terr = 1;\n\t\tgoto out_dump;\n\t}\n\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tconst struct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_read(c, &br->key, &zbr->key);\n\t\tzbr->lnum = le32_to_cpu(br->lnum);\n\t\tzbr->offs = le32_to_cpu(br->offs);\n\t\tzbr->len  = le32_to_cpu(br->len);\n\t\tzbr->znode = NULL;\n\n\t\t/* Validate branch */\n\n\t\tif (zbr->lnum < c->main_first ||\n\t\t    zbr->lnum >= c->leb_cnt || zbr->offs < 0 ||\n\t\t    zbr->offs + zbr->len > c->leb_size || zbr->offs & 7) {\n\t\t\tubifs_err(\"bad branch %d\", i);\n\t\t\terr = 2;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tswitch (key_type(c, &zbr->key)) {\n\t\tcase UBIFS_INO_KEY:\n\t\tcase UBIFS_DATA_KEY:\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"bad key type at slot %d: %d\",\n\t\t\t\t  i, key_type(c, &zbr->key));\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (znode->level)\n\t\t\tcontinue;\n\n\t\ttype = key_type(c, &zbr->key);\n\t\tif (c->ranges[type].max_len == 0) {\n\t\t\tif (zbr->len != c->ranges[type].len) {\n\t\t\t\tubifs_err(\"bad target node (type %d) length (%d)\",\n\t\t\t\t\t  type, zbr->len);\n\t\t\t\tubifs_err(\"have to be %d\", c->ranges[type].len);\n\t\t\t\terr = 4;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else if (zbr->len < c->ranges[type].min_len ||\n\t\t\t   zbr->len > c->ranges[type].max_len) {\n\t\t\tubifs_err(\"bad target node (type %d) length (%d)\",\n\t\t\t\t  type, zbr->len);\n\t\t\tubifs_err(\"have to be in range of %d-%d\",\n\t\t\t\t  c->ranges[type].min_len,\n\t\t\t\t  c->ranges[type].max_len);\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\t/*\n\t * Ensure that the next key is greater or equivalent to the\n\t * previous one.\n\t */\n\tfor (i = 0; i < znode->child_cnt - 1; i++) {\n\t\tconst union ubifs_key *key1, *key2;\n\n\t\tkey1 = &znode->zbranch[i].key;\n\t\tkey2 = &znode->zbranch[i + 1].key;\n\n\t\tcmp = keys_cmp(c, key1, key2);\n\t\tif (cmp > 0) {\n\t\t\tubifs_err(\"bad key order (keys %d and %d)\", i, i + 1);\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t} else if (cmp == 0 && !is_hash_key(c, key1)) {\n\t\t\t/* These can only be keys with colliding hash */\n\t\t\tubifs_err(\"keys %d and %d are not hashed but equivalent\",\n\t\t\t\t  i, i + 1);\n\t\t\terr = 7;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tkfree(idx);\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"bad indexing node at LEB %d:%d, error %d\", lnum, offs, err);\n\tubifs_dump_node(c, idx);\n\tkfree(idx);\n\treturn -EINVAL;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "-E"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "de(c, idx);\n\tkf",
          "args": [
            "e",
            "idx"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d indexin",
          "args": [
            "node at LEB %d:%d, error %d\", lnum, offs,",
            "rr);",
            "ubif",
            "dum"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ys %d and",
          "args": [
            "%d are not hashed but equivalent\",\n\t\t\t\t  i, i",
            "r = 7"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", key1)) {",
          "args": [
            "* Th"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d key ord",
          "args": [
            "r (keys %d and %d)\", i, i + 1);",
            "r = 6"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey1, key",
          "args": [
            ")",
            "if",
            "cmp"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve to be",
          "args": [
            "n range of %d-%d\",\n\t\t\t\t  c->ra",
            "e].min_len,\n\t\t\t\t  c->ra",
            "e].max_len);\n\t\t\terr = 5"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d target",
          "args": [
            "ode (type %d) length (%d)\",\n\t\t\t\t  type,",
            "n);",
            "ubifs_e"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve to be",
          "args": [
            "d\", c->ranges[t",
            "e].len);\n\t\t\t\terr ="
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d target",
          "args": [
            "ode (type %d) length (%d)\",\n\t\t\t\t\t  type",
            "n);",
            "ubifs_"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->key",
          "args": [
            ";",
            "if (c->r"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d key typ",
          "args": [
            "at slot %d: %d\",\n\t\t\t\t  i, ke",
            ",",
            "zbr->key));\n\t\t\terr = 3"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->key",
          "args": [
            ")",
            "err ="
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zbr->key",
          "args": [
            ")",
            "case U"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d branch",
          "args": [
            "d\", i);\n\t\t\terr",
            "2"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->len);",
          "args": [
            "br->zno"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->offs);",
          "args": [
            "zbr->len"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r->lnum);",
          "args": [
            "zbr->off"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "br->key,",
          "args": [
            "&",
            "r->key);",
            "zbr->lnu"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nch(c, idx, i);",
          "args": [
            "ruc",
            "u"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x levels",
          "args": [
            "d, znode level %d\",\n\t\t\t  UBIFS_",
            "ELS, znode->leve",
            ";\n\t\terr = 1;"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrent fan",
          "args": [
            "ut %d, branch count %d\",\n\t\t\t  c->fan",
            "ode->chil",
            "cnt);\n\t\tubifs_er"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d:%d,",
          "args": [
            "evel %d, %d branch\",\n\t\tlnum, off",
            "node",
            "leve",
            "znode->chil",
            "cnt);\n\n\tif (znod"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->level);",
          "args": [
            "dbg_tnc("
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dx->child_c",
          "args": [
            "t);\n\tznode->le"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, idx, UBIF",
          "args": [
            "_",
            "X_N",
            "E, len, lnum,",
            "fs)",
            "if",
            "rr <"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x_idx_n",
          "args": [
            "de_sz, GFP_NOFS);",
            "f (!idx)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nad_znode(struct ubifs_info *c, int lnum, int offs, int len,\n\t\t      struct ubifs_znode *znode)\n{\n\tint i, err, type, cmp;\n\tstruct ubifs_idx_node *idx;\n\n\tidx = kmalloc(c->max_idx_node_sz, GFP_NOFS);\n\tif (!idx)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_read_node(c, idx, UBIFS_IDX_NODE, len, lnum, offs);\n\tif (err < 0) {\n\t\tkfree(idx);\n\t\treturn err;\n\t}\n\n\tznode->child_cnt = le16_to_cpu(idx->child_cnt);\n\tznode->level = le16_to_cpu(idx->level);\n\n\tdbg_tnc(\"LEB %d:%d, level %d, %d branch\",\n\t\tlnum, offs, znode->level, znode->child_cnt);\n\n\tif (znode->child_cnt > c->fanout || znode->level > UBIFS_MAX_LEVELS) {\n\t\tubifs_err(\"current fanout %d, branch count %d\",\n\t\t\t  c->fanout, znode->child_cnt);\n\t\tubifs_err(\"max levels %d, znode level %d\",\n\t\t\t  UBIFS_MAX_LEVELS, znode->level);\n\t\terr = 1;\n\t\tgoto out_dump;\n\t}\n\n\tfor (i = 0; i < znode->child_cnt; i++) {\n\t\tconst struct ubifs_branch *br = ubifs_idx_branch(c, idx, i);\n\t\tstruct ubifs_zbranch *zbr = &znode->zbranch[i];\n\n\t\tkey_read(c, &br->key, &zbr->key);\n\t\tzbr->lnum = le32_to_cpu(br->lnum);\n\t\tzbr->offs = le32_to_cpu(br->offs);\n\t\tzbr->len  = le32_to_cpu(br->len);\n\t\tzbr->znode = NULL;\n\n\t\t/* Validate branch */\n\n\t\tif (zbr->lnum < c->main_first ||\n\t\t    zbr->lnum >= c->leb_cnt || zbr->offs < 0 ||\n\t\t    zbr->offs + zbr->len > c->leb_size || zbr->offs & 7) {\n\t\t\tubifs_err(\"bad branch %d\", i);\n\t\t\terr = 2;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tswitch (key_type(c, &zbr->key)) {\n\t\tcase UBIFS_INO_KEY:\n\t\tcase UBIFS_DATA_KEY:\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tubifs_err(\"bad key type at slot %d: %d\",\n\t\t\t\t  i, key_type(c, &zbr->key));\n\t\t\terr = 3;\n\t\t\tgoto out_dump;\n\t\t}\n\n\t\tif (znode->level)\n\t\t\tcontinue;\n\n\t\ttype = key_type(c, &zbr->key);\n\t\tif (c->ranges[type].max_len == 0) {\n\t\t\tif (zbr->len != c->ranges[type].len) {\n\t\t\t\tubifs_err(\"bad target node (type %d) length (%d)\",\n\t\t\t\t\t  type, zbr->len);\n\t\t\t\tubifs_err(\"have to be %d\", c->ranges[type].len);\n\t\t\t\terr = 4;\n\t\t\t\tgoto out_dump;\n\t\t\t}\n\t\t} else if (zbr->len < c->ranges[type].min_len ||\n\t\t\t   zbr->len > c->ranges[type].max_len) {\n\t\t\tubifs_err(\"bad target node (type %d) length (%d)\",\n\t\t\t\t  type, zbr->len);\n\t\t\tubifs_err(\"have to be in range of %d-%d\",\n\t\t\t\t  c->ranges[type].min_len,\n\t\t\t\t  c->ranges[type].max_len);\n\t\t\terr = 5;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\t/*\n\t * Ensure that the next key is greater or equivalent to the\n\t * previous one.\n\t */\n\tfor (i = 0; i < znode->child_cnt - 1; i++) {\n\t\tconst union ubifs_key *key1, *key2;\n\n\t\tkey1 = &znode->zbranch[i].key;\n\t\tkey2 = &znode->zbranch[i + 1].key;\n\n\t\tcmp = keys_cmp(c, key1, key2);\n\t\tif (cmp > 0) {\n\t\t\tubifs_err(\"bad key order (keys %d and %d)\", i, i + 1);\n\t\t\terr = 6;\n\t\t\tgoto out_dump;\n\t\t} else if (cmp == 0 && !is_hash_key(c, key1)) {\n\t\t\t/* These can only be keys with colliding hash */\n\t\t\tubifs_err(\"keys %d and %d are not hashed but equivalent\",\n\t\t\t\t  i, i + 1);\n\t\t\terr = 7;\n\t\t\tgoto out_dump;\n\t\t}\n\t}\n\n\tkfree(idx);\n\treturn 0;\n\nout_dump:\n\tubifs_err(\"bad indexing node at LEB %d:%d, error %d\", lnum, offs, err);\n\tubifs_dump_node(c, idx);\n\tkfree(idx);\n\treturn -EINVAL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_tnc_subtree(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "228-257",
    "snippet": "stroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torder_next(zn);\n\t}\n}\n\n/",
          "args": [
            "*"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "y(zn))\n\t\t\t\tcle",
          "args": [
            "n_"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anch[",
          "args": [
            "].znode);\n\t\t}\n\n\t\tif"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t\t\tkfree(",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(zn->zbranch[",
          "args": [
            "].znode))\n\t\t\t\tclean_"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zn);\n\twhile",
          "args": [
            "1)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torder_first(znode);\n\tlon",
          "args": [
            "clea"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nstroy_tnc_subtree(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn = ubifs_tnc_postorder_first(znode);\n\tlong clean_freed = 0;\n\tint n;\n\n\tubifs_assert(zn);\n\twhile (1) {\n\t\tfor (n = 0; n < zn->child_cnt; n++) {\n\t\t\tif (!zn->zbranch[n].znode)\n\t\t\t\tcontinue;\n\n\t\t\tif (zn->level > 0 &&\n\t\t\t    !ubifs_zn_dirty(zn->zbranch[n].znode))\n\t\t\t\tclean_freed += 1;\n\n\t\t\tcond_resched();\n\t\t\tkfree(zn->zbranch[n].znode);\n\t\t}\n\n\t\tif (zn == znode) {\n\t\t\tif (!ubifs_zn_dirty(zn))\n\t\t\t\tclean_freed += 1;\n\t\t\tkfree(zn);\n\t\t\treturn clean_freed;\n\t\t}\n\n\t\tzn = ubifs_tnc_postorder_next(zn);\n\t}\n}\n\n/**\n * read"
  },
  {
    "function_name": "torder_next(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "203-219",
    "snippet": "znode *ubifs_tnc_postorder_next(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(znode);\n\tif (unlikely(!znode->parent))\n\t\treturn NULL;\n\n\t/* Switch to the next index in the parent */\n\tzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\n\tif (!zn)\n\t\t/* This is in fact the last child, return parent */\n\t\treturn znode->parent;\n\n\t/* Go to the first znode in this new subtree */\n\treturn ubifs_tnc_postorder_first(zn);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torder_first(zn);\n}\n\n/**",
          "args": [
            "*"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_child(znode->paren",
          "args": [
            ", znode->iip",
            "1);\n\tif (!zn)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de->pare",
          "args": [
            "t))\n\t\treturn N"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);\n\tif",
          "args": [
            "unlik"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_tnc_postorder_next(struct ubifs_znode *znode)\n{\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(znode);\n\tif (unlikely(!znode->parent))\n\t\treturn NULL;\n\n\t/* Switch to the next index in the parent */\n\tzn = ubifs_tnc_find_child(znode->parent, znode->iip + 1);\n\tif (!zn)\n\t\t/* This is in fact the last child, return parent */\n\t\treturn znode->parent;\n\n\t/* Go to the first znode in this new subtree */\n\treturn ubifs_tnc_postorder_first(zn);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "torder_first(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "179-194",
    "snippet": "znode *ubifs_tnc_postorder_first(struct ubifs_znode *znode)\n{\n\tif (unlikely(!znode))\n\t\treturn NULL;\n\n\twhile (znode->level > 0) {\n\t\tstruct ubifs_znode *child;\n\n\t\tchild = ubifs_tnc_find_child(znode, 0);\n\t\tif (!child)\n\t\t\treturn znode;\n\t\tznode = child;\n\t}\n\n\treturn znode;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_child(znode, 0);",
          "args": [
            "if (!",
            "i"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de))\n\t\tr",
          "args": [
            "turn N"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_tnc_postorder_first(struct ubifs_znode *znode)\n{\n\tif (unlikely(!znode))\n\t\treturn NULL;\n\n\twhile (znode->level > 0) {\n\t\tstruct ubifs_znode *child;\n\n\t\tchild = ubifs_tnc_find_child(znode, 0);\n\t\tif (!child)\n\t\t\treturn znode;\n\t\tznode = child;\n\t}\n\n\treturn znode;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "zbranch(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "135-170",
    "snippet": "rch_zbranch(const struct ubifs_info *c,\n\t\t\t const struct ubifs_znode *znode,\n\t\t\t const union ubifs_key *key, int *n)\n{\n\tint beg = 0, end = znode->child_cnt, uninitialized_var(mid);\n\tint uninitialized_var(cmp);\n\tconst struct ubifs_zbranch *zbr = &znode->zbranch[0];\n\n\tubifs_assert(end > beg);\n\n\twhile (end > beg) {\n\t\tmid = (beg + end) >> 1;\n\t\tcmp = keys_cmp(c, key, &zbr[mid].key);\n\t\tif (cmp > 0)\n\t\t\tbeg = mid + 1;\n\t\telse if (cmp < 0)\n\t\t\tend = mid;\n\t\telse {\n\t\t\t*n = mid;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t*n = end - 1;\n\n\t/* The insert point is after *n */\n\tubifs_assert(*n >= -1 && *n < znode->child_cnt);\n\tif (*n == -1)\n\t\tubifs_assert(keys_cmp(c, key, &zbr[0].key) < 0);\n\telse\n\t\tubifs_assert(keys_cmp(c, key, &zbr[*n].key) > 0);\n\tif (*n + 1 < znode->child_cnt)\n\t\tubifs_assert(keys_cmp(c, key, &zbr[*n + 1].key) < 0);\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keys_cmp(c,",
          "args": [
            "ey, &zbr[*n + 1].key) < 0);\n\n\treturn 0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "*",
            "+ 1",
            "key) < 0);\n\n\tret"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keys_cmp(c,",
          "args": [
            "ey, &zbr[*n].key) > 0);\n\tif (*n +"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "*",
            ".ke",
            "> 0);\n\tif ("
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keys_cmp(c,",
          "args": [
            "ey, &zbr[0].key) < 0);\n\telse\n\t\tub"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "0",
            "key",
            "< 0);\n\telse"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n >= -1 &&",
          "args": [
            "n < znode->child_cnt);\n\tif (*n =="
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey, &zbr",
          "args": [
            "m",
            "].k",
            ");\n\t\tif (cmp"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end > beg);",
          "args": [
            "while (e"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nrch_zbranch(const struct ubifs_info *c,\n\t\t\t const struct ubifs_znode *znode,\n\t\t\t const union ubifs_key *key, int *n)\n{\n\tint beg = 0, end = znode->child_cnt, uninitialized_var(mid);\n\tint uninitialized_var(cmp);\n\tconst struct ubifs_zbranch *zbr = &znode->zbranch[0];\n\n\tubifs_assert(end > beg);\n\n\twhile (end > beg) {\n\t\tmid = (beg + end) >> 1;\n\t\tcmp = keys_cmp(c, key, &zbr[mid].key);\n\t\tif (cmp > 0)\n\t\t\tbeg = mid + 1;\n\t\telse if (cmp < 0)\n\t\t\tend = mid;\n\t\telse {\n\t\t\t*n = mid;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t*n = end - 1;\n\n\t/* The insert point is after *n */\n\tubifs_assert(*n >= -1 && *n < znode->child_cnt);\n\tif (*n == -1)\n\t\tubifs_assert(keys_cmp(c, key, &zbr[0].key) < 0);\n\telse\n\t\tubifs_assert(keys_cmp(c, key, &zbr[*n].key) > 0);\n\tif (*n + 1 < znode->child_cnt)\n\t\tubifs_assert(keys_cmp(c, key, &zbr[*n + 1].key) < 0);\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "elorder_next(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
    "lines": "40-118",
    "snippet": "znode *ubifs_tnc_levelorder_next(struct ubifs_znode *zr,\n\t\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level, iip, level_search = 0;\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(zr);\n\n\tif (unlikely(!znode))\n\t\treturn zr;\n\n\tif (unlikely(znode == zr)) {\n\t\tif (znode->level == 0)\n\t\t\treturn NULL;\n\t\treturn ubifs_tnc_find_child(zr, 0);\n\t}\n\n\tlevel = znode->level;\n\n\tiip = znode->iip;\n\twhile (1) {\n\t\tubifs_assert(znode->level <= zr->level);\n\n\t\t/*\n\t\t * First walk up until there is a znode with next branch to\n\t\t * look at.\n\t\t */\n\t\twhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\n\t\t\tznode = znode->parent;\n\t\t\tiip = znode->iip;\n\t\t}\n\n\t\tif (unlikely(znode->parent == zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t/* This level is done, switch to the lower one */\n\t\t\tlevel -= 1;\n\t\t\tif (level_search || level < 0)\n\t\t\t\t/*\n\t\t\t\t * We were already looking for znode at lower\n\t\t\t\t * level ('level_search'). As we are here\n\t\t\t\t * again, it just does not exist. Or all levels\n\t\t\t\t * were finished ('level < 0').\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\n\t\t\tlevel_search = 1;\n\t\t\tiip = -1;\n\t\t\tznode = ubifs_tnc_find_child(zr, 0);\n\t\t\tubifs_assert(znode);\n\t\t}\n\n\t\t/* Switch to the next index */\n\t\tzn = ubifs_tnc_find_child(znode->parent, iip + 1);\n\t\tif (!zn) {\n\t\t\t/* No more children to look at, we have walk up */\n\t\t\tiip = znode->parent->child_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Walk back down to the level we came from ('level') */\n\t\twhile (zn->level != level) {\n\t\t\tznode = zn;\n\t\t\tzn = ubifs_tnc_find_child(zn, 0);\n\t\t\tif (!zn) {\n\t\t\t\t/*\n\t\t\t\t * This path is not too deep so it does not\n\t\t\t\t * reach 'level'. Try next path.\n\t\t\t\t */\n\t\t\t\tiip = znode->iip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zn) {\n\t\t\tubifs_assert(zn->level >= 0);\n\t\t\treturn zn;\n\t\t}\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * ubifs"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zn->level >=",
          "args": [
            "0);\n\t\t\treturn"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_child(zn, 0);\n\t\t\ti",
          "args": [
            "(",
            "n"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_child(znode->paren",
          "args": [
            ", iip + 1);",
            "f (!zn)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode);\n\t\t}",
          "args": [
            "/*"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_child(zr, 0);\n\t\t\tu",
          "args": [
            "if",
            "a"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->paren",
          "args": [
            "== zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t/* Th"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "znode->level",
          "args": [
            "<= zr->level);\n\n\t\t/*\n\t\t *"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_child(zr, 0);\n\t}",
          "args": [
            "le",
            "l"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e == zr)",
          "args": [
            "{\n\t\tif (zn"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de))\n\t\tr",
          "args": [
            "turn z"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zr);\n\n\tif (u",
          "args": [
            "li"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\nznode *ubifs_tnc_levelorder_next(struct ubifs_znode *zr,\n\t\t\t\t\t      struct ubifs_znode *znode)\n{\n\tint level, iip, level_search = 0;\n\tstruct ubifs_znode *zn;\n\n\tubifs_assert(zr);\n\n\tif (unlikely(!znode))\n\t\treturn zr;\n\n\tif (unlikely(znode == zr)) {\n\t\tif (znode->level == 0)\n\t\t\treturn NULL;\n\t\treturn ubifs_tnc_find_child(zr, 0);\n\t}\n\n\tlevel = znode->level;\n\n\tiip = znode->iip;\n\twhile (1) {\n\t\tubifs_assert(znode->level <= zr->level);\n\n\t\t/*\n\t\t * First walk up until there is a znode with next branch to\n\t\t * look at.\n\t\t */\n\t\twhile (znode->parent != zr && iip >= znode->parent->child_cnt) {\n\t\t\tznode = znode->parent;\n\t\t\tiip = znode->iip;\n\t\t}\n\n\t\tif (unlikely(znode->parent == zr &&\n\t\t\t     iip >= znode->parent->child_cnt)) {\n\t\t\t/* This level is done, switch to the lower one */\n\t\t\tlevel -= 1;\n\t\t\tif (level_search || level < 0)\n\t\t\t\t/*\n\t\t\t\t * We were already looking for znode at lower\n\t\t\t\t * level ('level_search'). As we are here\n\t\t\t\t * again, it just does not exist. Or all levels\n\t\t\t\t * were finished ('level < 0').\n\t\t\t\t */\n\t\t\t\treturn NULL;\n\n\t\t\tlevel_search = 1;\n\t\t\tiip = -1;\n\t\t\tznode = ubifs_tnc_find_child(zr, 0);\n\t\t\tubifs_assert(znode);\n\t\t}\n\n\t\t/* Switch to the next index */\n\t\tzn = ubifs_tnc_find_child(znode->parent, iip + 1);\n\t\tif (!zn) {\n\t\t\t/* No more children to look at, we have walk up */\n\t\t\tiip = znode->parent->child_cnt;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Walk back down to the level we came from ('level') */\n\t\twhile (zn->level != level) {\n\t\t\tznode = zn;\n\t\t\tzn = ubifs_tnc_find_child(zn, 0);\n\t\t\tif (!zn) {\n\t\t\t\t/*\n\t\t\t\t * This path is not too deep so it does not\n\t\t\t\t * reach 'level'. Try next path.\n\t\t\t\t */\n\t\t\t\tiip = znode->iip;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (zn) {\n\t\t\tubifs_assert(zn->level >= 0);\n\t\t\treturn zn;\n\t\t}\n\t}\n}\n\n/**\n * ubif"
  }
]