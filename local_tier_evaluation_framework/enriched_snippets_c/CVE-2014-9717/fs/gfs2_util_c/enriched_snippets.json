[
  {
    "function_name": "gfs2_io_error_bh_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "253-264",
    "snippet": "int gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t       const char *function, char *file, unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: I/O error\\n\"\n\t\t\t      \"  block = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr,\n\t\t\t      function, file, line);\n\treturn rv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: I/O error\\n\"\n\t\t\t      \"  block = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "function",
            "file",
            "line"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_io_error_bh_i(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t       const char *function, char *file, unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: I/O error\\n\"\n\t\t\t      \"  block = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr,\n\t\t\t      function, file, line);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_io_error_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "236-245",
    "snippet": "int gfs2_io_error_i(struct gfs2_sbd *sdp, const char *function, char *file,\n\t\t    unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: I/O error\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      function, file, line);\n\treturn rv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: I/O error\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "function",
            "file",
            "line"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_io_error_i(struct gfs2_sbd *sdp, const char *function, char *file,\n\t\t    unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: I/O error\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      function, file, line);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_metatype_check_ii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "216-228",
    "snippet": "int gfs2_metatype_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t\t   u16 type, u16 t, const char *function,\n\t\t\t   char *file, unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (type: exp=%u, found=%u)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr, type, t,\n\t\t\t      function, file, line);\n\treturn (me) ? -1 : -2;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (type: exp=%u, found=%u)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "type",
            "t",
            "function",
            "file",
            "line"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_metatype_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t\t   u16 type, u16 t, const char *function,\n\t\t\t   char *file, unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (type: exp=%u, found=%u)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr, type, t,\n\t\t\t      function, file, line);\n\treturn (me) ? -1 : -2;\n}"
  },
  {
    "function_name": "gfs2_meta_check_ii",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "196-208",
    "snippet": "int gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t       const char *type, const char *function, char *file,\n\t\t       unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (%s)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr, type,\n\t\t\t      function, file, line);\n\treturn (me) ? -1 : -2;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (%s)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "(unsigned long long)bh->b_blocknr",
            "type",
            "function",
            "file",
            "line"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_meta_check_ii(struct gfs2_sbd *sdp, struct buffer_head *bh,\n\t\t       const char *type, const char *function, char *file,\n\t\t       unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: invalid metadata block\\n\"\n\t\t\t      \"  bh = %llu (%s)\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)bh->b_blocknr, type,\n\t\t\t      function, file, line);\n\treturn (me) ? -1 : -2;\n}"
  },
  {
    "function_name": "gfs2_consist_rgrpd_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "176-188",
    "snippet": "int gfs2_consist_rgrpd_i(struct gfs2_rgrpd *rgd, int cluster_wide,\n\t\t\t const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  RG = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)rgd->rd_addr,\n\t\t\t      function, file, line);\n\treturn rv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  RG = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "(unsigned long long)rgd->rd_addr",
            "function",
            "file",
            "line"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_consist_rgrpd_i(struct gfs2_rgrpd *rgd, int cluster_wide,\n\t\t\t const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = rgd->rd_sbd;\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  RG = %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)rgd->rd_addr,\n\t\t\t      function, file, line);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_consist_inode_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "155-168",
    "snippet": "int gfs2_consist_inode_i(struct gfs2_inode *ip, int cluster_wide,\n\t\t\t const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  inode = %llu %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)ip->i_no_formal_ino,\n\t\t\t      (unsigned long long)ip->i_no_addr,\n\t\t\t      function, file, line);\n\treturn rv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  inode = %llu %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\"",
            "(unsigned long long)ip->i_no_formal_ino",
            "(unsigned long long)ip->i_no_addr",
            "function",
            "file",
            "line"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFS2_SB",
          "args": [
            "&ip->i_inode"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "GFS2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "413-416",
          "snippet": "static inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline struct gfs2_sbd *GFS2_SB(const struct inode *inode)\n{\n\treturn inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_consist_inode_i(struct gfs2_inode *ip, int cluster_wide,\n\t\t\t const char *function, char *file, unsigned int line)\n{\n\tstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error\\n\"\n\t\t\t      \"  inode = %llu %llu\\n\"\n\t\t\t      \"  function = %s, file = %s, line = %u\\n\",\n\t\t\t      (unsigned long long)ip->i_no_formal_ino,\n\t\t\t      (unsigned long long)ip->i_no_addr,\n\t\t\t      function, file, line);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_consist_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "139-147",
    "snippet": "int gfs2_consist_i(struct gfs2_sbd *sdp, int cluster_wide, const char *function,\n\t\t   char *file, unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error - function = %s, file = %s, line = %u\\n\",\n\t\t\t      function, file, line);\n\treturn rv;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: filesystem consistency error - function = %s, file = %s, line = %u\\n\"",
            "function",
            "file",
            "line"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_consist_i(struct gfs2_sbd *sdp, int cluster_wide, const char *function,\n\t\t   char *file, unsigned int line)\n{\n\tint rv;\n\trv = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: filesystem consistency error - function = %s, file = %s, line = %u\\n\",\n\t\t\t      function, file, line);\n\treturn rv;\n}"
  },
  {
    "function_name": "gfs2_assert_warn_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "105-131",
    "snippet": "int gfs2_assert_warn_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t       const char *function, char *file, unsigned int line)\n{\n\tif (time_before(jiffies,\n\t\t\tsdp->sd_last_warning +\n\t\t\tgfs2_tune_get(sdp, gt_complain_secs) * HZ))\n\t\treturn -2;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW)\n\t\tfs_warn(sdp, \"warning: assertion \\\"%s\\\" failed at function = %s, file = %s, line = %u\\n\",\n\t\t\tassertion, function, file, line);\n\n\tif (sdp->sd_args.ar_debug)\n\t\tBUG();\n\telse\n\t\tdump_stack();\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: warning: assertion \\\"%s\\\" failed\\n\"\n\t\t      \"GFS2: fsid=%s:   function = %s, file = %s, line = %u\\n\",\n\t\t      sdp->sd_fsname, assertion,\n\t\t      sdp->sd_fsname, function, file, line);\n\n\tsdp->sd_last_warning = jiffies;\n\n\treturn -1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"GFS2: fsid=%s: warning: assertion \\\"%s\\\" failed\\n\"\n\t\t      \"GFS2: fsid=%s:   function = %s, file = %s, line = %u\\n\"",
            "sdp->sd_fsname",
            "assertion",
            "sdp->sd_fsname",
            "function",
            "file",
            "line"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_warn",
          "args": [
            "sdp",
            "\"warning: assertion \\\"%s\\\" failed at function = %s, file = %s, line = %u\\n\"",
            "assertion",
            "function",
            "file",
            "line"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "befs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "40-51",
          "snippet": "void\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_warning(const struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "sdp->sd_last_warning +\n\t\t\tgfs2_tune_get(sdp, gt_complain_secs) * HZ"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_tune_get",
          "args": [
            "sdp",
            "gt_complain_secs"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_tune_get_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.h",
          "lines": "155-163",
          "snippet": "static inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}",
          "includes": [
            "#include \"incore.h\"",
            "#include <linux/mempool.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"incore.h\"\n#include <linux/mempool.h>\n\nstatic inline unsigned int gfs2_tune_get_i(struct gfs2_tune *gt,\n\t\t\t\t\t   unsigned int *p)\n{\n\tunsigned int x;\n\tspin_lock(&gt->gt_spin);\n\tx = *p;\n\tspin_unlock(&gt->gt_spin);\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_assert_warn_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t       const char *function, char *file, unsigned int line)\n{\n\tif (time_before(jiffies,\n\t\t\tsdp->sd_last_warning +\n\t\t\tgfs2_tune_get(sdp, gt_complain_secs) * HZ))\n\t\treturn -2;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW)\n\t\tfs_warn(sdp, \"warning: assertion \\\"%s\\\" failed at function = %s, file = %s, line = %u\\n\",\n\t\t\tassertion, function, file, line);\n\n\tif (sdp->sd_args.ar_debug)\n\t\tBUG();\n\telse\n\t\tdump_stack();\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: warning: assertion \\\"%s\\\" failed\\n\"\n\t\t      \"GFS2: fsid=%s:   function = %s, file = %s, line = %u\\n\",\n\t\t      sdp->sd_fsname, assertion,\n\t\t      sdp->sd_fsname, function, file, line);\n\n\tsdp->sd_last_warning = jiffies;\n\n\treturn -1;\n}"
  },
  {
    "function_name": "gfs2_assert_withdraw_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "87-97",
    "snippet": "int gfs2_assert_withdraw_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t\t   const char *function, char *file, unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: assertion \\\"%s\\\" failed\\n\"\n\t\t\t      \"   function = %s, file = %s, line = %u\\n\",\n\t\t\t      assertion, function, file, line);\n\tdump_stack();\n\treturn (me) ? -1 : -2;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_lm_withdraw",
          "args": [
            "sdp",
            "\"fatal: assertion \\\"%s\\\" failed\\n\"\n\t\t\t      \"   function = %s, file = %s, line = %u\\n\"",
            "assertion",
            "function",
            "file",
            "line"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_lm_withdraw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
          "lines": "38-79",
          "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/crc32.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_assert_withdraw_i(struct gfs2_sbd *sdp, char *assertion,\n\t\t\t   const char *function, char *file, unsigned int line)\n{\n\tint me;\n\tme = gfs2_lm_withdraw(sdp,\n\t\t\t      \"fatal: assertion \\\"%s\\\" failed\\n\"\n\t\t\t      \"   function = %s, file = %s, line = %u\\n\",\n\t\t\t      assertion, function, file, line);\n\tdump_stack();\n\treturn (me) ? -1 : -2;\n}"
  },
  {
    "function_name": "gfs2_lm_withdraw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "38-79",
    "snippet": "int gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"GFS2: fsid=%s: panic requested\\n\"",
            "sdp->sd_fsname"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"withdrawn\\n\""
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lm->lm_unmount",
          "args": [
            "sdp"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&sdp->sd_wdack"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "sdp->sd_lockstruct.ls_ops->lm_proto_name",
            "\"lock_dlm\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_uevent",
          "args": [
            "&sdp->sd_kobj",
            "KOBJ_OFFLINE"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kobject_uevent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "113-124",
          "snippet": "static void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nstatic void btrfs_kobject_uevent(struct block_device *bdev,\n\t\t\t\t enum kobject_action action)\n{\n\tint ret;\n\n\tret = kobject_uevent(&disk_to_dev(bdev->bd_disk)->kobj, action);\n\tif (ret)\n\t\tpr_warn(\"BTRFS: Sending event '%d' to kobject: '%s' (%p): failed\\n\",\n\t\t\taction,\n\t\t\tkobject_name(&disk_to_dev(bdev->bd_disk)->kobj),\n\t\t\t&disk_to_dev(bdev->bd_disk)->kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sdp->sd_args.ar_debug"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "SDF_SHUTDOWN",
            "&sdp->sd_flags"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nint gfs2_lm_withdraw(struct gfs2_sbd *sdp, const char *fmt, ...)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tconst struct lm_lockops *lm = ls->ls_ops;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW &&\n\t    test_and_set_bit(SDF_SHUTDOWN, &sdp->sd_flags))\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tfs_err(sdp, \"%pV\", &vaf);\n\n\tva_end(args);\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_WITHDRAW) {\n\t\tfs_err(sdp, \"about to withdraw this file system\\n\");\n\t\tBUG_ON(sdp->sd_args.ar_debug);\n\n\t\tkobject_uevent(&sdp->sd_kobj, KOBJ_OFFLINE);\n\n\t\tif (!strcmp(sdp->sd_lockstruct.ls_ops->lm_proto_name, \"lock_dlm\"))\n\t\t\twait_for_completion(&sdp->sd_wdack);\n\n\t\tif (lm->lm_unmount) {\n\t\t\tfs_err(sdp, \"telling LM to unmount\\n\");\n\t\t\tlm->lm_unmount(sdp);\n\t\t}\n\t\tfs_err(sdp, \"withdrawn\\n\");\n\t\tdump_stack();\n\t}\n\n\tif (sdp->sd_args.ar_errors == GFS2_ERRORS_PANIC)\n\t\tpanic(\"GFS2: fsid=%s: panic requested\\n\", sdp->sd_fsname);\n\n\treturn -1;\n}"
  },
  {
    "function_name": "gfs2_assert_i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/util.c",
    "lines": "33-36",
    "snippet": "void gfs2_assert_i(struct gfs2_sbd *sdp)\n{\n\tfs_emerg(sdp, \"fatal assertion failed\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include \"gfs2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/crc32.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/completion.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_emerg",
          "args": [
            "sdp",
            "\"fatal assertion failed\\n\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/crc32.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n\nvoid gfs2_assert_i(struct gfs2_sbd *sdp)\n{\n\tfs_emerg(sdp, \"fatal assertion failed\\n\");\n}"
  }
]