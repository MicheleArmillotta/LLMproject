[
  {
    "function_name": "exit_affs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "634-638",
    "snippet": "static void __exit exit_affs_fs(void)\n{\n\tunregister_filesystem(&affs_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type affs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"affs\",\n\t.mount\t\t= affs_mount,\n\t.kill_sb\t= affs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "141-149",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * affs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&affs_fs_type"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type affs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"affs\",\n\t.mount\t\t= affs_mount,\n\t.kill_sb\t= affs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_affs_fs(void)\n{\n\tunregister_filesystem(&affs_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_affs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "619-632",
    "snippet": "static int __init init_affs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&affs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type affs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"affs\",\n\t.mount\t\t= affs_mount,\n\t.kill_sb\t= affs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "141-149",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * affs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&affs_fs_type"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "129-139",
          "snippet": "static int __init init_inodecache(void)\n{\n\taffs_inode_cachep = kmem_cache_create(\"affs_inode_cache\",\n\t\t\t\t\t     sizeof(struct affs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (affs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * affs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\taffs_inode_cachep = kmem_cache_create(\"affs_inode_cache\",\n\t\t\t\t\t     sizeof(struct affs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (affs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct file_system_type affs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"affs\",\n\t.mount\t\t= affs_mount,\n\t.kill_sb\t= affs_kill_sb,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_affs_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&affs_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "affs_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "597-608",
    "snippet": "static void affs_kill_sb(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tkill_block_super(sb);\n\tif (sbi) {\n\t\taffs_free_bitmap(sb);\n\t\taffs_brelse(sbi->s_root_bh);\n\t\tkfree(sbi->s_prefix);\n\t\tmutex_destroy(&sbi->s_bmlock);\n\t\tkfree(sbi);\n\t}\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_prefix"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_brelse",
          "args": [
            "sbi->s_root_bh"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_free_bitmap",
          "args": [
            "sb"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "352-364",
          "snippet": "void affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_block_super",
          "args": [
            "sb"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_kill_block_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "629-638",
          "snippet": "static void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_sb_info_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nstruct kmem_cache *ecryptfs_sb_info_cache;\n\nstatic void ecryptfs_kill_block_super(struct super_block *sb)\n{\n\tstruct ecryptfs_sb_info *sb_info = ecryptfs_superblock_to_private(sb);\n\tkill_anon_super(sb);\n\tif (!sb_info)\n\t\treturn;\n\tecryptfs_destroy_mount_crypt_stat(&sb_info->mount_crypt_stat);\n\tbdi_destroy(&sb_info->bdi);\n\tkmem_cache_free(ecryptfs_sb_info_cache, sb_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void affs_kill_sb(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tkill_block_super(sb);\n\tif (sbi) {\n\t\taffs_free_bitmap(sb);\n\t\taffs_brelse(sbi->s_root_bh);\n\t\tkfree(sbi->s_prefix);\n\t\tmutex_destroy(&sbi->s_bmlock);\n\t\tkfree(sbi);\n\t}\n}"
  },
  {
    "function_name": "affs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "591-595",
    "snippet": "static struct dentry *affs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, affs_fill_super);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int affs_remount (struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "affs_fill_super"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int affs_remount (struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *affs_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, affs_fill_super);\n}"
  },
  {
    "function_name": "affs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "568-589",
    "snippet": "static int\naffs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tint\t\t free;\n\tu64\t\t id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tpr_debug(\"%s() partsize=%d, reserved=%d\\n\",\n\t\t __func__, AFFS_SB(sb)->s_partition_size,\n\t\t AFFS_SB(sb)->s_reserved);\n\n\tfree          = affs_count_free_blocks(sb);\n\tbuf->f_type    = AFFS_SUPER_MAGIC;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = AFFS_SB(sb)->s_partition_size - AFFS_SB(sb)->s_reserved;\n\tbuf->f_bfree   = free;\n\tbuf->f_bavail  = free;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = AFFSNAMEMAX;\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int affs_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "affs_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "13-35",
          "snippet": "u32\naffs_count_free_blocks(struct super_block *sb)\n{\n\tstruct affs_bm_info *bm;\n\tu32 free;\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tmutex_lock(&AFFS_SB(sb)->s_bmlock);\n\n\tbm = AFFS_SB(sb)->s_bitmap;\n\tfree = 0;\n\tfor (i = AFFS_SB(sb)->s_bmap_count; i > 0; bm++, i--)\n\t\tfree += bm->bm_free;\n\n\tmutex_unlock(&AFFS_SB(sb)->s_bmlock);\n\n\treturn free;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nu32\naffs_count_free_blocks(struct super_block *sb)\n{\n\tstruct affs_bm_info *bm;\n\tu32 free;\n\tint i;\n\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tmutex_lock(&AFFS_SB(sb)->s_bmlock);\n\n\tbm = AFFS_SB(sb)->s_bitmap;\n\tfree = 0;\n\tfor (i = AFFS_SB(sb)->s_bmap_count; i > 0; bm++, i--)\n\t\tfree += bm->bm_free;\n\n\tmutex_unlock(&AFFS_SB(sb)->s_bmlock);\n\n\treturn free;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s() partsize=%d, reserved=%d\\n\"",
            "__func__",
            "AFFS_SB(sb)->s_partition_size",
            "AFFS_SB(sb)->s_reserved"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int affs_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int\naffs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tint\t\t free;\n\tu64\t\t id = huge_encode_dev(sb->s_bdev->bd_dev);\n\n\tpr_debug(\"%s() partsize=%d, reserved=%d\\n\",\n\t\t __func__, AFFS_SB(sb)->s_partition_size,\n\t\t AFFS_SB(sb)->s_reserved);\n\n\tfree          = affs_count_free_blocks(sb);\n\tbuf->f_type    = AFFS_SUPER_MAGIC;\n\tbuf->f_bsize   = sb->s_blocksize;\n\tbuf->f_blocks  = AFFS_SB(sb)->s_partition_size - AFFS_SB(sb)->s_reserved;\n\tbuf->f_bfree   = free;\n\tbuf->f_bavail  = free;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\tbuf->f_namelen = AFFSNAMEMAX;\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "511-566",
    "snippet": "static int\naffs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tint\t\t\t blocksize;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t mode;\n\tint\t\t\t reserved;\n\tint\t\t\t root_block;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t res = 0;\n\tchar\t\t\t*new_opts = kstrdup(data, GFP_KERNEL);\n\tchar\t\t\t volume[32];\n\tchar\t\t\t*prefix = NULL;\n\n\tpr_debug(\"%s(flags=0x%x,opts=\\\"%s\\\")\\n\", __func__, *flags, data);\n\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\n\tmemcpy(volume, sbi->s_volume, 32);\n\tif (!parse_options(data, &uid, &gid, &mode, &reserved, &root_block,\n\t\t\t   &blocksize, &prefix, volume,\n\t\t\t   &mount_flags)) {\n\t\tkfree(prefix);\n\t\tkfree(new_opts);\n\t\treturn -EINVAL;\n\t}\n\n\tflush_delayed_work(&sbi->sb_work);\n\treplace_mount_options(sb, new_opts);\n\n\tsbi->s_flags = mount_flags;\n\tsbi->s_mode  = mode;\n\tsbi->s_uid   = uid;\n\tsbi->s_gid   = gid;\n\t/* protect against readers */\n\tspin_lock(&sbi->symlink_lock);\n\tif (prefix) {\n\t\tkfree(sbi->s_prefix);\n\t\tsbi->s_prefix = prefix;\n\t}\n\tmemcpy(sbi->s_volume, volume, 32);\n\tspin_unlock(&sbi->symlink_lock);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\n\tif (*flags & MS_RDONLY)\n\t\taffs_free_bitmap(sb);\n\telse\n\t\tres = affs_init_bitmap(sb, flags);\n\n\treturn res;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int affs_remount (struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_init_bitmap",
          "args": [
            "sb",
            "flags"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "affs_init_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "243-350",
          "snippet": "int affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nint affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_free_bitmap",
          "args": [
            "sb"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "affs_free_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "352-364",
          "snippet": "void affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nvoid affs_free_bitmap(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (!sbi->s_bitmap)\n\t\treturn;\n\n\taffs_brelse(sbi->s_bmap_bh);\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_last_bmap = ~0;\n\tkfree(sbi->s_bitmap);\n\tsbi->s_bitmap = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->symlink_lock"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sbi->s_volume",
            "volume",
            "32"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_prefix"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->symlink_lock"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_mount_options",
          "args": [
            "sb",
            "new_opts"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "replace_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1196-1204",
          "snippet": "void replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid replace_mount_options(struct super_block *sb, char *options)\n{\n\tchar *old = sb->s_options;\n\trcu_assign_pointer(sb->s_options, options);\n\tif (old) {\n\t\tsynchronize_rcu();\n\t\tkfree(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&sbi->sb_work"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_opts"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "prefix"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "&uid",
            "&gid",
            "&mode",
            "&reserved",
            "&root_block",
            "&blocksize",
            "&prefix",
            "volume",
            "&mount_flags"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "189-292",
          "snippet": "static int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};\n\nstatic int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "volume",
            "sbi->s_volume",
            "32"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(flags=0x%x,opts=\\\"%s\\\")\\n\"",
            "__func__",
            "*flags",
            "data"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data",
            "GFP_KERNEL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int affs_remount (struct super_block *sb, int *flags, char *data);\n\nstatic int\naffs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tint\t\t\t blocksize;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t mode;\n\tint\t\t\t reserved;\n\tint\t\t\t root_block;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t res = 0;\n\tchar\t\t\t*new_opts = kstrdup(data, GFP_KERNEL);\n\tchar\t\t\t volume[32];\n\tchar\t\t\t*prefix = NULL;\n\n\tpr_debug(\"%s(flags=0x%x,opts=\\\"%s\\\")\\n\", __func__, *flags, data);\n\n\tsync_filesystem(sb);\n\t*flags |= MS_NODIRATIME;\n\n\tmemcpy(volume, sbi->s_volume, 32);\n\tif (!parse_options(data, &uid, &gid, &mode, &reserved, &root_block,\n\t\t\t   &blocksize, &prefix, volume,\n\t\t\t   &mount_flags)) {\n\t\tkfree(prefix);\n\t\tkfree(new_opts);\n\t\treturn -EINVAL;\n\t}\n\n\tflush_delayed_work(&sbi->sb_work);\n\treplace_mount_options(sb, new_opts);\n\n\tsbi->s_flags = mount_flags;\n\tsbi->s_mode  = mode;\n\tsbi->s_uid   = uid;\n\tsbi->s_gid   = gid;\n\t/* protect against readers */\n\tspin_lock(&sbi->symlink_lock);\n\tif (prefix) {\n\t\tkfree(sbi->s_prefix);\n\t\tsbi->s_prefix = prefix;\n\t}\n\tmemcpy(sbi->s_volume, volume, 32);\n\tspin_unlock(&sbi->symlink_lock);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\n\tif (*flags & MS_RDONLY)\n\t\taffs_free_bitmap(sb);\n\telse\n\t\tres = affs_init_bitmap(sb, flags);\n\n\treturn res;\n}"
  },
  {
    "function_name": "affs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "298-509",
    "snippet": "static int affs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct affs_sb_info\t*sbi;\n\tstruct buffer_head\t*root_bh = NULL;\n\tstruct buffer_head\t*boot_bh;\n\tstruct inode\t\t*root_inode = NULL;\n\ts32\t\t\t root_block;\n\tint\t\t\t size, blocksize;\n\tu32\t\t\t chksum;\n\tint\t\t\t num_bm;\n\tint\t\t\t i, j;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t reserved;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t tmp_flags;\t/* fix remount prototype... */\n\tu8\t\t\t sig[4];\n\tint\t\t\t ret;\n\n\tsave_mount_options(sb, data);\n\n\tpr_debug(\"read_super(%s)\\n\", data ? (const char *)data : \"no options\");\n\n\tsb->s_magic             = AFFS_SUPER_MAGIC;\n\tsb->s_op                = &affs_sops;\n\tsb->s_flags |= MS_NODIRATIME;\n\n\tsbi = kzalloc(sizeof(struct affs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\tmutex_init(&sbi->s_bmlock);\n\tspin_lock_init(&sbi->symlink_lock);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sb_work, flush_superblock);\n\n\tif (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,\n\t\t\t\t&blocksize,&sbi->s_prefix,\n\t\t\t\tsbi->s_volume, &mount_flags)) {\n\t\tpr_err(\"Error parsing options\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* N.B. after this point s_prefix must be released */\n\n\tsbi->s_flags   = mount_flags;\n\tsbi->s_mode    = i;\n\tsbi->s_uid     = uid;\n\tsbi->s_gid     = gid;\n\tsbi->s_reserved= reserved;\n\n\t/* Get the size of the device in 512-byte blocks.\n\t * If we later see that the partition uses bigger\n\t * blocks, we will have to change it.\n\t */\n\n\tsize = sb->s_bdev->bd_inode->i_size >> 9;\n\tpr_debug(\"initial blocksize=%d, #blocks=%d\\n\", 512, size);\n\n\taffs_set_blocksize(sb, PAGE_SIZE);\n\t/* Try to find root block. Its location depends on the block size. */\n\n\ti = 512;\n\tj = 4096;\n\tif (blocksize > 0) {\n\t\ti = j = blocksize;\n\t\tsize = size / (blocksize / 512);\n\t}\n\tfor (blocksize = i; blocksize <= j; blocksize <<= 1, size >>= 1) {\n\t\tsbi->s_root_block = root_block;\n\t\tif (root_block < 0)\n\t\t\tsbi->s_root_block = (reserved + size - 1) / 2;\n\t\tpr_debug(\"setting blocksize to %d\\n\", blocksize);\n\t\taffs_set_blocksize(sb, blocksize);\n\t\tsbi->s_partition_size = size;\n\n\t\t/* The root block location that was calculated above is not\n\t\t * correct if the partition size is an odd number of 512-\n\t\t * byte blocks, which will be rounded down to a number of\n\t\t * 1024-byte blocks, and if there were an even number of\n\t\t * reserved blocks. Ideally, all partition checkers should\n\t\t * report the real number of blocks of the real blocksize,\n\t\t * but since this just cannot be done, we have to try to\n\t\t * find the root block anyways. In the above case, it is one\n\t\t * block behind the calculated one. So we check this one, too.\n\t\t */\n\t\tfor (num_bm = 0; num_bm < 2; num_bm++) {\n\t\t\tpr_debug(\"Dev %s, trying root=%u, bs=%d, \"\n\t\t\t\t\"size=%d, reserved=%d\\n\",\n\t\t\t\tsb->s_id,\n\t\t\t\tsbi->s_root_block + num_bm,\n\t\t\t\tblocksize, size, reserved);\n\t\t\troot_bh = affs_bread(sb, sbi->s_root_block + num_bm);\n\t\t\tif (!root_bh)\n\t\t\t\tcontinue;\n\t\t\tif (!affs_checksum_block(sb, root_bh) &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_HEAD(root_bh)->ptype) == T_SHORT &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_TAIL(sb, root_bh)->stype) == ST_ROOT) {\n\t\t\t\tsbi->s_hashsize    = blocksize / 4 - 56;\n\t\t\t\tsbi->s_root_block += num_bm;\n\t\t\t\tgoto got_root;\n\t\t\t}\n\t\t\taffs_brelse(root_bh);\n\t\t\troot_bh = NULL;\n\t\t}\n\t}\n\tif (!silent)\n\t\tpr_err(\"No valid root block on device %s\\n\", sb->s_id);\n\treturn -EINVAL;\n\n\t/* N.B. after this point bh must be released */\ngot_root:\n\t/* Keep super block in cache */\n\tsbi->s_root_bh = root_bh;\n\troot_block = sbi->s_root_block;\n\n\t/* Find out which kind of FS we have */\n\tboot_bh = sb_bread(sb, 0);\n\tif (!boot_bh) {\n\t\tpr_err(\"Cannot read boot block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(sig, boot_bh->b_data, 4);\n\tbrelse(boot_bh);\n\tchksum = be32_to_cpu(*(__be32 *)sig);\n\n\t/* Dircache filesystems are compatible with non-dircache ones\n\t * when reading. As long as they aren't supported, writing is\n\t * not recommended.\n\t */\n\tif ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS\n\t     || chksum == MUFS_DCOFS) && !(sb->s_flags & MS_RDONLY)) {\n\t\tpr_notice(\"Dircache FS - mounting %s read only\\n\", sb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tswitch (chksum) {\n\tcase MUFS_FS:\n\tcase MUFS_INTLFFS:\n\tcase MUFS_DCFFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\t/* fall thru */\n\tcase FS_INTLFFS:\n\tcase FS_DCFFS:\n\t\tsbi->s_flags |= SF_INTL;\n\t\tbreak;\n\tcase MUFS_FFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\tbreak;\n\tcase FS_FFS:\n\t\tbreak;\n\tcase MUFS_OFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\t/* fall thru */\n\tcase FS_OFS:\n\t\tsbi->s_flags |= SF_OFS;\n\t\tsb->s_flags |= MS_NOEXEC;\n\t\tbreak;\n\tcase MUFS_DCOFS:\n\tcase MUFS_INTLOFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\tcase FS_DCOFS:\n\tcase FS_INTLOFS:\n\t\tsbi->s_flags |= SF_INTL | SF_OFS;\n\t\tsb->s_flags |= MS_NOEXEC;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown filesystem on device %s: %08X\\n\",\n\t\t       sb->s_id, chksum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mount_flags & SF_VERBOSE) {\n\t\tu8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];\n\t\tpr_notice(\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\",\n\t\t\tlen > 31 ? 31 : len,\n\t\t\tAFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,\n\t\t\tsig, sig[3] + '0', blocksize);\n\t}\n\n\tsb->s_flags |= MS_NODEV | MS_NOSUID;\n\n\tsbi->s_data_blksize = sb->s_blocksize;\n\tif (sbi->s_flags & SF_OFS)\n\t\tsbi->s_data_blksize -= 24;\n\n\ttmp_flags = sb->s_flags;\n\tret = affs_init_bitmap(sb, &tmp_flags);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_flags = tmp_flags;\n\n\t/* set up enough so that it can read an inode */\n\n\troot_inode = affs_iget(sb, root_block);\n\tif (IS_ERR(root_inode))\n\t\treturn PTR_ERR(root_inode);\n\n\tif (AFFS_SB(sb)->s_flags & SF_INTL)\n\t\tsb->s_d_op = &affs_intl_dentry_operations;\n\telse\n\t\tsb->s_d_op = &affs_dentry_operations;\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tpr_err(\"AFFS: Get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"s_flags=%lX\\n\", sb->s_flags);\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int affs_remount (struct super_block *sb, int *flags, char *data);",
      "static const struct super_operations affs_sops = {\n\t.alloc_inode\t= affs_alloc_inode,\n\t.destroy_inode\t= affs_destroy_inode,\n\t.write_inode\t= affs_write_inode,\n\t.evict_inode\t= affs_evict_inode,\n\t.put_super\t= affs_put_super,\n\t.sync_fs\t= affs_sync_fs,\n\t.statfs\t\t= affs_statfs,\n\t.remount_fs\t= affs_remount,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"s_flags=%lX\\n\"",
            "sb->s_flags"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"AFFS: Get root inode failed\\n\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root_inode"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root_inode"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_iget",
          "args": [
            "sb",
            "root_block"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "affs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/inode.c",
          "lines": "16-162",
          "snippet": "struct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/gfp.h>\n#include <linux/sched.h>\n\nstruct inode *affs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct affs_sb_info\t*sbi = AFFS_SB(sb);\n\tstruct buffer_head\t*bh;\n\tstruct affs_tail\t*tail;\n\tstruct inode\t\t*inode;\n\tu32\t\t\t block;\n\tu32\t\t\t size;\n\tu32\t\t\t prot;\n\tu16\t\t\t id;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tpr_debug(\"affs_iget(%lu)\\n\", inode->i_ino);\n\n\tblock = inode->i_ino;\n\tbh = affs_bread(sb, block);\n\tif (!bh) {\n\t\taffs_warning(sb, \"read_inode\", \"Cannot read block %d\", block);\n\t\tgoto bad_inode;\n\t}\n\tif (affs_checksum_block(sb, bh) || be32_to_cpu(AFFS_HEAD(bh)->ptype) != T_SHORT) {\n\t\taffs_warning(sb,\"read_inode\",\n\t\t\t   \"Checksum or type (ptype=%d) error on inode %d\",\n\t\t\t   AFFS_HEAD(bh)->ptype, block);\n\t\tgoto bad_inode;\n\t}\n\n\ttail = AFFS_TAIL(sb, bh);\n\tprot = be32_to_cpu(tail->protect);\n\n\tinode->i_size = 0;\n\tset_nlink(inode, 1);\n\tinode->i_mode = 0;\n\tAFFS_I(inode)->i_extcnt = 1;\n\tAFFS_I(inode)->i_ext_last = ~1;\n\tAFFS_I(inode)->i_protect = prot;\n\tatomic_set(&AFFS_I(inode)->i_opencnt, 0);\n\tAFFS_I(inode)->i_blkcnt = 0;\n\tAFFS_I(inode)->i_lc = NULL;\n\tAFFS_I(inode)->i_lc_size = 0;\n\tAFFS_I(inode)->i_lc_shift = 0;\n\tAFFS_I(inode)->i_lc_mask = 0;\n\tAFFS_I(inode)->i_ac = NULL;\n\tAFFS_I(inode)->i_ext_bh = NULL;\n\tAFFS_I(inode)->mmu_private = 0;\n\tAFFS_I(inode)->i_lastalloc = 0;\n\tAFFS_I(inode)->i_pa_cnt = 0;\n\n\tif (sbi->s_flags & SF_SETMODE)\n\t\tinode->i_mode = sbi->s_mode;\n\telse\n\t\tinode->i_mode = prot_to_mode(prot);\n\n\tid = be16_to_cpu(tail->uid);\n\tif (id == 0 || sbi->s_flags & SF_SETUID)\n\t\tinode->i_uid = sbi->s_uid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_uid_write(inode, 0);\n\telse\n\t\ti_uid_write(inode, id);\n\n\tid = be16_to_cpu(tail->gid);\n\tif (id == 0 || sbi->s_flags & SF_SETGID)\n\t\tinode->i_gid = sbi->s_gid;\n\telse if (id == 0xFFFF && sbi->s_flags & SF_MUFS)\n\t\ti_gid_write(inode, 0);\n\telse\n\t\ti_gid_write(inode, id);\n\n\tswitch (be32_to_cpu(tail->stype)) {\n\tcase ST_ROOT:\n\t\tinode->i_uid = sbi->s_uid;\n\t\tinode->i_gid = sbi->s_gid;\n\t\t/* fall through */\n\tcase ST_USERDIR:\n\t\tif (be32_to_cpu(tail->stype) == ST_USERDIR ||\n\t\t    sbi->s_flags & SF_SETMODE) {\n\t\t\tif (inode->i_mode & S_IRUSR)\n\t\t\t\tinode->i_mode |= S_IXUSR;\n\t\t\tif (inode->i_mode & S_IRGRP)\n\t\t\t\tinode->i_mode |= S_IXGRP;\n\t\t\tif (inode->i_mode & S_IROTH)\n\t\t\t\tinode->i_mode |= S_IXOTH;\n\t\t\tinode->i_mode |= S_IFDIR;\n\t\t} else\n\t\t\tinode->i_mode = S_IRUGO | S_IXUGO | S_IWUSR | S_IFDIR;\n\t\t/* Maybe it should be controlled by mount parameter? */\n\t\t//inode->i_mode |= S_ISVTX;\n\t\tinode->i_op = &affs_dir_inode_operations;\n\t\tinode->i_fop = &affs_dir_operations;\n\t\tbreak;\n\tcase ST_LINKDIR:\n#if 0\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKDIR\");\n\t\tgoto bad_inode;\n#else\n\t\tinode->i_mode |= S_IFDIR;\n\t\t/* ... and leave ->i_op and ->i_fop pointing to empty */\n\t\tbreak;\n#endif\n\tcase ST_LINKFILE:\n\t\taffs_warning(sb, \"read_inode\", \"inode is LINKFILE\");\n\t\tgoto bad_inode;\n\tcase ST_FILE:\n\t\tsize = be32_to_cpu(tail->size);\n\t\tinode->i_mode |= S_IFREG;\n\t\tAFFS_I(inode)->mmu_private = inode->i_size = size;\n\t\tif (inode->i_size) {\n\t\t\tAFFS_I(inode)->i_blkcnt = (size - 1) /\n\t\t\t\t\t       sbi->s_data_blksize + 1;\n\t\t\tAFFS_I(inode)->i_extcnt = (AFFS_I(inode)->i_blkcnt - 1) /\n\t\t\t\t\t       sbi->s_hashsize + 1;\n\t\t}\n\t\tif (tail->link_chain)\n\t\t\tset_nlink(inode, 2);\n\t\tinode->i_mapping->a_ops = (sbi->s_flags & SF_OFS) ? &affs_aops_ofs : &affs_aops;\n\t\tinode->i_op = &affs_file_inode_operations;\n\t\tinode->i_fop = &affs_file_operations;\n\t\tbreak;\n\tcase ST_SOFTLINK:\n\t\tinode->i_mode |= S_IFLNK;\n\t\tinode->i_op = &affs_symlink_inode_operations;\n\t\tinode->i_data.a_ops = &affs_symlink_aops;\n\t\tbreak;\n\t}\n\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec\n\t\t       = (be32_to_cpu(tail->change.days) * (24 * 60 * 60) +\n\t\t         be32_to_cpu(tail->change.mins) * 60 +\n\t\t\t be32_to_cpu(tail->change.ticks) / 50 +\n\t\t\t ((8 * 365 + 2) * 24 * 60 * 60)) +\n\t\t\t sys_tz.tz_minuteswest * 60;\n\tinode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = inode->i_atime.tv_nsec = 0;\n\taffs_brelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\taffs_brelse(bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_init_bitmap",
          "args": [
            "sb",
            "&tmp_flags"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "affs_init_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/bitmap.c",
          "lines": "243-350",
          "snippet": "int affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/slab.h>\n\nint affs_init_bitmap(struct super_block *sb, int *flags)\n{\n\tstruct affs_bm_info *bm;\n\tstruct buffer_head *bmap_bh = NULL, *bh = NULL;\n\t__be32 *bmap_blk;\n\tu32 size, blk, end, offset, mask;\n\tint i, res = 0;\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\n\tif (*flags & MS_RDONLY)\n\t\treturn 0;\n\n\tif (!AFFS_ROOT_TAIL(sb, sbi->s_root_bh)->bm_flag) {\n\t\tpr_notice(\"Bitmap invalid - mounting %s read only\\n\", sb->s_id);\n\t\t*flags |= MS_RDONLY;\n\t\treturn 0;\n\t}\n\n\tsbi->s_last_bmap = ~0;\n\tsbi->s_bmap_bh = NULL;\n\tsbi->s_bmap_bits = sb->s_blocksize * 8 - 32;\n\tsbi->s_bmap_count = (sbi->s_partition_size - sbi->s_reserved +\n\t\t\t\t sbi->s_bmap_bits - 1) / sbi->s_bmap_bits;\n\tsize = sbi->s_bmap_count * sizeof(*bm);\n\tbm = sbi->s_bitmap = kzalloc(size, GFP_KERNEL);\n\tif (!sbi->s_bitmap) {\n\t\tpr_err(\"Bitmap allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbmap_blk = (__be32 *)sbi->s_root_bh->b_data;\n\tblk = sb->s_blocksize / 4 - 49;\n\tend = blk + 25;\n\n\tfor (i = sbi->s_bmap_count; i > 0; bm++, i--) {\n\t\taffs_brelse(bh);\n\n\t\tbm->bm_key = be32_to_cpu(bmap_blk[blk]);\n\t\tbh = affs_bread(sb, bm->bm_key);\n\t\tif (!bh) {\n\t\t\tpr_err(\"Cannot read bitmap\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tif (affs_checksum_block(sb, bh)) {\n\t\t\tpr_warn(\"Bitmap %u invalid - mounting %s read only.\\n\",\n\t\t\t\tbm->bm_key, sb->s_id);\n\t\t\t*flags |= MS_RDONLY;\n\t\t\tgoto out;\n\t\t}\n\t\tpr_debug(\"read bitmap block %d: %d\\n\", blk, bm->bm_key);\n\t\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\n\t\t/* Don't try read the extension if this is the last block,\n\t\t * but we also need the right bm pointer below\n\t\t */\n\t\tif (++blk < end || i == 1)\n\t\t\tcontinue;\n\t\tif (bmap_bh)\n\t\t\taffs_brelse(bmap_bh);\n\t\tbmap_bh = affs_bread(sb, be32_to_cpu(bmap_blk[blk]));\n\t\tif (!bmap_bh) {\n\t\t\tpr_err(\"Cannot read bitmap extension\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tbmap_blk = (__be32 *)bmap_bh->b_data;\n\t\tblk = 0;\n\t\tend = sb->s_blocksize / 4 - 1;\n\t}\n\n\toffset = (sbi->s_partition_size - sbi->s_reserved) % sbi->s_bmap_bits;\n\tmask = ~(0xFFFFFFFFU << (offset & 31));\n\tpr_debug(\"last word: %d %d %d\\n\", offset, offset / 32 + 1, mask);\n\toffset = offset / 32 + 1;\n\n\tif (mask) {\n\t\tu32 old, new;\n\n\t\t/* Mark unused bits in the last word as allocated */\n\t\told = be32_to_cpu(((__be32 *)bh->b_data)[offset]);\n\t\tnew = old & mask;\n\t\t//if (old != new) {\n\t\t\t((__be32 *)bh->b_data)[offset] = cpu_to_be32(new);\n\t\t\t/* fix checksum */\n\t\t\t//new -= old;\n\t\t\t//old = be32_to_cpu(*(__be32 *)bh->b_data);\n\t\t\t//*(__be32 *)bh->b_data = cpu_to_be32(old - new);\n\t\t\t//mark_buffer_dirty(bh);\n\t\t//}\n\t\t/* correct offset for the bitmap count below */\n\t\t//offset++;\n\t}\n\twhile (++offset < sb->s_blocksize / 4)\n\t\t((__be32 *)bh->b_data)[offset] = 0;\n\t((__be32 *)bh->b_data)[0] = 0;\n\t((__be32 *)bh->b_data)[0] = cpu_to_be32(-affs_checksum_block(sb, bh));\n\tmark_buffer_dirty(bh);\n\n\t/* recalculate bitmap count for last block */\n\tbm--;\n\tbm->bm_free = memweight(bh->b_data + 4, sb->s_blocksize - 4);\n\nout:\n\taffs_brelse(bh);\n\taffs_brelse(bmap_bh);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\"",
            "len > 31 ? 31 : len",
            "AFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1",
            "sig",
            "sig[3] + '0'",
            "blocksize"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "root_bh"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "root_bh"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unknown filesystem on device %s: %08X\\n\"",
            "sb->s_id",
            "chksum"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Dircache FS - mounting %s read only\\n\"",
            "sb->s_id"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)sig"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "boot_bh"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "affs_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "260-266",
          "snippet": "static inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);",
            "extern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);",
            "extern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern int\taffs_insert_hash(struct inode *inode, struct buffer_head *bh);\nextern u32\taffs_checksum_block(struct super_block *sb, struct buffer_head *bh);\nextern void\taffs_fix_checksum(struct super_block *sb, struct buffer_head *bh);\nextern u32\taffs_count_free_blocks(struct super_block *s);\n\nstatic inline void\naffs_brelse(struct buffer_head *bh)\n{\n\tif (bh)\n\t\tpr_debug(\"%s: %lld\\n\", __func__, (long long) bh->b_blocknr);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "sig",
            "boot_bh->b_data",
            "4"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Cannot read boot block\\n\""
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No valid root block on device %s\\n\"",
            "sb->s_id"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_ROOT_TAIL(sb, root_bh)->stype"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "root_bh"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "AFFS_ROOT_HEAD(root_bh)->ptype"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_HEAD",
          "args": [
            "root_bh"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_checksum_block",
          "args": [
            "sb",
            "root_bh"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "affs_checksum_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "335-346",
          "snippet": "u32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nu32\naffs_checksum_block(struct super_block *sb, struct buffer_head *bh)\n{\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 sum;\n\tint bsize;\n\n\tsum = 0;\n\tfor (bsize = sb->s_blocksize / sizeof(__be32); bsize > 0; bsize--)\n\t\tsum += be32_to_cpu(*ptr++);\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_bread",
          "args": [
            "sb",
            "sbi->s_root_block + num_bm"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "affs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "216-223",
          "snippet": "static inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern u32\taffs_count_free_blocks(struct super_block *s);",
            "extern void\taffs_free_block(struct super_block *sb, u32 block);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern u32\taffs_count_free_blocks(struct super_block *s);\nextern void\taffs_free_block(struct super_block *sb, u32 block);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct buffer_head *\naffs_bread(struct super_block *sb, int block)\n{\n\tpr_debug(\"%s: %d\\n\", __func__, block);\n\tif (block >= AFFS_SB(sb)->s_reserved && block < AFFS_SB(sb)->s_partition_size)\n\t\treturn sb_bread(sb, block);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Dev %s, trying root=%u, bs=%d, \"\n\t\t\t\t\"size=%d, reserved=%d\\n\"",
            "sb->s_id",
            "sbi->s_root_block + num_bm",
            "blocksize",
            "size",
            "reserved"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "affs_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "affs_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "211-215",
          "snippet": "static inline void\naffs_set_blocksize(struct super_block *sb, int size)\n{\n\tsb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline void\naffs_set_blocksize(struct super_block *sb, int size)\n{\n\tsb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"setting blocksize to %d\\n\"",
            "blocksize"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"initial blocksize=%d, #blocks=%d\\n\"",
            "512",
            "size"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error parsing options\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "&uid",
            "&gid",
            "&i",
            "&reserved",
            "&root_block",
            "&blocksize",
            "&sbi->s_prefix",
            "sbi->s_volume",
            "&mount_flags"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "189-292",
          "snippet": "static int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};\n\nstatic int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sbi->sb_work",
            "flush_superblock"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->symlink_lock"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_bmlock"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct affs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"read_super(%s)\\n\"",
            "data ? (const char *)data : \"no options\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int affs_remount (struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations affs_sops = {\n\t.alloc_inode\t= affs_alloc_inode,\n\t.destroy_inode\t= affs_destroy_inode,\n\t.write_inode\t= affs_write_inode,\n\t.evict_inode\t= affs_evict_inode,\n\t.put_super\t= affs_put_super,\n\t.sync_fs\t= affs_sync_fs,\n\t.statfs\t\t= affs_statfs,\n\t.remount_fs\t= affs_remount,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int affs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct affs_sb_info\t*sbi;\n\tstruct buffer_head\t*root_bh = NULL;\n\tstruct buffer_head\t*boot_bh;\n\tstruct inode\t\t*root_inode = NULL;\n\ts32\t\t\t root_block;\n\tint\t\t\t size, blocksize;\n\tu32\t\t\t chksum;\n\tint\t\t\t num_bm;\n\tint\t\t\t i, j;\n\tkuid_t\t\t\t uid;\n\tkgid_t\t\t\t gid;\n\tint\t\t\t reserved;\n\tunsigned long\t\t mount_flags;\n\tint\t\t\t tmp_flags;\t/* fix remount prototype... */\n\tu8\t\t\t sig[4];\n\tint\t\t\t ret;\n\n\tsave_mount_options(sb, data);\n\n\tpr_debug(\"read_super(%s)\\n\", data ? (const char *)data : \"no options\");\n\n\tsb->s_magic             = AFFS_SUPER_MAGIC;\n\tsb->s_op                = &affs_sops;\n\tsb->s_flags |= MS_NODIRATIME;\n\n\tsbi = kzalloc(sizeof(struct affs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\tsbi->sb = sb;\n\tmutex_init(&sbi->s_bmlock);\n\tspin_lock_init(&sbi->symlink_lock);\n\tspin_lock_init(&sbi->work_lock);\n\tINIT_DELAYED_WORK(&sbi->sb_work, flush_superblock);\n\n\tif (!parse_options(data,&uid,&gid,&i,&reserved,&root_block,\n\t\t\t\t&blocksize,&sbi->s_prefix,\n\t\t\t\tsbi->s_volume, &mount_flags)) {\n\t\tpr_err(\"Error parsing options\\n\");\n\t\treturn -EINVAL;\n\t}\n\t/* N.B. after this point s_prefix must be released */\n\n\tsbi->s_flags   = mount_flags;\n\tsbi->s_mode    = i;\n\tsbi->s_uid     = uid;\n\tsbi->s_gid     = gid;\n\tsbi->s_reserved= reserved;\n\n\t/* Get the size of the device in 512-byte blocks.\n\t * If we later see that the partition uses bigger\n\t * blocks, we will have to change it.\n\t */\n\n\tsize = sb->s_bdev->bd_inode->i_size >> 9;\n\tpr_debug(\"initial blocksize=%d, #blocks=%d\\n\", 512, size);\n\n\taffs_set_blocksize(sb, PAGE_SIZE);\n\t/* Try to find root block. Its location depends on the block size. */\n\n\ti = 512;\n\tj = 4096;\n\tif (blocksize > 0) {\n\t\ti = j = blocksize;\n\t\tsize = size / (blocksize / 512);\n\t}\n\tfor (blocksize = i; blocksize <= j; blocksize <<= 1, size >>= 1) {\n\t\tsbi->s_root_block = root_block;\n\t\tif (root_block < 0)\n\t\t\tsbi->s_root_block = (reserved + size - 1) / 2;\n\t\tpr_debug(\"setting blocksize to %d\\n\", blocksize);\n\t\taffs_set_blocksize(sb, blocksize);\n\t\tsbi->s_partition_size = size;\n\n\t\t/* The root block location that was calculated above is not\n\t\t * correct if the partition size is an odd number of 512-\n\t\t * byte blocks, which will be rounded down to a number of\n\t\t * 1024-byte blocks, and if there were an even number of\n\t\t * reserved blocks. Ideally, all partition checkers should\n\t\t * report the real number of blocks of the real blocksize,\n\t\t * but since this just cannot be done, we have to try to\n\t\t * find the root block anyways. In the above case, it is one\n\t\t * block behind the calculated one. So we check this one, too.\n\t\t */\n\t\tfor (num_bm = 0; num_bm < 2; num_bm++) {\n\t\t\tpr_debug(\"Dev %s, trying root=%u, bs=%d, \"\n\t\t\t\t\"size=%d, reserved=%d\\n\",\n\t\t\t\tsb->s_id,\n\t\t\t\tsbi->s_root_block + num_bm,\n\t\t\t\tblocksize, size, reserved);\n\t\t\troot_bh = affs_bread(sb, sbi->s_root_block + num_bm);\n\t\t\tif (!root_bh)\n\t\t\t\tcontinue;\n\t\t\tif (!affs_checksum_block(sb, root_bh) &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_HEAD(root_bh)->ptype) == T_SHORT &&\n\t\t\t    be32_to_cpu(AFFS_ROOT_TAIL(sb, root_bh)->stype) == ST_ROOT) {\n\t\t\t\tsbi->s_hashsize    = blocksize / 4 - 56;\n\t\t\t\tsbi->s_root_block += num_bm;\n\t\t\t\tgoto got_root;\n\t\t\t}\n\t\t\taffs_brelse(root_bh);\n\t\t\troot_bh = NULL;\n\t\t}\n\t}\n\tif (!silent)\n\t\tpr_err(\"No valid root block on device %s\\n\", sb->s_id);\n\treturn -EINVAL;\n\n\t/* N.B. after this point bh must be released */\ngot_root:\n\t/* Keep super block in cache */\n\tsbi->s_root_bh = root_bh;\n\troot_block = sbi->s_root_block;\n\n\t/* Find out which kind of FS we have */\n\tboot_bh = sb_bread(sb, 0);\n\tif (!boot_bh) {\n\t\tpr_err(\"Cannot read boot block\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(sig, boot_bh->b_data, 4);\n\tbrelse(boot_bh);\n\tchksum = be32_to_cpu(*(__be32 *)sig);\n\n\t/* Dircache filesystems are compatible with non-dircache ones\n\t * when reading. As long as they aren't supported, writing is\n\t * not recommended.\n\t */\n\tif ((chksum == FS_DCFFS || chksum == MUFS_DCFFS || chksum == FS_DCOFS\n\t     || chksum == MUFS_DCOFS) && !(sb->s_flags & MS_RDONLY)) {\n\t\tpr_notice(\"Dircache FS - mounting %s read only\\n\", sb->s_id);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tswitch (chksum) {\n\tcase MUFS_FS:\n\tcase MUFS_INTLFFS:\n\tcase MUFS_DCFFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\t/* fall thru */\n\tcase FS_INTLFFS:\n\tcase FS_DCFFS:\n\t\tsbi->s_flags |= SF_INTL;\n\t\tbreak;\n\tcase MUFS_FFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\tbreak;\n\tcase FS_FFS:\n\t\tbreak;\n\tcase MUFS_OFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\t\t/* fall thru */\n\tcase FS_OFS:\n\t\tsbi->s_flags |= SF_OFS;\n\t\tsb->s_flags |= MS_NOEXEC;\n\t\tbreak;\n\tcase MUFS_DCOFS:\n\tcase MUFS_INTLOFS:\n\t\tsbi->s_flags |= SF_MUFS;\n\tcase FS_DCOFS:\n\tcase FS_INTLOFS:\n\t\tsbi->s_flags |= SF_INTL | SF_OFS;\n\t\tsb->s_flags |= MS_NOEXEC;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown filesystem on device %s: %08X\\n\",\n\t\t       sb->s_id, chksum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mount_flags & SF_VERBOSE) {\n\t\tu8 len = AFFS_ROOT_TAIL(sb, root_bh)->disk_name[0];\n\t\tpr_notice(\"Mounting volume \\\"%.*s\\\": Type=%.3s\\\\%c, Blocksize=%d\\n\",\n\t\t\tlen > 31 ? 31 : len,\n\t\t\tAFFS_ROOT_TAIL(sb, root_bh)->disk_name + 1,\n\t\t\tsig, sig[3] + '0', blocksize);\n\t}\n\n\tsb->s_flags |= MS_NODEV | MS_NOSUID;\n\n\tsbi->s_data_blksize = sb->s_blocksize;\n\tif (sbi->s_flags & SF_OFS)\n\t\tsbi->s_data_blksize -= 24;\n\n\ttmp_flags = sb->s_flags;\n\tret = affs_init_bitmap(sb, &tmp_flags);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_flags = tmp_flags;\n\n\t/* set up enough so that it can read an inode */\n\n\troot_inode = affs_iget(sb, root_block);\n\tif (IS_ERR(root_inode))\n\t\treturn PTR_ERR(root_inode);\n\n\tif (AFFS_SB(sb)->s_flags & SF_INTL)\n\t\tsb->s_d_op = &affs_intl_dentry_operations;\n\telse\n\t\tsb->s_d_op = &affs_dentry_operations;\n\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tpr_err(\"AFFS: Get root inode failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"s_flags=%lX\\n\", sb->s_flags);\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "189-292",
    "snippet": "static int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Unrecognized mount option \\\"%s\\\" or missing value\\n\"",
            "p"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "volume",
            "vol",
            "32"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "*uid"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "*gid"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "root"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "reserved"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&n"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_bs, \"bs=%u\"},\n\t{Opt_mode, \"mode=%o\"},\n\t{Opt_mufs, \"mufs\"},\n\t{Opt_notruncate, \"nofilenametruncate\"},\n\t{Opt_prefix, \"prefix=%s\"},\n\t{Opt_protect, \"protect\"},\n\t{Opt_reserved, \"reserved=%u\"},\n\t{Opt_root, \"root=%u\"},\n\t{Opt_setgid, \"setgid=%u\"},\n\t{Opt_setuid, \"setuid=%u\"},\n\t{Opt_verbose, \"verbose\"},\n\t{Opt_volume, \"volume=%s\"},\n\t{Opt_ignore, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_ignore, \"quota\"},\n\t{Opt_ignore, \"usrquota\"},\n\t{Opt_err, NULL},\n};\n\nstatic int\nparse_options(char *options, kuid_t *uid, kgid_t *gid, int *mode, int *reserved, s32 *root,\n\t\tint *blocksize, char **prefix, char *volume, unsigned long *mount_opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\n\t/* Fill in defaults */\n\n\t*uid        = current_uid();\n\t*gid        = current_gid();\n\t*reserved   = 2;\n\t*root       = -1;\n\t*blocksize  = -1;\n\tvolume[0]   = ':';\n\tvolume[1]   = 0;\n\t*mount_opts = 0;\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, n, option;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bs:\n\t\t\tif (match_int(&args[0], &n))\n\t\t\t\treturn 0;\n\t\t\tif (n != 512 && n != 1024 && n != 2048\n\t\t\t    && n != 4096) {\n\t\t\t\tpr_warn(\"Invalid blocksize (512, 1024, 2048, 4096 allowed)\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*blocksize = n;\n\t\t\tbreak;\n\t\tcase Opt_mode:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*mode = option & 0777;\n\t\t\t*mount_opts |= SF_SETMODE;\n\t\t\tbreak;\n\t\tcase Opt_mufs:\n\t\t\t*mount_opts |= SF_MUFS;\n\t\t\tbreak;\n\t\tcase Opt_notruncate:\n\t\t\t*mount_opts |= SF_NO_TRUNCATE;\n\t\t\tbreak;\n\t\tcase Opt_prefix:\n\t\t\t*prefix = match_strdup(&args[0]);\n\t\t\tif (!*prefix)\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_PREFIX;\n\t\t\tbreak;\n\t\tcase Opt_protect:\n\t\t\t*mount_opts |= SF_IMMUTABLE;\n\t\t\tbreak;\n\t\tcase Opt_reserved:\n\t\t\tif (match_int(&args[0], reserved))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_root:\n\t\t\tif (match_int(&args[0], root))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_setgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(*gid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETGID;\n\t\t\tbreak;\n\t\tcase Opt_setuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\t*uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(*uid))\n\t\t\t\treturn 0;\n\t\t\t*mount_opts |= SF_SETUID;\n\t\t\tbreak;\n\t\tcase Opt_verbose:\n\t\t\t*mount_opts |= SF_VERBOSE;\n\t\t\tbreak;\n\t\tcase Opt_volume: {\n\t\t\tchar *vol = match_strdup(&args[0]);\n\t\t\tif (!vol)\n\t\t\t\treturn 0;\n\t\t\tstrlcpy(volume, vol, 32);\n\t\t\tkfree(vol);\n\t\t\tbreak;\n\t\t}\n\t\tcase Opt_ignore:\n\t\t \t/* Silently ignore the quota options */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognized mount option \\\"%s\\\" or missing value\\n\",\n\t\t\t\tp);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "141-149",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * affs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "affs_inode_cachep"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(affs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "129-139",
    "snippet": "static int __init init_inodecache(void)\n{\n\taffs_inode_cachep = kmem_cache_create(\"affs_inode_cache\",\n\t\t\t\t\t     sizeof(struct affs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (affs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * affs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"affs_inode_cache\"",
            "sizeof(struct affs_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\taffs_inode_cachep = kmem_cache_create(\"affs_inode_cache\",\n\t\t\t\t\t     sizeof(struct affs_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (affs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "120-127",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct affs_inode_info *ei = (struct affs_inode_info *) foo;\n\n\tsema_init(&ei->i_link_lock, 1);\n\tsema_init(&ei->i_ext_lock, 1);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&ei->i_ext_lock",
            "1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&ei->i_link_lock",
            "1"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct affs_inode_info *ei = (struct affs_inode_info *) foo;\n\n\tsema_init(&ei->i_link_lock, 1);\n\tsema_init(&ei->i_ext_lock, 1);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "affs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "115-118",
    "snippet": "static void affs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, affs_i_callback);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "affs_i_callback"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void affs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, affs_i_callback);\n}"
  },
  {
    "function_name": "affs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "109-113",
    "snippet": "static void affs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(affs_inode_cachep, AFFS_I(inode));\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * affs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "affs_inode_cachep",
            "AFFS_I(inode)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_I",
          "args": [
            "inode"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "65-68",
          "snippet": "static inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void\tmode_to_prot(struct inode *inode);",
            "extern void\t\t\t affs_evict_inode(struct inode *inode);",
            "void\t\taffs_free_prealloc(struct inode *inode);",
            "extern void\taffs_truncate(struct inode *);",
            "extern void   affs_dir_truncate(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nextern void\tmode_to_prot(struct inode *inode);\nextern void\t\t\t affs_evict_inode(struct inode *inode);\nvoid\t\taffs_free_prealloc(struct inode *inode);\nextern void\taffs_truncate(struct inode *);\nextern void   affs_dir_truncate(struct inode *);\n\nstatic inline struct affs_inode_info *AFFS_I(struct inode *inode)\n{\n\treturn list_entry(inode, struct affs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic void affs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(affs_inode_cachep, AFFS_I(inode));\n}"
  },
  {
    "function_name": "affs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "93-107",
    "snippet": "static struct inode *affs_alloc_inode(struct super_block *sb)\n{\n\tstruct affs_inode_info *i;\n\n\ti = kmem_cache_alloc(affs_inode_cachep, GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\ti->vfs_inode.i_version = 1;\n\ti->i_lc = NULL;\n\ti->i_ext_bh = NULL;\n\ti->i_pa_cnt = 0;\n\n\treturn &i->vfs_inode;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * affs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "affs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * affs_inode_cachep;\n\nstatic struct inode *affs_alloc_inode(struct super_block *sb)\n{\n\tstruct affs_inode_info *i;\n\n\ti = kmem_cache_alloc(affs_inode_cachep, GFP_KERNEL);\n\tif (!i)\n\t\treturn NULL;\n\n\ti->vfs_inode.i_version = 1;\n\ti->i_lc = NULL;\n\ti->i_ext_bh = NULL;\n\ti->i_pa_cnt = 0;\n\n\treturn &i->vfs_inode;\n}"
  },
  {
    "function_name": "affs_mark_sb_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "74-89",
    "snippet": "void affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_long_wq",
            "&sbi->sb_work",
            "delay"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tunsigned long delay;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t       return;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t       delay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t       queue_delayed_work(system_long_wq, &sbi->sb_work, delay);\n\t       sbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
  },
  {
    "function_name": "flush_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "59-72",
    "snippet": "static void flush_superblock(struct work_struct *work)\n{\n\tstruct affs_sb_info *sbi;\n\tstruct super_block *sb;\n\n\tsbi = container_of(work, struct affs_sb_info, sb_work.work);\n\tsb = sbi->sb;\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\taffs_commit_super(sb, 1);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_commit_super",
          "args": [
            "sb",
            "1"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "affs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "26-41",
          "snippet": "static void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->work_lock"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structaffs_sb_info",
            "sb_work.work"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void flush_superblock(struct work_struct *work)\n{\n\tstruct affs_sb_info *sbi;\n\tstruct super_block *sb;\n\n\tsbi = container_of(work, struct affs_sb_info, sb_work.work);\n\tsb = sbi->sb;\n\n\tspin_lock(&sbi->work_lock);\n\tsbi->work_queued = 0;\n\tspin_unlock(&sbi->work_lock);\n\n\taffs_commit_super(sb, 1);\n}"
  },
  {
    "function_name": "affs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "52-57",
    "snippet": "static int\naffs_sync_fs(struct super_block *sb, int wait)\n{\n\taffs_commit_super(sb, wait);\n\treturn 0;\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "affs_commit_super",
          "args": [
            "sb",
            "wait"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "affs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
          "lines": "26-41",
          "snippet": "static void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}",
          "includes": [
            "#include \"affs.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int\naffs_sync_fs(struct super_block *sb, int wait)\n{\n\taffs_commit_super(sb, wait);\n\treturn 0;\n}"
  },
  {
    "function_name": "affs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "43-50",
    "snippet": "static void\naffs_put_super(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tcancel_delayed_work_sync(&sbi->sb_work);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&sbi->sb_work"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s()\\n\"",
            "__func__"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\naffs_put_super(struct super_block *sb)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tpr_debug(\"%s()\\n\", __func__);\n\n\tcancel_delayed_work_sync(&sbi->sb_work);\n}"
  },
  {
    "function_name": "affs_commit_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/super.c",
    "lines": "26-41",
    "snippet": "static void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}",
    "includes": [
      "#include \"affs.h\"",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/magic.h>",
      "#include <linux/parser.h>",
      "#include <linux/statfs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "affs_fix_checksum",
          "args": [
            "sb",
            "bh"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "affs_fix_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "353-366",
          "snippet": "void\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\naffs_fix_checksum(struct super_block *sb, struct buffer_head *bh)\n{\n\tint cnt = sb->s_blocksize / sizeof(__be32);\n\t__be32 *ptr = (__be32 *)bh->b_data;\n\tu32 checksum;\n\t__be32 *checksumptr;\n\n\tchecksumptr = ptr + 5;\n\t*checksumptr = 0;\n\tfor (checksum = 0; cnt > 0; ptr++, cnt--)\n\t\tchecksum += be32_to_cpu(*ptr);\n\t*checksumptr = cpu_to_be32(-checksum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "secs_to_datestamp",
          "args": [
            "get_seconds()",
            "&tail->disk_change"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "secs_to_datestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/amigaffs.c",
          "lines": "368-385",
          "snippet": "void\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}",
          "includes": [
            "#include \"affs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"affs.h\"\n\nvoid\nsecs_to_datestamp(time_t secs, struct affs_date *ds)\n{\n\tu32\t days;\n\tu32\t minute;\n\n\tsecs -= sys_tz.tz_minuteswest * 60 + ((8 * 365 + 2) * 24 * 60 * 60);\n\tif (secs < 0)\n\t\tsecs = 0;\n\tdays    = secs / 86400;\n\tsecs   -= days * 86400;\n\tminute  = secs / 60;\n\tsecs   -= minute * 60;\n\n\tds->days = cpu_to_be32(days);\n\tds->mins = cpu_to_be32(minute);\n\tds->ticks = cpu_to_be32(secs * 50);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_ROOT_TAIL",
          "args": [
            "sb",
            "bh"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFFS_SB",
          "args": [
            "sb"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "AFFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/affs/affs.h",
          "lines": "123-126",
          "snippet": "static inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/mutex.h>",
            "#include <linux/amigaffs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void affs_mark_sb_dirty(struct super_block *sb);",
            "extern void\taffs_free_bitmap(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/amigaffs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n\nvoid affs_mark_sb_dirty(struct super_block *sb);\nextern void\taffs_free_bitmap(struct super_block *sb);\n\nstatic inline struct affs_sb_info *AFFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"affs.h\"\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void\naffs_commit_super(struct super_block *sb, int wait)\n{\n\tstruct affs_sb_info *sbi = AFFS_SB(sb);\n\tstruct buffer_head *bh = sbi->s_root_bh;\n\tstruct affs_root_tail *tail = AFFS_ROOT_TAIL(sb, bh);\n\n\tlock_buffer(bh);\n\tsecs_to_datestamp(get_seconds(), &tail->disk_change);\n\taffs_fix_checksum(sb, bh);\n\tunlock_buffer(bh);\n\n\tmark_buffer_dirty(bh);\n\tif (wait)\n\t\tsync_dirty_buffer(bh);\n}"
  }
]