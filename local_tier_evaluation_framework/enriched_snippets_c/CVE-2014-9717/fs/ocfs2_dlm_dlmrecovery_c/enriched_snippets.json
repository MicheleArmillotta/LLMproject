[
  {
    "function_name": "dlm_finalize_reco_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2865-2935",
    "snippet": "int dlm_finalize_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_finalize_reco *fr = (struct dlm_finalize_reco *)msg->buf;\n\tint stage = 1;\n\n\t/* ok to return 0, domain has gone away */\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tif (fr->flags & DLM_FINALIZE_STAGE2)\n\t\tstage = 2;\n\n\tmlog(0, \"%s: node %u finalizing recovery stage%d of \"\n\t     \"node %u (%u:%u)\\n\", dlm->name, fr->node_idx, stage,\n\t     fr->dead_node, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->reco.new_master != fr->node_idx) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg, but node \"\n\t\t     \"%u is supposed to be the new master, dead=%u\\n\",\n\t\t     fr->node_idx, dlm->reco.new_master, fr->dead_node);\n\t\tBUG();\n\t}\n\tif (dlm->reco.dead_node != fr->dead_node) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg for dead \"\n\t\t     \"node %u, but node %u is supposed to be dead\\n\",\n\t\t     fr->node_idx, fr->dead_node, dlm->reco.dead_node);\n\t\tBUG();\n\t}\n\n\tswitch (stage) {\n\t\tcase 1:\n\t\t\tdlm_finish_local_lockres_recovery(dlm, fr->dead_node, fr->node_idx);\n\t\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize1 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node has already received it!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!(dlm->reco.state & DLM_RECO_STATE_FINALIZE)) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize2 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node did not have finalize1!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tdlm_kick_recovery_thread(dlm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\n\tmlog(0, \"%s: recovery done, reco master was %u, dead now %u, master now %u\\n\",\n\t     dlm->name, fr->node_idx, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_FINALIZE_STAGE2  0x01"
    ],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2933
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: recovery done, reco master was %u, dead now %u, master now %u\\n\"",
            "dlm->name",
            "fr->node_idx",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 2924
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "191-200",
          "snippet": "void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_recovery_thread(void *data);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
            "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_reset_recovery",
          "args": [
            "dlm"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_reset_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "136-142",
          "snippet": "static inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_reco_node_status",
          "args": [
            "dlm"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_reco_node_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "252-297",
          "snippet": "static void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
            "static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);\n\nstatic void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: received finalize2 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node did not have finalize1!\\n\"",
            "dlm->name",
            "fr->node_idx",
            "fr->dead_node"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: received finalize1 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node has already received it!\\n\"",
            "dlm->name",
            "fr->node_idx",
            "fr->dead_node"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_finish_local_lockres_recovery",
          "args": [
            "dlm",
            "fr->dead_node",
            "fr->node_idx"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_finish_local_lockres_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2120-2181",
          "snippet": "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"node %u sent recovery finalize msg for dead \"\n\t\t     \"node %u, but node %u is supposed to be dead\\n\"",
            "fr->node_idx",
            "fr->dead_node",
            "dlm->reco.dead_node"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"node %u sent recovery finalize msg, but node \"\n\t\t     \"%u is supposed to be the new master, dead=%u\\n\"",
            "fr->node_idx",
            "dlm->reco.new_master",
            "fr->dead_node"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u finalizing recovery stage%d of \"\n\t     \"node %u (%u:%u)\\n\"",
            "dlm->name",
            "fr->node_idx",
            "stage",
            "fr->dead_node",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_FINALIZE_STAGE2  0x01\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nint dlm_finalize_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t      void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_finalize_reco *fr = (struct dlm_finalize_reco *)msg->buf;\n\tint stage = 1;\n\n\t/* ok to return 0, domain has gone away */\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tif (fr->flags & DLM_FINALIZE_STAGE2)\n\t\tstage = 2;\n\n\tmlog(0, \"%s: node %u finalizing recovery stage%d of \"\n\t     \"node %u (%u:%u)\\n\", dlm->name, fr->node_idx, stage,\n\t     fr->dead_node, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tspin_lock(&dlm->spinlock);\n\n\tif (dlm->reco.new_master != fr->node_idx) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg, but node \"\n\t\t     \"%u is supposed to be the new master, dead=%u\\n\",\n\t\t     fr->node_idx, dlm->reco.new_master, fr->dead_node);\n\t\tBUG();\n\t}\n\tif (dlm->reco.dead_node != fr->dead_node) {\n\t\tmlog(ML_ERROR, \"node %u sent recovery finalize msg for dead \"\n\t\t     \"node %u, but node %u is supposed to be dead\\n\",\n\t\t     fr->node_idx, fr->dead_node, dlm->reco.dead_node);\n\t\tBUG();\n\t}\n\n\tswitch (stage) {\n\t\tcase 1:\n\t\t\tdlm_finish_local_lockres_recovery(dlm, fr->dead_node, fr->node_idx);\n\t\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize1 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node has already received it!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!(dlm->reco.state & DLM_RECO_STATE_FINALIZE)) {\n\t\t\t\tmlog(ML_ERROR, \"%s: received finalize2 from \"\n\t\t\t\t     \"new master %u for dead node %u, but \"\n\t\t\t\t     \"this node did not have finalize1!\\n\",\n\t\t\t\t     dlm->name, fr->node_idx, fr->dead_node);\n\t\t\t\tdlm_print_reco_node_status(dlm);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tdlm_kick_recovery_thread(dlm);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\n\tmlog(0, \"%s: recovery done, reco master was %u, dead now %u, master now %u\\n\",\n\t     dlm->name, fr->node_idx, dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_send_finalize_reco_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2809-2863",
    "snippet": "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\tstruct dlm_finalize_reco fr;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\tint stage = 1;\n\n\tmlog(0, \"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\", dlm->name, dlm->reco.dead_node, stage);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\nstage2:\n\tmemset(&fr, 0, sizeof(fr));\n\tfr.node_idx = dlm->node_num;\n\tfr.dead_node = dlm->reco.dead_node;\n\tif (stage == 2)\n\t\tfr.flags |= DLM_FINALIZE_STAGE2;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\t &fr, sizeof(fr), nodenum, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", ret, DLM_FINALIZE_RECO_MSG,\n\t\t\t     dlm->key, nodenum);\n\t\t\tif (dlm_is_host_down(ret)) {\n\t\t\t\t/* this has no effect on this recovery\n\t\t\t\t * session, so set the status to zero to\n\t\t\t\t * finish out the last recovery */\n\t\t\t\tmlog(ML_ERROR, \"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\", nodenum);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (stage == 1) {\n\t\t/* reset the node_iter back to the top and send finalize2 */\n\t\titer.curnode = -1;\n\t\tstage = 2;\n\t\tgoto stage2;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_FINALIZE_STAGE2  0x01"
    ],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\"",
            "nodenum"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2843
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\"",
            "ret",
            "DLM_FINALIZE_RECO_MSG",
            "dlm->key",
            "nodenum"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_FINALIZE_RECO_MSG",
            "dlm->key",
            "&fr",
            "sizeof(fr)",
            "nodenum",
            "&status"
          ],
          "line": 2835
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fr",
            "0",
            "sizeof(fr)"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "dlm->domain_map",
            "&iter"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "stage"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_FINALIZE_STAGE2  0x01\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\tstruct dlm_finalize_reco fr;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\tint stage = 1;\n\n\tmlog(0, \"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\", dlm->name, dlm->reco.dead_node, stage);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\nstage2:\n\tmemset(&fr, 0, sizeof(fr));\n\tfr.node_idx = dlm->node_num;\n\tfr.dead_node = dlm->reco.dead_node;\n\tif (stage == 2)\n\t\tfr.flags |= DLM_FINALIZE_STAGE2;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\t &fr, sizeof(fr), nodenum, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", ret, DLM_FINALIZE_RECO_MSG,\n\t\t\t     dlm->key, nodenum);\n\t\t\tif (dlm_is_host_down(ret)) {\n\t\t\t\t/* this has no effect on this recovery\n\t\t\t\t * session, so set the status to zero to\n\t\t\t\t * finish out the last recovery */\n\t\t\t\tmlog(ML_ERROR, \"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\", nodenum);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (stage == 1) {\n\t\t/* reset the node_iter back to the top and send finalize2 */\n\t\titer.curnode = -1;\n\t\tstage = 2;\n\t\tgoto stage2;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_begin_reco_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2733-2806",
    "snippet": "int dlm_begin_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_begin_reco *br = (struct dlm_begin_reco *)msg->buf;\n\n\t/* ok to return 0, domain has gone away */\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u) \"\n\t\t     \"but this node is in finalize state, waiting on finalize2\\n\",\n\t\t     dlm->name, br->node_idx, br->dead_node,\n\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_put(dlm);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_fire_domain_eviction_callbacks(dlm, br->dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\tif (test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\t\tmlog(0, \"%s: new_master %u died, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t} else {\n\t\t\tmlog(0, \"%s: new_master %u NOT DEAD, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t\t/* may not have seen the new master as dead yet */\n\t\t}\n\t}\n\tif (dlm->reco.dead_node != O2NM_INVALID_NODE_NUM) {\n\t\tmlog(ML_NOTICE, \"%s: dead_node previously set to %u, \"\n\t\t     \"node %u changing it to %u\\n\", dlm->name,\n\t\t     dlm->reco.dead_node, br->node_idx, br->dead_node);\n\t}\n\tdlm_set_reco_master(dlm, br->node_idx);\n\tdlm_set_reco_dead_node(dlm, br->dead_node);\n\tif (!test_bit(br->dead_node, dlm->recovery_map)) {\n\t\tmlog(0, \"recovery master %u sees %u as dead, but this \"\n\t\t     \"node has not yet.  marking %u as dead\\n\",\n\t\t     br->node_idx, br->dead_node, br->dead_node);\n\t\tif (!test_bit(br->dead_node, dlm->domain_map) ||\n\t\t    !test_bit(br->dead_node, dlm->live_nodes_map))\n\t\t\tmlog(0, \"%u not in domain/live_nodes map \"\n\t\t\t     \"so setting it in reco map manually\\n\",\n\t\t\t     br->dead_node);\n\t\t/* force the recovery cleanup in __dlm_hb_node_down\n\t\t * both of these will be cleared in a moment */\n\t\tset_bit(br->dead_node, dlm->domain_map);\n\t\tset_bit(br->dead_node, dlm->live_nodes_map);\n\t\t__dlm_hb_node_down(dlm, br->dead_node);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_kick_recovery_thread(dlm);\n\n\tmlog(0, \"%s: recovery started by node %u, for %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: recovery started by node %u, for %u (%u:%u)\\n\"",
            "dlm->name",
            "br->node_idx",
            "br->dead_node",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "191-200",
          "snippet": "void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_recovery_thread(void *data);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
            "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_hb_node_down",
          "args": [
            "dlm",
            "br->dead_node"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_hb_node_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2393-2454",
          "snippet": "static void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "br->dead_node",
            "dlm->live_nodes_map"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%u not in domain/live_nodes map \"\n\t\t\t     \"so setting it in reco map manually\\n\"",
            "br->dead_node"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "br->dead_node",
            "dlm->live_nodes_map"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"recovery master %u sees %u as dead, but this \"\n\t\t     \"node has not yet.  marking %u as dead\\n\"",
            "br->node_idx",
            "br->dead_node",
            "br->dead_node"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_dead_node",
          "args": [
            "dlm",
            "br->dead_node"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_dead_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "117-125",
          "snippet": "static inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_master",
          "args": [
            "dlm",
            "br->node_idx"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "127-134",
          "snippet": "static inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: dead_node previously set to %u, \"\n\t\t     \"node %u changing it to %u\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "br->node_idx",
            "br->dead_node"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: new_master %u NOT DEAD, changing \"\n\t\t\t     \"to %u\\n\"",
            "dlm->name",
            "dlm->reco.new_master",
            "br->node_idx"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: new_master %u died, changing \"\n\t\t\t     \"to %u\\n\"",
            "dlm->name",
            "dlm->reco.new_master",
            "br->node_idx"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_fire_domain_eviction_callbacks",
          "args": [
            "dlm",
            "br->dead_node"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_fire_domain_eviction_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2280-2290",
          "snippet": "void dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);",
            "static DECLARE_RWSEM(dlm_callback_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u wants to recover node %u (%u:%u)\\n\"",
            "dlm->name",
            "br->node_idx",
            "br->dead_node",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u wants to recover node %u (%u:%u) \"\n\t\t     \"but this node is in finalize state, waiting on finalize2\\n\"",
            "dlm->name",
            "br->node_idx",
            "br->dead_node",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nint dlm_begin_reco_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t   void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_begin_reco *br = (struct dlm_begin_reco *)msg->buf;\n\n\t/* ok to return 0, domain has gone away */\n\tif (!dlm_grab(dlm))\n\t\treturn 0;\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u) \"\n\t\t     \"but this node is in finalize state, waiting on finalize2\\n\",\n\t\t     dlm->name, br->node_idx, br->dead_node,\n\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\tspin_unlock(&dlm->spinlock);\n\t\tdlm_put(dlm);\n\t\treturn -EAGAIN;\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tmlog(0, \"%s: node %u wants to recover node %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_fire_domain_eviction_callbacks(dlm, br->dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\tif (test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\t\tmlog(0, \"%s: new_master %u died, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t} else {\n\t\t\tmlog(0, \"%s: new_master %u NOT DEAD, changing \"\n\t\t\t     \"to %u\\n\", dlm->name, dlm->reco.new_master,\n\t\t\t     br->node_idx);\n\t\t\t/* may not have seen the new master as dead yet */\n\t\t}\n\t}\n\tif (dlm->reco.dead_node != O2NM_INVALID_NODE_NUM) {\n\t\tmlog(ML_NOTICE, \"%s: dead_node previously set to %u, \"\n\t\t     \"node %u changing it to %u\\n\", dlm->name,\n\t\t     dlm->reco.dead_node, br->node_idx, br->dead_node);\n\t}\n\tdlm_set_reco_master(dlm, br->node_idx);\n\tdlm_set_reco_dead_node(dlm, br->dead_node);\n\tif (!test_bit(br->dead_node, dlm->recovery_map)) {\n\t\tmlog(0, \"recovery master %u sees %u as dead, but this \"\n\t\t     \"node has not yet.  marking %u as dead\\n\",\n\t\t     br->node_idx, br->dead_node, br->dead_node);\n\t\tif (!test_bit(br->dead_node, dlm->domain_map) ||\n\t\t    !test_bit(br->dead_node, dlm->live_nodes_map))\n\t\t\tmlog(0, \"%u not in domain/live_nodes map \"\n\t\t\t     \"so setting it in reco map manually\\n\",\n\t\t\t     br->dead_node);\n\t\t/* force the recovery cleanup in __dlm_hb_node_down\n\t\t * both of these will be cleared in a moment */\n\t\tset_bit(br->dead_node, dlm->domain_map);\n\t\tset_bit(br->dead_node, dlm->live_nodes_map);\n\t\t__dlm_hb_node_down(dlm, br->dead_node);\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_kick_recovery_thread(dlm);\n\n\tmlog(0, \"%s: recovery started by node %u, for %u (%u:%u)\\n\",\n\t     dlm->name, br->node_idx, br->dead_node,\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tdlm_put(dlm);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_send_begin_reco_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2646-2731",
    "snippet": "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_begin_reco br;\n\tint ret = 0;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\n\tmlog(0, \"%s: dead node is %u\\n\", dlm->name, dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dead_node, iter.node_map);\n\n\tmemset(&br, 0, sizeof(br));\n\tbr.node_idx = dlm->node_num;\n\tbr.dead_node = dead_node;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = 0;\n\t\tif (nodenum == dead_node) {\n\t\t\tmlog(0, \"not sending begin reco to dead node \"\n\t\t\t\t  \"%u\\n\", dead_node);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodenum == dlm->node_num) {\n\t\t\tmlog(0, \"not sending begin reco to self\\n\");\n\t\t\tcontinue;\n\t\t}\nretry:\n\t\tret = -EINVAL;\n\t\tmlog(0, \"attempting to send begin reco msg to %d\\n\",\n\t\t\t  nodenum);\n\t\tret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\t &br, sizeof(br), nodenum, &status);\n\t\t/* negative status is handled ok by caller here */\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (dlm_is_host_down(ret)) {\n\t\t\t/* node is down.  not involved in recovery\n\t\t\t * so just keep going */\n\t\t\tmlog(ML_NOTICE, \"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\", dlm->name, nodenum, ret);\n\t\t\tret = 0;\n\t\t}\n\n\t\t/*\n\t\t * Prior to commit aad1b15310b9bcd59fa81ab8f2b1513b59553ea8,\n\t\t * dlm_begin_reco_handler() returned EAGAIN and not -EAGAIN.\n\t\t * We are handling both for compatibility reasons.\n\t\t */\n\t\tif (ret == -EAGAIN || ret == EAGAIN) {\n\t\t\tmlog(0, \"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\", dlm->name,\n\t\t\t     dead_node, nodenum);\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tstruct dlm_lock_resource *res;\n\n\t\t\t/* this is now a serious problem, possibly ENOMEM\n\t\t\t * in the network stack.  must retry */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\", dlm->name, nodenum, ret);\n\t\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\t\tif (res) {\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t} else {\n\t\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t\t}\n\t\t\t/* sleep for a bit in hopes that we can avoid\n\t\t\t * another ENOMEM */\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"recovery lock not found\\n\""
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "DLM_RECOVERY_LOCK_NAME",
            "DLM_RECOVERY_LOCK_NAME_LEN"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\"",
            "dlm->name",
            "nodenum",
            "ret"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\"",
            "dlm->name",
            "dead_node",
            "nodenum"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\"",
            "dlm->name",
            "nodenum",
            "ret"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_BEGIN_RECO_MSG",
            "dlm->key",
            "&br",
            "sizeof(br)",
            "nodenum",
            "&status"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"attempting to send begin reco msg to %d\\n\"",
            "nodenum"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 2666
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&br",
            "0",
            "sizeof(br)"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "dead_node",
            "iter.node_map"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "dlm->domain_map",
            "&iter"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: dead node is %u\\n\"",
            "dlm->name",
            "dead_node"
          ],
          "line": 2654
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_begin_reco br;\n\tint ret = 0;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\n\tmlog(0, \"%s: dead node is %u\\n\", dlm->name, dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dead_node, iter.node_map);\n\n\tmemset(&br, 0, sizeof(br));\n\tbr.node_idx = dlm->node_num;\n\tbr.dead_node = dead_node;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = 0;\n\t\tif (nodenum == dead_node) {\n\t\t\tmlog(0, \"not sending begin reco to dead node \"\n\t\t\t\t  \"%u\\n\", dead_node);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodenum == dlm->node_num) {\n\t\t\tmlog(0, \"not sending begin reco to self\\n\");\n\t\t\tcontinue;\n\t\t}\nretry:\n\t\tret = -EINVAL;\n\t\tmlog(0, \"attempting to send begin reco msg to %d\\n\",\n\t\t\t  nodenum);\n\t\tret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\t &br, sizeof(br), nodenum, &status);\n\t\t/* negative status is handled ok by caller here */\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (dlm_is_host_down(ret)) {\n\t\t\t/* node is down.  not involved in recovery\n\t\t\t * so just keep going */\n\t\t\tmlog(ML_NOTICE, \"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\", dlm->name, nodenum, ret);\n\t\t\tret = 0;\n\t\t}\n\n\t\t/*\n\t\t * Prior to commit aad1b15310b9bcd59fa81ab8f2b1513b59553ea8,\n\t\t * dlm_begin_reco_handler() returned EAGAIN and not -EAGAIN.\n\t\t * We are handling both for compatibility reasons.\n\t\t */\n\t\tif (ret == -EAGAIN || ret == EAGAIN) {\n\t\t\tmlog(0, \"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\", dlm->name,\n\t\t\t     dead_node, nodenum);\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tstruct dlm_lock_resource *res;\n\n\t\t\t/* this is now a serious problem, possibly ENOMEM\n\t\t\t * in the network stack.  must retry */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\", dlm->name, nodenum, ret);\n\t\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\t\tif (res) {\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t} else {\n\t\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t\t}\n\t\t\t/* sleep for a bit in hopes that we can avoid\n\t\t\t * another ENOMEM */\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_pick_recovery_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2522-2644",
    "snippet": "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\n{\n\tenum dlm_status ret;\n\tstruct dlm_lockstatus lksb;\n\tint status = -EINVAL;\n\n\tmlog(0, \"starting recovery of %s at %lu, dead=%u, this=%u\\n\",\n\t     dlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\nagain:\n\tmemset(&lksb, 0, sizeof(lksb));\n\n\tret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\n\t\t      DLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\n\t\t      dlm_reco_ast, dlm, dlm_reco_bast);\n\n\tmlog(0, \"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\",\n\t     dlm->name, ret, lksb.status);\n\n\tif (ret == DLM_NORMAL) {\n\t\tmlog(0, \"dlm=%s dlmlock says I got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\n\t\t/* got the EX lock.  check to see if another node\n\t\t * just became the reco master */\n\t\tif (dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: got reco EX lock, but %u will \"\n\t\t\t     \"do the recovery\\n\", dlm->name,\n\t\t\t     dlm->reco.new_master);\n\t\t\tstatus = -EEXIST;\n\t\t} else {\n\t\t\tstatus = 0;\n\n\t\t\t/* see if recovery was already finished elsewhere */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tmlog(0, \"%s: got reco EX lock, but \"\n\t\t\t\t     \"node got recovered already\\n\", dlm->name);\n\t\t\t\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\t\t\t\tmlog(ML_ERROR, \"%s: new master is %u \"\n\t\t\t\t\t     \"but no dead node!\\n\",\n\t\t\t\t\t     dlm->name, dlm->reco.new_master);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* if this node has actually become the recovery master,\n\t\t * set the master and send the messages to begin recovery */\n\t\tif (!status) {\n\t\t\tmlog(0, \"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\", dlm->name,\n\t\t\t     dlm->reco.dead_node, dlm->node_num);\n\t\t\tstatus = dlm_send_begin_reco_message(dlm,\n\t\t\t\t      dlm->reco.dead_node);\n\t\t\t/* this always succeeds */\n\t\t\tBUG_ON(status);\n\n\t\t\t/* set the new_master to this node */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_set_reco_master(dlm, dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* recovery lock is a special case.  ast will not get fired,\n\t\t * so just go ahead and unlock it. */\n\t\tret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\n\t\tif (ret == DLM_DENIED) {\n\t\t\tmlog(0, \"got DLM_DENIED, trying LKM_CANCEL\\n\");\n\t\t\tret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\n\t\t}\n\t\tif (ret != DLM_NORMAL) {\n\t\t\t/* this would really suck. this could only happen\n\t\t\t * if there was a network error during the unlock\n\t\t\t * because of node death.  this means the unlock\n\t\t\t * is actually \"done\" and the lock structure is\n\t\t\t * even freed.  we can continue, but only\n\t\t\t * because this specific lock name is special. */\n\t\t\tmlog(ML_ERROR, \"dlmunlock returned %d\\n\", ret);\n\t\t}\n\t} else if (ret == DLM_NOTQUEUED) {\n\t\tmlog(0, \"dlm=%s dlmlock says another node got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\t/* another node is master. wait on\n\t\t * reco.new_master != O2NM_INVALID_NODE_NUM\n\t\t * for at most one second */\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t dlm_reco_master_ready(dlm),\n\t\t\t\t\t msecs_to_jiffies(1000));\n\t\tif (!dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: reco master taking awhile\\n\",\n\t\t\t     dlm->name);\n\t\t\tgoto again;\n\t\t}\n\t\t/* another node has informed this one that it is reco master */\n\t\tmlog(0, \"%s: reco master %u is ready to recover %u\\n\",\n\t\t     dlm->name, dlm->reco.new_master, dlm->reco.dead_node);\n\t\tstatus = -EEXIST;\n\t} else if (ret == DLM_RECOVERING) {\n\t\tmlog(0, \"dlm=%s dlmlock says master node died (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\tgoto again;\n\t} else {\n\t\tstruct dlm_lock_resource *res;\n\n\t\t/* dlmlock returned something other than NOTQUEUED or NORMAL */\n\t\tmlog(ML_ERROR, \"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\", dlm->name, dlm_errname(ret),\n\t\t     dlm_errname(lksb.status));\n\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\tif (res) {\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_lockres_put(res);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t}\n\t\tBUG();\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"recovery lock not found\\n\""
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "DLM_RECOVERY_LOCK_NAME",
            "DLM_RECOVERY_LOCK_NAME_LEN"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\"",
            "dlm->name",
            "dlm_errname(ret)",
            "dlm_errname(lksb.status)"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_errname",
          "args": [
            "lksb.status"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_errname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "237-242",
          "snippet": "const char *dlm_errname(enum dlm_status err)\n{\n\tif (err >= DLM_MAXSTATS || err < 0)\n\t\treturn dlm_errnames[DLM_MAXSTATS];\n\treturn dlm_errnames[err];\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *dlm_errnames[] = {\n\t[DLM_NORMAL] =\t\t\t\"DLM_NORMAL\",\n\t[DLM_GRANTED] =\t\t\t\"DLM_GRANTED\",\n\t[DLM_DENIED] =\t\t\t\"DLM_DENIED\",\n\t[DLM_DENIED_NOLOCKS] =\t\t\"DLM_DENIED_NOLOCKS\",\n\t[DLM_WORKING] =\t\t\t\"DLM_WORKING\",\n\t[DLM_BLOCKED] =\t\t\t\"DLM_BLOCKED\",\n\t[DLM_BLOCKED_ORPHAN] =\t\t\"DLM_BLOCKED_ORPHAN\",\n\t[DLM_DENIED_GRACE_PERIOD] =\t\"DLM_DENIED_GRACE_PERIOD\",\n\t[DLM_SYSERR] =\t\t\t\"DLM_SYSERR\",\n\t[DLM_NOSUPPORT] =\t\t\"DLM_NOSUPPORT\",\n\t[DLM_CANCELGRANT] =\t\t\"DLM_CANCELGRANT\",\n\t[DLM_IVLOCKID] =\t\t\"DLM_IVLOCKID\",\n\t[DLM_SYNC] =\t\t\t\"DLM_SYNC\",\n\t[DLM_BADTYPE] =\t\t\t\"DLM_BADTYPE\",\n\t[DLM_BADRESOURCE] =\t\t\"DLM_BADRESOURCE\",\n\t[DLM_MAXHANDLES] =\t\t\"DLM_MAXHANDLES\",\n\t[DLM_NOCLINFO] =\t\t\"DLM_NOCLINFO\",\n\t[DLM_NOLOCKMGR] =\t\t\"DLM_NOLOCKMGR\",\n\t[DLM_NOPURGED] =\t\t\"DLM_NOPURGED\",\n\t[DLM_BADARGS] =\t\t\t\"DLM_BADARGS\",\n\t[DLM_VOID] =\t\t\t\"DLM_VOID\",\n\t[DLM_NOTQUEUED] =\t\t\"DLM_NOTQUEUED\",\n\t[DLM_IVBUFLEN] =\t\t\"DLM_IVBUFLEN\",\n\t[DLM_CVTUNGRANT] =\t\t\"DLM_CVTUNGRANT\",\n\t[DLM_BADPARAM] =\t\t\"DLM_BADPARAM\",\n\t[DLM_VALNOTVALID] =\t\t\"DLM_VALNOTVALID\",\n\t[DLM_REJECTED] =\t\t\"DLM_REJECTED\",\n\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",\n\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",\n\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",\n\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",\n\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",\n\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",\n\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\",\n\t[DLM_IVGROUPID] =\t\t\"DLM_IVGROUPID\",\n\t[DLM_VERS_CONFLICT] =\t\t\"DLM_VERS_CONFLICT\",\n\t[DLM_BAD_DEVICE_PATH] =\t\t\"DLM_BAD_DEVICE_PATH\",\n\t[DLM_NO_DEVICE_PERMISSION] =\t\"DLM_NO_DEVICE_PERMISSION\",\n\t[DLM_NO_CONTROL_DEVICE ] =\t\"DLM_NO_CONTROL_DEVICE \",\n\t[DLM_RECOVERING] =\t\t\"DLM_RECOVERING\",\n\t[DLM_MIGRATING] =\t\t\"DLM_MIGRATING\",\n\t[DLM_MAXSTATS] =\t\t\"DLM_MAXSTATS\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic const char *dlm_errnames[] = {\n\t[DLM_NORMAL] =\t\t\t\"DLM_NORMAL\",\n\t[DLM_GRANTED] =\t\t\t\"DLM_GRANTED\",\n\t[DLM_DENIED] =\t\t\t\"DLM_DENIED\",\n\t[DLM_DENIED_NOLOCKS] =\t\t\"DLM_DENIED_NOLOCKS\",\n\t[DLM_WORKING] =\t\t\t\"DLM_WORKING\",\n\t[DLM_BLOCKED] =\t\t\t\"DLM_BLOCKED\",\n\t[DLM_BLOCKED_ORPHAN] =\t\t\"DLM_BLOCKED_ORPHAN\",\n\t[DLM_DENIED_GRACE_PERIOD] =\t\"DLM_DENIED_GRACE_PERIOD\",\n\t[DLM_SYSERR] =\t\t\t\"DLM_SYSERR\",\n\t[DLM_NOSUPPORT] =\t\t\"DLM_NOSUPPORT\",\n\t[DLM_CANCELGRANT] =\t\t\"DLM_CANCELGRANT\",\n\t[DLM_IVLOCKID] =\t\t\"DLM_IVLOCKID\",\n\t[DLM_SYNC] =\t\t\t\"DLM_SYNC\",\n\t[DLM_BADTYPE] =\t\t\t\"DLM_BADTYPE\",\n\t[DLM_BADRESOURCE] =\t\t\"DLM_BADRESOURCE\",\n\t[DLM_MAXHANDLES] =\t\t\"DLM_MAXHANDLES\",\n\t[DLM_NOCLINFO] =\t\t\"DLM_NOCLINFO\",\n\t[DLM_NOLOCKMGR] =\t\t\"DLM_NOLOCKMGR\",\n\t[DLM_NOPURGED] =\t\t\"DLM_NOPURGED\",\n\t[DLM_BADARGS] =\t\t\t\"DLM_BADARGS\",\n\t[DLM_VOID] =\t\t\t\"DLM_VOID\",\n\t[DLM_NOTQUEUED] =\t\t\"DLM_NOTQUEUED\",\n\t[DLM_IVBUFLEN] =\t\t\"DLM_IVBUFLEN\",\n\t[DLM_CVTUNGRANT] =\t\t\"DLM_CVTUNGRANT\",\n\t[DLM_BADPARAM] =\t\t\"DLM_BADPARAM\",\n\t[DLM_VALNOTVALID] =\t\t\"DLM_VALNOTVALID\",\n\t[DLM_REJECTED] =\t\t\"DLM_REJECTED\",\n\t[DLM_ABORT] =\t\t\t\"DLM_ABORT\",\n\t[DLM_CANCEL] =\t\t\t\"DLM_CANCEL\",\n\t[DLM_IVRESHANDLE] =\t\t\"DLM_IVRESHANDLE\",\n\t[DLM_DEADLOCK] =\t\t\"DLM_DEADLOCK\",\n\t[DLM_DENIED_NOASTS] =\t\t\"DLM_DENIED_NOASTS\",\n\t[DLM_FORWARD] =\t\t\t\"DLM_FORWARD\",\n\t[DLM_TIMEOUT] =\t\t\t\"DLM_TIMEOUT\",\n\t[DLM_IVGROUPID] =\t\t\"DLM_IVGROUPID\",\n\t[DLM_VERS_CONFLICT] =\t\t\"DLM_VERS_CONFLICT\",\n\t[DLM_BAD_DEVICE_PATH] =\t\t\"DLM_BAD_DEVICE_PATH\",\n\t[DLM_NO_DEVICE_PERMISSION] =\t\"DLM_NO_DEVICE_PERMISSION\",\n\t[DLM_NO_CONTROL_DEVICE ] =\t\"DLM_NO_CONTROL_DEVICE \",\n\t[DLM_RECOVERING] =\t\t\"DLM_RECOVERING\",\n\t[DLM_MIGRATING] =\t\t\"DLM_MIGRATING\",\n\t[DLM_MAXSTATS] =\t\t\"DLM_MAXSTATS\",\n};\n\nconst char *dlm_errname(enum dlm_status err)\n{\n\tif (err >= DLM_MAXSTATS || err < 0)\n\t\treturn dlm_errnames[DLM_MAXSTATS];\n\treturn dlm_errnames[err];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm=%s dlmlock says master node died (this=%u)\\n\"",
            "dlm->name",
            "dlm->node_num"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: reco master %u is ready to recover %u\\n\"",
            "dlm->name",
            "dlm->reco.new_master",
            "dlm->reco.dead_node"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: reco master taking awhile\\n\"",
            "dlm->name"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_reco_master_ready",
          "args": [
            "dlm"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_reco_master_ready",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "330-337",
          "snippet": "static int dlm_reco_master_ready(struct dlm_ctxt *dlm)\n{\n\tint ready;\n\tspin_lock(&dlm->spinlock);\n\tready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\n\tspin_unlock(&dlm->spinlock);\n\treturn ready;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_reco_master_ready(struct dlm_ctxt *dlm)\n{\n\tint ready;\n\tspin_lock(&dlm->spinlock);\n\tready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\n\tspin_unlock(&dlm->spinlock);\n\treturn ready;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_reco_master_ready(dlm)",
            "msecs_to_jiffies(1000)"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "1000"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmunlock",
          "args": [
            "dlm",
            "&lksb",
            "LKM_CANCEL",
            "dlm_reco_unlock_ast",
            "dlm"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "dlmunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "587-696",
          "snippet": "enum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_unlock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t\t\t struct dlm_lock *lock,\n\t\t\t\t\t\t struct dlm_lockstatus *lksb,\n\t\t\t\t\t\t int flags,\n\t\t\t\t\t\t u8 owner);\n\nenum dlm_status dlmunlock(struct dlm_ctxt *dlm, struct dlm_lockstatus *lksb,\n\t\t\t  int flags, dlm_astunlockfunc_t *unlockast, void *data)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_lock *lock = NULL;\n\tint call_ast, is_master;\n\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tif (flags & ~(LKM_CANCEL | LKM_VALBLK | LKM_INVVALBLK)) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tif ((flags & (LKM_VALBLK | LKM_CANCEL)) == (LKM_VALBLK | LKM_CANCEL)) {\n\t\tmlog(0, \"VALBLK given with CANCEL: ignoring VALBLK\\n\");\n\t\tflags &= ~LKM_VALBLK;\n\t}\n\n\tif (!lksb->lockid || !lksb->lockid->lockres) {\n\t\tdlm_error(DLM_BADPARAM);\n\t\treturn DLM_BADPARAM;\n\t}\n\n\tlock = lksb->lockid;\n\tBUG_ON(!lock);\n\tdlm_lock_get(lock);\n\n\tres = lock->lockres;\n\tBUG_ON(!res);\n\tdlm_lockres_get(res);\nretry:\n\tcall_ast = 0;\n\t/* need to retry up here because owner may have changed */\n\tmlog(0, \"lock=%p res=%p\\n\", lock, res);\n\n\tspin_lock(&res->spinlock);\n\tis_master = (res->owner == dlm->node_num);\n\tif (flags & LKM_VALBLK && lock->ml.type != LKM_EXMODE)\n\t\tflags &= ~LKM_VALBLK;\n\tspin_unlock(&res->spinlock);\n\n\tif (is_master) {\n\t\tstatus = dlmunlock_master(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_master: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t} else {\n\t\tstatus = dlmunlock_remote(dlm, res, lock, lksb, flags,\n\t\t\t\t\t  &call_ast);\n\t\tmlog(0, \"done calling dlmunlock_remote: returned %d, \"\n\t\t     \"call_ast is %d\\n\", status, call_ast);\n\t}\n\n\tif (status == DLM_RECOVERING ||\n\t    status == DLM_MIGRATING ||\n\t    status == DLM_FORWARD ||\n\t    status == DLM_NOLOCKMGR) {\n\n\t\t/* We want to go away for a tiny bit to allow recovery\n\t\t * / migration to complete on this resource. I don't\n\t\t * know of any wait queue we could sleep on as this\n\t\t * may be happening on another node. Perhaps the\n\t\t * proper solution is to queue up requests on the\n\t\t * other end? */\n\n\t\t/* do we want to yield(); ?? */\n\t\tmsleep(50);\n\n\t\tmlog(0, \"retrying unlock due to pending recovery/\"\n\t\t     \"migration/in-progress/reconnect\\n\");\n\t\tgoto retry;\n\t}\n\n\tif (call_ast) {\n\t\tmlog(0, \"calling unlockast(%p, %d)\\n\", data, status);\n\t\tif (is_master) {\n\t\t\t/* it is possible that there is one last bast\n\t\t\t * pending.  make sure it is flushed, then\n\t\t\t * call the unlockast.\n\t\t\t * not an issue if this is a mastered remotely,\n\t\t\t * since this lock has been removed from the\n\t\t\t * lockres queues and cannot be found. */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\twait_event(dlm->ast_wq,\n\t\t\t\t   dlm_lock_basts_flushed(dlm, lock));\n\t\t}\n\t\t(*unlockast)(data, status);\n\t}\n\n\tif (status == DLM_CANCELGRANT)\n\t\tstatus = DLM_NORMAL;\n\n\tif (status == DLM_NORMAL) {\n\t\tmlog(0, \"kicking the thread\\n\");\n\t\tdlm_kick_thread(dlm, res);\n\t} else\n\t\tdlm_error(status);\n\n\tdlm_lockres_calc_usage(dlm, res);\n\tdlm_lockres_put(res);\n\tdlm_lock_put(lock);\n\n\tmlog(0, \"returning status=%d!\\n\", status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_master",
          "args": [
            "dlm",
            "dlm->node_num"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "127-134",
          "snippet": "static inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_begin_reco_message",
          "args": [
            "dlm",
            "dlm->reco.dead_node"
          ],
          "line": 2576
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_begin_reco_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2646-2731",
          "snippet": "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_begin_reco br;\n\tint ret = 0;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\n\tmlog(0, \"%s: dead node is %u\\n\", dlm->name, dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dead_node, iter.node_map);\n\n\tmemset(&br, 0, sizeof(br));\n\tbr.node_idx = dlm->node_num;\n\tbr.dead_node = dead_node;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = 0;\n\t\tif (nodenum == dead_node) {\n\t\t\tmlog(0, \"not sending begin reco to dead node \"\n\t\t\t\t  \"%u\\n\", dead_node);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodenum == dlm->node_num) {\n\t\t\tmlog(0, \"not sending begin reco to self\\n\");\n\t\t\tcontinue;\n\t\t}\nretry:\n\t\tret = -EINVAL;\n\t\tmlog(0, \"attempting to send begin reco msg to %d\\n\",\n\t\t\t  nodenum);\n\t\tret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\t &br, sizeof(br), nodenum, &status);\n\t\t/* negative status is handled ok by caller here */\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (dlm_is_host_down(ret)) {\n\t\t\t/* node is down.  not involved in recovery\n\t\t\t * so just keep going */\n\t\t\tmlog(ML_NOTICE, \"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\", dlm->name, nodenum, ret);\n\t\t\tret = 0;\n\t\t}\n\n\t\t/*\n\t\t * Prior to commit aad1b15310b9bcd59fa81ab8f2b1513b59553ea8,\n\t\t * dlm_begin_reco_handler() returned EAGAIN and not -EAGAIN.\n\t\t * We are handling both for compatibility reasons.\n\t\t */\n\t\tif (ret == -EAGAIN || ret == EAGAIN) {\n\t\t\tmlog(0, \"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\", dlm->name,\n\t\t\t     dead_node, nodenum);\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tstruct dlm_lock_resource *res;\n\n\t\t\t/* this is now a serious problem, possibly ENOMEM\n\t\t\t * in the network stack.  must retry */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\", dlm->name, nodenum, ret);\n\t\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\t\tif (res) {\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t} else {\n\t\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t\t}\n\t\t\t/* sleep for a bit in hopes that we can avoid\n\t\t\t * another ENOMEM */\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_begin_reco br;\n\tint ret = 0;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\n\tmlog(0, \"%s: dead node is %u\\n\", dlm->name, dead_node);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\tclear_bit(dead_node, iter.node_map);\n\n\tmemset(&br, 0, sizeof(br));\n\tbr.node_idx = dlm->node_num;\n\tbr.dead_node = dead_node;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tret = 0;\n\t\tif (nodenum == dead_node) {\n\t\t\tmlog(0, \"not sending begin reco to dead node \"\n\t\t\t\t  \"%u\\n\", dead_node);\n\t\t\tcontinue;\n\t\t}\n\t\tif (nodenum == dlm->node_num) {\n\t\t\tmlog(0, \"not sending begin reco to self\\n\");\n\t\t\tcontinue;\n\t\t}\nretry:\n\t\tret = -EINVAL;\n\t\tmlog(0, \"attempting to send begin reco msg to %d\\n\",\n\t\t\t  nodenum);\n\t\tret = o2net_send_message(DLM_BEGIN_RECO_MSG, dlm->key,\n\t\t\t\t\t &br, sizeof(br), nodenum, &status);\n\t\t/* negative status is handled ok by caller here */\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (dlm_is_host_down(ret)) {\n\t\t\t/* node is down.  not involved in recovery\n\t\t\t * so just keep going */\n\t\t\tmlog(ML_NOTICE, \"%s: node %u was down when sending \"\n\t\t\t     \"begin reco msg (%d)\\n\", dlm->name, nodenum, ret);\n\t\t\tret = 0;\n\t\t}\n\n\t\t/*\n\t\t * Prior to commit aad1b15310b9bcd59fa81ab8f2b1513b59553ea8,\n\t\t * dlm_begin_reco_handler() returned EAGAIN and not -EAGAIN.\n\t\t * We are handling both for compatibility reasons.\n\t\t */\n\t\tif (ret == -EAGAIN || ret == EAGAIN) {\n\t\t\tmlog(0, \"%s: trying to start recovery of node \"\n\t\t\t     \"%u, but node %u is waiting for last recovery \"\n\t\t\t     \"to complete, backoff for a bit\\n\", dlm->name,\n\t\t\t     dead_node, nodenum);\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tstruct dlm_lock_resource *res;\n\n\t\t\t/* this is now a serious problem, possibly ENOMEM\n\t\t\t * in the network stack.  must retry */\n\t\t\tmlog_errno(ret);\n\t\t\tmlog(ML_ERROR, \"begin reco of dlm %s to node %u \"\n\t\t\t     \"returned %d\\n\", dlm->name, nodenum, ret);\n\t\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\t\tif (res) {\n\t\t\t\tdlm_print_one_lock_resource(res);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t} else {\n\t\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t\t}\n\t\t\t/* sleep for a bit in hopes that we can avoid\n\t\t\t * another ENOMEM */\n\t\t\tmsleep(100);\n\t\t\tgoto retry;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "dlm->node_num"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\"",
            "dlm->name",
            "ret",
            "lksb.status"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlmlock",
          "args": [
            "dlm",
            "LKM_EXMODE",
            "&lksb",
            "LKM_NOQUEUE|LKM_RECOVERY",
            "DLM_RECOVERY_LOCK_NAME",
            "DLM_RECOVERY_LOCK_NAME_LEN",
            "dlm_reco_ast",
            "dlm",
            "dlm_reco_bast"
          ],
          "line": 2533
        },
        "resolved": true,
        "details": {
          "function_name": "dlmlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "558-760",
          "snippet": "enum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nenum dlm_status dlmlock(struct dlm_ctxt *dlm, int mode,\n\t\t\tstruct dlm_lockstatus *lksb, int flags,\n\t\t\tconst char *name, int namelen, dlm_astlockfunc_t *ast,\n\t\t\tvoid *data, dlm_bastlockfunc_t *bast)\n{\n\tenum dlm_status status;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tint convert = 0, recovery = 0;\n\n\t/* yes this function is a mess.\n\t * TODO: clean this up.  lots of common code in the\n\t *       lock and convert paths, especially in the retry blocks */\n\tif (!lksb) {\n\t\tdlm_error(DLM_BADARGS);\n\t\treturn DLM_BADARGS;\n\t}\n\n\tstatus = DLM_BADPARAM;\n\tif (mode != LKM_EXMODE && mode != LKM_PRMODE && mode != LKM_NLMODE) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tif (flags & ~LKM_VALID_FLAGS) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\n\tconvert = (flags & LKM_CONVERT);\n\trecovery = (flags & LKM_RECOVERY);\n\n\tif (recovery &&\n\t    (!dlm_is_recovery_lock(name, namelen) || convert) ) {\n\t\tdlm_error(status);\n\t\tgoto error;\n\t}\n\tif (convert && (flags & LKM_LOCAL)) {\n\t\tmlog(ML_ERROR, \"strange LOCAL convert request!\\n\");\n\t\tgoto error;\n\t}\n\n\tif (convert) {\n\t\t/* CONVERT request */\n\n\t\t/* if converting, must pass in a valid dlm_lock */\n\t\tlock = lksb->lockid;\n\t\tif (!lock) {\n\t\t\tmlog(ML_ERROR, \"NULL lock pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tres = lock->lockres;\n\t\tif (!res) {\n\t\t\tmlog(ML_ERROR, \"NULL lockres pointer in convert \"\n\t\t\t     \"request\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tdlm_lockres_get(res);\n\n\t\t/* XXX: for ocfs2 purposes, the ast/bast/astdata/lksb are\n\t \t * static after the original lock call.  convert requests will\n\t\t * ensure that everything is the same, or return DLM_BADARGS.\n\t \t * this means that DLM_DENIED_NOASTS will never be returned.\n\t \t */\n\t\tif (lock->lksb != lksb || lock->ast != ast ||\n\t\t    lock->bast != bast || lock->astdata != data) {\n\t\t\tstatus = DLM_BADARGS;\n\t\t\tmlog(ML_ERROR, \"new args:  lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lksb, ast, bast, data);\n\t\t\tmlog(ML_ERROR, \"orig args: lksb=%p, ast=%p, bast=%p, \"\n\t\t\t     \"astdata=%p\\n\", lock->lksb, lock->ast,\n\t\t\t     lock->bast, lock->astdata);\n\t\t\tgoto error;\n\t\t}\nretry_convert:\n\t\tdlm_wait_for_recovery(dlm);\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmconvert_master(dlm, res, lock, flags, mode);\n\t\telse\n\t\t\tstatus = dlmconvert_remote(dlm, res, lock, flags, mode);\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\t/* for now, see how this works without sleeping\n\t\t\t * and just retry right away.  I suspect the reco\n\t\t\t * or migration will complete fast enough that\n\t\t\t * no waiting will be necessary */\n\t\t\tmlog(0, \"retrying convert with migration/recovery/\"\n\t\t\t     \"in-progress\\n\");\n\t\t\tmsleep(100);\n\t\t\tgoto retry_convert;\n\t\t}\n\t} else {\n\t\tu64 tmpcookie;\n\n\t\t/* LOCK request */\n\t\tstatus = DLM_BADARGS;\n\t\tif (!name) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tstatus = DLM_IVBUFLEN;\n\t\tif (namelen > DLM_LOCKID_NAME_MAX || namelen < 1) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tdlm_get_next_cookie(dlm->node_num, &tmpcookie);\n\t\tlock = dlm_new_lock(mode, dlm->node_num, tmpcookie, lksb);\n\t\tif (!lock) {\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (!recovery)\n\t\t\tdlm_wait_for_recovery(dlm);\n\n\t\t/* find or create the lock resource */\n\t\tres = dlm_get_lock_resource(dlm, name, namelen, flags);\n\t\tif (!res) {\n\t\t\tstatus = DLM_IVLOCKID;\n\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\n\t\tmlog(0, \"type=%d, flags = 0x%x\\n\", mode, flags);\n\t\tmlog(0, \"creating lock: lock=%p res=%p\\n\", lock, res);\n\n\t\tdlm_lock_attach_lockres(lock, res);\n\t\tlock->ast = ast;\n\t\tlock->bast = bast;\n\t\tlock->astdata = data;\n\nretry_lock:\n\t\tif (flags & LKM_VALBLK) {\n\t\t\tmlog(0, \"LKM_VALBLK passed by caller\\n\");\n\n\t\t\t/* LVB requests for non PR, PW or EX locks are\n\t\t\t * ignored. */\n\t\t\tif (mode < LKM_PRMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\n\t\tif (res->owner == dlm->node_num)\n\t\t\tstatus = dlmlock_master(dlm, res, lock, flags);\n\t\telse\n\t\t\tstatus = dlmlock_remote(dlm, res, lock, flags);\n\n\t\tif (status == DLM_RECOVERING || status == DLM_MIGRATING ||\n\t\t    status == DLM_FORWARD) {\n\t\t\tmsleep(100);\n\t\t\tif (recovery) {\n\t\t\t\tif (status != DLM_RECOVERING)\n\t\t\t\t\tgoto retry_lock;\n\t\t\t\t/* wait to see the node go down, then\n\t\t\t\t * drop down and allow the lockres to\n\t\t\t\t * get cleaned up.  need to remaster. */\n\t\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\t} else {\n\t\t\t\tdlm_wait_for_recovery(dlm);\n\t\t\t\tgoto retry_lock;\n\t\t\t}\n\t\t}\n\n\t\t/* Inflight taken in dlm_get_lock_resource() is dropped here */\n\t\tspin_lock(&res->spinlock);\n\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\n\t\tdlm_lockres_calc_usage(dlm, res);\n\t\tdlm_kick_thread(dlm, res);\n\n\t\tif (status != DLM_NORMAL) {\n\t\t\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n\t\t\tif (status != DLM_NOTQUEUED)\n\t\t\t\tdlm_error(status);\n\t\t\tgoto error;\n\t\t}\n\t}\n\nerror:\n\tif (status != DLM_NORMAL) {\n\t\tif (lock && !convert)\n\t\t\tdlm_lock_put(lock);\n\t\t// this is kind of unnecessary\n\t\tlksb->status = status;\n\t}\n\n\t/* put lockres ref from the convert path\n\t * or from dlm_get_lock_resource */\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lksb",
            "0",
            "sizeof(lksb)"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"starting recovery of %s at %lu, dead=%u, this=%u\\n\"",
            "dlm->name",
            "jiffies",
            "dlm->reco.dead_node",
            "dlm->node_num"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\n{\n\tenum dlm_status ret;\n\tstruct dlm_lockstatus lksb;\n\tint status = -EINVAL;\n\n\tmlog(0, \"starting recovery of %s at %lu, dead=%u, this=%u\\n\",\n\t     dlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\nagain:\n\tmemset(&lksb, 0, sizeof(lksb));\n\n\tret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\n\t\t      DLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\n\t\t      dlm_reco_ast, dlm, dlm_reco_bast);\n\n\tmlog(0, \"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\",\n\t     dlm->name, ret, lksb.status);\n\n\tif (ret == DLM_NORMAL) {\n\t\tmlog(0, \"dlm=%s dlmlock says I got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\n\t\t/* got the EX lock.  check to see if another node\n\t\t * just became the reco master */\n\t\tif (dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: got reco EX lock, but %u will \"\n\t\t\t     \"do the recovery\\n\", dlm->name,\n\t\t\t     dlm->reco.new_master);\n\t\t\tstatus = -EEXIST;\n\t\t} else {\n\t\t\tstatus = 0;\n\n\t\t\t/* see if recovery was already finished elsewhere */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tmlog(0, \"%s: got reco EX lock, but \"\n\t\t\t\t     \"node got recovered already\\n\", dlm->name);\n\t\t\t\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\t\t\t\tmlog(ML_ERROR, \"%s: new master is %u \"\n\t\t\t\t\t     \"but no dead node!\\n\",\n\t\t\t\t\t     dlm->name, dlm->reco.new_master);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* if this node has actually become the recovery master,\n\t\t * set the master and send the messages to begin recovery */\n\t\tif (!status) {\n\t\t\tmlog(0, \"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\", dlm->name,\n\t\t\t     dlm->reco.dead_node, dlm->node_num);\n\t\t\tstatus = dlm_send_begin_reco_message(dlm,\n\t\t\t\t      dlm->reco.dead_node);\n\t\t\t/* this always succeeds */\n\t\t\tBUG_ON(status);\n\n\t\t\t/* set the new_master to this node */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_set_reco_master(dlm, dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* recovery lock is a special case.  ast will not get fired,\n\t\t * so just go ahead and unlock it. */\n\t\tret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\n\t\tif (ret == DLM_DENIED) {\n\t\t\tmlog(0, \"got DLM_DENIED, trying LKM_CANCEL\\n\");\n\t\t\tret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\n\t\t}\n\t\tif (ret != DLM_NORMAL) {\n\t\t\t/* this would really suck. this could only happen\n\t\t\t * if there was a network error during the unlock\n\t\t\t * because of node death.  this means the unlock\n\t\t\t * is actually \"done\" and the lock structure is\n\t\t\t * even freed.  we can continue, but only\n\t\t\t * because this specific lock name is special. */\n\t\t\tmlog(ML_ERROR, \"dlmunlock returned %d\\n\", ret);\n\t\t}\n\t} else if (ret == DLM_NOTQUEUED) {\n\t\tmlog(0, \"dlm=%s dlmlock says another node got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\t/* another node is master. wait on\n\t\t * reco.new_master != O2NM_INVALID_NODE_NUM\n\t\t * for at most one second */\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t dlm_reco_master_ready(dlm),\n\t\t\t\t\t msecs_to_jiffies(1000));\n\t\tif (!dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: reco master taking awhile\\n\",\n\t\t\t     dlm->name);\n\t\t\tgoto again;\n\t\t}\n\t\t/* another node has informed this one that it is reco master */\n\t\tmlog(0, \"%s: reco master %u is ready to recover %u\\n\",\n\t\t     dlm->name, dlm->reco.new_master, dlm->reco.dead_node);\n\t\tstatus = -EEXIST;\n\t} else if (ret == DLM_RECOVERING) {\n\t\tmlog(0, \"dlm=%s dlmlock says master node died (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\tgoto again;\n\t} else {\n\t\tstruct dlm_lock_resource *res;\n\n\t\t/* dlmlock returned something other than NOTQUEUED or NORMAL */\n\t\tmlog(ML_ERROR, \"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\", dlm->name, dlm_errname(ret),\n\t\t     dlm_errname(lksb.status));\n\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\tif (res) {\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_lockres_put(res);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t}\n\t\tBUG();\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_reco_unlock_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2505-2508",
    "snippet": "static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st)\n{\n\tmlog(0, \"unlockast for recovery lock fired!\\n\");\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_reco_ast(void *astdata);",
      "static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"unlockast for recovery lock fired!\\n\""
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_reco_ast(void *astdata);\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);\n\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st)\n{\n\tmlog(0, \"unlockast for recovery lock fired!\\n\");\n}"
  },
  {
    "function_name": "dlm_reco_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2499-2504",
    "snippet": "static void dlm_reco_bast(void *astdata, int blocked_type)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"bast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_reco_ast(void *astdata);",
      "static void dlm_reco_bast(void *astdata, int blocked_type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"bast for recovery lock fired!, this=%u, dlm=%s\\n\"",
            "dlm->node_num",
            "dlm->name"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_reco_ast(void *astdata);\nstatic void dlm_reco_bast(void *astdata, int blocked_type);\n\nstatic void dlm_reco_bast(void *astdata, int blocked_type)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"bast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}"
  },
  {
    "function_name": "dlm_reco_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2493-2498",
    "snippet": "static void dlm_reco_ast(void *astdata)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"ast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_reco_ast(void *astdata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"ast for recovery lock fired!, this=%u, dlm=%s\\n\"",
            "dlm->node_num",
            "dlm->name"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_reco_ast(void *astdata);\n\nstatic void dlm_reco_ast(void *astdata)\n{\n\tstruct dlm_ctxt *dlm = astdata;\n\tmlog(0, \"ast for recovery lock fired!, this=%u, dlm=%s\\n\",\n\t     dlm->node_num, dlm->name);\n}"
  },
  {
    "function_name": "dlm_hb_node_up_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2477-2491",
    "snippet": "void dlm_hb_node_up_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(idx, dlm->live_nodes_map);\n\t/* do NOT notify mle attached to the heartbeat events.\n\t * new nodes are not interesting in mastery until joined. */\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "idx",
            "dlm->live_nodes_map"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_hb_node_up_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\tspin_lock(&dlm->spinlock);\n\tset_bit(idx, dlm->live_nodes_map);\n\t/* do NOT notify mle attached to the heartbeat events.\n\t * new nodes are not interesting in mastery until joined. */\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}"
  },
  {
    "function_name": "dlm_hb_node_down_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2456-2475",
    "snippet": "void dlm_hb_node_down_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\t/*\n\t * This will notify any dlm users that a node in our domain\n\t * went away without notifying us first.\n\t */\n\tif (test_bit(idx, dlm->domain_map))\n\t\tdlm_fire_domain_eviction_callbacks(dlm, idx);\n\n\tspin_lock(&dlm->spinlock);\n\t__dlm_hb_node_down(dlm, idx);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_hb_node_down",
          "args": [
            "dlm",
            "idx"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_hb_node_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2393-2454",
          "snippet": "static void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_fire_domain_eviction_callbacks",
          "args": [
            "dlm",
            "idx"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_fire_domain_eviction_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "2280-2290",
          "snippet": "void dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);",
            "static DECLARE_RWSEM(dlm_callback_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\nstatic DECLARE_RWSEM(dlm_callback_sem);\n\nvoid dlm_fire_domain_eviction_callbacks(struct dlm_ctxt *dlm,\n\t\t\t\t\tint node_num)\n{\n\tstruct dlm_eviction_cb *cb;\n\n\tdown_read(&dlm_callback_sem);\n\tlist_for_each_entry(cb, &dlm->dlm_eviction_callbacks, ec_item) {\n\t\tcb->ec_func(node_num, cb->ec_data);\n\t}\n\tup_read(&dlm_callback_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "idx",
            "dlm->domain_map"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_hb_node_down_cb(struct o2nm_node *node, int idx, void *data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\n\tif (!dlm_grab(dlm))\n\t\treturn;\n\n\t/*\n\t * This will notify any dlm users that a node in our domain\n\t * went away without notifying us first.\n\t */\n\tif (test_bit(idx, dlm->domain_map))\n\t\tdlm_fire_domain_eviction_callbacks(dlm, idx);\n\n\tspin_lock(&dlm->spinlock);\n\t__dlm_hb_node_down(dlm, idx);\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n}"
  },
  {
    "function_name": "__dlm_hb_node_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2393-2454",
    "snippet": "static void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "idx",
            "dlm->recovery_map"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "byte_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "55-58",
          "snippet": "static inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline void byte_set_bit(u8 nr, u8 map[])\n{\n\tmap[nr >> 3] |= (1UL << (nr & 7));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\"",
            "dlm->name",
            "idx"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "idx",
            "dlm->recovery_map"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->migration_wq"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "idx",
            "dlm->exit_domain_map"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u being removed from domain map!\\n\"",
            "idx"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_hb_event_notify_attached",
          "args": [
            "dlm",
            "idx",
            "0"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_hb_event_notify_attached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "361-373",
          "snippet": "void dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);",
            "static void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);",
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_mle_node_down(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_master_list_entry *mle,\n\t\t\t      struct o2nm_node *node,\n\t\t\t      int idx);\nstatic void dlm_mle_node_up(struct dlm_ctxt *dlm,\n\t\t\t    struct dlm_master_list_entry *mle,\n\t\t\t    struct o2nm_node *node,\n\t\t\t    int idx);\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nvoid dlm_hb_event_notify_attached(struct dlm_ctxt *dlm, int idx, int node_up)\n{\n\tstruct dlm_master_list_entry *mle;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry(mle, &dlm->mle_hb_events, hb_events) {\n\t\tif (node_up)\n\t\t\tdlm_mle_node_up(dlm, mle, NULL, idx);\n\t\telse\n\t\t\tdlm_mle_node_down(dlm, mle, NULL, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_do_local_recovery_cleanup",
          "args": [
            "dlm",
            "idx"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_local_recovery_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2311-2391",
          "snippet": "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_lock_resource *res;\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock *lock;\n\n\n\t/* purge any stale mles */\n\tdlm_clean_master_list(dlm, dead_node);\n\n\t/*\n\t * now clean up all lock resources.  there are two rules:\n\t *\n\t * 1) if the dead node was the master, move the lockres\n\t *    to the recovering list.  set the RECOVERING flag.\n\t *    this lockres needs to be cleaned up before it can\n\t *    be used further.\n\t *\n\t * 2) if this node was the master, remove all locks from\n\t *    each of the lockres queues that were owned by the\n\t *    dead node.  once recovery finishes, the dlm thread\n\t *    can be kicked again to see if any ASTs or BASTs\n\t *    need to be fired as a result.\n\t */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n \t\t\t/* always prune any $RECOVERY entries for dead nodes,\n \t\t\t * otherwise hangs can occur during later recovery */\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\t/* Can't schedule\n\t\t\t\t\t\t * DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t\t * - do manually */\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* zero the lvb if necessary */\n\t\t\tdlm_revalidate_lvb(dlm, res, dead_node);\n\t\t\tif (res->owner == dead_node) {\n\t\t\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\t\t\tmlog(ML_NOTICE, \"%s: res %.*s, Skip \"\n\t\t\t\t\t     \"recovery as it is being freed\\n\",\n\t\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t\t     res->lockname.name);\n\t\t\t\t} else\n\t\t\t\t\tdlm_move_lockres_to_recovery_list(dlm,\n\t\t\t\t\t\t\t\t\t  res);\n\n\t\t\t} else if (res->owner == dlm->node_num) {\n\t\t\t\tdlm_free_dead_locks(dlm, res, dead_node);\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\tif (test_bit(dead_node, res->refmap)) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_lock_resource *res;\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock *lock;\n\n\n\t/* purge any stale mles */\n\tdlm_clean_master_list(dlm, dead_node);\n\n\t/*\n\t * now clean up all lock resources.  there are two rules:\n\t *\n\t * 1) if the dead node was the master, move the lockres\n\t *    to the recovering list.  set the RECOVERING flag.\n\t *    this lockres needs to be cleaned up before it can\n\t *    be used further.\n\t *\n\t * 2) if this node was the master, remove all locks from\n\t *    each of the lockres queues that were owned by the\n\t *    dead node.  once recovery finishes, the dlm thread\n\t *    can be kicked again to see if any ASTs or BASTs\n\t *    need to be fired as a result.\n\t */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n \t\t\t/* always prune any $RECOVERY entries for dead nodes,\n \t\t\t * otherwise hangs can occur during later recovery */\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\t/* Can't schedule\n\t\t\t\t\t\t * DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t\t * - do manually */\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* zero the lvb if necessary */\n\t\t\tdlm_revalidate_lvb(dlm, res, dead_node);\n\t\t\tif (res->owner == dead_node) {\n\t\t\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\t\t\tmlog(ML_NOTICE, \"%s: res %.*s, Skip \"\n\t\t\t\t\t     \"recovery as it is being freed\\n\",\n\t\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t\t     res->lockname.name);\n\t\t\t\t} else\n\t\t\t\t\tdlm_move_lockres_to_recovery_list(dlm,\n\t\t\t\t\t\t\t\t\t  res);\n\n\t\t\t} else if (res->owner == dlm->node_num) {\n\t\t\t\tdlm_free_dead_locks(dlm, res, dead_node);\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\tif (test_bit(dead_node, res->refmap)) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_set_joining_node",
          "args": [
            "dlm",
            "DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 2414
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_set_joining_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "267-274",
          "snippet": "static inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void __dlm_set_joining_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tdlm->joining_node = node;\n\twake_up(&dlm->dlm_join_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_reset_recovery",
          "args": [
            "dlm"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_reset_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "136-142",
          "snippet": "static inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void __dlm_hb_node_down(struct dlm_ctxt *dlm, int idx)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\n\tif (dlm->reco.new_master == idx) {\n\t\tmlog(0, \"%s: recovery master %d just died\\n\",\n\t\t     dlm->name, idx);\n\t\tif (dlm->reco.state & DLM_RECO_STATE_FINALIZE) {\n\t\t\t/* finalize1 was reached, so it is safe to clear\n\t\t\t * the new_master and dead_node.  that recovery\n\t\t\t * is complete. */\n\t\t\tmlog(0, \"%s: dead master %d had reached \"\n\t\t\t     \"finalize1 state, clearing\\n\", dlm->name, idx);\n\t\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\t\t__dlm_reset_recovery(dlm);\n\t\t}\n\t}\n\n\t/* Clean up join state on node death. */\n\tif (dlm->joining_node == idx) {\n\t\tmlog(0, \"Clearing join state for node %u\\n\", idx);\n\t\t__dlm_set_joining_node(dlm, DLM_LOCK_RES_OWNER_UNKNOWN);\n\t}\n\n\t/* check to see if the node is already considered dead */\n\tif (!test_bit(idx, dlm->live_nodes_map)) {\n\t\tmlog(0, \"for domain %s, node %d is already dead. \"\n\t\t     \"another node likely did recovery already.\\n\",\n\t\t     dlm->name, idx);\n\t\treturn;\n\t}\n\n\t/* check to see if we do not care about this node */\n\tif (!test_bit(idx, dlm->domain_map)) {\n\t\t/* This also catches the case that we get a node down\n\t\t * but haven't joined the domain yet. */\n\t\tmlog(0, \"node %u already removed from domain!\\n\", idx);\n\t\treturn;\n\t}\n\n\tclear_bit(idx, dlm->live_nodes_map);\n\n\t/* make sure local cleanup occurs before the heartbeat events */\n\tif (!test_bit(idx, dlm->recovery_map))\n\t\tdlm_do_local_recovery_cleanup(dlm, idx);\n\n\t/* notify anything attached to the heartbeat events */\n\tdlm_hb_event_notify_attached(dlm, idx, 0);\n\n\tmlog(0, \"node %u being removed from domain map!\\n\", idx);\n\tclear_bit(idx, dlm->domain_map);\n\tclear_bit(idx, dlm->exit_domain_map);\n\t/* wake up migration waiters if a node goes down.\n\t * perhaps later we can genericize this for other waiters. */\n\twake_up(&dlm->migration_wq);\n\n\tif (test_bit(idx, dlm->recovery_map))\n\t\tmlog(0, \"domain %s, node %u already added \"\n\t\t     \"to recovery map!\\n\", dlm->name, idx);\n\telse\n\t\tset_bit(idx, dlm->recovery_map);\n}"
  },
  {
    "function_name": "dlm_do_local_recovery_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2311-2391",
    "snippet": "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_lock_resource *res;\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock *lock;\n\n\n\t/* purge any stale mles */\n\tdlm_clean_master_list(dlm, dead_node);\n\n\t/*\n\t * now clean up all lock resources.  there are two rules:\n\t *\n\t * 1) if the dead node was the master, move the lockres\n\t *    to the recovering list.  set the RECOVERING flag.\n\t *    this lockres needs to be cleaned up before it can\n\t *    be used further.\n\t *\n\t * 2) if this node was the master, remove all locks from\n\t *    each of the lockres queues that were owned by the\n\t *    dead node.  once recovery finishes, the dlm thread\n\t *    can be kicked again to see if any ASTs or BASTs\n\t *    need to be fired as a result.\n\t */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n \t\t\t/* always prune any $RECOVERY entries for dead nodes,\n \t\t\t * otherwise hangs can occur during later recovery */\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\t/* Can't schedule\n\t\t\t\t\t\t * DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t\t * - do manually */\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* zero the lvb if necessary */\n\t\t\tdlm_revalidate_lvb(dlm, res, dead_node);\n\t\t\tif (res->owner == dead_node) {\n\t\t\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\t\t\tmlog(ML_NOTICE, \"%s: res %.*s, Skip \"\n\t\t\t\t\t     \"recovery as it is being freed\\n\",\n\t\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t\t     res->lockname.name);\n\t\t\t\t} else\n\t\t\t\t\tdlm_move_lockres_to_recovery_list(dlm,\n\t\t\t\t\t\t\t\t\t  res);\n\n\t\t\t} else if (res->owner == dlm->node_num) {\n\t\t\t\tdlm_free_dead_locks(dlm, res, dead_node);\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\tif (test_bit(dead_node, res->refmap)) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_clear_refmap_bit",
          "args": [
            "dlm",
            "res",
            "dead_node"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_clear_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "644-653",
          "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dead_node"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "dead_node",
            "res->refmap"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_calc_usage",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_calc_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "124-148",
          "snippet": "void __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_lockres_calc_usage(struct dlm_ctxt *dlm,\n\t\t\t      struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (__dlm_lockres_unused(res)){\n\t\tif (list_empty(&res->purge)) {\n\t\t\tmlog(0, \"%s: Adding res %.*s to purge list\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\t\tres->last_used = jiffies;\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->purge, &dlm->purge_list);\n\t\t\tdlm->purge_count++;\n\t\t}\n\t} else if (!list_empty(&res->purge)) {\n\t\tmlog(0, \"%s: Removing res %.*s from purge list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\n\t\tlist_del_init(&res->purge);\n\t\tdlm_lockres_put(res);\n\t\tdlm->purge_count--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_free_dead_locks",
          "args": [
            "dlm",
            "res",
            "dead_node"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_free_dead_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2237-2302",
          "snippet": "static void dlm_free_dead_locks(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct dlm_lock *lock, *next;\n\tunsigned int freed = 0;\n\n\t/* this node is the lockres master:\n\t * 1) remove any stale locks for the dead node\n\t * 2) if the dead node had an EX when he died, blank out the lvb\n\t */\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* We do two dlm_lock_put(). One for removing from list and the other is\n\t * to force the DLM_UNLOCK_FREE_LOCK action so as to free the locks */\n\n\t/* TODO: check pending_asts, pending_basts here */\n\tlist_for_each_entry_safe(lock, next, &res->granted, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->converting, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->blocked, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\n\tif (freed) {\n\t\tmlog(0, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\tif(!test_bit(dead_node, res->refmap)) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\t\t__dlm_print_one_lock_resource(res);\n\t\t}\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t} else if (test_bit(dead_node, res->refmap)) {\n\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t}\n\n\t/* do not kick thread yet */\n\t__dlm_dirty_lockres(dlm, res);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_free_dead_locks(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct dlm_lock *lock, *next;\n\tunsigned int freed = 0;\n\n\t/* this node is the lockres master:\n\t * 1) remove any stale locks for the dead node\n\t * 2) if the dead node had an EX when he died, blank out the lvb\n\t */\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* We do two dlm_lock_put(). One for removing from list and the other is\n\t * to force the DLM_UNLOCK_FREE_LOCK action so as to free the locks */\n\n\t/* TODO: check pending_asts, pending_basts here */\n\tlist_for_each_entry_safe(lock, next, &res->granted, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->converting, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->blocked, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\n\tif (freed) {\n\t\tmlog(0, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\tif(!test_bit(dead_node, res->refmap)) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\t\t__dlm_print_one_lock_resource(res);\n\t\t}\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t} else if (test_bit(dead_node, res->refmap)) {\n\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t}\n\n\t/* do not kick thread yet */\n\t__dlm_dirty_lockres(dlm, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_move_lockres_to_recovery_list",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_move_lockres_to_recovery_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2035-2113",
          "snippet": "void dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: res %.*s, Skip \"\n\t\t\t\t\t     \"recovery as it is being freed\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_revalidate_lvb",
          "args": [
            "dlm",
            "res",
            "dead_node"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_revalidate_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2194-2235",
          "snippet": "static void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tint blank_lvb = 0, local = 0;\n\tint i;\n\tu8 search_node;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->owner == dlm->node_num)\n\t\t/* if this node owned the lockres, and if the dead node\n\t\t * had an EX when he died, blank out the lvb */\n\t\tsearch_node = dead_node;\n\telse {\n\t\t/* if this is a secondary lockres, and we had no EX or PR\n\t\t * locks granted, we can no longer trust the lvb */\n\t\tsearch_node = dlm->node_num;\n\t\tlocal = 1;  /* check local state for valid lvb */\n\t}\n\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == search_node) {\n\t\t\t\tif (dlm_lvb_needs_invalidation(lock, local)) {\n\t\t\t\t\t/* zero the lksb lvb and lockres lvb */\n\t\t\t\t\tblank_lvb = 1;\n\t\t\t\t\tmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blank_lvb) {\n\t\tmlog(0, \"clearing %.*s lvb, dead node %u had EX\\n\",\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tint blank_lvb = 0, local = 0;\n\tint i;\n\tu8 search_node;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->owner == dlm->node_num)\n\t\t/* if this node owned the lockres, and if the dead node\n\t\t * had an EX when he died, blank out the lvb */\n\t\tsearch_node = dead_node;\n\telse {\n\t\t/* if this is a secondary lockres, and we had no EX or PR\n\t\t * locks granted, we can no longer trust the lvb */\n\t\tsearch_node = dlm->node_num;\n\t\tlocal = 1;  /* check local state for valid lvb */\n\t}\n\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == search_node) {\n\t\t\t\tif (dlm_lvb_needs_invalidation(lock, local)) {\n\t\t\t\t\t/* zero the lksb lvb and lockres lvb */\n\t\t\t\t\tblank_lvb = 1;\n\t\t\t\t\tmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blank_lvb) {\n\t\tmlog(0, \"clearing %.*s lvb, dead node %u had EX\\n\",\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\"",
            "dead_node",
            "dlm->name"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->granted",
            "list"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "res",
            "bucket",
            "hash_node"
          ],
          "line": 2338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_clean_master_list",
          "args": [
            "dlm",
            "dead_node"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clean_master_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3246-3319",
          "snippet": "void dlm_clean_master_list(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tmlog(0, \"dlm=%s, dead node=%u\\n\", dlm->name, dead_node);\ntop:\n\tassert_spin_locked(&dlm->spinlock);\n\n\t/* clean the master list */\n\tspin_lock(&dlm->master_lock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t\t\t       mle->type != DLM_MLE_MASTER &&\n\t\t\t       mle->type != DLM_MLE_MIGRATION);\n\n\t\t\t/* MASTER mles are initiated locally. The waiting\n\t\t\t * process will notice the node map change shortly.\n\t\t\t * Let that happen as normal. */\n\t\t\tif (mle->type == DLM_MLE_MASTER)\n\t\t\t\tcontinue;\n\n\t\t\t/* BLOCK mles are initiated by other nodes. Need to\n\t\t\t * clean up if the dead node would have been the\n\t\t\t * master. */\n\t\t\tif (mle->type == DLM_MLE_BLOCK) {\n\t\t\t\tdlm_clean_block_mle(dlm, mle, dead_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Everything else is a MIGRATION mle */\n\n\t\t\t/* The rule for MIGRATION mles is that the master\n\t\t\t * becomes UNKNOWN if *either* the original or the new\n\t\t\t * master dies. All UNKNOWN lockres' are sent to\n\t\t\t * whichever node becomes the recovery master. The new\n\t\t\t * master is responsible for determining if there is\n\t\t\t * still a master for this lockres, or if he needs to\n\t\t\t * take over mastery. Either way, this node should\n\t\t\t * expect another message to resolve this. */\n\n\t\t\tif (mle->master != dead_node &&\n\t\t\t    mle->new_master != dead_node)\n\t\t\t\tcontinue;\n\n\t\t\t/* If we have reached this point, this mle needs to be\n\t\t\t * removed from the list and freed. */\n\t\t\tdlm_clean_migration_mle(dlm, mle);\n\n\t\t\tmlog(0, \"%s: node %u died during migration from \"\n\t\t\t     \"%u to %u!\\n\", dlm->name, dead_node, mle->master,\n\t\t\t     mle->new_master);\n\n\t\t\t/* If we find a lockres associated with the mle, we've\n\t\t\t * hit this rare case that messes up our lock ordering.\n\t\t\t * If so, we need to drop the master lock so that we can\n\t\t\t * take the lockres lock, meaning that we will have to\n\t\t\t * restart from the head of list. */\n\t\t\tres = dlm_reset_mleres_owner(dlm, mle);\n\t\t\tif (res)\n\t\t\t\t/* restart */\n\t\t\t\tgoto top;\n\n\t\t\t/* This may be the last reference */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_clean_master_list(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_master_list_entry *mle;\n\tstruct dlm_lock_resource *res;\n\tstruct hlist_head *bucket;\n\tstruct hlist_node *tmp;\n\tunsigned int i;\n\n\tmlog(0, \"dlm=%s, dead node=%u\\n\", dlm->name, dead_node);\ntop:\n\tassert_spin_locked(&dlm->spinlock);\n\n\t/* clean the master list */\n\tspin_lock(&dlm->master_lock);\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_master_hash(dlm, i);\n\t\thlist_for_each_entry_safe(mle, tmp, bucket, master_hash_node) {\n\t\t\tBUG_ON(mle->type != DLM_MLE_BLOCK &&\n\t\t\t       mle->type != DLM_MLE_MASTER &&\n\t\t\t       mle->type != DLM_MLE_MIGRATION);\n\n\t\t\t/* MASTER mles are initiated locally. The waiting\n\t\t\t * process will notice the node map change shortly.\n\t\t\t * Let that happen as normal. */\n\t\t\tif (mle->type == DLM_MLE_MASTER)\n\t\t\t\tcontinue;\n\n\t\t\t/* BLOCK mles are initiated by other nodes. Need to\n\t\t\t * clean up if the dead node would have been the\n\t\t\t * master. */\n\t\t\tif (mle->type == DLM_MLE_BLOCK) {\n\t\t\t\tdlm_clean_block_mle(dlm, mle, dead_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Everything else is a MIGRATION mle */\n\n\t\t\t/* The rule for MIGRATION mles is that the master\n\t\t\t * becomes UNKNOWN if *either* the original or the new\n\t\t\t * master dies. All UNKNOWN lockres' are sent to\n\t\t\t * whichever node becomes the recovery master. The new\n\t\t\t * master is responsible for determining if there is\n\t\t\t * still a master for this lockres, or if he needs to\n\t\t\t * take over mastery. Either way, this node should\n\t\t\t * expect another message to resolve this. */\n\n\t\t\tif (mle->master != dead_node &&\n\t\t\t    mle->new_master != dead_node)\n\t\t\t\tcontinue;\n\n\t\t\t/* If we have reached this point, this mle needs to be\n\t\t\t * removed from the list and freed. */\n\t\t\tdlm_clean_migration_mle(dlm, mle);\n\n\t\t\tmlog(0, \"%s: node %u died during migration from \"\n\t\t\t     \"%u to %u!\\n\", dlm->name, dead_node, mle->master,\n\t\t\t     mle->new_master);\n\n\t\t\t/* If we find a lockres associated with the mle, we've\n\t\t\t * hit this rare case that messes up our lock ordering.\n\t\t\t * If so, we need to drop the master lock so that we can\n\t\t\t * take the lockres lock, meaning that we will have to\n\t\t\t * restart from the head of list. */\n\t\t\tres = dlm_reset_mleres_owner(dlm, mle);\n\t\t\tif (res)\n\t\t\t\t/* restart */\n\t\t\t\tgoto top;\n\n\t\t\t/* This may be the last reference */\n\t\t\t__dlm_put_mle(mle);\n\t\t}\n\t}\n\tspin_unlock(&dlm->master_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_lock_resource *res;\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock *lock;\n\n\n\t/* purge any stale mles */\n\tdlm_clean_master_list(dlm, dead_node);\n\n\t/*\n\t * now clean up all lock resources.  there are two rules:\n\t *\n\t * 1) if the dead node was the master, move the lockres\n\t *    to the recovering list.  set the RECOVERING flag.\n\t *    this lockres needs to be cleaned up before it can\n\t *    be used further.\n\t *\n\t * 2) if this node was the master, remove all locks from\n\t *    each of the lockres queues that were owned by the\n\t *    dead node.  once recovery finishes, the dlm thread\n\t *    can be kicked again to see if any ASTs or BASTs\n\t *    need to be fired as a result.\n\t */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n \t\t\t/* always prune any $RECOVERY entries for dead nodes,\n \t\t\t * otherwise hangs can occur during later recovery */\n\t\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t\t res->lockname.len)) {\n\t\t\t\tspin_lock(&res->spinlock);\n\t\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\t/* Can't schedule\n\t\t\t\t\t\t * DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t\t * - do manually */\n\t\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* zero the lvb if necessary */\n\t\t\tdlm_revalidate_lvb(dlm, res, dead_node);\n\t\t\tif (res->owner == dead_node) {\n\t\t\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\t\t\tmlog(ML_NOTICE, \"%s: res %.*s, Skip \"\n\t\t\t\t\t     \"recovery as it is being freed\\n\",\n\t\t\t\t\t     dlm->name, res->lockname.len,\n\t\t\t\t\t     res->lockname.name);\n\t\t\t\t} else\n\t\t\t\t\tdlm_move_lockres_to_recovery_list(dlm,\n\t\t\t\t\t\t\t\t\t  res);\n\n\t\t\t} else if (res->owner == dlm->node_num) {\n\t\t\t\tdlm_free_dead_locks(dlm, res, dead_node);\n\t\t\t\t__dlm_lockres_calc_usage(dlm, res);\n\t\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\t\tif (test_bit(dead_node, res->refmap)) {\n\t\t\t\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t\t\t\t\t\"no locks and had not purged before dying\\n\",\n\t\t\t\t\t\tdlm->name, res->lockname.len,\n\t\t\t\t\t\tres->lockname.name, dead_node);\n\t\t\t\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t}\n\t}\n\n}"
  },
  {
    "function_name": "dlm_free_dead_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2237-2302",
    "snippet": "static void dlm_free_dead_locks(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct dlm_lock *lock, *next;\n\tunsigned int freed = 0;\n\n\t/* this node is the lockres master:\n\t * 1) remove any stale locks for the dead node\n\t * 2) if the dead node had an EX when he died, blank out the lvb\n\t */\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* We do two dlm_lock_put(). One for removing from list and the other is\n\t * to force the DLM_UNLOCK_FREE_LOCK action so as to free the locks */\n\n\t/* TODO: check pending_asts, pending_basts here */\n\tlist_for_each_entry_safe(lock, next, &res->granted, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->converting, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->blocked, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\n\tif (freed) {\n\t\tmlog(0, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\tif(!test_bit(dead_node, res->refmap)) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\t\t__dlm_print_one_lock_resource(res);\n\t\t}\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t} else if (test_bit(dead_node, res->refmap)) {\n\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t}\n\n\t/* do not kick thread yet */\n\t__dlm_dirty_lockres(dlm, res);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_dirty_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_dirty_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "457-478",
          "snippet": "void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_clear_refmap_bit",
          "args": [
            "dlm",
            "res",
            "dead_node"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_clear_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "644-653",
          "snippet": "void dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_clear_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, clr node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tclear_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dead_node"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "dead_node",
            "res->refmap"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "freed",
            "dead_node"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "freed",
            "dead_node"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lock",
            "next",
            "&res->blocked",
            "list"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lock",
            "next",
            "&res->converting",
            "list"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lock",
            "next",
            "&res->granted",
            "list"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_free_dead_locks(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct dlm_lock *lock, *next;\n\tunsigned int freed = 0;\n\n\t/* this node is the lockres master:\n\t * 1) remove any stale locks for the dead node\n\t * 2) if the dead node had an EX when he died, blank out the lvb\n\t */\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* We do two dlm_lock_put(). One for removing from list and the other is\n\t * to force the DLM_UNLOCK_FREE_LOCK action so as to free the locks */\n\n\t/* TODO: check pending_asts, pending_basts here */\n\tlist_for_each_entry_safe(lock, next, &res->granted, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->converting, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\tlist_for_each_entry_safe(lock, next, &res->blocked, list) {\n\t\tif (lock->ml.node == dead_node) {\n\t\t\tlist_del_init(&lock->list);\n\t\t\tdlm_lock_put(lock);\n\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK - do manually */\n\t\t\tdlm_lock_put(lock);\n\t\t\tfreed++;\n\t\t}\n\t}\n\n\tif (freed) {\n\t\tmlog(0, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t     \"dropping ref from lockres\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\tif(!test_bit(dead_node, res->refmap)) {\n\t\t\tmlog(ML_ERROR, \"%s:%.*s: freed %u locks for dead node %u, \"\n\t\t\t     \"but ref was not set\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, freed, dead_node);\n\t\t\t__dlm_print_one_lock_resource(res);\n\t\t}\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t} else if (test_bit(dead_node, res->refmap)) {\n\t\tmlog(0, \"%s:%.*s: dead node %u had a ref, but had \"\n\t\t     \"no locks and had not purged before dying\\n\", dlm->name,\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tdlm_lockres_clear_refmap_bit(dlm, res, dead_node);\n\t}\n\n\t/* do not kick thread yet */\n\t__dlm_dirty_lockres(dlm, res);\n}"
  },
  {
    "function_name": "dlm_revalidate_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2194-2235",
    "snippet": "static void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tint blank_lvb = 0, local = 0;\n\tint i;\n\tu8 search_node;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->owner == dlm->node_num)\n\t\t/* if this node owned the lockres, and if the dead node\n\t\t * had an EX when he died, blank out the lvb */\n\t\tsearch_node = dead_node;\n\telse {\n\t\t/* if this is a secondary lockres, and we had no EX or PR\n\t\t * locks granted, we can no longer trust the lvb */\n\t\tsearch_node = dlm->node_num;\n\t\tlocal = 1;  /* check local state for valid lvb */\n\t}\n\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == search_node) {\n\t\t\t\tif (dlm_lvb_needs_invalidation(lock, local)) {\n\t\t\t\t\t/* zero the lksb lvb and lockres lvb */\n\t\t\t\t\tblank_lvb = 1;\n\t\t\t\t\tmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blank_lvb) {\n\t\tmlog(0, \"clearing %.*s lvb, dead node %u had EX\\n\",\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "res->lvb",
            "0",
            "DLM_LVB_LEN"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"clearing %.*s lvb, dead node %u had EX\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "dead_node"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lock->lksb->lvb",
            "0",
            "DLM_LVB_LEN"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lvb_needs_invalidation",
          "args": [
            "lock",
            "local"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lvb_needs_invalidation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2183-2192",
          "snippet": "static inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\n{\n\tif (local) {\n\t\tif (lock->ml.type != LKM_EXMODE &&\n\t\t    lock->ml.type != LKM_PRMODE)\n\t\t\treturn 1;\n\t} else if (lock->ml.type == LKM_EXMODE)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\n{\n\tif (local) {\n\t\tif (lock->ml.type != LKM_EXMODE &&\n\t\t    lock->ml.type != LKM_PRMODE)\n\t\t\treturn 1;\n\t} else if (lock->ml.type == LKM_EXMODE)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "i"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_revalidate_lvb(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res, u8 dead_node)\n{\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock;\n\tint blank_lvb = 0, local = 0;\n\tint i;\n\tu8 search_node;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->owner == dlm->node_num)\n\t\t/* if this node owned the lockres, and if the dead node\n\t\t * had an EX when he died, blank out the lvb */\n\t\tsearch_node = dead_node;\n\telse {\n\t\t/* if this is a secondary lockres, and we had no EX or PR\n\t\t * locks granted, we can no longer trust the lvb */\n\t\tsearch_node = dlm->node_num;\n\t\tlocal = 1;  /* check local state for valid lvb */\n\t}\n\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_CONVERTING_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.node == search_node) {\n\t\t\t\tif (dlm_lvb_needs_invalidation(lock, local)) {\n\t\t\t\t\t/* zero the lksb lvb and lockres lvb */\n\t\t\t\t\tblank_lvb = 1;\n\t\t\t\t\tmemset(lock->lksb->lvb, 0, DLM_LVB_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (blank_lvb) {\n\t\tmlog(0, \"clearing %.*s lvb, dead node %u had EX\\n\",\n\t\t     res->lockname.len, res->lockname.name, dead_node);\n\t\tmemset(res->lvb, 0, DLM_LVB_LEN);\n\t}\n}"
  },
  {
    "function_name": "dlm_lvb_needs_invalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2183-2192",
    "snippet": "static inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\n{\n\tif (local) {\n\t\tif (lock->ml.type != LKM_EXMODE &&\n\t\t    lock->ml.type != LKM_PRMODE)\n\t\t\treturn 1;\n\t} else if (lock->ml.type == LKM_EXMODE)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_lvb_needs_invalidation(struct dlm_lock *lock, int local)\n{\n\tif (local) {\n\t\tif (lock->ml.type != LKM_EXMODE &&\n\t\t    lock->ml.type != LKM_PRMODE)\n\t\t\treturn 1;\n\t} else if (lock->ml.type == LKM_EXMODE)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_finish_local_lockres_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2120-2181",
    "snippet": "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_dirty_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_dirty_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "457-478",
          "snippet": "void __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid __dlm_dirty_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\n\t/* don't shuffle secondary queues */\n\tif ((res->owner == dlm->node_num)) {\n\t\tif (res->state & (DLM_LOCK_RES_MIGRATING |\n\t\t\t\t  DLM_LOCK_RES_BLOCK_DIRTY))\n\t\t    return;\n\n\t\tif (list_empty(&res->dirty)) {\n\t\t\t/* ref for dirty_list */\n\t\t\tdlm_lockres_get(res);\n\t\t\tlist_add_tail(&res->dirty, &dlm->dirty_list);\n\t\t\tres->state |= DLM_LOCK_RES_DIRTY;\n\t\t}\n\t}\n\n\tmlog(0, \"%s: res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_has_locks",
          "args": [
            "res"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_has_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "80-87",
          "snippet": "int __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint __dlm_lockres_has_locks(struct dlm_lock_resource *res)\n{\n\tif (list_empty(&res->granted) &&\n\t    list_empty(&res->converting) &&\n\t    list_empty(&res->blocked))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_change_lockres_owner",
          "args": [
            "dlm",
            "res",
            "new_master"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_change_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1140-1148",
          "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Changing owner from %u to %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->owner",
            "new_master"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->recovering"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->recovering"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "res",
            "bucket",
            "hash_node"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_hash",
          "args": [
            "dlm",
            "i"
          ],
          "line": 2153
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "190-193",
          "snippet": "static inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_BUCKETS_PER_PAGE\t(PAGE_SIZE / sizeof(struct hlist_head))\n\nstatic inline struct hlist_head *dlm_lockres_hash(struct dlm_ctxt *dlm, unsigned i)\n{\n\treturn dlm->lockres_hash[(i / DLM_BUCKETS_PER_PAGE) % DLM_HASH_PAGES] + (i % DLM_BUCKETS_PER_PAGE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->recovering"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: res %.*s, Changing owner from %u to %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "res->owner",
            "new_master"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "res",
            "next",
            "&dlm->reco.resources",
            "recovering"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dlm_move_lockres_to_recovery_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "2035-2113",
    "snippet": "void dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_commit_pending_cancel",
          "args": [
            "res",
            "lock"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_commit_pending_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "275-280",
          "snippet": "void dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_commit_pending_cancel(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i != DLM_CONVERTING_LIST"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_commit_pending_unlock",
          "args": [
            "res",
            "lock"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_commit_pending_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmunlock.c",
          "lines": "267-273",
          "snippet": "void dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\t/* leave DLM_LKSB_PUT_LVB on the lksb so any final\n\t * update of the lvb will be sent to the new master */\n\tlist_del_init(&lock->list);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_commit_pending_unlock(struct dlm_lock_resource *res,\n\t\t\t       struct dlm_lock *lock)\n{\n\t/* leave DLM_LKSB_PUT_LVB on the lksb so any final\n\t * update of the lvb will be sent to the new master */\n\tlist_del_init(&lock->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i != DLM_GRANTED_LIST"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_revert_pending_lock",
          "args": [
            "res",
            "lock"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_revert_pending_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "199-205",
          "snippet": "void dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_lock_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t       struct dlm_lock_resource *res,\n\t\t\t\t\t       struct dlm_lock *lock, int flags);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_revert_pending_lock(struct dlm_lock_resource *res,\n\t\t\t     struct dlm_lock *lock)\n{\n\t/* remove from local queue if it failed */\n\tlist_del_init(&lock->list);\n\tlock->lksb->flags &= ~DLM_LKSB_GET_LVB;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i != DLM_BLOCKED_LIST"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_revert_pending_convert",
          "args": [
            "res",
            "lock"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_revert_pending_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "244-251",
          "snippet": "void dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i != DLM_CONVERTING_LIST"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lock",
            "next",
            "queue",
            "list"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "i"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&res->recovering",
            "&dlm->reco.resources"
          ],
          "line": 2054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&res->recovering"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Recovering res %s:%.*s, is already on recovery list!\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&res->recovering"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res)\n{\n\tint i;\n\tstruct list_head *queue;\n\tstruct dlm_lock *lock, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\tassert_spin_locked(&res->spinlock);\n\tres->state |= DLM_LOCK_RES_RECOVERING;\n\tif (!list_empty(&res->recovering)) {\n\t\tmlog(0,\n\t\t     \"Recovering res %s:%.*s, is already on recovery list!\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t\tlist_del_init(&res->recovering);\n\t\tdlm_lockres_put(res);\n\t}\n\t/* We need to hold a reference while on the recovery list */\n\tdlm_lockres_get(res);\n\tlist_add_tail(&res->recovering, &dlm->reco.resources);\n\n\t/* find any pending locks and put them back on proper list */\n\tfor (i=DLM_BLOCKED_LIST; i>=DLM_GRANTED_LIST; i--) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry_safe(lock, next, queue, list) {\n\t\t\tdlm_lock_get(lock);\n\t\t\tif (lock->convert_pending) {\n\t\t\t\t/* move converting lock back to granted */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with convert pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_revert_pending_convert(res, lock);\n\t\t\t\tlock->convert_pending = 0;\n\t\t\t} else if (lock->lock_pending) {\n\t\t\t\t/* remove pending lock requests completely */\n\t\t\t\tBUG_ON(i != DLM_BLOCKED_LIST);\n\t\t\t\tmlog(0, \"node died with lock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\t/* lock will be floating until ref in\n\t\t\t\t * dlmlock_remote is freed after the network\n\t\t\t\t * call returns.  ok for it to not be on any\n\t\t\t\t * list since no ast can be called\n\t\t\t\t * (the master is dead). */\n\t\t\t\tdlm_revert_pending_lock(res, lock);\n\t\t\t\tlock->lock_pending = 0;\n\t\t\t} else if (lock->unlock_pending) {\n\t\t\t\t/* if an unlock was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master.  note that the dlm_unlock\n\t\t\t\t * call is still responsible for calling\n\t\t\t\t * the unlockast.  that will happen after\n\t\t\t\t * the network call times out.  for now,\n\t\t\t\t * just move lists to prepare the new\n\t\t\t\t * recovery master.  */\n\t\t\t\tBUG_ON(i != DLM_GRANTED_LIST);\n\t\t\t\tmlog(0, \"node died with unlock pending \"\n\t\t\t\t     \"on %.*s. remove from blocked list and skip.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_unlock(res, lock);\n\t\t\t\tlock->unlock_pending = 0;\n\t\t\t} else if (lock->cancel_pending) {\n\t\t\t\t/* if a cancel was in progress, treat as\n\t\t\t\t * if this had completed successfully\n\t\t\t\t * before sending this lock state to the\n\t\t\t\t * new master */\n\t\t\t\tBUG_ON(i != DLM_CONVERTING_LIST);\n\t\t\t\tmlog(0, \"node died with cancel pending \"\n\t\t\t\t     \"on %.*s. move back to granted list.\\n\",\n\t\t\t\t     res->lockname.len, res->lockname.name);\n\t\t\t\tdlm_commit_pending_cancel(res, lock);\n\t\t\t\tlock->cancel_pending = 0;\n\t\t\t}\n\t\t\tdlm_lock_put(lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dlm_process_recovery_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1774-2033",
    "snippet": "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_migratable_lock *ml;\n\tstruct list_head *queue, *iter;\n\tstruct list_head *tmpq = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ret = 0;\n\tint i, j, bad;\n\tstruct dlm_lock *lock;\n\tu8 from = O2NM_MAX_NODES;\n\tunsigned int added = 0;\n\t__be64 c;\n\n\tmlog(0, \"running %d locks for this lockres\\n\", mres->num_locks);\n\tfor (i=0; i<mres->num_locks; i++) {\n\t\tml = &(mres->ml[i]);\n\n\t\tif (dlm_is_dummy_lock(dlm, ml, &from)) {\n\t\t\t/* placeholder, just need to set the refmap bit */\n\t\t\tBUG_ON(mres->num_locks != 1);\n\t\t\tmlog(0, \"%s:%.*s: dummy lock for %u\\n\",\n\t\t\t     dlm->name, mres->lockname_len, mres->lockname,\n\t\t\t     from);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, from);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(ml->highest_blocked != LKM_IVMODE);\n\t\tnewlock = NULL;\n\t\tlksb = NULL;\n\n\t\tqueue = dlm_list_num_to_pointer(res, ml->list);\n\t\ttmpq = NULL;\n\n\t\t/* if the lock is for the local node it needs to\n\t\t * be moved to the proper location within the queue.\n\t\t * do not allocate a new lock structure. */\n\t\tif (ml->node == dlm->node_num) {\n\t\t\t/* MIGRATION ONLY! */\n\t\t\tBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\n\n\t\t\tlock = NULL;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\n\t\t\t\ttmpq = dlm_list_idx_to_ptr(res, j);\n\t\t\t\tlist_for_each(iter, tmpq) {\n\t\t\t\t\tlock = list_entry(iter,\n\t\t\t\t\t\t  struct dlm_lock, list);\n\t\t\t\t\tif (lock->ml.cookie == ml->cookie)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlock = NULL;\n\t\t\t\t}\n\t\t\t\tif (lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* lock is always created locally first, and\n\t\t\t * destroyed locally last.  it must be on the list */\n\t\t\tif (!lock) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (lock->ml.node != ml->node) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     lock->ml.node);\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (tmpq != queue) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(0, \"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     j, ml->list, res->lockname.len,\n\t\t\t\t     res->lockname.name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* see NOTE above about why we do not update\n\t\t\t * to match the master here */\n\n\t\t\t/* move the lock to its proper place */\n\t\t\t/* do not alter lock refcount.  switching lists. */\n\t\t\tlist_move_tail(&lock->list, queue);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\n\t\t\tmlog(0, \"just reordered a local lock!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* lock is for another node. */\n\t\tnewlock = dlm_new_lock(ml->type, ml->node,\n\t\t\t\t       be64_to_cpu(ml->cookie), NULL);\n\t\tif (!newlock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leave;\n\t\t}\n\t\tlksb = newlock->lksb;\n\t\tdlm_lock_attach_lockres(newlock, res);\n\n\t\tif (ml->convert_type != LKM_IVMODE) {\n\t\t\tBUG_ON(queue != &res->converting);\n\t\t\tnewlock->ml.convert_type = ml->convert_type;\n\t\t}\n\t\tlksb->flags |= (ml->flags &\n\t\t\t\t(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\n\t\tif (ml->type == LKM_NLMODE)\n\t\t\tgoto skip_lvb;\n\n\t\t/*\n\t\t * If the lock is in the blocked list it can't have a valid lvb,\n\t\t * so skip it\n\t\t */\n\t\tif (ml->list == DLM_BLOCKED_LIST)\n\t\t\tgoto skip_lvb;\n\n\t\tif (!dlm_lvb_is_empty(mres->lvb)) {\n\t\t\tif (lksb->flags & DLM_LKSB_PUT_LVB) {\n\t\t\t\t/* other node was trying to update\n\t\t\t\t * lvb when node died.  recreate the\n\t\t\t\t * lksb with the updated lvb. */\n\t\t\t\tmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t\t/* the lock resource lvb update must happen\n\t\t\t\t * NOW, before the spinlock is dropped.\n\t\t\t\t * we no longer wait for the AST to update\n\t\t\t\t * the lvb. */\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t} else {\n\t\t\t\t/* otherwise, the node is sending its\n\t\t\t\t * most recent valid lvb info */\n\t\t\t\tBUG_ON(ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE);\n\t\t\t\tif (!dlm_lvb_is_empty(res->lvb) &&\n \t\t\t\t    (ml->type == LKM_EXMODE ||\n \t\t\t\t     memcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\n \t\t\t\t\tint i;\n \t\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\", dlm->name,\n \t\t\t\t\t     res->lockname.len,\n \t\t\t\t\t     res->lockname.name, ml->type);\n \t\t\t\t\tprintk(\"lockres lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", res->lvb[i]);\n \t\t\t\t\tprintk(\"]\\nmigrated lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", mres->lvb[i]);\n \t\t\t\t\tprintk(\"]\\n\");\n \t\t\t\t\tdlm_print_one_lock_resource(res);\n \t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t}\n\t\t}\nskip_lvb:\n\n\t\t/* NOTE:\n\t\t * wrt lock queue ordering and recovery:\n\t\t *    1. order of locks on granted queue is\n\t\t *       meaningless.\n\t\t *    2. order of locks on converting queue is\n\t\t *       LOST with the node death.  sorry charlie.\n\t\t *    3. order of locks on the blocked queue is\n\t\t *       also LOST.\n\t\t * order of locks does not affect integrity, it\n\t\t * just means that a lock request may get pushed\n\t\t * back in line as a result of the node death.\n\t\t * also note that for a given node the lock order\n\t\t * for its secondary queue locks is preserved\n\t\t * relative to each other, but clearly *not*\n\t\t * preserved relative to locks from other nodes.\n\t\t */\n\t\tbad = 0;\n\t\tspin_lock(&res->spinlock);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == ml->cookie) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)));\n\n\t\t\t\tmlog(ML_NOTICE, \"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\",\n\t      \t\t\t     ml->type, ml->convert_type, ml->node,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\n\t\t\t\t     ml->list);\n\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tbad = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bad) {\n\t\t\tdlm_lock_get(newlock);\n\t\t\tif (mres->flags & DLM_MRES_RECOVERY &&\n\t\t\t\t\tml->list == DLM_CONVERTING_LIST &&\n\t\t\t\t\tnewlock->ml.type >\n\t\t\t\t\tnewlock->ml.convert_type) {\n\t\t\t\t/* newlock is doing downconvert, add it to the\n\t\t\t\t * head of converting list */\n\t\t\t\tlist_add(&newlock->list, queue);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&newlock->list, queue);\n\t\t\tmlog(0, \"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, ml->node);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, ml->node);\n\t\t\tadded++;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tmlog(0, \"done running all the locks\\n\");\n\nleave:\n\t/* balance the ref taken when the work was queued */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_drop_inflight_ref(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_drop_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_drop_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "672-686",
          "snippet": "void dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"done running all the locks\\n\""
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_set_refmap_bit",
          "args": [
            "dlm",
            "res",
            "ml->node"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_set_refmap_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "633-642",
          "snippet": "void dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_set_refmap_bit(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res, int bit)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"res %.*s, set node %u, %ps()\\n\", res->lockname.len,\n\t     res->lockname.name, bit, __builtin_return_address(0));\n\n\tset_bit(bit, res->refmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "ml->node"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&newlock->list",
            "queue"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&newlock->list",
            "queue"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "newlock"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\"",
            "ml->type",
            "ml->convert_type",
            "ml->node",
            "dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie))",
            "ml->list"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(ml->cookie)"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ml->cookie"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(ml->cookie)"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ml->cookie"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_get_lock_cookie_node(be64_to_cpu(c))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(c))"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res->lvb",
            "mres->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"]\\n\""
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "ml->type"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "res->lvb",
            "mres->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lvb_is_empty",
          "args": [
            "res->lvb"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lvb_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "396-403",
          "snippet": "static inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res->lvb",
            "mres->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lksb->lvb",
            "mres->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "queue != &res->converting"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_attach_lockres",
          "args": [
            "newlock",
            "res"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_attach_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "374-379",
          "snippet": "void dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_attach_lockres(struct dlm_lock *lock,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tdlm_lockres_get(res);\n\tlock->lockres = res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lock",
          "args": [
            "ml->type",
            "ml->node",
            "be64_to_cpu(ml->cookie)",
            "NULL"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "423-449",
          "snippet": "struct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lock_cache;",
            "static void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);",
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lock_cache;\nstatic void dlm_init_lock(struct dlm_lock *newlock, int type,\n\t\t\t  u8 node, u64 cookie);\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nstruct dlm_lock * dlm_new_lock(int type, u8 node, u64 cookie,\n\t\t\t       struct dlm_lockstatus *lksb)\n{\n\tstruct dlm_lock *lock;\n\tint kernel_allocated = 0;\n\n\tlock = kmem_cache_zalloc(dlm_lock_cache, GFP_NOFS);\n\tif (!lock)\n\t\treturn NULL;\n\n\tif (!lksb) {\n\t\t/* zero memory only if kernel-allocated */\n\t\tlksb = kzalloc(sizeof(*lksb), GFP_NOFS);\n\t\tif (!lksb) {\n\t\t\tkmem_cache_free(dlm_lock_cache, lock);\n\t\t\treturn NULL;\n\t\t}\n\t\tkernel_allocated = 1;\n\t}\n\n\tdlm_init_lock(lock, type, node, cookie);\n\tif (kernel_allocated)\n\t\tlock->lksb_kernel_allocated = 1;\n\tlock->lksb = lksb;\n\tlksb->lockid = lock;\n\treturn lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "ml->cookie"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "queue"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(c))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(c))",
            "j",
            "ml->list",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(c))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(c))",
            "ml->node",
            "ml->list",
            "ml->flags",
            "ml->type",
            "ml->convert_type",
            "ml->highest_blocked"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(c))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(c))",
            "res->lockname.len",
            "res->lockname.name",
            "lock->ml.node"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(c))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(c))",
            "ml->node",
            "ml->list",
            "ml->flags",
            "ml->type",
            "ml->convert_type",
            "ml->highest_blocked"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "c"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "iter",
            "structdlm_lock",
            "list"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "iter",
            "tmpq"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "j"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(mres->flags & DLM_MRES_MIGRATION)"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_num_to_pointer",
          "args": [
            "res",
            "ml->list"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_num_to_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1737-1746",
          "snippet": "static inline struct list_head *\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\n{\n\tstruct list_head *ret;\n\tBUG_ON(list_num < 0);\n\tBUG_ON(list_num > 2);\n\tret = &(res->granted);\n\tret += list_num;\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\n\nstatic inline struct list_head *\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\n{\n\tstruct list_head *ret;\n\tBUG_ON(list_num < 0);\n\tBUG_ON(list_num > 2);\n\tret = &(res->granted);\n\tret += list_num;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ml->highest_blocked != LKM_IVMODE"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: dummy lock for %u\\n\"",
            "dlm->name",
            "mres->lockname_len",
            "mres->lockname",
            "from"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mres->num_locks != 1"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_dummy_lock",
          "args": [
            "dlm",
            "ml",
            "&from"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_dummy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1264-1277",
          "snippet": "static inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lock *ml,\n\t\t\t\t    u8 *nodenum)\n{\n\tif (unlikely(ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST)) {\n\t\t*nodenum = ml->node;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lock *ml,\n\t\t\t\t    u8 *nodenum)\n{\n\tif (unlikely(ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST)) {\n\t\t*nodenum = ml->node;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"running %d locks for this lockres\\n\"",
            "mres->num_locks"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_migratable_lock *ml;\n\tstruct list_head *queue, *iter;\n\tstruct list_head *tmpq = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ret = 0;\n\tint i, j, bad;\n\tstruct dlm_lock *lock;\n\tu8 from = O2NM_MAX_NODES;\n\tunsigned int added = 0;\n\t__be64 c;\n\n\tmlog(0, \"running %d locks for this lockres\\n\", mres->num_locks);\n\tfor (i=0; i<mres->num_locks; i++) {\n\t\tml = &(mres->ml[i]);\n\n\t\tif (dlm_is_dummy_lock(dlm, ml, &from)) {\n\t\t\t/* placeholder, just need to set the refmap bit */\n\t\t\tBUG_ON(mres->num_locks != 1);\n\t\t\tmlog(0, \"%s:%.*s: dummy lock for %u\\n\",\n\t\t\t     dlm->name, mres->lockname_len, mres->lockname,\n\t\t\t     from);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, from);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(ml->highest_blocked != LKM_IVMODE);\n\t\tnewlock = NULL;\n\t\tlksb = NULL;\n\n\t\tqueue = dlm_list_num_to_pointer(res, ml->list);\n\t\ttmpq = NULL;\n\n\t\t/* if the lock is for the local node it needs to\n\t\t * be moved to the proper location within the queue.\n\t\t * do not allocate a new lock structure. */\n\t\tif (ml->node == dlm->node_num) {\n\t\t\t/* MIGRATION ONLY! */\n\t\t\tBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\n\n\t\t\tlock = NULL;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\n\t\t\t\ttmpq = dlm_list_idx_to_ptr(res, j);\n\t\t\t\tlist_for_each(iter, tmpq) {\n\t\t\t\t\tlock = list_entry(iter,\n\t\t\t\t\t\t  struct dlm_lock, list);\n\t\t\t\t\tif (lock->ml.cookie == ml->cookie)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlock = NULL;\n\t\t\t\t}\n\t\t\t\tif (lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* lock is always created locally first, and\n\t\t\t * destroyed locally last.  it must be on the list */\n\t\t\tif (!lock) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (lock->ml.node != ml->node) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     lock->ml.node);\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (tmpq != queue) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(0, \"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     j, ml->list, res->lockname.len,\n\t\t\t\t     res->lockname.name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* see NOTE above about why we do not update\n\t\t\t * to match the master here */\n\n\t\t\t/* move the lock to its proper place */\n\t\t\t/* do not alter lock refcount.  switching lists. */\n\t\t\tlist_move_tail(&lock->list, queue);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\n\t\t\tmlog(0, \"just reordered a local lock!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* lock is for another node. */\n\t\tnewlock = dlm_new_lock(ml->type, ml->node,\n\t\t\t\t       be64_to_cpu(ml->cookie), NULL);\n\t\tif (!newlock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leave;\n\t\t}\n\t\tlksb = newlock->lksb;\n\t\tdlm_lock_attach_lockres(newlock, res);\n\n\t\tif (ml->convert_type != LKM_IVMODE) {\n\t\t\tBUG_ON(queue != &res->converting);\n\t\t\tnewlock->ml.convert_type = ml->convert_type;\n\t\t}\n\t\tlksb->flags |= (ml->flags &\n\t\t\t\t(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\n\t\tif (ml->type == LKM_NLMODE)\n\t\t\tgoto skip_lvb;\n\n\t\t/*\n\t\t * If the lock is in the blocked list it can't have a valid lvb,\n\t\t * so skip it\n\t\t */\n\t\tif (ml->list == DLM_BLOCKED_LIST)\n\t\t\tgoto skip_lvb;\n\n\t\tif (!dlm_lvb_is_empty(mres->lvb)) {\n\t\t\tif (lksb->flags & DLM_LKSB_PUT_LVB) {\n\t\t\t\t/* other node was trying to update\n\t\t\t\t * lvb when node died.  recreate the\n\t\t\t\t * lksb with the updated lvb. */\n\t\t\t\tmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t\t/* the lock resource lvb update must happen\n\t\t\t\t * NOW, before the spinlock is dropped.\n\t\t\t\t * we no longer wait for the AST to update\n\t\t\t\t * the lvb. */\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t} else {\n\t\t\t\t/* otherwise, the node is sending its\n\t\t\t\t * most recent valid lvb info */\n\t\t\t\tBUG_ON(ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE);\n\t\t\t\tif (!dlm_lvb_is_empty(res->lvb) &&\n \t\t\t\t    (ml->type == LKM_EXMODE ||\n \t\t\t\t     memcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\n \t\t\t\t\tint i;\n \t\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\", dlm->name,\n \t\t\t\t\t     res->lockname.len,\n \t\t\t\t\t     res->lockname.name, ml->type);\n \t\t\t\t\tprintk(\"lockres lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", res->lvb[i]);\n \t\t\t\t\tprintk(\"]\\nmigrated lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", mres->lvb[i]);\n \t\t\t\t\tprintk(\"]\\n\");\n \t\t\t\t\tdlm_print_one_lock_resource(res);\n \t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t}\n\t\t}\nskip_lvb:\n\n\t\t/* NOTE:\n\t\t * wrt lock queue ordering and recovery:\n\t\t *    1. order of locks on granted queue is\n\t\t *       meaningless.\n\t\t *    2. order of locks on converting queue is\n\t\t *       LOST with the node death.  sorry charlie.\n\t\t *    3. order of locks on the blocked queue is\n\t\t *       also LOST.\n\t\t * order of locks does not affect integrity, it\n\t\t * just means that a lock request may get pushed\n\t\t * back in line as a result of the node death.\n\t\t * also note that for a given node the lock order\n\t\t * for its secondary queue locks is preserved\n\t\t * relative to each other, but clearly *not*\n\t\t * preserved relative to locks from other nodes.\n\t\t */\n\t\tbad = 0;\n\t\tspin_lock(&res->spinlock);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == ml->cookie) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)));\n\n\t\t\t\tmlog(ML_NOTICE, \"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\",\n\t      \t\t\t     ml->type, ml->convert_type, ml->node,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\n\t\t\t\t     ml->list);\n\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tbad = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bad) {\n\t\t\tdlm_lock_get(newlock);\n\t\t\tif (mres->flags & DLM_MRES_RECOVERY &&\n\t\t\t\t\tml->list == DLM_CONVERTING_LIST &&\n\t\t\t\t\tnewlock->ml.type >\n\t\t\t\t\tnewlock->ml.convert_type) {\n\t\t\t\t/* newlock is doing downconvert, add it to the\n\t\t\t\t * head of converting list */\n\t\t\t\tlist_add(&newlock->list, queue);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&newlock->list, queue);\n\t\t\tmlog(0, \"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, ml->node);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, ml->node);\n\t\t\tadded++;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tmlog(0, \"done running all the locks\\n\");\n\nleave:\n\t/* balance the ref taken when the work was queued */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_drop_inflight_ref(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_list_num_to_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1737-1746",
    "snippet": "static inline struct list_head *\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\n{\n\tstruct list_head *ret;\n\tBUG_ON(list_num < 0);\n\tBUG_ON(list_num > 2);\n\tret = &(res->granted);\n\tret += list_num;\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_num > 2"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_num < 0"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\n\nstatic inline struct list_head *\ndlm_list_num_to_pointer(struct dlm_lock_resource *res, int list_num)\n{\n\tstruct list_head *ret;\n\tBUG_ON(list_num < 0);\n\tBUG_ON(list_num > 2);\n\tret = &(res->granted);\n\tret += list_num;\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_master_requery_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1688-1735",
    "snippet": "int dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_master_requery *req = (struct dlm_master_requery *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tunsigned int hash;\n\tint master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tu32 flags = DLM_ASSERT_MASTER_REQUERY;\n\n\tif (!dlm_grab(dlm)) {\n\t\t/* since the domain has gone away on this\n\t\t * node, the proper response is UNKNOWN */\n\t\treturn master;\n\t}\n\n\thash = dlm_lockid_hash(req->name, req->namelen);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, req->name, req->namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tmaster = res->owner;\n\t\tif (master == dlm->node_num) {\n\t\t\tint ret = dlm_dispatch_assert_master(dlm, res,\n\t\t\t\t\t\t\t     0, 0, flags);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tdlm_put(dlm);\n\t\t\t\t/* sender will take care of this and retry */\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\t__dlm_lockres_grab_inflight_worker(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t} else {\n\t\t\t/* put.. incase we are not the master */\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\treturn master;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_grab_inflight_worker",
          "args": [
            "dlm",
            "res"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_grab_inflight_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "688-696",
          "snippet": "void __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_grab_inflight_worker(struct dlm_ctxt *dlm,\n\t\tstruct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tres->inflight_assert_workers++;\n\tmlog(0, \"%s:%.*s: inflight assert worker++: now %u\\n\",\n\t\t\tdlm->name, res->lockname.len, res->lockname.name,\n\t\t\tres->inflight_assert_workers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_dispatch_assert_master",
          "args": [
            "dlm",
            "res",
            "0",
            "0",
            "flags"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dispatch_assert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "2069-2098",
          "snippet": "int dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_assert_master(struct dlm_ctxt *dlm,\n\t\t\t\tstruct dlm_lock_resource *res,\n\t\t\t\tvoid *nodemap, u32 flags);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_dispatch_assert_master(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_lock_resource *res,\n\t\t\t       int ignore_higher, u8 request_from, u32 flags)\n{\n\tstruct dlm_work_item *item;\n\titem = kzalloc(sizeof(*item), GFP_ATOMIC);\n\tif (!item)\n\t\treturn -ENOMEM;\n\n\n\t/* queue up work for dlm_assert_master_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);\n\titem->u.am.lockres = res; /* already have a ref */\n\t/* can optionally ignore node numbers higher than this node */\n\titem->u.am.ignore_higher = ignore_higher;\n\titem->u.am.request_from = request_from;\n\titem->u.am.flags = flags;\n\n\tif (ignore_higher)\n\t\tmlog(0, \"IGNORE HIGHER: %.*s\\n\", res->lockname.len,\n\t\t     res->lockname.name);\n\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lookup_lockres",
          "args": [
            "dlm",
            "req->name",
            "req->namelen",
            "hash"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "221-244",
          "snippet": "struct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * __dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t\t\tconst char *name,\n\t\t\t\t\t\tunsigned int len,\n\t\t\t\t\t\tunsigned int hash)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tmlog(0, \"%.*s\\n\", len, name);\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tres = __dlm_lookup_lockres_full(dlm, name, len, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tif (res->state & DLM_LOCK_RES_DROPPING_REF) {\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockid_hash",
          "args": [
            "req->name",
            "req->namelen"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nint dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_master_requery *req = (struct dlm_master_requery *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tunsigned int hash;\n\tint master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\tu32 flags = DLM_ASSERT_MASTER_REQUERY;\n\n\tif (!dlm_grab(dlm)) {\n\t\t/* since the domain has gone away on this\n\t\t * node, the proper response is UNKNOWN */\n\t\treturn master;\n\t}\n\n\thash = dlm_lockid_hash(req->name, req->namelen);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, req->name, req->namelen, hash);\n\tif (res) {\n\t\tspin_lock(&res->spinlock);\n\t\tmaster = res->owner;\n\t\tif (master == dlm->node_num) {\n\t\t\tint ret = dlm_dispatch_assert_master(dlm, res,\n\t\t\t\t\t\t\t     0, 0, flags);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\t\tdlm_put(dlm);\n\t\t\t\t/* sender will take care of this and retry */\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\t__dlm_lockres_grab_inflight_worker(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t} else {\n\t\t\t/* put.. incase we are not the master */\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n\n\tdlm_put(dlm);\n\treturn master;\n}"
  },
  {
    "function_name": "dlm_do_master_requery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1650-1682",
    "snippet": "int dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u responded to master requery with %u\\n\"",
            "nodenum",
            "*real_master"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "status & 0xff"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status > DLM_LOCK_RES_OWNER_UNKNOWN"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "status < 0"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "50"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\"",
            "ret",
            "DLM_MASTER_REQUERY_MSG",
            "dlm->key",
            "nodenum"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_MASTER_REQUERY_MSG",
            "dlm->key",
            "&req",
            "sizeof(req)",
            "nodenum",
            "&status"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "req.name",
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&req",
            "0",
            "sizeof(req)"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_lockres_master_requery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1592-1647",
    "snippet": "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\n\t*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\t/* we only reach here if one of the two nodes in a\n\t * migration died while the migration was in progress.\n\t * at this point we need to requery the master.  we\n\t * know that the new_master got as far as creating\n\t * an mle on at least one node, but we do not know\n\t * if any nodes had actually cleared the mle and set\n\t * the master to the new_master.  the old master\n\t * is supposed to set the owner to UNKNOWN in the\n\t * event of a new_master death, so the only possible\n\t * responses that we can get from nodes here are\n\t * that the master is new_master, or that the master\n\t * is UNKNOWN.\n\t * if all nodes come back with UNKNOWN then we know\n\t * the lock needs remastering here.\n\t * if any node comes back with a valid master, check\n\t * to see if that master is the one that we are\n\t * recovering.  if so, then the new_master died and\n\t * we need to remaster this lock.  if not, then the\n\t * new_master survived and that node will respond to\n\t * other nodes about the owner.\n\t * if there is an owner, this node needs to dump this\n\t * lockres and alert the sender that this lockres\n\t * was rejected. */\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t}\n\t\tif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lock master is %u\\n\", *real_master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lock master is %u\\n\"",
            "*real_master"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_master_requery",
          "args": [
            "dlm",
            "res",
            "nodenum",
            "real_master"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_master_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1650-1682",
          "snippet": "int dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nint dlm_do_master_requery(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t  u8 nodenum, u8 *real_master)\n{\n\tint ret = -EINVAL;\n\tstruct dlm_master_requery req;\n\tint status = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.node_idx = dlm->node_num;\n\treq.namelen = res->lockname.len;\n\tmemcpy(req.name, res->lockname.name, res->lockname.len);\n\nresend:\n\tret = o2net_send_message(DLM_MASTER_REQUERY_MSG, dlm->key,\n\t\t\t\t &req, sizeof(req), nodenum, &status);\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t     \"0x%x) to node %u\\n\", ret, DLM_MASTER_REQUERY_MSG,\n\t\t     dlm->key, nodenum);\n\telse if (status == -ENOMEM) {\n\t\tmlog_errno(status);\n\t\tmsleep(50);\n\t\tgoto resend;\n\t} else {\n\t\tBUG_ON(status < 0);\n\t\tBUG_ON(status > DLM_LOCK_RES_OWNER_UNKNOWN);\n\t\t*real_master = (u8) (status & 0xff);\n\t\tmlog(0, \"node %u responded to master requery with %u\\n\",\n\t\t\t  nodenum, *real_master);\n\t\tret = 0;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_next",
          "args": [
            "&iter"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1119-1129",
          "snippet": "static inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_node_iter_next(struct dlm_node_iter *iter)\n{\n\tint bit;\n\tbit = find_next_bit(iter->node_map, O2NM_MAX_NODES, iter->curnode+1);\n\tif (bit >= O2NM_MAX_NODES) {\n\t\titer->curnode = O2NM_MAX_NODES;\n\t\treturn -ENOENT;\n\t}\n\titer->curnode = bit;\n\treturn bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_node_iter_init",
          "args": [
            "dlm->domain_map",
            "&iter"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_node_iter_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1112-1117",
          "snippet": "static inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_node_iter_init(unsigned long *map,\n\t\t\t\t      struct dlm_node_iter *iter)\n{\n\tmemcpy(iter->node_map, map, sizeof(iter->node_map));\n\titer->curnode = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\n\t*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\t/* we only reach here if one of the two nodes in a\n\t * migration died while the migration was in progress.\n\t * at this point we need to requery the master.  we\n\t * know that the new_master got as far as creating\n\t * an mle on at least one node, but we do not know\n\t * if any nodes had actually cleared the mle and set\n\t * the master to the new_master.  the old master\n\t * is supposed to set the owner to UNKNOWN in the\n\t * event of a new_master death, so the only possible\n\t * responses that we can get from nodes here are\n\t * that the master is new_master, or that the master\n\t * is UNKNOWN.\n\t * if all nodes come back with UNKNOWN then we know\n\t * the lock needs remastering here.\n\t * if any node comes back with a valid master, check\n\t * to see if that master is the one that we are\n\t * recovering.  if so, then the new_master died and\n\t * we need to remaster this lock.  if not, then the\n\t * new_master survived and that node will respond to\n\t * other nodes about the owner.\n\t * if there is an owner, this node needs to dump this\n\t * lockres and alert the sender that this lockres\n\t * was rejected. */\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t}\n\t\tif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lock master is %u\\n\", *real_master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_mig_lockres_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1524-1588",
    "snippet": "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm;\n\tstruct dlm_migratable_lockres *mres;\n\tint ret = 0;\n\tstruct dlm_lock_resource *res;\n\tu8 real_master;\n\tu8 extra_ref;\n\n\tdlm = item->dlm;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tres = item->u.ml.lockres;\n\treal_master = item->u.ml.real_master;\n\textra_ref = item->u.ml.extra_ref;\n\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* this case is super-rare. only occurs if\n\t\t * node death happens during migration. */\nagain:\n\t\tret = dlm_lockres_master_requery(dlm, res, &real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(0, \"dlm_lockres_master_requery ret=%d\\n\",\n\t\t\t\t  ret);\n\t\t\tgoto again;\n\t\t}\n\t\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lockres %.*s not claimed.  \"\n\t\t\t\t   \"this node will take it.\\n\",\n\t\t\t\t   res->lockname.len, res->lockname.name);\n\t\t} else {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(0, \"master needs to respond to sender \"\n\t\t\t\t  \"that node %u still owns %.*s\\n\",\n\t\t\t\t  real_master, res->lockname.len,\n\t\t\t\t  res->lockname.name);\n\t\t\t/* cannot touch this lockres */\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tret = dlm_process_recovery_data(dlm, res, mres);\n\tif (ret < 0)\n\t\tmlog(0, \"dlm_process_recovery_data returned  %d\\n\", ret);\n\telse\n\t\tmlog(0, \"dlm_process_recovery_data succeeded\\n\");\n\n\tif ((mres->flags & (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) ==\n\t                   (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) {\n\t\tret = dlm_finish_migration(dlm, res, mres->master);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\nleave:\n\t/* See comment in dlm_mig_lockres_handler() */\n\tif (res) {\n\t\tif (extra_ref)\n\t\t\tdlm_lockres_put(res);\n\t\tdlm_lockres_put(res);\n\t}\n\tkfree(data);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_finish_migration",
          "args": [
            "dlm",
            "res",
            "mres->master"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_finish_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3321-3384",
          "snippet": "int dlm_finish_migration(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t u8 old_master)\n{\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tclear_bit(old_master, iter.node_map);\n\tclear_bit(dlm->node_num, iter.node_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* ownership of the lockres is changing.  account for the\n\t * mastery reference here since old_master will briefly have\n\t * a reference after the migration completes */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_set_refmap_bit(dlm, res, old_master);\n\tspin_unlock(&res->spinlock);\n\n\tmlog(0, \"now time to do a migrate request to other nodes\\n\");\n\tret = dlm_do_migrate_request(dlm, res, old_master,\n\t\t\t\t     dlm->node_num, &iter);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"doing assert master of %.*s to all except the original node\\n\",\n\t     res->lockname.len, res->lockname.name);\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\t/* no longer need to retry.  all living nodes contacted. */\n\t\tmlog_errno(ret);\n\t\tret = 0;\n\t}\n\n\tmemset(iter.node_map, 0, sizeof(iter.node_map));\n\tset_bit(old_master, iter.node_map);\n\tmlog(0, \"doing assert master of %.*s back to %u\\n\",\n\t     res->lockname.len, res->lockname.name, old_master);\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\tmlog(0, \"assert master to original master failed \"\n\t\t     \"with %d.\\n\", ret);\n\t\t/* the only nonzero status here would be because of\n\t\t * a dead original node.  we're done. */\n\t\tret = 0;\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, dlm->node_num);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\t/* re-dirty it on the new master */\n\tdlm_kick_thread(dlm, res);\n\twake_up(&res->wq);\nleave:\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);",
            "static int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_master_request(struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle, int to);\nstatic int dlm_add_migration_mle(struct dlm_ctxt *dlm,\n\t\t\t\t struct dlm_lock_resource *res,\n\t\t\t\t struct dlm_master_list_entry *mle,\n\t\t\t\t struct dlm_master_list_entry **oldmle,\n\t\t\t\t const char *name, unsigned int namelen,\n\t\t\t\t u8 new_master, u8 master);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nint dlm_finish_migration(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t u8 old_master)\n{\n\tstruct dlm_node_iter iter;\n\tint ret = 0;\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tclear_bit(old_master, iter.node_map);\n\tclear_bit(dlm->node_num, iter.node_map);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* ownership of the lockres is changing.  account for the\n\t * mastery reference here since old_master will briefly have\n\t * a reference after the migration completes */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_set_refmap_bit(dlm, res, old_master);\n\tspin_unlock(&res->spinlock);\n\n\tmlog(0, \"now time to do a migrate request to other nodes\\n\");\n\tret = dlm_do_migrate_request(dlm, res, old_master,\n\t\t\t\t     dlm->node_num, &iter);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"doing assert master of %.*s to all except the original node\\n\",\n\t     res->lockname.len, res->lockname.name);\n\t/* this call now finishes out the nodemap\n\t * even if one or more nodes die */\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\t/* no longer need to retry.  all living nodes contacted. */\n\t\tmlog_errno(ret);\n\t\tret = 0;\n\t}\n\n\tmemset(iter.node_map, 0, sizeof(iter.node_map));\n\tset_bit(old_master, iter.node_map);\n\tmlog(0, \"doing assert master of %.*s back to %u\\n\",\n\t     res->lockname.len, res->lockname.name, old_master);\n\tret = dlm_do_assert_master(dlm, res, iter.node_map,\n\t\t\t\t   DLM_ASSERT_MASTER_FINISH_MIGRATION);\n\tif (ret < 0) {\n\t\tmlog(0, \"assert master to original master failed \"\n\t\t     \"with %d.\\n\", ret);\n\t\t/* the only nonzero status here would be because of\n\t\t * a dead original node.  we're done. */\n\t\tret = 0;\n\t}\n\n\t/* all done, set the owner, clear the flag */\n\tspin_lock(&res->spinlock);\n\tdlm_set_lockres_owner(dlm, res, dlm->node_num);\n\tres->state &= ~DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\t/* re-dirty it on the new master */\n\tdlm_kick_thread(dlm, res);\n\twake_up(&res->wq);\nleave:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm_process_recovery_data succeeded\\n\""
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm_process_recovery_data returned  %d\\n\"",
            "ret"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_process_recovery_data",
          "args": [
            "dlm",
            "res",
            "mres"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_process_recovery_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1774-2033",
          "snippet": "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_migratable_lock *ml;\n\tstruct list_head *queue, *iter;\n\tstruct list_head *tmpq = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ret = 0;\n\tint i, j, bad;\n\tstruct dlm_lock *lock;\n\tu8 from = O2NM_MAX_NODES;\n\tunsigned int added = 0;\n\t__be64 c;\n\n\tmlog(0, \"running %d locks for this lockres\\n\", mres->num_locks);\n\tfor (i=0; i<mres->num_locks; i++) {\n\t\tml = &(mres->ml[i]);\n\n\t\tif (dlm_is_dummy_lock(dlm, ml, &from)) {\n\t\t\t/* placeholder, just need to set the refmap bit */\n\t\t\tBUG_ON(mres->num_locks != 1);\n\t\t\tmlog(0, \"%s:%.*s: dummy lock for %u\\n\",\n\t\t\t     dlm->name, mres->lockname_len, mres->lockname,\n\t\t\t     from);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, from);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(ml->highest_blocked != LKM_IVMODE);\n\t\tnewlock = NULL;\n\t\tlksb = NULL;\n\n\t\tqueue = dlm_list_num_to_pointer(res, ml->list);\n\t\ttmpq = NULL;\n\n\t\t/* if the lock is for the local node it needs to\n\t\t * be moved to the proper location within the queue.\n\t\t * do not allocate a new lock structure. */\n\t\tif (ml->node == dlm->node_num) {\n\t\t\t/* MIGRATION ONLY! */\n\t\t\tBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\n\n\t\t\tlock = NULL;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\n\t\t\t\ttmpq = dlm_list_idx_to_ptr(res, j);\n\t\t\t\tlist_for_each(iter, tmpq) {\n\t\t\t\t\tlock = list_entry(iter,\n\t\t\t\t\t\t  struct dlm_lock, list);\n\t\t\t\t\tif (lock->ml.cookie == ml->cookie)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlock = NULL;\n\t\t\t\t}\n\t\t\t\tif (lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* lock is always created locally first, and\n\t\t\t * destroyed locally last.  it must be on the list */\n\t\t\tif (!lock) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (lock->ml.node != ml->node) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     lock->ml.node);\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (tmpq != queue) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(0, \"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     j, ml->list, res->lockname.len,\n\t\t\t\t     res->lockname.name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* see NOTE above about why we do not update\n\t\t\t * to match the master here */\n\n\t\t\t/* move the lock to its proper place */\n\t\t\t/* do not alter lock refcount.  switching lists. */\n\t\t\tlist_move_tail(&lock->list, queue);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\n\t\t\tmlog(0, \"just reordered a local lock!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* lock is for another node. */\n\t\tnewlock = dlm_new_lock(ml->type, ml->node,\n\t\t\t\t       be64_to_cpu(ml->cookie), NULL);\n\t\tif (!newlock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leave;\n\t\t}\n\t\tlksb = newlock->lksb;\n\t\tdlm_lock_attach_lockres(newlock, res);\n\n\t\tif (ml->convert_type != LKM_IVMODE) {\n\t\t\tBUG_ON(queue != &res->converting);\n\t\t\tnewlock->ml.convert_type = ml->convert_type;\n\t\t}\n\t\tlksb->flags |= (ml->flags &\n\t\t\t\t(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\n\t\tif (ml->type == LKM_NLMODE)\n\t\t\tgoto skip_lvb;\n\n\t\t/*\n\t\t * If the lock is in the blocked list it can't have a valid lvb,\n\t\t * so skip it\n\t\t */\n\t\tif (ml->list == DLM_BLOCKED_LIST)\n\t\t\tgoto skip_lvb;\n\n\t\tif (!dlm_lvb_is_empty(mres->lvb)) {\n\t\t\tif (lksb->flags & DLM_LKSB_PUT_LVB) {\n\t\t\t\t/* other node was trying to update\n\t\t\t\t * lvb when node died.  recreate the\n\t\t\t\t * lksb with the updated lvb. */\n\t\t\t\tmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t\t/* the lock resource lvb update must happen\n\t\t\t\t * NOW, before the spinlock is dropped.\n\t\t\t\t * we no longer wait for the AST to update\n\t\t\t\t * the lvb. */\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t} else {\n\t\t\t\t/* otherwise, the node is sending its\n\t\t\t\t * most recent valid lvb info */\n\t\t\t\tBUG_ON(ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE);\n\t\t\t\tif (!dlm_lvb_is_empty(res->lvb) &&\n \t\t\t\t    (ml->type == LKM_EXMODE ||\n \t\t\t\t     memcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\n \t\t\t\t\tint i;\n \t\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\", dlm->name,\n \t\t\t\t\t     res->lockname.len,\n \t\t\t\t\t     res->lockname.name, ml->type);\n \t\t\t\t\tprintk(\"lockres lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", res->lvb[i]);\n \t\t\t\t\tprintk(\"]\\nmigrated lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", mres->lvb[i]);\n \t\t\t\t\tprintk(\"]\\n\");\n \t\t\t\t\tdlm_print_one_lock_resource(res);\n \t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t}\n\t\t}\nskip_lvb:\n\n\t\t/* NOTE:\n\t\t * wrt lock queue ordering and recovery:\n\t\t *    1. order of locks on granted queue is\n\t\t *       meaningless.\n\t\t *    2. order of locks on converting queue is\n\t\t *       LOST with the node death.  sorry charlie.\n\t\t *    3. order of locks on the blocked queue is\n\t\t *       also LOST.\n\t\t * order of locks does not affect integrity, it\n\t\t * just means that a lock request may get pushed\n\t\t * back in line as a result of the node death.\n\t\t * also note that for a given node the lock order\n\t\t * for its secondary queue locks is preserved\n\t\t * relative to each other, but clearly *not*\n\t\t * preserved relative to locks from other nodes.\n\t\t */\n\t\tbad = 0;\n\t\tspin_lock(&res->spinlock);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == ml->cookie) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)));\n\n\t\t\t\tmlog(ML_NOTICE, \"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\",\n\t      \t\t\t     ml->type, ml->convert_type, ml->node,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\n\t\t\t\t     ml->list);\n\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tbad = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bad) {\n\t\t\tdlm_lock_get(newlock);\n\t\t\tif (mres->flags & DLM_MRES_RECOVERY &&\n\t\t\t\t\tml->list == DLM_CONVERTING_LIST &&\n\t\t\t\t\tnewlock->ml.type >\n\t\t\t\t\tnewlock->ml.convert_type) {\n\t\t\t\t/* newlock is doing downconvert, add it to the\n\t\t\t\t * head of converting list */\n\t\t\t\tlist_add(&newlock->list, queue);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&newlock->list, queue);\n\t\t\tmlog(0, \"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, ml->node);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, ml->node);\n\t\t\tadded++;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tmlog(0, \"done running all the locks\\n\");\n\nleave:\n\t/* balance the ref taken when the work was queued */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_drop_inflight_ref(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_migratable_lock *ml;\n\tstruct list_head *queue, *iter;\n\tstruct list_head *tmpq = NULL;\n\tstruct dlm_lock *newlock = NULL;\n\tstruct dlm_lockstatus *lksb = NULL;\n\tint ret = 0;\n\tint i, j, bad;\n\tstruct dlm_lock *lock;\n\tu8 from = O2NM_MAX_NODES;\n\tunsigned int added = 0;\n\t__be64 c;\n\n\tmlog(0, \"running %d locks for this lockres\\n\", mres->num_locks);\n\tfor (i=0; i<mres->num_locks; i++) {\n\t\tml = &(mres->ml[i]);\n\n\t\tif (dlm_is_dummy_lock(dlm, ml, &from)) {\n\t\t\t/* placeholder, just need to set the refmap bit */\n\t\t\tBUG_ON(mres->num_locks != 1);\n\t\t\tmlog(0, \"%s:%.*s: dummy lock for %u\\n\",\n\t\t\t     dlm->name, mres->lockname_len, mres->lockname,\n\t\t\t     from);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, from);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(ml->highest_blocked != LKM_IVMODE);\n\t\tnewlock = NULL;\n\t\tlksb = NULL;\n\n\t\tqueue = dlm_list_num_to_pointer(res, ml->list);\n\t\ttmpq = NULL;\n\n\t\t/* if the lock is for the local node it needs to\n\t\t * be moved to the proper location within the queue.\n\t\t * do not allocate a new lock structure. */\n\t\tif (ml->node == dlm->node_num) {\n\t\t\t/* MIGRATION ONLY! */\n\t\t\tBUG_ON(!(mres->flags & DLM_MRES_MIGRATION));\n\n\t\t\tlock = NULL;\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tfor (j = DLM_GRANTED_LIST; j <= DLM_BLOCKED_LIST; j++) {\n\t\t\t\ttmpq = dlm_list_idx_to_ptr(res, j);\n\t\t\t\tlist_for_each(iter, tmpq) {\n\t\t\t\t\tlock = list_entry(iter,\n\t\t\t\t\t\t  struct dlm_lock, list);\n\t\t\t\t\tif (lock->ml.cookie == ml->cookie)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tlock = NULL;\n\t\t\t\t}\n\t\t\t\tif (lock)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* lock is always created locally first, and\n\t\t\t * destroyed locally last.  it must be on the list */\n\t\t\tif (!lock) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Could not find local lock \"\n\t\t\t\t\t       \"with cookie %u:%llu, node %u, \"\n\t\t\t\t\t       \"list %u, flags 0x%x, type %d, \"\n\t\t\t\t\t       \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (lock->ml.node != ml->node) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"Mismatched node# in lock \"\n\t\t\t\t     \"cookie %u:%llu, name %.*s, node %u\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     lock->ml.node);\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(ML_ERROR, \"Migrate lock cookie %u:%llu, \"\n\t\t\t\t     \"node %u, list %u, flags 0x%x, type %d, \"\n\t\t\t\t     \"conv %d, highest blocked %d\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     ml->node, ml->list, ml->flags, ml->type,\n\t\t\t\t     ml->convert_type, ml->highest_blocked);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tBUG();\n\t\t\t}\n\n\t\t\tif (tmpq != queue) {\n\t\t\t\tc = ml->cookie;\n\t\t\t\tmlog(0, \"Lock cookie %u:%llu was on list %u \"\n\t\t\t\t     \"instead of list %u for %.*s\\n\",\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)),\n\t\t\t\t     j, ml->list, res->lockname.len,\n\t\t\t\t     res->lockname.name);\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* see NOTE above about why we do not update\n\t\t\t * to match the master here */\n\n\t\t\t/* move the lock to its proper place */\n\t\t\t/* do not alter lock refcount.  switching lists. */\n\t\t\tlist_move_tail(&lock->list, queue);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tadded++;\n\n\t\t\tmlog(0, \"just reordered a local lock!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* lock is for another node. */\n\t\tnewlock = dlm_new_lock(ml->type, ml->node,\n\t\t\t\t       be64_to_cpu(ml->cookie), NULL);\n\t\tif (!newlock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leave;\n\t\t}\n\t\tlksb = newlock->lksb;\n\t\tdlm_lock_attach_lockres(newlock, res);\n\n\t\tif (ml->convert_type != LKM_IVMODE) {\n\t\t\tBUG_ON(queue != &res->converting);\n\t\t\tnewlock->ml.convert_type = ml->convert_type;\n\t\t}\n\t\tlksb->flags |= (ml->flags &\n\t\t\t\t(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\n\t\tif (ml->type == LKM_NLMODE)\n\t\t\tgoto skip_lvb;\n\n\t\t/*\n\t\t * If the lock is in the blocked list it can't have a valid lvb,\n\t\t * so skip it\n\t\t */\n\t\tif (ml->list == DLM_BLOCKED_LIST)\n\t\t\tgoto skip_lvb;\n\n\t\tif (!dlm_lvb_is_empty(mres->lvb)) {\n\t\t\tif (lksb->flags & DLM_LKSB_PUT_LVB) {\n\t\t\t\t/* other node was trying to update\n\t\t\t\t * lvb when node died.  recreate the\n\t\t\t\t * lksb with the updated lvb. */\n\t\t\t\tmemcpy(lksb->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t\t/* the lock resource lvb update must happen\n\t\t\t\t * NOW, before the spinlock is dropped.\n\t\t\t\t * we no longer wait for the AST to update\n\t\t\t\t * the lvb. */\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t} else {\n\t\t\t\t/* otherwise, the node is sending its\n\t\t\t\t * most recent valid lvb info */\n\t\t\t\tBUG_ON(ml->type != LKM_EXMODE &&\n\t\t\t\t       ml->type != LKM_PRMODE);\n\t\t\t\tif (!dlm_lvb_is_empty(res->lvb) &&\n \t\t\t\t    (ml->type == LKM_EXMODE ||\n \t\t\t\t     memcmp(res->lvb, mres->lvb, DLM_LVB_LEN))) {\n \t\t\t\t\tint i;\n \t\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: received bad \"\n \t\t\t\t\t     \"lvb! type=%d\\n\", dlm->name,\n \t\t\t\t\t     res->lockname.len,\n \t\t\t\t\t     res->lockname.name, ml->type);\n \t\t\t\t\tprintk(\"lockres lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", res->lvb[i]);\n \t\t\t\t\tprintk(\"]\\nmigrated lvb=[\");\n \t\t\t\t\tfor (i=0; i<DLM_LVB_LEN; i++)\n \t\t\t\t\t\tprintk(\"%02x\", mres->lvb[i]);\n \t\t\t\t\tprintk(\"]\\n\");\n \t\t\t\t\tdlm_print_one_lock_resource(res);\n \t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tmemcpy(res->lvb, mres->lvb, DLM_LVB_LEN);\n\t\t\t}\n\t\t}\nskip_lvb:\n\n\t\t/* NOTE:\n\t\t * wrt lock queue ordering and recovery:\n\t\t *    1. order of locks on granted queue is\n\t\t *       meaningless.\n\t\t *    2. order of locks on converting queue is\n\t\t *       LOST with the node death.  sorry charlie.\n\t\t *    3. order of locks on the blocked queue is\n\t\t *       also LOST.\n\t\t * order of locks does not affect integrity, it\n\t\t * just means that a lock request may get pushed\n\t\t * back in line as a result of the node death.\n\t\t * also note that for a given node the lock order\n\t\t * for its secondary queue locks is preserved\n\t\t * relative to each other, but clearly *not*\n\t\t * preserved relative to locks from other nodes.\n\t\t */\n\t\tbad = 0;\n\t\tspin_lock(&res->spinlock);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\tif (lock->ml.cookie == ml->cookie) {\n\t\t\t\tc = lock->ml.cookie;\n\t\t\t\tmlog(ML_ERROR, \"%s:%.*s: %u:%llu: lock already \"\n\t\t\t\t     \"exists on this lockres!\\n\", dlm->name,\n\t\t\t\t     res->lockname.len, res->lockname.name,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(c)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(c)));\n\n\t\t\t\tmlog(ML_NOTICE, \"sent lock: type=%d, conv=%d, \"\n\t\t\t\t     \"node=%u, cookie=%u:%llu, queue=%d\\n\",\n\t      \t\t\t     ml->type, ml->convert_type, ml->node,\n\t\t\t\t     dlm_get_lock_cookie_node(be64_to_cpu(ml->cookie)),\n\t\t\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(ml->cookie)),\n\t\t\t\t     ml->list);\n\n\t\t\t\t__dlm_print_one_lock_resource(res);\n\t\t\t\tbad = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!bad) {\n\t\t\tdlm_lock_get(newlock);\n\t\t\tif (mres->flags & DLM_MRES_RECOVERY &&\n\t\t\t\t\tml->list == DLM_CONVERTING_LIST &&\n\t\t\t\t\tnewlock->ml.type >\n\t\t\t\t\tnewlock->ml.convert_type) {\n\t\t\t\t/* newlock is doing downconvert, add it to the\n\t\t\t\t * head of converting list */\n\t\t\t\tlist_add(&newlock->list, queue);\n\t\t\t} else\n\t\t\t\tlist_add_tail(&newlock->list, queue);\n\t\t\tmlog(0, \"%s:%.*s: added lock for node %u, \"\n\t\t\t     \"setting refmap bit\\n\", dlm->name,\n\t\t\t     res->lockname.len, res->lockname.name, ml->node);\n\t\t\tdlm_lockres_set_refmap_bit(dlm, res, ml->node);\n\t\t\tadded++;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t}\n\tmlog(0, \"done running all the locks\\n\");\n\nleave:\n\t/* balance the ref taken when the work was queued */\n\tspin_lock(&res->spinlock);\n\tdlm_lockres_drop_inflight_ref(dlm, res);\n\tspin_unlock(&res->spinlock);\n\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"master needs to respond to sender \"\n\t\t\t\t  \"that node %u still owns %.*s\\n\"",
            "real_master",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_drop_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_drop_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "672-686",
          "snippet": "void dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_drop_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tBUG_ON(res->inflight_locks == 0);\n\n\tres->inflight_locks--;\n\n\tmlog(0, \"%s: res %.*s, inflight--: now %u, %ps()\\n\", dlm->name,\n\t     res->lockname.len, res->lockname.name, res->inflight_locks,\n\t     __builtin_return_address(0));\n\n\twake_up(&res->wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lockres %.*s not claimed.  \"\n\t\t\t\t   \"this node will take it.\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_master_requery",
          "args": [
            "dlm",
            "res",
            "&real_master"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_master_requery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1592-1647",
          "snippet": "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\n\t*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\t/* we only reach here if one of the two nodes in a\n\t * migration died while the migration was in progress.\n\t * at this point we need to requery the master.  we\n\t * know that the new_master got as far as creating\n\t * an mle on at least one node, but we do not know\n\t * if any nodes had actually cleared the mle and set\n\t * the master to the new_master.  the old master\n\t * is supposed to set the owner to UNKNOWN in the\n\t * event of a new_master death, so the only possible\n\t * responses that we can get from nodes here are\n\t * that the master is new_master, or that the master\n\t * is UNKNOWN.\n\t * if all nodes come back with UNKNOWN then we know\n\t * the lock needs remastering here.\n\t * if any node comes back with a valid master, check\n\t * to see if that master is the one that we are\n\t * recovering.  if so, then the new_master died and\n\t * we need to remaster this lock.  if not, then the\n\t * new_master survived and that node will respond to\n\t * other nodes about the owner.\n\t * if there is an owner, this node needs to dump this\n\t * lockres and alert the sender that this lockres\n\t * was rejected. */\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t}\n\t\tif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lock master is %u\\n\", *real_master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
            "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master)\n{\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint ret = 0;\n\n\t*real_master = DLM_LOCK_RES_OWNER_UNKNOWN;\n\n\t/* we only reach here if one of the two nodes in a\n\t * migration died while the migration was in progress.\n\t * at this point we need to requery the master.  we\n\t * know that the new_master got as far as creating\n\t * an mle on at least one node, but we do not know\n\t * if any nodes had actually cleared the mle and set\n\t * the master to the new_master.  the old master\n\t * is supposed to set the owner to UNKNOWN in the\n\t * event of a new_master death, so the only possible\n\t * responses that we can get from nodes here are\n\t * that the master is new_master, or that the master\n\t * is UNKNOWN.\n\t * if all nodes come back with UNKNOWN then we know\n\t * the lock needs remastering here.\n\t * if any node comes back with a valid master, check\n\t * to see if that master is the one that we are\n\t * recovering.  if so, then the new_master died and\n\t * we need to remaster this lock.  if not, then the\n\t * new_master survived and that node will respond to\n\t * other nodes about the owner.\n\t * if there is an owner, this node needs to dump this\n\t * lockres and alert the sender that this lockres\n\t * was rejected. */\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\t/* do not send to self */\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = dlm_do_master_requery(dlm, res, nodenum, real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tif (!dlm_is_host_down(ret))\n\t\t\t\tBUG();\n\t\t\t/* host is down, so answer for that node would be\n\t\t\t * DLM_LOCK_RES_OWNER_UNKNOWN.  continue. */\n\t\t}\n\t\tif (*real_master != DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lock master is %u\\n\", *real_master);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_ctxt *dlm;\n\tstruct dlm_migratable_lockres *mres;\n\tint ret = 0;\n\tstruct dlm_lock_resource *res;\n\tu8 real_master;\n\tu8 extra_ref;\n\n\tdlm = item->dlm;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tres = item->u.ml.lockres;\n\treal_master = item->u.ml.real_master;\n\textra_ref = item->u.ml.extra_ref;\n\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* this case is super-rare. only occurs if\n\t\t * node death happens during migration. */\nagain:\n\t\tret = dlm_lockres_master_requery(dlm, res, &real_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(0, \"dlm_lockres_master_requery ret=%d\\n\",\n\t\t\t\t  ret);\n\t\t\tgoto again;\n\t\t}\n\t\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"lockres %.*s not claimed.  \"\n\t\t\t\t   \"this node will take it.\\n\",\n\t\t\t\t   res->lockname.len, res->lockname.name);\n\t\t} else {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_lockres_drop_inflight_ref(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tmlog(0, \"master needs to respond to sender \"\n\t\t\t\t  \"that node %u still owns %.*s\\n\",\n\t\t\t\t  real_master, res->lockname.len,\n\t\t\t\t  res->lockname.name);\n\t\t\t/* cannot touch this lockres */\n\t\t\tgoto leave;\n\t\t}\n\t}\n\n\tret = dlm_process_recovery_data(dlm, res, mres);\n\tif (ret < 0)\n\t\tmlog(0, \"dlm_process_recovery_data returned  %d\\n\", ret);\n\telse\n\t\tmlog(0, \"dlm_process_recovery_data succeeded\\n\");\n\n\tif ((mres->flags & (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) ==\n\t                   (DLM_MRES_MIGRATION|DLM_MRES_ALL_DONE)) {\n\t\tret = dlm_finish_migration(dlm, res, mres->master);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\nleave:\n\t/* See comment in dlm_mig_lockres_handler() */\n\tif (res) {\n\t\tif (extra_ref)\n\t\t\tdlm_lockres_put(res);\n\t\tdlm_lockres_put(res);\n\t}\n\tkfree(data);\n}"
  },
  {
    "function_name": "dlm_mig_lockres_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1364-1521",
    "snippet": "int dlm_mig_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_migratable_lockres *mres =\n\t\t(struct dlm_migratable_lockres *)msg->buf;\n\tint ret = 0;\n\tu8 real_master;\n\tu8 extra_refs = 0;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\tstruct dlm_lock_resource *res = NULL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(!(mres->flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\treal_master = mres->master;\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* cannot migrate a lockres with no master */\n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t}\n\n\tmlog(0, \"%s message received from node %u\\n\",\n\t\t  (mres->flags & DLM_MRES_RECOVERY) ?\n\t\t  \"recovery\" : \"migration\", mres->master);\n\tif (mres->flags & DLM_MRES_ALL_DONE)\n\t\tmlog(0, \"all done flag.  all lockres data received!\\n\");\n\n\tret = -ENOMEM;\n\tbuf = kmalloc(be16_to_cpu(msg->data_len), GFP_NOFS);\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!buf || !item)\n\t\tgoto leave;\n\n\t/* lookup the lock to see if we have a secondary queue for this\n\t * already...  just add the locks in and this will have its owner\n\t * and RECOVERY flag changed when it completes. */\n\tres = dlm_lookup_lockres(dlm, mres->lockname, mres->lockname_len);\n\tif (res) {\n\t \t/* this will get a ref on res */\n\t\t/* mark it as recovering/migrating and hash it */\n\t\tspin_lock(&res->spinlock);\n\t\tif (mres->flags & DLM_MRES_RECOVERY) {\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\t} else {\n\t\t\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t\t\t/* this is at least the second\n\t\t\t\t * lockres message */\n\t\t\t\tmlog(0, \"lock %.*s is already migrating\\n\",\n\t\t\t\t\t  mres->lockname_len,\n\t\t\t\t\t  mres->lockname);\n\t\t\t} else if (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\t\t\t/* caller should BUG */\n\t\t\t\tmlog(ML_ERROR, \"node is attempting to migrate \"\n\t\t\t\t     \"lock %.*s, but marked as recovering!\\n\",\n\t\t\t\t     mres->lockname_len, mres->lockname);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t} else {\n\t\t/* need to allocate, just like if it was\n\t\t * mastered here normally  */\n\t\tres = dlm_new_lockres(dlm, mres->lockname, mres->lockname_len);\n\t\tif (!res)\n\t\t\tgoto leave;\n\n\t\t/* to match the ref that we would have gotten if\n\t\t * dlm_lookup_lockres had succeeded */\n\t\tdlm_lockres_get(res);\n\n\t\t/* mark it as recovering/migrating and hash it */\n\t\tif (mres->flags & DLM_MRES_RECOVERY)\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\telse\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\t/* Add an extra ref for this lock-less lockres lest the\n\t\t * dlm_thread purges it before we get the chance to add\n\t\t * locks to it */\n\t\tdlm_lockres_get(res);\n\n\t\t/* There are three refs that need to be put.\n\t\t * 1. Taken above.\n\t\t * 2. kref_init in dlm_new_lockres()->dlm_init_lockres().\n\t\t * 3. dlm_lookup_lockres()\n\t\t * The first one is handled at the end of this function. The\n\t\t * other two are handled in the worker thread after locks have\n\t\t * been attached. Yes, we don't wait for purge time to match\n\t\t * kref_init. The lockres will still have atleast one ref\n\t\t * added because it is in the hash __dlm_insert_lockres() */\n\t\textra_refs++;\n\n\t\t/* now that the new lockres is inserted,\n\t\t * make it usable by other processes */\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t}\n\n\t/* at this point we have allocated everything we need,\n\t * and we have a hashed lockres with an extra ref and\n\t * the proper res->state flags. */\n\tret = 0;\n\tspin_lock(&res->spinlock);\n\t/* drop this either when master requery finds a different master\n\t * or when a lock is added by the recovery worker */\n\tdlm_lockres_grab_inflight_ref(dlm, res);\n\tif (mres->master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* migration cannot have an unknown master */\n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t\tmlog(0, \"recovery has passed me a lockres with an \"\n\t\t\t  \"unknown owner.. will need to requery: \"\n\t\t\t  \"%.*s\\n\", mres->lockname_len, mres->lockname);\n\t} else {\n\t\t/* take a reference now to pin the lockres, drop it\n\t\t * when locks are added in the worker */\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* queue up work for dlm_mig_lockres_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tmemcpy(buf, msg->buf, be16_to_cpu(msg->data_len));  /* copy the whole message */\n\tdlm_init_work_item(dlm, item, dlm_mig_lockres_worker, buf);\n\titem->u.ml.lockres = res; /* already have a ref */\n\titem->u.ml.real_master = real_master;\n\titem->u.ml.extra_ref = extra_refs;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\nleave:\n\t/* One extra ref taken needs to be put here */\n\tif (extra_refs)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\tif (ret < 0) {\n\t\tkfree(buf);\n\t\tkfree(item);\n\t\tmlog_errno(ret);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);",
      "static int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "item"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "dlm->dlm_worker",
            "&dlm->dispatched_work"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->list",
            "&dlm->work_list"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_work_item",
          "args": [
            "dlm",
            "item",
            "dlm_mig_lockres_worker",
            "buf"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "254-263",
          "snippet": "static inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "msg->buf",
            "be16_to_cpu(msg->data_len)"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "msg->data_len"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_change_lockres_owner",
          "args": [
            "dlm",
            "res",
            "dlm->node_num"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_change_lockres_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1140-1148",
          "snippet": "static inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_change_lockres_owner(struct dlm_ctxt *dlm,\n\t\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t\t    u8 owner)\n{\n\tassert_spin_locked(&res->spinlock);\n\n\tif (owner != res->owner)\n\t\tdlm_set_lockres_owner(dlm, res, owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"recovery has passed me a lockres with an \"\n\t\t\t  \"unknown owner.. will need to requery: \"\n\t\t\t  \"%.*s\\n\"",
            "mres->lockname_len",
            "mres->lockname"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(mres->flags & DLM_MRES_RECOVERY)"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lockres_grab_inflight_ref",
          "args": [
            "dlm",
            "res"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_grab_inflight_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "665-670",
          "snippet": "void dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_grab_inflight_ref(struct dlm_ctxt *dlm,\n\t\t\t\t   struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\t__dlm_lockres_grab_inflight_ref(dlm, res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_get",
          "args": [
            "res"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "873-878",
          "snippet": "static inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_lockres_get(struct dlm_lock_resource *res)\n{\n\t/* This is called on every lookup, so it might be worth\n\t * inlining. */\n\tkref_get(&res->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_insert_lockres",
          "args": [
            "dlm",
            "res"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_insert_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "169-186",
          "snippet": "void __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nvoid __dlm_insert_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tstruct hlist_head *bucket;\n\tstruct qstr *q;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tq = &res->lockname;\n\tbucket = dlm_lockres_hash(dlm, q->hash);\n\n\t/* get a reference for our hashtable */\n\tdlm_lockres_get(res);\n\n\thlist_add_head(&res->hash_node, bucket);\n\n\tmlog(0, \"%s: Hash res %.*s\\n\", dlm->name, res->lockname.len,\n\t     res->lockname.name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lockres",
          "args": [
            "dlm",
            "mres->lockname",
            "mres->lockname_len"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "610-631",
          "snippet": "struct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dlm_lockres_cache;",
            "static struct kmem_cache *dlm_lockname_cache;",
            "static void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);",
            "static int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);",
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *dlm_lockres_cache;\nstatic struct kmem_cache *dlm_lockname_cache;\nstatic void dlm_init_mle(struct dlm_master_list_entry *mle,\n\t\t\tenum dlm_mle_type type,\n\t\t\tstruct dlm_ctxt *dlm,\n\t\t\tstruct dlm_lock_resource *res,\n\t\t\tconst char *name,\n\t\t\tunsigned int namelen);\nstatic int dlm_find_mle(struct dlm_ctxt *dlm,\n\t\t\tstruct dlm_master_list_entry **mle,\n\t\t\tchar *name, unsigned int namelen);\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nstruct dlm_lock_resource *dlm_new_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t   const char *name,\n\t\t\t\t   unsigned int namelen)\n{\n\tstruct dlm_lock_resource *res = NULL;\n\n\tres = kmem_cache_zalloc(dlm_lockres_cache, GFP_NOFS);\n\tif (!res)\n\t\tgoto error;\n\n\tres->lockname.name = kmem_cache_zalloc(dlm_lockname_cache, GFP_NOFS);\n\tif (!res->lockname.name)\n\t\tgoto error;\n\n\tdlm_init_lockres(dlm, res, name, namelen);\n\treturn res;\n\nerror:\n\tif (res)\n\t\tkmem_cache_free(dlm_lockres_cache, res);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "mres->lockname",
            "mres->lockname_len"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "be16_to_cpu(msg->data_len)",
            "GFP_NOFS"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "msg->data_len"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"all done flag.  all lockres data received!\\n\""
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(mres->flags & DLM_MRES_RECOVERY)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(mres->flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION))"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic int dlm_lockres_master_requery(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      u8 *real_master);\n\nint dlm_mig_lockres_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t    void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_migratable_lockres *mres =\n\t\t(struct dlm_migratable_lockres *)msg->buf;\n\tint ret = 0;\n\tu8 real_master;\n\tu8 extra_refs = 0;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\tstruct dlm_lock_resource *res = NULL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tBUG_ON(!(mres->flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\treal_master = mres->master;\n\tif (real_master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* cannot migrate a lockres with no master */\n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t}\n\n\tmlog(0, \"%s message received from node %u\\n\",\n\t\t  (mres->flags & DLM_MRES_RECOVERY) ?\n\t\t  \"recovery\" : \"migration\", mres->master);\n\tif (mres->flags & DLM_MRES_ALL_DONE)\n\t\tmlog(0, \"all done flag.  all lockres data received!\\n\");\n\n\tret = -ENOMEM;\n\tbuf = kmalloc(be16_to_cpu(msg->data_len), GFP_NOFS);\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!buf || !item)\n\t\tgoto leave;\n\n\t/* lookup the lock to see if we have a secondary queue for this\n\t * already...  just add the locks in and this will have its owner\n\t * and RECOVERY flag changed when it completes. */\n\tres = dlm_lookup_lockres(dlm, mres->lockname, mres->lockname_len);\n\tif (res) {\n\t \t/* this will get a ref on res */\n\t\t/* mark it as recovering/migrating and hash it */\n\t\tspin_lock(&res->spinlock);\n\t\tif (mres->flags & DLM_MRES_RECOVERY) {\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\t} else {\n\t\t\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t\t\t/* this is at least the second\n\t\t\t\t * lockres message */\n\t\t\t\tmlog(0, \"lock %.*s is already migrating\\n\",\n\t\t\t\t\t  mres->lockname_len,\n\t\t\t\t\t  mres->lockname);\n\t\t\t} else if (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\t\t\t/* caller should BUG */\n\t\t\t\tmlog(ML_ERROR, \"node is attempting to migrate \"\n\t\t\t\t     \"lock %.*s, but marked as recovering!\\n\",\n\t\t\t\t     mres->lockname_len, mres->lockname);\n\t\t\t\tret = -EFAULT;\n\t\t\t\tspin_unlock(&res->spinlock);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\t\t}\n\t\tspin_unlock(&res->spinlock);\n\t} else {\n\t\t/* need to allocate, just like if it was\n\t\t * mastered here normally  */\n\t\tres = dlm_new_lockres(dlm, mres->lockname, mres->lockname_len);\n\t\tif (!res)\n\t\t\tgoto leave;\n\n\t\t/* to match the ref that we would have gotten if\n\t\t * dlm_lookup_lockres had succeeded */\n\t\tdlm_lockres_get(res);\n\n\t\t/* mark it as recovering/migrating and hash it */\n\t\tif (mres->flags & DLM_MRES_RECOVERY)\n\t\t\tres->state |= DLM_LOCK_RES_RECOVERING;\n\t\telse\n\t\t\tres->state |= DLM_LOCK_RES_MIGRATING;\n\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_insert_lockres(dlm, res);\n\t\tspin_unlock(&dlm->spinlock);\n\n\t\t/* Add an extra ref for this lock-less lockres lest the\n\t\t * dlm_thread purges it before we get the chance to add\n\t\t * locks to it */\n\t\tdlm_lockres_get(res);\n\n\t\t/* There are three refs that need to be put.\n\t\t * 1. Taken above.\n\t\t * 2. kref_init in dlm_new_lockres()->dlm_init_lockres().\n\t\t * 3. dlm_lookup_lockres()\n\t\t * The first one is handled at the end of this function. The\n\t\t * other two are handled in the worker thread after locks have\n\t\t * been attached. Yes, we don't wait for purge time to match\n\t\t * kref_init. The lockres will still have atleast one ref\n\t\t * added because it is in the hash __dlm_insert_lockres() */\n\t\textra_refs++;\n\n\t\t/* now that the new lockres is inserted,\n\t\t * make it usable by other processes */\n\t\tspin_lock(&res->spinlock);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\tspin_unlock(&res->spinlock);\n\t\twake_up(&res->wq);\n\t}\n\n\t/* at this point we have allocated everything we need,\n\t * and we have a hashed lockres with an extra ref and\n\t * the proper res->state flags. */\n\tret = 0;\n\tspin_lock(&res->spinlock);\n\t/* drop this either when master requery finds a different master\n\t * or when a lock is added by the recovery worker */\n\tdlm_lockres_grab_inflight_ref(dlm, res);\n\tif (mres->master == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t/* migration cannot have an unknown master */\n\t\tBUG_ON(!(mres->flags & DLM_MRES_RECOVERY));\n\t\tmlog(0, \"recovery has passed me a lockres with an \"\n\t\t\t  \"unknown owner.. will need to requery: \"\n\t\t\t  \"%.*s\\n\", mres->lockname_len, mres->lockname);\n\t} else {\n\t\t/* take a reference now to pin the lockres, drop it\n\t\t * when locks are added in the worker */\n\t\tdlm_change_lockres_owner(dlm, res, dlm->node_num);\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* queue up work for dlm_mig_lockres_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tmemcpy(buf, msg->buf, be16_to_cpu(msg->data_len));  /* copy the whole message */\n\tdlm_init_work_item(dlm, item, dlm_mig_lockres_worker, buf);\n\titem->u.ml.lockres = res; /* already have a ref */\n\titem->u.ml.real_master = real_master;\n\titem->u.ml.extra_ref = extra_refs;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\nleave:\n\t/* One extra ref taken needs to be put here */\n\tif (extra_refs)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\tif (ret < 0) {\n\t\tkfree(buf);\n\t\tkfree(item);\n\t\tmlog_errno(ret);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_send_one_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1279-1347",
    "snippet": "int dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);",
      "static u64 dlm_get_next_mig_cookie(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\"",
            "dlm->name",
            "send_to",
            "flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: dlm_send_mig_lockres_msg returned %d\\n\"",
            "dlm->name",
            "ret"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_mig_lockres_msg",
          "args": [
            "dlm",
            "mres",
            "send_to",
            "res",
            "total_locks"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_mig_lockres_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1112-1172",
          "snippet": "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_migratable_lockres *mres,\n\t\t\t\t      u8 send_to,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      int total_locks)\n{\n\tu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\n\tint mres_total_locks = be32_to_cpu(mres->total_locks);\n\tint sz, ret = 0, status = 0;\n\tu8 orig_flags = mres->flags,\n\t   orig_master = mres->master;\n\n\tBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\n\tif (!mres->num_locks)\n\t\treturn 0;\n\n\tsz = sizeof(struct dlm_migratable_lockres) +\n\t\t(mres->num_locks * sizeof(struct dlm_migratable_lock));\n\n\t/* add an all-done flag if we reached the last lock */\n\torig_flags = mres->flags;\n\tBUG_ON(total_locks > mres_total_locks);\n\tif (total_locks == mres_total_locks)\n\t\tmres->flags |= DLM_MRES_ALL_DONE;\n\n\tmlog(0, \"%s:%.*s: sending mig lockres (%s) to %u\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\",\n\t     send_to);\n\n\t/* send it */\n\tret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\n\t\t\t\t sz, send_to, &status);\n\tif (ret < 0) {\n\t\t/* XXX: negative status is not handled.\n\t\t * this will end up killing this node. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\", dlm->name, mres->lockname_len,\n\t\t     mres->lockname, ret, send_to,\n\t\t     (orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\"));\n\t} else {\n\t\t/* might get an -ENOMEM back here */\n\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmlog(ML_ERROR, \"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\", send_to);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n\n\t/* zero and reinit the message buffer */\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, mres_total_locks,\n\t\t\t\t    mig_cookie, orig_flags, orig_master);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\n\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_migratable_lockres *mres,\n\t\t\t\t      u8 send_to,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      int total_locks)\n{\n\tu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\n\tint mres_total_locks = be32_to_cpu(mres->total_locks);\n\tint sz, ret = 0, status = 0;\n\tu8 orig_flags = mres->flags,\n\t   orig_master = mres->master;\n\n\tBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\n\tif (!mres->num_locks)\n\t\treturn 0;\n\n\tsz = sizeof(struct dlm_migratable_lockres) +\n\t\t(mres->num_locks * sizeof(struct dlm_migratable_lock));\n\n\t/* add an all-done flag if we reached the last lock */\n\torig_flags = mres->flags;\n\tBUG_ON(total_locks > mres_total_locks);\n\tif (total_locks == mres_total_locks)\n\t\tmres->flags |= DLM_MRES_ALL_DONE;\n\n\tmlog(0, \"%s:%.*s: sending mig lockres (%s) to %u\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\",\n\t     send_to);\n\n\t/* send it */\n\tret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\n\t\t\t\t sz, send_to, &status);\n\tif (ret < 0) {\n\t\t/* XXX: negative status is not handled.\n\t\t * this will end up killing this node. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\", dlm->name, mres->lockname_len,\n\t\t     mres->lockname, ret, send_to,\n\t\t     (orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\"));\n\t} else {\n\t\t/* might get an -ENOMEM back here */\n\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmlog(ML_ERROR, \"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\", send_to);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n\n\t/* zero and reinit the message buffer */\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, mres_total_locks,\n\t\t\t\t    mig_cookie, orig_flags, orig_master);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_add_dummy_lock",
          "args": [
            "dlm",
            "mres"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_dummy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1250-1262",
          "snippet": "static void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_lock dummy;\n\tmemset(&dummy, 0, sizeof(dummy));\n\tdummy.ml.cookie = 0;\n\tdummy.ml.type = LKM_IVMODE;\n\tdummy.ml.convert_type = LKM_IVMODE;\n\tdummy.ml.highest_blocked = LKM_IVMODE;\n\tdummy.lksb = NULL;\n\tdummy.ml.node = dlm->node_num;\n\tdlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_lock dummy;\n\tmemset(&dummy, 0, sizeof(dummy));\n\tdummy.ml.cookie = 0;\n\tdummy.ml.type = LKM_IVMODE;\n\tdummy.ml.convert_type = LKM_IVMODE;\n\tdummy.ml.highest_blocked = LKM_IVMODE;\n\tdummy.lksb = NULL;\n\tdummy.ml.node = dlm->node_num;\n\tdlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: sending dummy lock to %u, %s\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "send_to",
            "flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_add_lock_to_array",
          "args": [
            "lock",
            "mres",
            "i"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_lock_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1226-1248",
          "snippet": "static int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "queue",
            "list"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_list_idx_to_ptr",
          "args": [
            "res",
            "i"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_list_idx_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "417-430",
          "snippet": "static inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline struct list_head *\ndlm_list_idx_to_ptr(struct dlm_lock_resource *res, enum dlm_lockres_list idx)\n{\n\tstruct list_head *ret = NULL;\n\tif (idx == DLM_GRANTED_LIST)\n\t\tret = &res->granted;\n\telse if (idx == DLM_CONVERTING_LIST)\n\t\tret = &res->converting;\n\telse if (idx == DLM_BLOCKED_LIST)\n\t\tret = &res->blocked;\n\telse\n\t\tBUG();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_migratable_lockres",
          "args": [
            "mres",
            "res->lockname.name",
            "res->lockname.len",
            "total_locks",
            "mig_cookie",
            "flags",
            "res->owner"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_migratable_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1174-1188",
          "snippet": "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_next_mig_cookie",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_next_mig_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "104-115",
          "snippet": "static u64 dlm_get_next_mig_cookie(void)\n{\n\tu64 c;\n\tspin_lock(&dlm_mig_cookie_lock);\n\tc = dlm_mig_cookie;\n\tif (dlm_mig_cookie == (~0ULL))\n\t\tdlm_mig_cookie = 1;\n\telse\n\t\tdlm_mig_cookie++;\n\tspin_unlock(&dlm_mig_cookie_lock);\n\treturn c;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 dlm_get_next_mig_cookie(void);",
            "static DEFINE_SPINLOCK(dlm_mig_cookie_lock);",
            "static u64 dlm_mig_cookie = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u64 dlm_get_next_mig_cookie(void);\nstatic DEFINE_SPINLOCK(dlm_mig_cookie_lock);\nstatic u64 dlm_mig_cookie = 1;\n\nstatic u64 dlm_get_next_mig_cookie(void)\n{\n\tu64 c;\n\tspin_lock(&dlm_mig_cookie_lock);\n\tc = dlm_mig_cookie;\n\tif (dlm_mig_cookie == (~0ULL))\n\t\tdlm_mig_cookie = 1;\n\telse\n\t\tdlm_mig_cookie++;\n\tspin_unlock(&dlm_mig_cookie_lock);\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\"",
            "total_locks"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_num_locks_in_lockres",
          "args": [
            "res"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_num_locks_in_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1097-1109",
          "snippet": "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\n{\n\tint total_locks = 0;\n\tstruct list_head *iter, *queue = &res->granted;\n\tint i;\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each(iter, queue)\n\t\t\ttotal_locks++;\n\t\tqueue++;\n\t}\n\treturn total_locks;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\n{\n\tint total_locks = 0;\n\tstruct list_head *iter, *queue = &res->granted;\n\tint i;\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each(iter, queue)\n\t\t\ttotal_locks++;\n\t\tqueue++;\n\t}\n\treturn total_locks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION))"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic u64 dlm_get_next_mig_cookie(void);\n\nint dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_is_dummy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1264-1277",
    "snippet": "static inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lock *ml,\n\t\t\t\t    u8 *nodenum)\n{\n\tif (unlikely(ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST)) {\n\t\t*nodenum = ml->node;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic inline int dlm_is_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lock *ml,\n\t\t\t\t    u8 *nodenum)\n{\n\tif (unlikely(ml->cookie == 0 &&\n\t    ml->type == LKM_IVMODE &&\n\t    ml->convert_type == LKM_IVMODE &&\n\t    ml->highest_blocked == LKM_IVMODE &&\n\t    ml->list == DLM_BLOCKED_LIST)) {\n\t\t*nodenum = ml->node;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_add_dummy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1250-1262",
    "snippet": "static void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_lock dummy;\n\tmemset(&dummy, 0, sizeof(dummy));\n\tdummy.ml.cookie = 0;\n\tdummy.ml.type = LKM_IVMODE;\n\tdummy.ml.convert_type = LKM_IVMODE;\n\tdummy.ml.highest_blocked = LKM_IVMODE;\n\tdummy.lksb = NULL;\n\tdummy.ml.node = dlm->node_num;\n\tdlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_add_lock_to_array",
          "args": [
            "&dummy",
            "mres",
            "DLM_BLOCKED_LIST"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_lock_to_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1226-1248",
          "snippet": "static int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dummy",
            "0",
            "sizeof(dummy)"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic void dlm_add_dummy_lock(struct dlm_ctxt *dlm,\n\t\t\t       struct dlm_migratable_lockres *mres)\n{\n\tstruct dlm_lock dummy;\n\tmemset(&dummy, 0, sizeof(dummy));\n\tdummy.ml.cookie = 0;\n\tdummy.ml.type = LKM_IVMODE;\n\tdummy.ml.convert_type = LKM_IVMODE;\n\tdummy.ml.highest_blocked = LKM_IVMODE;\n\tdummy.lksb = NULL;\n\tdummy.ml.node = dlm->node_num;\n\tdlm_add_lock_to_array(&dummy, mres, DLM_BLOCKED_LIST);\n}"
  },
  {
    "function_name": "dlm_add_lock_to_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1226-1248",
    "snippet": "static int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_prepare_lvb_for_migration",
          "args": [
            "lock",
            "mres",
            "queue"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_prepare_lvb_for_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1190-1222",
          "snippet": "static void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_migratable_lockres *mres,\n\t\t\t\t\t  int queue)\n{\n\tif (!lock->lksb)\n\t       return;\n\n\t/* Ignore lvb in all locks in the blocked list */\n\tif (queue == DLM_BLOCKED_LIST)\n\t\treturn;\n\n\t/* Only consider lvbs in locks with granted EX or PR lock levels */\n\tif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\n\t\treturn;\n\n\tif (dlm_lvb_is_empty(mres->lvb)) {\n\t\tmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\t\treturn;\n\t}\n\n\t/* Ensure the lvb copied for migration matches in other valid locks */\n\tif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\n\t\treturn;\n\n\tmlog(ML_ERROR, \"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     lock->lockres->lockname.len, lock->lockres->lockname.name,\n\t     lock->ml.node);\n\tdlm_print_one_lock_resource(lock->lockres);\n\tBUG();\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_migratable_lockres *mres,\n\t\t\t\t\t  int queue)\n{\n\tif (!lock->lksb)\n\t       return;\n\n\t/* Ignore lvb in all locks in the blocked list */\n\tif (queue == DLM_BLOCKED_LIST)\n\t\treturn;\n\n\t/* Only consider lvbs in locks with granted EX or PR lock levels */\n\tif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\n\t\treturn;\n\n\tif (dlm_lvb_is_empty(mres->lvb)) {\n\t\tmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\t\treturn;\n\t}\n\n\t/* Ensure the lvb copied for migration matches in other valid locks */\n\tif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\n\t\treturn;\n\n\tmlog(ML_ERROR, \"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     lock->lockres->lockname.len, lock->lockres->lockname.name,\n\t     lock->ml.node);\n\tdlm_print_one_lock_resource(lock->lockres);\n\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic int dlm_add_lock_to_array(struct dlm_lock *lock,\n\t\t\t\t struct dlm_migratable_lockres *mres, int queue)\n{\n\tstruct dlm_migratable_lock *ml;\n\tint lock_num = mres->num_locks;\n\n\tml = &(mres->ml[lock_num]);\n\tml->cookie = lock->ml.cookie;\n\tml->type = lock->ml.type;\n\tml->convert_type = lock->ml.convert_type;\n\tml->highest_blocked = lock->ml.highest_blocked;\n\tml->list = queue;\n\tif (lock->lksb) {\n\t\tml->flags = lock->lksb->flags;\n\t\tdlm_prepare_lvb_for_migration(lock, mres, queue);\n\t}\n\tml->node = lock->ml.node;\n\tmres->num_locks++;\n\t/* we reached the max, send this network message */\n\tif (mres->num_locks == DLM_MAX_MIGRATABLE_LOCKS)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_prepare_lvb_for_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1190-1222",
    "snippet": "static void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_migratable_lockres *mres,\n\t\t\t\t\t  int queue)\n{\n\tif (!lock->lksb)\n\t       return;\n\n\t/* Ignore lvb in all locks in the blocked list */\n\tif (queue == DLM_BLOCKED_LIST)\n\t\treturn;\n\n\t/* Only consider lvbs in locks with granted EX or PR lock levels */\n\tif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\n\t\treturn;\n\n\tif (dlm_lvb_is_empty(mres->lvb)) {\n\t\tmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\t\treturn;\n\t}\n\n\t/* Ensure the lvb copied for migration matches in other valid locks */\n\tif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\n\t\treturn;\n\n\tmlog(ML_ERROR, \"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     lock->lockres->lockname.len, lock->lockres->lockname.name,\n\t     lock->ml.node);\n\tdlm_print_one_lock_resource(lock->lockres);\n\tBUG();\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "lock->lockres"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "lock->lockres->lockname.len",
            "lock->lockres->lockname.name",
            "lock->ml.node"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "mres->lvb",
            "lock->lksb->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mres->lvb",
            "lock->lksb->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lvb_is_empty",
          "args": [
            "mres->lvb"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lvb_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "396-403",
          "snippet": "static inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lvb_is_empty(char *lvb)\n{\n\tint i;\n\tfor (i=0; i<DLM_LVB_LEN; i++)\n\t\tif (lvb[i])\n\t\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic void dlm_prepare_lvb_for_migration(struct dlm_lock *lock,\n\t\t\t\t\t  struct dlm_migratable_lockres *mres,\n\t\t\t\t\t  int queue)\n{\n\tif (!lock->lksb)\n\t       return;\n\n\t/* Ignore lvb in all locks in the blocked list */\n\tif (queue == DLM_BLOCKED_LIST)\n\t\treturn;\n\n\t/* Only consider lvbs in locks with granted EX or PR lock levels */\n\tif (lock->ml.type != LKM_EXMODE && lock->ml.type != LKM_PRMODE)\n\t\treturn;\n\n\tif (dlm_lvb_is_empty(mres->lvb)) {\n\t\tmemcpy(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\t\treturn;\n\t}\n\n\t/* Ensure the lvb copied for migration matches in other valid locks */\n\tif (!memcmp(mres->lvb, lock->lksb->lvb, DLM_LVB_LEN))\n\t\treturn;\n\n\tmlog(ML_ERROR, \"Mismatched lvb in lock cookie=%u:%llu, name=%.*s, \"\n\t     \"node=%u\\n\",\n\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t     lock->lockres->lockname.len, lock->lockres->lockname.name,\n\t     lock->ml.node);\n\tdlm_print_one_lock_resource(lock->lockres);\n\tBUG();\n}"
  },
  {
    "function_name": "dlm_init_migratable_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1174-1188",
    "snippet": "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "cookie"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "total_locks"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mres->lockname",
            "lockname",
            "namelen"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "mres"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}"
  },
  {
    "function_name": "dlm_send_mig_lockres_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1112-1172",
    "snippet": "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_migratable_lockres *mres,\n\t\t\t\t      u8 send_to,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      int total_locks)\n{\n\tu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\n\tint mres_total_locks = be32_to_cpu(mres->total_locks);\n\tint sz, ret = 0, status = 0;\n\tu8 orig_flags = mres->flags,\n\t   orig_master = mres->master;\n\n\tBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\n\tif (!mres->num_locks)\n\t\treturn 0;\n\n\tsz = sizeof(struct dlm_migratable_lockres) +\n\t\t(mres->num_locks * sizeof(struct dlm_migratable_lock));\n\n\t/* add an all-done flag if we reached the last lock */\n\torig_flags = mres->flags;\n\tBUG_ON(total_locks > mres_total_locks);\n\tif (total_locks == mres_total_locks)\n\t\tmres->flags |= DLM_MRES_ALL_DONE;\n\n\tmlog(0, \"%s:%.*s: sending mig lockres (%s) to %u\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\",\n\t     send_to);\n\n\t/* send it */\n\tret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\n\t\t\t\t sz, send_to, &status);\n\tif (ret < 0) {\n\t\t/* XXX: negative status is not handled.\n\t\t * this will end up killing this node. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\", dlm->name, mres->lockname_len,\n\t\t     mres->lockname, ret, send_to,\n\t\t     (orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\"));\n\t} else {\n\t\t/* might get an -ENOMEM back here */\n\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmlog(ML_ERROR, \"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\", send_to);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n\n\t/* zero and reinit the message buffer */\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, mres_total_locks,\n\t\t\t\t    mig_cookie, orig_flags, orig_master);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_init_migratable_lockres",
          "args": [
            "mres",
            "res->lockname.name",
            "res->lockname.len",
            "mres_total_locks",
            "mig_cookie",
            "orig_flags",
            "orig_master"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_migratable_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1174-1188",
          "snippet": "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\n\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master)\n{\n\t/* mres here is one full page */\n\tclear_page(mres);\n\tmres->lockname_len = namelen;\n\tmemcpy(mres->lockname, lockname, namelen);\n\tmres->num_locks = 0;\n\tmres->total_locks = cpu_to_be32(total_locks);\n\tmres->mig_cookie = cpu_to_be64(cookie);\n\tmres->flags = flags;\n\tmres->master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\"",
            "send_to"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\"",
            "dlm->name",
            "mres->lockname_len",
            "mres->lockname",
            "ret",
            "send_to",
            "(orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\")"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_MIG_LOCKRES_MSG",
            "dlm->key",
            "mres",
            "sz",
            "send_to",
            "&status"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s:%.*s: sending mig lockres (%s) to %u\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name",
            "orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\"",
            "send_to"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "total_locks > mres_total_locks"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "mres->total_locks"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "mres->mig_cookie"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\n\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_migratable_lockres *mres,\n\t\t\t\t      u8 send_to,\n\t\t\t\t      struct dlm_lock_resource *res,\n\t\t\t\t      int total_locks)\n{\n\tu64 mig_cookie = be64_to_cpu(mres->mig_cookie);\n\tint mres_total_locks = be32_to_cpu(mres->total_locks);\n\tint sz, ret = 0, status = 0;\n\tu8 orig_flags = mres->flags,\n\t   orig_master = mres->master;\n\n\tBUG_ON(mres->num_locks > DLM_MAX_MIGRATABLE_LOCKS);\n\tif (!mres->num_locks)\n\t\treturn 0;\n\n\tsz = sizeof(struct dlm_migratable_lockres) +\n\t\t(mres->num_locks * sizeof(struct dlm_migratable_lock));\n\n\t/* add an all-done flag if we reached the last lock */\n\torig_flags = mres->flags;\n\tBUG_ON(total_locks > mres_total_locks);\n\tif (total_locks == mres_total_locks)\n\t\tmres->flags |= DLM_MRES_ALL_DONE;\n\n\tmlog(0, \"%s:%.*s: sending mig lockres (%s) to %u\\n\",\n\t     dlm->name, res->lockname.len, res->lockname.name,\n\t     orig_flags & DLM_MRES_MIGRATION ? \"migration\" : \"recovery\",\n\t     send_to);\n\n\t/* send it */\n\tret = o2net_send_message(DLM_MIG_LOCKRES_MSG, dlm->key, mres,\n\t\t\t\t sz, send_to, &status);\n\tif (ret < 0) {\n\t\t/* XXX: negative status is not handled.\n\t\t * this will end up killing this node. */\n\t\tmlog(ML_ERROR, \"%s: res %.*s, Error %d send MIG_LOCKRES to \"\n\t\t     \"node %u (%s)\\n\", dlm->name, mres->lockname_len,\n\t\t     mres->lockname, ret, send_to,\n\t\t     (orig_flags & DLM_MRES_MIGRATION ?\n\t\t      \"migration\" : \"recovery\"));\n\t} else {\n\t\t/* might get an -ENOMEM back here */\n\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmlog(ML_ERROR, \"node %u told me to kill \"\n\t\t\t\t     \"myself!\\n\", send_to);\n\t\t\t\tBUG();\n\t\t\t}\n\t\t}\n\t}\n\n\t/* zero and reinit the message buffer */\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, mres_total_locks,\n\t\t\t\t    mig_cookie, orig_flags, orig_master);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_num_locks_in_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1097-1109",
    "snippet": "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\n{\n\tint total_locks = 0;\n\tstruct list_head *iter, *queue = &res->granted;\n\tint i;\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each(iter, queue)\n\t\t\ttotal_locks++;\n\t\tqueue++;\n\t}\n\treturn total_locks;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "iter",
            "queue"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\n\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res)\n{\n\tint total_locks = 0;\n\tstruct list_head *iter, *queue = &res->granted;\n\tint i;\n\n\tfor (i=0; i<3; i++) {\n\t\tlist_for_each(iter, queue)\n\t\t\ttotal_locks++;\n\t\tqueue++;\n\t}\n\treturn total_locks;\n}"
  },
  {
    "function_name": "dlm_move_reco_locks_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "1051-1095",
    "snippet": "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t       \tu8 dead_node)\n{\n\tstruct dlm_lock_resource *res, *next;\n\tstruct dlm_lock *lock;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\t/* always prune any $RECOVERY entries for dead nodes,\n\t\t * otherwise hangs can occur during later recovery */\n\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t * - do manually */\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"found lockres owned by dead node while \"\n\t\t\t\t  \"doing recovery for node %u. sending it.\\n\",\n\t\t\t\t  dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\", dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&res->recovering",
            "list"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\"",
            "dead_node"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&res->recovering",
            "list"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lock->list"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\"",
            "dead_node",
            "dlm->name"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lock",
            "&res->granted",
            "list"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_recovery_lock",
          "args": [
            "res->lockname.name",
            "res->lockname.len"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_recovery_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "97-103",
          "snippet": "static inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_RECOVERY_LOCK_NAME_LEN   9",
            "#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_RECOVERY_LOCK_NAME_LEN   9\n#define DLM_RECOVERY_LOCK_NAME       \"$RECOVERY\"\n\nstatic inline int dlm_is_recovery_lock(const char *lock_name, int name_len)\n{\n\tif (name_len == DLM_RECOVERY_LOCK_NAME_LEN &&\n\t    memcmp(lock_name, DLM_RECOVERY_LOCK_NAME, name_len)==0)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "res",
            "next",
            "&dlm->reco.resources",
            "recovering"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t       \tu8 dead_node)\n{\n\tstruct dlm_lock_resource *res, *next;\n\tstruct dlm_lock *lock;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\t/* always prune any $RECOVERY entries for dead nodes,\n\t\t * otherwise hangs can occur during later recovery */\n\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t * - do manually */\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"found lockres owned by dead node while \"\n\t\t\t\t  \"doing recovery for node %u. sending it.\\n\",\n\t\t\t\t  dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\", dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_reco_data_done_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "986-1049",
    "snippet": "int dlm_reco_data_done_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_reco_data_done *done = (struct dlm_reco_data_done *)msg->buf;\n\tstruct dlm_reco_node_data *ndata = NULL;\n\tint ret = -EINVAL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tmlog(0, \"got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t     \"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t     dlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tmlog_bug_on_msg((done->dead_node != dlm->reco.dead_node),\n\t\t\t\"Got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t\t\t\"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t\t\tdlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tif (ndata->node_num != done->node_idx)\n\t\t\tcontinue;\n\n\t\tswitch (ndata->state) {\n\t\t\t/* should have moved beyond INIT but not to FINALIZE yet */\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tmlog(ML_ERROR, \"bad ndata state for node %u:\"\n\t\t\t\t     \" state=%d\\n\", ndata->node_num,\n\t\t\t\t     ndata->state);\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\t/* these states are possible at this point, anywhere along\n\t\t\t * the line of recovery */\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tmlog(0, \"node %u is DONE sending \"\n\t\t\t\t\t  \"recovery data!\\n\",\n\t\t\t\t\t  ndata->node_num);\n\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dlm_reco_state_lock);\n\n\t/* wake the recovery thread, some node is done */\n\tif (!ret)\n\t\tdlm_kick_recovery_thread(dlm);\n\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"failed to find recovery node data for node \"\n\t\t     \"%u\\n\", done->node_idx);\n\tdlm_put(dlm);\n\n\tmlog(0, \"leaving reco data done handler, ret=%d\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);",
      "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"leaving reco data done handler, ret=%d\\n\"",
            "ret"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_recovery_thread",
          "args": [
            "dlm"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_recovery_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "191-200",
          "snippet": "void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_recovery_thread(void *data);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
            "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"bad ndata state for node %u:\"\n\t\t\t\t     \" state=%d\\n\"",
            "ndata->node_num",
            "ndata->state"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ndata",
            "&dlm->reco.node_data",
            "list"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "(done->dead_node != dlm->reco.dead_node)",
            "\"Got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t\t\t\"node_idx=%u, this node=%u\\n\"",
            "done->dead_node",
            "dlm->reco.dead_node",
            "done->node_idx",
            "dlm->node_num"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t     \"node_idx=%u, this node=%u\\n\"",
            "done->dead_node",
            "dlm->reco.dead_node",
            "done->node_idx",
            "dlm->node_num"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nint dlm_reco_data_done_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t       void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_reco_data_done *done = (struct dlm_reco_data_done *)msg->buf;\n\tstruct dlm_reco_node_data *ndata = NULL;\n\tint ret = -EINVAL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tmlog(0, \"got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t     \"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t     dlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tmlog_bug_on_msg((done->dead_node != dlm->reco.dead_node),\n\t\t\t\"Got DATA DONE: dead_node=%u, reco.dead_node=%u, \"\n\t\t\t\"node_idx=%u, this node=%u\\n\", done->dead_node,\n\t\t\tdlm->reco.dead_node, done->node_idx, dlm->node_num);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tif (ndata->node_num != done->node_idx)\n\t\t\tcontinue;\n\n\t\tswitch (ndata->state) {\n\t\t\t/* should have moved beyond INIT but not to FINALIZE yet */\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tmlog(ML_ERROR, \"bad ndata state for node %u:\"\n\t\t\t\t     \" state=%d\\n\", ndata->node_num,\n\t\t\t\t     ndata->state);\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\t/* these states are possible at this point, anywhere along\n\t\t\t * the line of recovery */\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tmlog(0, \"node %u is DONE sending \"\n\t\t\t\t\t  \"recovery data!\\n\",\n\t\t\t\t\t  ndata->node_num);\n\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dlm_reco_state_lock);\n\n\t/* wake the recovery thread, some node is done */\n\tif (!ret)\n\t\tdlm_kick_recovery_thread(dlm);\n\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"failed to find recovery node data for node \"\n\t\t     \"%u\\n\", done->node_idx);\n\tdlm_put(dlm);\n\n\tmlog(0, \"leaving reco data done handler, ret=%d\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_send_all_done_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "959-983",
    "snippet": "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\n{\n\tint ret, tmpret;\n\tstruct dlm_reco_data_done done_msg;\n\n\tmemset(&done_msg, 0, sizeof(done_msg));\n\tdone_msg.node_idx = dlm->node_num;\n\tdone_msg.dead_node = dead_node;\n\tmlog(0, \"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\", send_to, done_msg.node_idx,\n\t     done_msg.dead_node);\n\n\tret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\n\t\t\t\t sizeof(done_msg), send_to, &tmpret);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret, send_to,\n\t\t     dead_node);\n\t\tif (!dlm_is_host_down(ret)) {\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\tret = tmpret;\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "ret"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\"",
            "dlm->name",
            "ret",
            "send_to",
            "dead_node"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_RECO_DATA_DONE_MSG",
            "dlm->key",
            "&done_msg",
            "sizeof(done_msg)",
            "send_to",
            "&tmpret"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\"",
            "send_to",
            "done_msg.node_idx",
            "done_msg.dead_node"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&done_msg",
            "0",
            "sizeof(done_msg)"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\n{\n\tint ret, tmpret;\n\tstruct dlm_reco_data_done done_msg;\n\n\tmemset(&done_msg, 0, sizeof(done_msg));\n\tdone_msg.node_idx = dlm->node_num;\n\tdone_msg.dead_node = dead_node;\n\tmlog(0, \"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\", send_to, done_msg.node_idx,\n\t     done_msg.dead_node);\n\n\tret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\n\t\t\t\t sizeof(done_msg), send_to, &tmpret);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret, send_to,\n\t\t     dead_node);\n\t\tif (!dlm_is_host_down(ret)) {\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\tret = tmpret;\n\treturn ret;\n}"
  },
  {
    "function_name": "dlm_request_all_locks_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "880-956",
    "snippet": "static void dlm_request_all_locks_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_migratable_lockres *mres;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm;\n\tLIST_HEAD(resources);\n\tint ret;\n\tu8 dead_node, reco_master;\n\tint skip_all_done = 0;\n\n\tdlm = item->dlm;\n\tdead_node = item->u.ral.dead_node;\n\treco_master = item->u.ral.reco_master;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tmlog(0, \"%s: recovery worker started, dead=%u, master=%u\\n\",\n\t     dlm->name, dead_node, reco_master);\n\n\tif (dead_node != dlm->reco.dead_node ||\n\t    reco_master != dlm->reco.new_master) {\n\t\t/* worker could have been created before the recovery master\n\t\t * died.  if so, do not continue, but do not error. */\n\t\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t\tmlog(ML_NOTICE, \"%s: will not send recovery state, \"\n\t\t\t     \"recovery master %u died, thread=(dead=%u,mas=%u)\"\n\t\t\t     \" current=(dead=%u,mas=%u)\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, reco_master,\n\t\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\t} else {\n\t\t\tmlog(ML_NOTICE, \"%s: reco state invalid: reco(dead=%u, \"\n\t\t\t     \"master=%u), request(dead=%u, master=%u)\\n\",\n\t\t\t     dlm->name, dlm->reco.dead_node,\n\t\t\t     dlm->reco.new_master, dead_node, reco_master);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/* lock resources should have already been moved to the\n \t * dlm->reco.resources list.  now move items from that list\n \t * to a temp list if the dead owner matches.  note that the\n\t * whole cluster recovers only one node at a time, so we\n\t * can safely move UNKNOWN lock resources for each recovery\n\t * session. */\n\tdlm_move_reco_locks_to_list(dlm, &resources, dead_node);\n\n\t/* now we can begin blasting lockreses without the dlm lock */\n\n\t/* any errors returned will be due to the new_master dying,\n\t * the dlm_reco_thread should detect this */\n\tlist_for_each_entry(res, &resources, recovering) {\n\t\tret = dlm_send_one_lockres(dlm, res, mres, reco_master,\n\t\t\t\t   \tDLM_MRES_RECOVERY);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery state for dead node %u, ret=%d\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, ret);\n\t\t\tskip_all_done = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* move the resources back to the list */\n\tspin_lock(&dlm->spinlock);\n\tlist_splice_init(&resources, &dlm->reco.resources);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (!skip_all_done) {\n\t\tret = dlm_send_all_done_msg(dlm, dead_node, reco_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery all-done for dead node %u, ret=%d\\n\",\n\t\t\t     dlm->name, reco_master, dead_node, ret);\n\t\t}\n\t}\nleave:\n\tfree_page((unsigned long)data);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)data"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: node %u went down while sending \"\n\t\t\t     \"recovery all-done for dead node %u, ret=%d\\n\"",
            "dlm->name",
            "reco_master",
            "dead_node",
            "ret"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_all_done_msg",
          "args": [
            "dlm",
            "dead_node",
            "reco_master"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_all_done_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "959-983",
          "snippet": "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\n{\n\tint ret, tmpret;\n\tstruct dlm_reco_data_done done_msg;\n\n\tmemset(&done_msg, 0, sizeof(done_msg));\n\tdone_msg.node_idx = dlm->node_num;\n\tdone_msg.dead_node = dead_node;\n\tmlog(0, \"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\", send_to, done_msg.node_idx,\n\t     done_msg.dead_node);\n\n\tret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\n\t\t\t\t sizeof(done_msg), send_to, &tmpret);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret, send_to,\n\t\t     dead_node);\n\t\tif (!dlm_is_host_down(ret)) {\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\tret = tmpret;\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm, u8 dead_node, u8 send_to)\n{\n\tint ret, tmpret;\n\tstruct dlm_reco_data_done done_msg;\n\n\tmemset(&done_msg, 0, sizeof(done_msg));\n\tdone_msg.node_idx = dlm->node_num;\n\tdone_msg.dead_node = dead_node;\n\tmlog(0, \"sending DATA DONE message to %u, \"\n\t     \"my node=%u, dead node=%u\\n\", send_to, done_msg.node_idx,\n\t     done_msg.dead_node);\n\n\tret = o2net_send_message(DLM_RECO_DATA_DONE_MSG, dlm->key, &done_msg,\n\t\t\t\t sizeof(done_msg), send_to, &tmpret);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"%s: Error %d send RECO_DATA_DONE to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret, send_to,\n\t\t     dead_node);\n\t\tif (!dlm_is_host_down(ret)) {\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\tret = tmpret;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&resources",
            "&dlm->reco.resources"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: node %u went down while sending \"\n\t\t\t     \"recovery state for dead node %u, ret=%d\\n\"",
            "dlm->name",
            "reco_master",
            "dead_node",
            "ret"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_one_lockres",
          "args": [
            "dlm",
            "res",
            "mres",
            "reco_master",
            "DLM_MRES_RECOVERY"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_one_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1279-1347",
          "snippet": "int dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);",
            "static int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);",
            "static u64 dlm_get_next_mig_cookie(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_mig_lockres_msg(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_migratable_lockres *mres,\n\t\t\t\t    u8 send_to,\n\t\t\t\t    struct dlm_lock_resource *res,\n\t\t\t\t    int total_locks);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_all_done_msg(struct dlm_ctxt *dlm,\n\t\t\t\t u8 dead_node, u8 send_to);\nstatic u64 dlm_get_next_mig_cookie(void);\n\nint dlm_send_one_lockres(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t struct dlm_migratable_lockres *mres,\n\t\t\t u8 send_to, u8 flags)\n{\n\tstruct list_head *queue;\n\tint total_locks, i;\n\tu64 mig_cookie = 0;\n\tstruct dlm_lock *lock;\n\tint ret = 0;\n\n\tBUG_ON(!(flags & (DLM_MRES_RECOVERY|DLM_MRES_MIGRATION)));\n\n\tmlog(0, \"sending to %u\\n\", send_to);\n\n\ttotal_locks = dlm_num_locks_in_lockres(res);\n\tif (total_locks > DLM_MAX_MIGRATABLE_LOCKS) {\n\t\t/* rare, but possible */\n\t\tmlog(0, \"argh.  lockres has %d locks.  this will \"\n\t\t\t  \"require more than one network packet to \"\n\t\t\t  \"migrate\\n\", total_locks);\n\t\tmig_cookie = dlm_get_next_mig_cookie();\n\t}\n\n\tdlm_init_migratable_lockres(mres, res->lockname.name,\n\t\t\t\t    res->lockname.len, total_locks,\n\t\t\t\t    mig_cookie, flags, res->owner);\n\n\ttotal_locks = 0;\n\tfor (i=DLM_GRANTED_LIST; i<=DLM_BLOCKED_LIST; i++) {\n\t\tqueue = dlm_list_idx_to_ptr(res, i);\n\t\tlist_for_each_entry(lock, queue, list) {\n\t\t\t/* add another lock. */\n\t\t\ttotal_locks++;\n\t\t\tif (!dlm_add_lock_to_array(lock, mres, i))\n\t\t\t\tcontinue;\n\n\t\t\t/* this filled the lock message,\n\t\t\t * we must send it immediately. */\n\t\t\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to,\n\t\t\t\t\t\t       res, total_locks);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (total_locks == 0) {\n\t\t/* send a dummy lock to indicate a mastery reference only */\n\t\tmlog(0, \"%s:%.*s: sending dummy lock to %u, %s\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t     send_to, flags & DLM_MRES_RECOVERY ? \"recovery\" :\n\t\t     \"migration\");\n\t\tdlm_add_dummy_lock(dlm, mres);\n\t}\n\t/* flush any remaining locks */\n\tret = dlm_send_mig_lockres_msg(dlm, mres, send_to, res, total_locks);\n\tif (ret < 0)\n\t\tgoto error;\n\treturn ret;\n\nerror:\n\tmlog(ML_ERROR, \"%s: dlm_send_mig_lockres_msg returned %d\\n\",\n\t     dlm->name, ret);\n\tif (!dlm_is_host_down(ret))\n\t\tBUG();\n\tmlog(0, \"%s: node %u went down while sending %s \"\n\t     \"lockres %.*s\\n\", dlm->name, send_to,\n\t     flags & DLM_MRES_RECOVERY ?  \"recovery\" : \"migration\",\n\t     res->lockname.len, res->lockname.name);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "res",
            "&resources",
            "recovering"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_move_reco_locks_to_list",
          "args": [
            "dlm",
            "&resources",
            "dead_node"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_move_reco_locks_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "1051-1095",
          "snippet": "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t       \tu8 dead_node)\n{\n\tstruct dlm_lock_resource *res, *next;\n\tstruct dlm_lock *lock;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\t/* always prune any $RECOVERY entries for dead nodes,\n\t\t * otherwise hangs can occur during later recovery */\n\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t * - do manually */\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"found lockres owned by dead node while \"\n\t\t\t\t  \"doing recovery for node %u. sending it.\\n\",\n\t\t\t\t  dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\", dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list,\n\t\t\t\t       \tu8 dead_node)\n{\n\tstruct dlm_lock_resource *res, *next;\n\tstruct dlm_lock *lock;\n\n\tspin_lock(&dlm->spinlock);\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\t/* always prune any $RECOVERY entries for dead nodes,\n\t\t * otherwise hangs can occur during later recovery */\n\t\tif (dlm_is_recovery_lock(res->lockname.name,\n\t\t\t\t\t res->lockname.len)) {\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t\t\tif (lock->ml.node == dead_node) {\n\t\t\t\t\tmlog(0, \"AHA! there was \"\n\t\t\t\t\t     \"a $RECOVERY lock for dead \"\n\t\t\t\t\t     \"node %u (%s)!\\n\",\n\t\t\t\t\t     dead_node, dlm->name);\n\t\t\t\t\tlist_del_init(&lock->list);\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\t/* Can't schedule DLM_UNLOCK_FREE_LOCK\n\t\t\t\t\t * - do manually */\n\t\t\t\t\tdlm_lock_put(lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"found lockres owned by dead node while \"\n\t\t\t\t  \"doing recovery for node %u. sending it.\\n\",\n\t\t\t\t  dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t} else if (res->owner == DLM_LOCK_RES_OWNER_UNKNOWN) {\n\t\t\tmlog(0, \"found UNKNOWN owner while doing recovery \"\n\t\t\t\t  \"for node %u. sending it.\\n\", dead_node);\n\t\t\tlist_move_tail(&res->recovering, list);\n\t\t}\n\t}\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: reco state invalid: reco(dead=%u, \"\n\t\t\t     \"master=%u), request(dead=%u, master=%u)\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "dlm->reco.new_master",
            "dead_node",
            "reco_master"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: will not send recovery state, \"\n\t\t\t     \"recovery master %u died, thread=(dead=%u,mas=%u)\"\n\t\t\t     \" current=(dead=%u,mas=%u)\\n\"",
            "dlm->name",
            "reco_master",
            "dead_node",
            "reco_master",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: recovery worker started, dead=%u, master=%u\\n\"",
            "dlm->name",
            "dead_node",
            "reco_master"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "resources"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_process_recovery_data(struct dlm_ctxt *dlm,\n\t\t\t\t     struct dlm_lock_resource *res,\n\t\t\t\t     struct dlm_migratable_lockres *mres);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item, void *data)\n{\n\tstruct dlm_migratable_lockres *mres;\n\tstruct dlm_lock_resource *res;\n\tstruct dlm_ctxt *dlm;\n\tLIST_HEAD(resources);\n\tint ret;\n\tu8 dead_node, reco_master;\n\tint skip_all_done = 0;\n\n\tdlm = item->dlm;\n\tdead_node = item->u.ral.dead_node;\n\treco_master = item->u.ral.reco_master;\n\tmres = (struct dlm_migratable_lockres *)data;\n\n\tmlog(0, \"%s: recovery worker started, dead=%u, master=%u\\n\",\n\t     dlm->name, dead_node, reco_master);\n\n\tif (dead_node != dlm->reco.dead_node ||\n\t    reco_master != dlm->reco.new_master) {\n\t\t/* worker could have been created before the recovery master\n\t\t * died.  if so, do not continue, but do not error. */\n\t\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t\tmlog(ML_NOTICE, \"%s: will not send recovery state, \"\n\t\t\t     \"recovery master %u died, thread=(dead=%u,mas=%u)\"\n\t\t\t     \" current=(dead=%u,mas=%u)\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, reco_master,\n\t\t\t     dlm->reco.dead_node, dlm->reco.new_master);\n\t\t} else {\n\t\t\tmlog(ML_NOTICE, \"%s: reco state invalid: reco(dead=%u, \"\n\t\t\t     \"master=%u), request(dead=%u, master=%u)\\n\",\n\t\t\t     dlm->name, dlm->reco.dead_node,\n\t\t\t     dlm->reco.new_master, dead_node, reco_master);\n\t\t}\n\t\tgoto leave;\n\t}\n\n\t/* lock resources should have already been moved to the\n \t * dlm->reco.resources list.  now move items from that list\n \t * to a temp list if the dead owner matches.  note that the\n\t * whole cluster recovers only one node at a time, so we\n\t * can safely move UNKNOWN lock resources for each recovery\n\t * session. */\n\tdlm_move_reco_locks_to_list(dlm, &resources, dead_node);\n\n\t/* now we can begin blasting lockreses without the dlm lock */\n\n\t/* any errors returned will be due to the new_master dying,\n\t * the dlm_reco_thread should detect this */\n\tlist_for_each_entry(res, &resources, recovering) {\n\t\tret = dlm_send_one_lockres(dlm, res, mres, reco_master,\n\t\t\t\t   \tDLM_MRES_RECOVERY);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery state for dead node %u, ret=%d\\n\", dlm->name,\n\t\t\t     reco_master, dead_node, ret);\n\t\t\tskip_all_done = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* move the resources back to the list */\n\tspin_lock(&dlm->spinlock);\n\tlist_splice_init(&resources, &dlm->reco.resources);\n\tspin_unlock(&dlm->spinlock);\n\n\tif (!skip_all_done) {\n\t\tret = dlm_send_all_done_msg(dlm, dead_node, reco_master);\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: node %u went down while sending \"\n\t\t\t     \"recovery all-done for dead node %u, ret=%d\\n\",\n\t\t\t     dlm->name, reco_master, dead_node, ret);\n\t\t}\n\t}\nleave:\n\tfree_page((unsigned long)data);\n}"
  },
  {
    "function_name": "dlm_request_all_locks_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "830-878",
    "snippet": "int dlm_request_all_locks_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_request *lr = (struct dlm_lock_request *)msg->buf;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tif (lr->dead_node != dlm->reco.dead_node) {\n\t\tmlog(ML_ERROR, \"%s: node %u sent dead_node=%u, but local \"\n\t\t     \"dead_node is %u\\n\", dlm->name, lr->node_idx,\n\t\t     lr->dead_node, dlm->reco.dead_node);\n\t\tdlm_print_reco_node_status(dlm);\n\t\t/* this is a hack */\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\tBUG_ON(lr->dead_node != dlm->reco.dead_node);\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!item) {\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* this will get freed by dlm_request_all_locks_worker */\n\tbuf = (char *) __get_free_page(GFP_NOFS);\n\tif (!buf) {\n\t\tkfree(item);\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* queue up work for dlm_request_all_locks_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_request_all_locks_worker, buf);\n\titem->u.ral.reco_master = lr->node_idx;\n\titem->u.ral.dead_node = lr->dead_node;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\n\tdlm_put(dlm);\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "dlm->dlm_worker",
            "&dlm->dispatched_work"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&item->list",
            "&dlm->work_list"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_init_work_item",
          "args": [
            "dlm",
            "item",
            "dlm_request_all_locks_worker",
            "buf"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "254-263",
          "snippet": "static inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline void dlm_init_work_item(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_work_item *i,\n\t\t\t\t      dlm_workfunc_t *f, void *data)\n{\n\tmemset(i, 0, sizeof(*i));\n\ti->func = f;\n\tINIT_LIST_HEAD(&i->list);\n\ti->data = data;\n\ti->dlm = dlm;  /* must have already done a dlm_grab on this! */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "item"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_NOFS"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*item)",
            "GFP_NOFS"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lr->dead_node != dlm->reco.dead_node"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_reco_node_status",
          "args": [
            "dlm"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_reco_node_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "252-297",
          "snippet": "static void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
            "static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);\n\nstatic void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: node %u sent dead_node=%u, but local \"\n\t\t     \"dead_node is %u\\n\"",
            "dlm->name",
            "lr->node_idx",
            "lr->dead_node",
            "dlm->reco.dead_node"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nint dlm_request_all_locks_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t\t  void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_lock_request *lr = (struct dlm_lock_request *)msg->buf;\n\tchar *buf = NULL;\n\tstruct dlm_work_item *item = NULL;\n\n\tif (!dlm_grab(dlm))\n\t\treturn -EINVAL;\n\n\tif (lr->dead_node != dlm->reco.dead_node) {\n\t\tmlog(ML_ERROR, \"%s: node %u sent dead_node=%u, but local \"\n\t\t     \"dead_node is %u\\n\", dlm->name, lr->node_idx,\n\t\t     lr->dead_node, dlm->reco.dead_node);\n\t\tdlm_print_reco_node_status(dlm);\n\t\t/* this is a hack */\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\tBUG_ON(lr->dead_node != dlm->reco.dead_node);\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (!item) {\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* this will get freed by dlm_request_all_locks_worker */\n\tbuf = (char *) __get_free_page(GFP_NOFS);\n\tif (!buf) {\n\t\tkfree(item);\n\t\tdlm_put(dlm);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* queue up work for dlm_request_all_locks_worker */\n\tdlm_grab(dlm);  /* get an extra ref for the work item */\n\tdlm_init_work_item(dlm, item, dlm_request_all_locks_worker, buf);\n\titem->u.ral.reco_master = lr->node_idx;\n\titem->u.ral.dead_node = lr->dead_node;\n\tspin_lock(&dlm->work_lock);\n\tlist_add_tail(&item->list, &dlm->work_list);\n\tspin_unlock(&dlm->work_lock);\n\tqueue_work(dlm->dlm_worker, &dlm->dispatched_work);\n\n\tdlm_put(dlm);\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_request_all_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "796-828",
    "snippet": "static int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\n\t\t\t\t u8 dead_node)\n{\n\tstruct dlm_lock_request lr;\n\tint ret;\n\tint status;\n\n\tmlog(0, \"\\n\");\n\n\n\tmlog(0, \"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\", dead_node, request_from);\n\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.node_idx = dlm->node_num;\n\tlr.dead_node = dead_node;\n\n\t// send message\n\tret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t &lr, sizeof(lr), request_from, &status);\n\n\t/* negative status is handled by caller */\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret,\n\t\t     request_from, dead_node);\n\telse\n\t\tret = status;\n\t// return from here, then\n\t// sleep until all received or error\n\treturn ret;\n\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\"",
            "dlm->name",
            "ret",
            "request_from",
            "dead_node"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2net_send_message",
          "args": [
            "DLM_LOCK_REQUEST_MSG",
            "dlm->key",
            "&lr",
            "sizeof(lr)",
            "request_from",
            "&status"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1147-1156",
          "snippet": "int o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void o2net_idle_timer(unsigned long data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic void o2net_idle_timer(unsigned long data);\n\nint o2net_send_message(u32 msg_type, u32 key, void *data, u32 len,\n\t\t       u8 target_node, int *status)\n{\n\tstruct kvec vec = {\n\t\t.iov_base = data,\n\t\t.iov_len = len,\n\t};\n\treturn o2net_send_message_vec(msg_type, key, &vec, 1,\n\t\t\t\t      target_node, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&lr",
            "0",
            "sizeof(lr)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\"",
            "dead_node",
            "request_from"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"\\n\""
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\n\t\t\t\t u8 dead_node)\n{\n\tstruct dlm_lock_request lr;\n\tint ret;\n\tint status;\n\n\tmlog(0, \"\\n\");\n\n\n\tmlog(0, \"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\", dead_node, request_from);\n\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.node_idx = dlm->node_num;\n\tlr.dead_node = dead_node;\n\n\t// send message\n\tret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t &lr, sizeof(lr), request_from, &status);\n\n\t/* negative status is handled by caller */\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret,\n\t\t     request_from, dead_node);\n\telse\n\t\tret = status;\n\t// return from here, then\n\t// sleep until all received or error\n\treturn ret;\n\n}"
  },
  {
    "function_name": "dlm_destroy_recovery_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "781-794",
    "snippet": "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ndata"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ndata->list"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ndata",
            "next",
            "&tmplist",
            "list"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&dlm->reco.node_data",
            "&tmplist"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmplist"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}"
  },
  {
    "function_name": "dlm_init_recovery_area",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "747-779",
    "snippet": "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint num=0;\n\tstruct dlm_reco_node_data *ndata;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->reco.node_map, dlm->domain_map, sizeof(dlm->domain_map));\n\t/* nodes can only be removed (by dying) after dropping\n\t * this lock, and death will be trapped later, so this should do */\n\tspin_unlock(&dlm->spinlock);\n\n\twhile (1) {\n\t\tnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\n\t\tif (num >= O2NM_MAX_NODES) {\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(num == dead_node);\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_NOFS);\n\t\tif (!ndata) {\n\t\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tndata->node_num = num;\n\t\tndata->state = DLM_RECO_NODE_DATA_INIT;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_add_tail(&ndata->list, &dlm->reco.node_data);\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t\tnum++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ndata->list",
            "&dlm->reco.node_data"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_reco_state_lock"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_destroy_recovery_area",
          "args": [
            "dlm",
            "dead_node"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_recovery_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "781-794",
          "snippet": "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ndata)",
            "GFP_NOFS"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num == dead_node"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->reco.node_map",
            "O2NM_MAX_NODES",
            "num"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dlm->reco.node_map",
            "dlm->domain_map",
            "sizeof(dlm->domain_map)"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint num=0;\n\tstruct dlm_reco_node_data *ndata;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->reco.node_map, dlm->domain_map, sizeof(dlm->domain_map));\n\t/* nodes can only be removed (by dying) after dropping\n\t * this lock, and death will be trapped later, so this should do */\n\tspin_unlock(&dlm->spinlock);\n\n\twhile (1) {\n\t\tnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\n\t\tif (num >= O2NM_MAX_NODES) {\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(num == dead_node);\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_NOFS);\n\t\tif (!ndata) {\n\t\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tndata->node_num = num;\n\t\tndata->state = DLM_RECO_NODE_DATA_INIT;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_add_tail(&ndata->list, &dlm->reco.node_data);\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t\tnum++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_remaster_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "551-745",
    "snippet": "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint status = 0;\n\tstruct dlm_reco_node_data *ndata;\n\tint all_nodes_done;\n\tint destroy = 0;\n\tint pass = 0;\n\n\tdo {\n\t\t/* we have become recovery master.  there is no escaping\n\t\t * this, so just keep trying until we get it. */\n\t\tstatus = dlm_init_recovery_area(dlm, dead_node);\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: failed to alloc recovery area, \"\n\t\t\t     \"retrying\\n\", dlm->name);\n\t\t\tmsleep(1000);\n\t\t}\n\t} while (status != 0);\n\n\t/* safe to access the node data list without a lock, since this\n\t * process is the only one to change the list */\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\n\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTING;\n\n\t\tmlog(0, \"%s: Requesting lock info from node %u\\n\", dlm->name,\n\t\t     ndata->node_num);\n\n\t\tif (ndata->node_num == dlm->node_num) {\n\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstatus = dlm_request_all_locks(dlm, ndata->node_num,\n\t\t\t\t\t\t       dead_node);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tif (dlm_is_host_down(status)) {\n\t\t\t\t\t/* node died, ignore it for recovery */\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DEAD;\n\t\t\t\t\t/* wait for the domain map to catch up\n\t\t\t\t\t * with the network state. */\n\t\t\t\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t\t   dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num),\n\t\t\t\t\t\t\t   msecs_to_jiffies(1000));\n\t\t\t\t\tmlog(0, \"waited 1 sec for %u, \"\n\t\t\t\t\t     \"dead? %s\\n\", ndata->node_num,\n\t\t\t\t\t     dlm_is_node_dead(dlm, ndata->node_num) ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\t\t\t\t} else {\n\t\t\t\t\t/* -ENOMEM on the other node */\n\t\t\t\t\tmlog(0, \"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     status);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (status != 0);\n\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tmlog(0, \"node %u died after requesting \"\n\t\t\t\t     \"recovery info for node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\t/* fine.  don't need this node's info.\n\t\t\t\t * continue without it. */\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTED;\n\t\t\t\tmlog(0, \"now receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tmlog(0, \"already receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tmlog(0, \"already DONE receiving recovery data \"\n\t\t\t\t     \"from node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t}\n\n\tmlog(0, \"%s: Done requesting all lock info\\n\", dlm->name);\n\n\t/* nodes should be sending reco data now\n\t * just need to wait */\n\n\twhile (1) {\n\t\t/* check all the nodes now to see if we are\n\t\t * done, or if anyone died */\n\t\tall_nodes_done = 1;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\t\tmlog(0, \"checking recovery state of node %u\\n\",\n\t\t\t     ndata->node_num);\n\t\t\tswitch (ndata->state) {\n\t\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\t\tmlog(ML_ERROR, \"bad ndata state for \"\n\t\t\t\t\t     \"node %u: state=%d\\n\",\n\t\t\t\t\t     ndata->node_num, ndata->state);\n\t\t\t\t\tBUG();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\t\tmlog(0, \"node %u died after \"\n\t\t\t\t\t     \"requesting recovery info for \"\n\t\t\t\t\t     \"node %u\\n\", ndata->node_num,\n\t\t\t\t\t     dead_node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\t\tmlog(0, \"%s: node %u still in state %s\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\");\n\t\t\t\t\tall_nodes_done = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\t\tmlog(0, \"%s: node %u state is done\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\t\tmlog(0, \"%s: node %u state is finalize\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\n\t\tmlog(0, \"pass #%d, all_nodes_done?: %s\\n\", ++pass,\n\t\t     all_nodes_done?\"yes\":\"no\");\n\t\tif (all_nodes_done) {\n\t\t\tint ret;\n\n\t\t\t/* Set this flag on recovery master to avoid\n\t\t\t * a new recovery for another dead node start\n\t\t\t * before the recovery is not done. That may\n\t\t\t * cause recovery hung.*/\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* all nodes are now in DLM_RECO_NODE_DATA_DONE state\n\t \t\t * just send a finalize message to everyone and\n\t \t\t * clean up */\n\t\t\tmlog(0, \"all nodes are done! send finalize\\n\");\n\t\t\tret = dlm_send_finalize_reco_message(dlm);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_finish_local_lockres_recovery(dlm, dead_node,\n\t\t\t\t\t\t\t  dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"should be done with recovery!\\n\");\n\n\t\t\tmlog(0, \"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\", dlm->name,\n\t\t\t     jiffies, dlm->reco.dead_node,\n\t\t\t     dlm->node_num, dlm->reco.new_master);\n\t\t\tdestroy = 1;\n\t\t\tstatus = 0;\n\t\t\t/* rescan everything marked dirty along the way */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* wait to be signalled, with periodic timeout\n\t\t * to check for node death */\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\n\n\t}\n\n\tif (destroy)\n\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)"
    ],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);",
      "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_destroy_recovery_area",
          "args": [
            "dlm",
            "dead_node"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_destroy_recovery_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "781-794",
          "snippet": "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tstruct dlm_reco_node_data *ndata, *next;\n\tLIST_HEAD(tmplist);\n\n\tspin_lock(&dlm_reco_state_lock);\n\tlist_splice_init(&dlm->reco.node_data, &tmplist);\n\tspin_unlock(&dlm_reco_state_lock);\n\n\tlist_for_each_entry_safe(ndata, next, &tmplist, list) {\n\t\tlist_del_init(&ndata->list);\n\t\tkfree(ndata);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "kthread_should_stop()",
            "msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "DLM_RECO_THREAD_TIMEOUT_MS"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "NULL"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\"",
            "dlm->name",
            "jiffies",
            "dlm->reco.dead_node",
            "dlm->node_num",
            "dlm->reco.new_master"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"should be done with recovery!\\n\""
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_finish_local_lockres_recovery",
          "args": [
            "dlm",
            "dead_node",
            "dlm->node_num"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_finish_local_lockres_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2120-2181",
          "snippet": "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master)\n{\n\tint i;\n\tstruct hlist_head *bucket;\n\tstruct dlm_lock_resource *res, *next;\n\n\tassert_spin_locked(&dlm->spinlock);\n\n\tlist_for_each_entry_safe(res, next, &dlm->reco.resources, recovering) {\n\t\tif (res->owner == dead_node) {\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tlist_del_init(&res->recovering);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t\tdlm_lockres_put(res);\n\t\t}\n\t}\n\n\t/* this will become unnecessary eventually, but\n\t * for now we need to run the whole hash, clear\n\t * the RECOVERING state and set the owner\n\t * if necessary */\n\tfor (i = 0; i < DLM_HASH_BUCKETS; i++) {\n\t\tbucket = dlm_lockres_hash(dlm, i);\n\t\thlist_for_each_entry(res, bucket, hash_node) {\n\t\t\tif (!(res->state & DLM_LOCK_RES_RECOVERING))\n\t\t\t\tcontinue;\n\n\t\t\tif (res->owner != dead_node &&\n\t\t\t    res->owner != dlm->node_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&res->recovering)) {\n\t\t\t\tlist_del_init(&res->recovering);\n\t\t\t\tdlm_lockres_put(res);\n\t\t\t}\n\n\t\t\t/* new_master has our reference from\n\t\t\t * the lock state sent during recovery */\n\t\t\tmlog(0, \"%s: res %.*s, Changing owner from %u to %u\\n\",\n\t\t\t     dlm->name, res->lockname.len, res->lockname.name,\n\t\t\t     res->owner, new_master);\n\t\t\tspin_lock(&res->spinlock);\n\t\t\tdlm_change_lockres_owner(dlm, res, new_master);\n\t\t\tres->state &= ~DLM_LOCK_RES_RECOVERING;\n\t\t\tif (__dlm_lockres_has_locks(res))\n\t\t\t\t__dlm_dirty_lockres(dlm, res);\n\t\t\tspin_unlock(&res->spinlock);\n\t\t\twake_up(&res->wq);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_send_finalize_reco_message",
          "args": [
            "dlm"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_finalize_reco_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2809-2863",
          "snippet": "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\tstruct dlm_finalize_reco fr;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\tint stage = 1;\n\n\tmlog(0, \"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\", dlm->name, dlm->reco.dead_node, stage);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\nstage2:\n\tmemset(&fr, 0, sizeof(fr));\n\tfr.node_idx = dlm->node_num;\n\tfr.dead_node = dlm->reco.dead_node;\n\tif (stage == 2)\n\t\tfr.flags |= DLM_FINALIZE_STAGE2;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\t &fr, sizeof(fr), nodenum, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", ret, DLM_FINALIZE_RECO_MSG,\n\t\t\t     dlm->key, nodenum);\n\t\t\tif (dlm_is_host_down(ret)) {\n\t\t\t\t/* this has no effect on this recovery\n\t\t\t\t * session, so set the status to zero to\n\t\t\t\t * finish out the last recovery */\n\t\t\t\tmlog(ML_ERROR, \"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\", nodenum);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (stage == 1) {\n\t\t/* reset the node_iter back to the top and send finalize2 */\n\t\titer.curnode = -1;\n\t\tstage = 2;\n\t\tgoto stage2;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_FINALIZE_STAGE2  0x01"
          ],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_FINALIZE_STAGE2  0x01\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm)\n{\n\tint ret = 0;\n\tstruct dlm_finalize_reco fr;\n\tstruct dlm_node_iter iter;\n\tint nodenum;\n\tint status;\n\tint stage = 1;\n\n\tmlog(0, \"finishing recovery for node %s:%u, \"\n\t     \"stage %d\\n\", dlm->name, dlm->reco.dead_node, stage);\n\n\tspin_lock(&dlm->spinlock);\n\tdlm_node_iter_init(dlm->domain_map, &iter);\n\tspin_unlock(&dlm->spinlock);\n\nstage2:\n\tmemset(&fr, 0, sizeof(fr));\n\tfr.node_idx = dlm->node_num;\n\tfr.dead_node = dlm->reco.dead_node;\n\tif (stage == 2)\n\t\tfr.flags |= DLM_FINALIZE_STAGE2;\n\n\twhile ((nodenum = dlm_node_iter_next(&iter)) >= 0) {\n\t\tif (nodenum == dlm->node_num)\n\t\t\tcontinue;\n\t\tret = o2net_send_message(DLM_FINALIZE_RECO_MSG, dlm->key,\n\t\t\t\t\t &fr, sizeof(fr), nodenum, &status);\n\t\tif (ret >= 0)\n\t\t\tret = status;\n\t\tif (ret < 0) {\n\t\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key \"\n\t\t\t     \"0x%x) to node %u\\n\", ret, DLM_FINALIZE_RECO_MSG,\n\t\t\t     dlm->key, nodenum);\n\t\t\tif (dlm_is_host_down(ret)) {\n\t\t\t\t/* this has no effect on this recovery\n\t\t\t\t * session, so set the status to zero to\n\t\t\t\t * finish out the last recovery */\n\t\t\t\tmlog(ML_ERROR, \"node %u went down after this \"\n\t\t\t\t     \"node finished recovery.\\n\", nodenum);\n\t\t\t\tret = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (stage == 1) {\n\t\t/* reset the node_iter back to the top and send finalize2 */\n\t\titer.curnode = -1;\n\t\tstage = 2;\n\t\tgoto stage2;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"pass #%d, all_nodes_done?: %s\\n\"",
            "++pass",
            "all_nodes_done?\"yes\":\"no\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u still in state %s\\n\"",
            "dlm->name",
            "ndata->node_num",
            "ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"checking recovery state of node %u\\n\"",
            "ndata->node_num"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ndata",
            "&dlm->reco.node_data",
            "list"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\"",
            "dlm->name",
            "ndata->node_num",
            "status"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_node_dead",
          "args": [
            "dlm",
            "ndata->node_num"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_node_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "341-348",
          "snippet": "int dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num)",
            "msecs_to_jiffies(1000)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "1000"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "status"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_request_all_locks",
          "args": [
            "dlm",
            "ndata->node_num",
            "dead_node"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_request_all_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "796-828",
          "snippet": "static int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\n\t\t\t\t u8 dead_node)\n{\n\tstruct dlm_lock_request lr;\n\tint ret;\n\tint status;\n\n\tmlog(0, \"\\n\");\n\n\n\tmlog(0, \"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\", dead_node, request_from);\n\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.node_idx = dlm->node_num;\n\tlr.dead_node = dead_node;\n\n\t// send message\n\tret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t &lr, sizeof(lr), request_from, &status);\n\n\t/* negative status is handled by caller */\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret,\n\t\t     request_from, dead_node);\n\telse\n\t\tret = status;\n\t// return from here, then\n\t// sleep until all received or error\n\treturn ret;\n\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm, u8 request_from,\n\t\t\t\t u8 dead_node)\n{\n\tstruct dlm_lock_request lr;\n\tint ret;\n\tint status;\n\n\tmlog(0, \"\\n\");\n\n\n\tmlog(0, \"dlm_request_all_locks: dead node is %u, sending request \"\n\t\t  \"to %u\\n\", dead_node, request_from);\n\n\tmemset(&lr, 0, sizeof(lr));\n\tlr.node_idx = dlm->node_num;\n\tlr.dead_node = dead_node;\n\n\t// send message\n\tret = o2net_send_message(DLM_LOCK_REQUEST_MSG, dlm->key,\n\t\t\t\t &lr, sizeof(lr), request_from, &status);\n\n\t/* negative status is handled by caller */\n\tif (ret < 0)\n\t\tmlog(ML_ERROR, \"%s: Error %d send LOCK_REQUEST to node %u \"\n\t\t     \"to recover dead node %u\\n\", dlm->name, ret,\n\t\t     request_from, dead_node);\n\telse\n\t\tret = status;\n\t// return from here, then\n\t// sleep until all received or error\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ndata->state != DLM_RECO_NODE_DATA_INIT"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ndata",
            "&dlm->reco.node_data",
            "list"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_init_recovery_area",
          "args": [
            "dlm",
            "dead_node"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_init_recovery_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "747-779",
          "snippet": "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint num=0;\n\tstruct dlm_reco_node_data *ndata;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->reco.node_map, dlm->domain_map, sizeof(dlm->domain_map));\n\t/* nodes can only be removed (by dying) after dropping\n\t * this lock, and death will be trapped later, so this should do */\n\tspin_unlock(&dlm->spinlock);\n\n\twhile (1) {\n\t\tnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\n\t\tif (num >= O2NM_MAX_NODES) {\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(num == dead_node);\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_NOFS);\n\t\tif (!ndata) {\n\t\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tndata->node_num = num;\n\t\tndata->state = DLM_RECO_NODE_DATA_INIT;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_add_tail(&ndata->list, &dlm->reco.node_data);\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t\tnum++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint num=0;\n\tstruct dlm_reco_node_data *ndata;\n\n\tspin_lock(&dlm->spinlock);\n\tmemcpy(dlm->reco.node_map, dlm->domain_map, sizeof(dlm->domain_map));\n\t/* nodes can only be removed (by dying) after dropping\n\t * this lock, and death will be trapped later, so this should do */\n\tspin_unlock(&dlm->spinlock);\n\n\twhile (1) {\n\t\tnum = find_next_bit (dlm->reco.node_map, O2NM_MAX_NODES, num);\n\t\tif (num >= O2NM_MAX_NODES) {\n\t\t\tbreak;\n\t\t}\n\t\tBUG_ON(num == dead_node);\n\n\t\tndata = kzalloc(sizeof(*ndata), GFP_NOFS);\n\t\tif (!ndata) {\n\t\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tndata->node_num = num;\n\t\tndata->state = DLM_RECO_NODE_DATA_INIT;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_add_tail(&ndata->list, &dlm->reco.node_data);\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t\tnum++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint status = 0;\n\tstruct dlm_reco_node_data *ndata;\n\tint all_nodes_done;\n\tint destroy = 0;\n\tint pass = 0;\n\n\tdo {\n\t\t/* we have become recovery master.  there is no escaping\n\t\t * this, so just keep trying until we get it. */\n\t\tstatus = dlm_init_recovery_area(dlm, dead_node);\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: failed to alloc recovery area, \"\n\t\t\t     \"retrying\\n\", dlm->name);\n\t\t\tmsleep(1000);\n\t\t}\n\t} while (status != 0);\n\n\t/* safe to access the node data list without a lock, since this\n\t * process is the only one to change the list */\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\n\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTING;\n\n\t\tmlog(0, \"%s: Requesting lock info from node %u\\n\", dlm->name,\n\t\t     ndata->node_num);\n\n\t\tif (ndata->node_num == dlm->node_num) {\n\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstatus = dlm_request_all_locks(dlm, ndata->node_num,\n\t\t\t\t\t\t       dead_node);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tif (dlm_is_host_down(status)) {\n\t\t\t\t\t/* node died, ignore it for recovery */\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DEAD;\n\t\t\t\t\t/* wait for the domain map to catch up\n\t\t\t\t\t * with the network state. */\n\t\t\t\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t\t   dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num),\n\t\t\t\t\t\t\t   msecs_to_jiffies(1000));\n\t\t\t\t\tmlog(0, \"waited 1 sec for %u, \"\n\t\t\t\t\t     \"dead? %s\\n\", ndata->node_num,\n\t\t\t\t\t     dlm_is_node_dead(dlm, ndata->node_num) ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\t\t\t\t} else {\n\t\t\t\t\t/* -ENOMEM on the other node */\n\t\t\t\t\tmlog(0, \"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     status);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (status != 0);\n\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tmlog(0, \"node %u died after requesting \"\n\t\t\t\t     \"recovery info for node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\t/* fine.  don't need this node's info.\n\t\t\t\t * continue without it. */\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTED;\n\t\t\t\tmlog(0, \"now receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tmlog(0, \"already receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tmlog(0, \"already DONE receiving recovery data \"\n\t\t\t\t     \"from node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t}\n\n\tmlog(0, \"%s: Done requesting all lock info\\n\", dlm->name);\n\n\t/* nodes should be sending reco data now\n\t * just need to wait */\n\n\twhile (1) {\n\t\t/* check all the nodes now to see if we are\n\t\t * done, or if anyone died */\n\t\tall_nodes_done = 1;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\t\tmlog(0, \"checking recovery state of node %u\\n\",\n\t\t\t     ndata->node_num);\n\t\t\tswitch (ndata->state) {\n\t\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\t\tmlog(ML_ERROR, \"bad ndata state for \"\n\t\t\t\t\t     \"node %u: state=%d\\n\",\n\t\t\t\t\t     ndata->node_num, ndata->state);\n\t\t\t\t\tBUG();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\t\tmlog(0, \"node %u died after \"\n\t\t\t\t\t     \"requesting recovery info for \"\n\t\t\t\t\t     \"node %u\\n\", ndata->node_num,\n\t\t\t\t\t     dead_node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\t\tmlog(0, \"%s: node %u still in state %s\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\");\n\t\t\t\t\tall_nodes_done = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\t\tmlog(0, \"%s: node %u state is done\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\t\tmlog(0, \"%s: node %u state is finalize\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\n\t\tmlog(0, \"pass #%d, all_nodes_done?: %s\\n\", ++pass,\n\t\t     all_nodes_done?\"yes\":\"no\");\n\t\tif (all_nodes_done) {\n\t\t\tint ret;\n\n\t\t\t/* Set this flag on recovery master to avoid\n\t\t\t * a new recovery for another dead node start\n\t\t\t * before the recovery is not done. That may\n\t\t\t * cause recovery hung.*/\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* all nodes are now in DLM_RECO_NODE_DATA_DONE state\n\t \t\t * just send a finalize message to everyone and\n\t \t\t * clean up */\n\t\t\tmlog(0, \"all nodes are done! send finalize\\n\");\n\t\t\tret = dlm_send_finalize_reco_message(dlm);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_finish_local_lockres_recovery(dlm, dead_node,\n\t\t\t\t\t\t\t  dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"should be done with recovery!\\n\");\n\n\t\t\tmlog(0, \"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\", dlm->name,\n\t\t\t     jiffies, dlm->reco.dead_node,\n\t\t\t     dlm->node_num, dlm->reco.new_master);\n\t\t\tdestroy = 1;\n\t\t\tstatus = 0;\n\t\t\t/* rescan everything marked dirty along the way */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* wait to be signalled, with periodic timeout\n\t\t * to check for node death */\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\n\n\t}\n\n\tif (destroy)\n\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_do_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "452-549",
    "snippet": "static int dlm_do_recovery(struct dlm_ctxt *dlm)\n{\n\tint status = 0;\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\n\t/* check to see if the new master has died */\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\n\t    test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\tmlog(0, \"new master %u died while recovering %u!\\n\",\n\t\t     dlm->reco.new_master, dlm->reco.dead_node);\n\t\t/* unset the new_master, leave dead_node */\n\t\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\t/* select a target to recover */\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\tint bit;\n\n\t\tbit = find_next_bit (dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES || bit < 0)\n\t\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t\telse\n\t\t\tdlm_set_reco_dead_node(dlm, bit);\n\t} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\n\t\t/* BUG? */\n\t\tmlog(ML_ERROR, \"dead_node %u no longer in recovery map!\\n\",\n\t\t     dlm->reco.dead_node);\n\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t// mlog(0, \"nothing to recover!  sleeping now!\\n\");\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* return to main thread loop and sleep. */\n\t\treturn 0;\n\t}\n\tmlog(0, \"%s(%d):recovery thread found node %u in the recovery map!\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.dead_node);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* take write barrier */\n\t/* (stops the list reshuffling thread, proxy ast handling) */\n\tdlm_begin_recovery(dlm);\n\n\tif (dlm->reco.new_master == dlm->node_num)\n\t\tgoto master_here;\n\n\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t/* choose a new master, returns 0 if this node\n\t\t * is the master, -EEXIST if it's another node.\n\t\t * this does not return until a new master is chosen\n\t\t * or recovery completes entirely. */\n\t\tret = dlm_pick_recovery_master(dlm);\n\t\tif (!ret) {\n\t\t\t/* already notified everyone.  go. */\n\t\t\tgoto master_here;\n\t\t}\n\t\tmlog(0, \"another node will master this recovery session.\\n\");\n\t}\n\n\tdlm_print_recovery_master(dlm);\n\n\t/* it is safe to start everything back up here\n\t * because all of the dead node's lock resources\n\t * have been marked as in-recovery */\n\tdlm_end_recovery(dlm);\n\n\t/* sleep out in main dlm_recovery_thread loop. */\n\treturn 0;\n\nmaster_here:\n\tdlm_print_recovery_master(dlm);\n\n\tstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\n\tif (status < 0) {\n\t\t/* we should never hit this anymore */\n\t\tmlog(ML_ERROR, \"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\", dlm->name, status, dlm->reco.dead_node);\n\t\t/* yield a bit to allow any final network messages\n\t\t * to get handled on remaining nodes */\n\t\tmsleep(100);\n\t} else {\n\t\t/* success!  see if any other nodes need recovery */\n\t\tmlog(0, \"DONE mastering recovery of %s:%u here(this=%u)!\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dlm->node_num);\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_reset_recovery(dlm);\n\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tdlm_end_recovery(dlm);\n\n\t/* continue and look for another dead node */\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_end_recovery",
          "args": [
            "dlm"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_end_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "434-442",
          "snippet": "static void dlm_end_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\n\tdlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n\tprintk(KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\", dlm->name);\n\twake_up(&dlm->reco.event);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic void dlm_end_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\n\tdlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n\tprintk(KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\", dlm->name);\n\twake_up(&dlm->reco.event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_reset_recovery",
          "args": [
            "dlm"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_reset_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "136-142",
          "snippet": "static inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"DONE mastering recovery of %s:%u here(this=%u)!\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "dlm->node_num"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\"",
            "dlm->name",
            "status",
            "dlm->reco.dead_node"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_remaster_locks",
          "args": [
            "dlm",
            "dlm->reco.dead_node"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_remaster_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "551-745",
          "snippet": "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint status = 0;\n\tstruct dlm_reco_node_data *ndata;\n\tint all_nodes_done;\n\tint destroy = 0;\n\tint pass = 0;\n\n\tdo {\n\t\t/* we have become recovery master.  there is no escaping\n\t\t * this, so just keep trying until we get it. */\n\t\tstatus = dlm_init_recovery_area(dlm, dead_node);\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: failed to alloc recovery area, \"\n\t\t\t     \"retrying\\n\", dlm->name);\n\t\t\tmsleep(1000);\n\t\t}\n\t} while (status != 0);\n\n\t/* safe to access the node data list without a lock, since this\n\t * process is the only one to change the list */\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\n\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTING;\n\n\t\tmlog(0, \"%s: Requesting lock info from node %u\\n\", dlm->name,\n\t\t     ndata->node_num);\n\n\t\tif (ndata->node_num == dlm->node_num) {\n\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstatus = dlm_request_all_locks(dlm, ndata->node_num,\n\t\t\t\t\t\t       dead_node);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tif (dlm_is_host_down(status)) {\n\t\t\t\t\t/* node died, ignore it for recovery */\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DEAD;\n\t\t\t\t\t/* wait for the domain map to catch up\n\t\t\t\t\t * with the network state. */\n\t\t\t\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t\t   dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num),\n\t\t\t\t\t\t\t   msecs_to_jiffies(1000));\n\t\t\t\t\tmlog(0, \"waited 1 sec for %u, \"\n\t\t\t\t\t     \"dead? %s\\n\", ndata->node_num,\n\t\t\t\t\t     dlm_is_node_dead(dlm, ndata->node_num) ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\t\t\t\t} else {\n\t\t\t\t\t/* -ENOMEM on the other node */\n\t\t\t\t\tmlog(0, \"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     status);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (status != 0);\n\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tmlog(0, \"node %u died after requesting \"\n\t\t\t\t     \"recovery info for node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\t/* fine.  don't need this node's info.\n\t\t\t\t * continue without it. */\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTED;\n\t\t\t\tmlog(0, \"now receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tmlog(0, \"already receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tmlog(0, \"already DONE receiving recovery data \"\n\t\t\t\t     \"from node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t}\n\n\tmlog(0, \"%s: Done requesting all lock info\\n\", dlm->name);\n\n\t/* nodes should be sending reco data now\n\t * just need to wait */\n\n\twhile (1) {\n\t\t/* check all the nodes now to see if we are\n\t\t * done, or if anyone died */\n\t\tall_nodes_done = 1;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\t\tmlog(0, \"checking recovery state of node %u\\n\",\n\t\t\t     ndata->node_num);\n\t\t\tswitch (ndata->state) {\n\t\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\t\tmlog(ML_ERROR, \"bad ndata state for \"\n\t\t\t\t\t     \"node %u: state=%d\\n\",\n\t\t\t\t\t     ndata->node_num, ndata->state);\n\t\t\t\t\tBUG();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\t\tmlog(0, \"node %u died after \"\n\t\t\t\t\t     \"requesting recovery info for \"\n\t\t\t\t\t     \"node %u\\n\", ndata->node_num,\n\t\t\t\t\t     dead_node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\t\tmlog(0, \"%s: node %u still in state %s\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\");\n\t\t\t\t\tall_nodes_done = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\t\tmlog(0, \"%s: node %u state is done\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\t\tmlog(0, \"%s: node %u state is finalize\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\n\t\tmlog(0, \"pass #%d, all_nodes_done?: %s\\n\", ++pass,\n\t\t     all_nodes_done?\"yes\":\"no\");\n\t\tif (all_nodes_done) {\n\t\t\tint ret;\n\n\t\t\t/* Set this flag on recovery master to avoid\n\t\t\t * a new recovery for another dead node start\n\t\t\t * before the recovery is not done. That may\n\t\t\t * cause recovery hung.*/\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* all nodes are now in DLM_RECO_NODE_DATA_DONE state\n\t \t\t * just send a finalize message to everyone and\n\t \t\t * clean up */\n\t\t\tmlog(0, \"all nodes are done! send finalize\\n\");\n\t\t\tret = dlm_send_finalize_reco_message(dlm);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_finish_local_lockres_recovery(dlm, dead_node,\n\t\t\t\t\t\t\t  dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"should be done with recovery!\\n\");\n\n\t\t\tmlog(0, \"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\", dlm->name,\n\t\t\t     jiffies, dlm->reco.dead_node,\n\t\t\t     dlm->node_num, dlm->reco.new_master);\n\t\t\tdestroy = 1;\n\t\t\tstatus = 0;\n\t\t\t/* rescan everything marked dirty along the way */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* wait to be signalled, with periodic timeout\n\t\t * to check for node death */\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\n\n\t}\n\n\tif (destroy)\n\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)"
          ],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_recovery_thread(void *data);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
            "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
            "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);",
            "static DEFINE_SPINLOCK(dlm_reco_state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\nstatic DEFINE_SPINLOCK(dlm_reco_state_lock);\n\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node)\n{\n\tint status = 0;\n\tstruct dlm_reco_node_data *ndata;\n\tint all_nodes_done;\n\tint destroy = 0;\n\tint pass = 0;\n\n\tdo {\n\t\t/* we have become recovery master.  there is no escaping\n\t\t * this, so just keep trying until we get it. */\n\t\tstatus = dlm_init_recovery_area(dlm, dead_node);\n\t\tif (status < 0) {\n\t\t\tmlog(ML_ERROR, \"%s: failed to alloc recovery area, \"\n\t\t\t     \"retrying\\n\", dlm->name);\n\t\t\tmsleep(1000);\n\t\t}\n\t} while (status != 0);\n\n\t/* safe to access the node data list without a lock, since this\n\t * process is the only one to change the list */\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tBUG_ON(ndata->state != DLM_RECO_NODE_DATA_INIT);\n\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTING;\n\n\t\tmlog(0, \"%s: Requesting lock info from node %u\\n\", dlm->name,\n\t\t     ndata->node_num);\n\n\t\tif (ndata->node_num == dlm->node_num) {\n\t\t\tndata->state = DLM_RECO_NODE_DATA_DONE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdo {\n\t\t\tstatus = dlm_request_all_locks(dlm, ndata->node_num,\n\t\t\t\t\t\t       dead_node);\n\t\t\tif (status < 0) {\n\t\t\t\tmlog_errno(status);\n\t\t\t\tif (dlm_is_host_down(status)) {\n\t\t\t\t\t/* node died, ignore it for recovery */\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tndata->state = DLM_RECO_NODE_DATA_DEAD;\n\t\t\t\t\t/* wait for the domain map to catch up\n\t\t\t\t\t * with the network state. */\n\t\t\t\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t\t   dlm_is_node_dead(dlm,\n\t\t\t\t\t\t\t\tndata->node_num),\n\t\t\t\t\t\t\t   msecs_to_jiffies(1000));\n\t\t\t\t\tmlog(0, \"waited 1 sec for %u, \"\n\t\t\t\t\t     \"dead? %s\\n\", ndata->node_num,\n\t\t\t\t\t     dlm_is_node_dead(dlm, ndata->node_num) ?\n\t\t\t\t\t     \"yes\" : \"no\");\n\t\t\t\t} else {\n\t\t\t\t\t/* -ENOMEM on the other node */\n\t\t\t\t\tmlog(0, \"%s: node %u returned \"\n\t\t\t\t\t     \"%d during recovery, retrying \"\n\t\t\t\t\t     \"after a short wait\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     status);\n\t\t\t\t\tmsleep(100);\n\t\t\t\t}\n\t\t\t}\n\t\t} while (status != 0);\n\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tBUG();\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tmlog(0, \"node %u died after requesting \"\n\t\t\t\t     \"recovery info for node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\t/* fine.  don't need this node's info.\n\t\t\t\t * continue without it. */\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tndata->state = DLM_RECO_NODE_DATA_REQUESTED;\n\t\t\t\tmlog(0, \"now receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tmlog(0, \"already receiving recovery data from \"\n\t\t\t\t     \"node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tmlog(0, \"already DONE receiving recovery data \"\n\t\t\t\t     \"from node %u for dead node %u\\n\",\n\t\t\t\t     ndata->node_num, dead_node);\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\t}\n\n\tmlog(0, \"%s: Done requesting all lock info\\n\", dlm->name);\n\n\t/* nodes should be sending reco data now\n\t * just need to wait */\n\n\twhile (1) {\n\t\t/* check all the nodes now to see if we are\n\t\t * done, or if anyone died */\n\t\tall_nodes_done = 1;\n\t\tspin_lock(&dlm_reco_state_lock);\n\t\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\t\tmlog(0, \"checking recovery state of node %u\\n\",\n\t\t\t     ndata->node_num);\n\t\t\tswitch (ndata->state) {\n\t\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\t\tmlog(ML_ERROR, \"bad ndata state for \"\n\t\t\t\t\t     \"node %u: state=%d\\n\",\n\t\t\t\t\t     ndata->node_num, ndata->state);\n\t\t\t\t\tBUG();\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\t\tmlog(0, \"node %u died after \"\n\t\t\t\t\t     \"requesting recovery info for \"\n\t\t\t\t\t     \"node %u\\n\", ndata->node_num,\n\t\t\t\t\t     dead_node);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\t\tmlog(0, \"%s: node %u still in state %s\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num,\n\t\t\t\t\t     ndata->state==DLM_RECO_NODE_DATA_RECEIVING ?\n\t\t\t\t\t     \"receiving\" : \"requested\");\n\t\t\t\t\tall_nodes_done = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\t\tmlog(0, \"%s: node %u state is done\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\t\tmlog(0, \"%s: node %u state is finalize\\n\",\n\t\t\t\t\t     dlm->name, ndata->node_num);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&dlm_reco_state_lock);\n\n\t\tmlog(0, \"pass #%d, all_nodes_done?: %s\\n\", ++pass,\n\t\t     all_nodes_done?\"yes\":\"no\");\n\t\tif (all_nodes_done) {\n\t\t\tint ret;\n\n\t\t\t/* Set this flag on recovery master to avoid\n\t\t\t * a new recovery for another dead node start\n\t\t\t * before the recovery is not done. That may\n\t\t\t * cause recovery hung.*/\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm->reco.state |= DLM_RECO_STATE_FINALIZE;\n\t\t\tspin_unlock(&dlm->spinlock);\n\n\t\t\t/* all nodes are now in DLM_RECO_NODE_DATA_DONE state\n\t \t\t * just send a finalize message to everyone and\n\t \t\t * clean up */\n\t\t\tmlog(0, \"all nodes are done! send finalize\\n\");\n\t\t\tret = dlm_send_finalize_reco_message(dlm);\n\t\t\tif (ret < 0)\n\t\t\t\tmlog_errno(ret);\n\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_finish_local_lockres_recovery(dlm, dead_node,\n\t\t\t\t\t\t\t  dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t\tmlog(0, \"should be done with recovery!\\n\");\n\n\t\t\tmlog(0, \"finishing recovery of %s at %lu, \"\n\t\t\t     \"dead=%u, this=%u, new=%u\\n\", dlm->name,\n\t\t\t     jiffies, dlm->reco.dead_node,\n\t\t\t     dlm->node_num, dlm->reco.new_master);\n\t\t\tdestroy = 1;\n\t\t\tstatus = 0;\n\t\t\t/* rescan everything marked dirty along the way */\n\t\t\tdlm_kick_thread(dlm, NULL);\n\t\t\tbreak;\n\t\t}\n\t\t/* wait to be signalled, with periodic timeout\n\t\t * to check for node death */\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS));\n\n\t}\n\n\tif (destroy)\n\t\tdlm_destroy_recovery_area(dlm, dead_node);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_print_recovery_master",
          "args": [
            "dlm"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_recovery_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "444-450",
          "snippet": "static void dlm_print_recovery_master(struct dlm_ctxt *dlm)\n{\n\tprintk(KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\", dlm->reco.new_master,\n\t       (dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\"),\n\t       dlm->reco.dead_node, dlm->name);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void dlm_print_recovery_master(struct dlm_ctxt *dlm)\n{\n\tprintk(KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\", dlm->reco.new_master,\n\t       (dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\"),\n\t       dlm->reco.dead_node, dlm->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"another node will master this recovery session.\\n\""
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_pick_recovery_master",
          "args": [
            "dlm"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_pick_recovery_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "2522-2644",
          "snippet": "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\n{\n\tenum dlm_status ret;\n\tstruct dlm_lockstatus lksb;\n\tint status = -EINVAL;\n\n\tmlog(0, \"starting recovery of %s at %lu, dead=%u, this=%u\\n\",\n\t     dlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\nagain:\n\tmemset(&lksb, 0, sizeof(lksb));\n\n\tret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\n\t\t      DLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\n\t\t      dlm_reco_ast, dlm, dlm_reco_bast);\n\n\tmlog(0, \"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\",\n\t     dlm->name, ret, lksb.status);\n\n\tif (ret == DLM_NORMAL) {\n\t\tmlog(0, \"dlm=%s dlmlock says I got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\n\t\t/* got the EX lock.  check to see if another node\n\t\t * just became the reco master */\n\t\tif (dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: got reco EX lock, but %u will \"\n\t\t\t     \"do the recovery\\n\", dlm->name,\n\t\t\t     dlm->reco.new_master);\n\t\t\tstatus = -EEXIST;\n\t\t} else {\n\t\t\tstatus = 0;\n\n\t\t\t/* see if recovery was already finished elsewhere */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tmlog(0, \"%s: got reco EX lock, but \"\n\t\t\t\t     \"node got recovered already\\n\", dlm->name);\n\t\t\t\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\t\t\t\tmlog(ML_ERROR, \"%s: new master is %u \"\n\t\t\t\t\t     \"but no dead node!\\n\",\n\t\t\t\t\t     dlm->name, dlm->reco.new_master);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* if this node has actually become the recovery master,\n\t\t * set the master and send the messages to begin recovery */\n\t\tif (!status) {\n\t\t\tmlog(0, \"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\", dlm->name,\n\t\t\t     dlm->reco.dead_node, dlm->node_num);\n\t\t\tstatus = dlm_send_begin_reco_message(dlm,\n\t\t\t\t      dlm->reco.dead_node);\n\t\t\t/* this always succeeds */\n\t\t\tBUG_ON(status);\n\n\t\t\t/* set the new_master to this node */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_set_reco_master(dlm, dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* recovery lock is a special case.  ast will not get fired,\n\t\t * so just go ahead and unlock it. */\n\t\tret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\n\t\tif (ret == DLM_DENIED) {\n\t\t\tmlog(0, \"got DLM_DENIED, trying LKM_CANCEL\\n\");\n\t\t\tret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\n\t\t}\n\t\tif (ret != DLM_NORMAL) {\n\t\t\t/* this would really suck. this could only happen\n\t\t\t * if there was a network error during the unlock\n\t\t\t * because of node death.  this means the unlock\n\t\t\t * is actually \"done\" and the lock structure is\n\t\t\t * even freed.  we can continue, but only\n\t\t\t * because this specific lock name is special. */\n\t\t\tmlog(ML_ERROR, \"dlmunlock returned %d\\n\", ret);\n\t\t}\n\t} else if (ret == DLM_NOTQUEUED) {\n\t\tmlog(0, \"dlm=%s dlmlock says another node got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\t/* another node is master. wait on\n\t\t * reco.new_master != O2NM_INVALID_NODE_NUM\n\t\t * for at most one second */\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t dlm_reco_master_ready(dlm),\n\t\t\t\t\t msecs_to_jiffies(1000));\n\t\tif (!dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: reco master taking awhile\\n\",\n\t\t\t     dlm->name);\n\t\t\tgoto again;\n\t\t}\n\t\t/* another node has informed this one that it is reco master */\n\t\tmlog(0, \"%s: reco master %u is ready to recover %u\\n\",\n\t\t     dlm->name, dlm->reco.new_master, dlm->reco.dead_node);\n\t\tstatus = -EEXIST;\n\t} else if (ret == DLM_RECOVERING) {\n\t\tmlog(0, \"dlm=%s dlmlock says master node died (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\tgoto again;\n\t} else {\n\t\tstruct dlm_lock_resource *res;\n\n\t\t/* dlmlock returned something other than NOTQUEUED or NORMAL */\n\t\tmlog(ML_ERROR, \"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\", dlm->name, dlm_errname(ret),\n\t\t     dlm_errname(lksb.status));\n\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\tif (res) {\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_lockres_put(res);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t}\n\t\tBUG();\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm)\n{\n\tenum dlm_status ret;\n\tstruct dlm_lockstatus lksb;\n\tint status = -EINVAL;\n\n\tmlog(0, \"starting recovery of %s at %lu, dead=%u, this=%u\\n\",\n\t     dlm->name, jiffies, dlm->reco.dead_node, dlm->node_num);\nagain:\n\tmemset(&lksb, 0, sizeof(lksb));\n\n\tret = dlmlock(dlm, LKM_EXMODE, &lksb, LKM_NOQUEUE|LKM_RECOVERY,\n\t\t      DLM_RECOVERY_LOCK_NAME, DLM_RECOVERY_LOCK_NAME_LEN,\n\t\t      dlm_reco_ast, dlm, dlm_reco_bast);\n\n\tmlog(0, \"%s: dlmlock($RECOVERY) returned %d, lksb=%d\\n\",\n\t     dlm->name, ret, lksb.status);\n\n\tif (ret == DLM_NORMAL) {\n\t\tmlog(0, \"dlm=%s dlmlock says I got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\n\t\t/* got the EX lock.  check to see if another node\n\t\t * just became the reco master */\n\t\tif (dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: got reco EX lock, but %u will \"\n\t\t\t     \"do the recovery\\n\", dlm->name,\n\t\t\t     dlm->reco.new_master);\n\t\t\tstatus = -EEXIST;\n\t\t} else {\n\t\t\tstatus = 0;\n\n\t\t\t/* see if recovery was already finished elsewhere */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tmlog(0, \"%s: got reco EX lock, but \"\n\t\t\t\t     \"node got recovered already\\n\", dlm->name);\n\t\t\t\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM) {\n\t\t\t\t\tmlog(ML_ERROR, \"%s: new master is %u \"\n\t\t\t\t\t     \"but no dead node!\\n\",\n\t\t\t\t\t     dlm->name, dlm->reco.new_master);\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* if this node has actually become the recovery master,\n\t\t * set the master and send the messages to begin recovery */\n\t\tif (!status) {\n\t\t\tmlog(0, \"%s: dead=%u, this=%u, sending \"\n\t\t\t     \"begin_reco now\\n\", dlm->name,\n\t\t\t     dlm->reco.dead_node, dlm->node_num);\n\t\t\tstatus = dlm_send_begin_reco_message(dlm,\n\t\t\t\t      dlm->reco.dead_node);\n\t\t\t/* this always succeeds */\n\t\t\tBUG_ON(status);\n\n\t\t\t/* set the new_master to this node */\n\t\t\tspin_lock(&dlm->spinlock);\n\t\t\tdlm_set_reco_master(dlm, dlm->node_num);\n\t\t\tspin_unlock(&dlm->spinlock);\n\t\t}\n\n\t\t/* recovery lock is a special case.  ast will not get fired,\n\t\t * so just go ahead and unlock it. */\n\t\tret = dlmunlock(dlm, &lksb, 0, dlm_reco_unlock_ast, dlm);\n\t\tif (ret == DLM_DENIED) {\n\t\t\tmlog(0, \"got DLM_DENIED, trying LKM_CANCEL\\n\");\n\t\t\tret = dlmunlock(dlm, &lksb, LKM_CANCEL, dlm_reco_unlock_ast, dlm);\n\t\t}\n\t\tif (ret != DLM_NORMAL) {\n\t\t\t/* this would really suck. this could only happen\n\t\t\t * if there was a network error during the unlock\n\t\t\t * because of node death.  this means the unlock\n\t\t\t * is actually \"done\" and the lock structure is\n\t\t\t * even freed.  we can continue, but only\n\t\t\t * because this specific lock name is special. */\n\t\t\tmlog(ML_ERROR, \"dlmunlock returned %d\\n\", ret);\n\t\t}\n\t} else if (ret == DLM_NOTQUEUED) {\n\t\tmlog(0, \"dlm=%s dlmlock says another node got it (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\t/* another node is master. wait on\n\t\t * reco.new_master != O2NM_INVALID_NODE_NUM\n\t\t * for at most one second */\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t dlm_reco_master_ready(dlm),\n\t\t\t\t\t msecs_to_jiffies(1000));\n\t\tif (!dlm_reco_master_ready(dlm)) {\n\t\t\tmlog(0, \"%s: reco master taking awhile\\n\",\n\t\t\t     dlm->name);\n\t\t\tgoto again;\n\t\t}\n\t\t/* another node has informed this one that it is reco master */\n\t\tmlog(0, \"%s: reco master %u is ready to recover %u\\n\",\n\t\t     dlm->name, dlm->reco.new_master, dlm->reco.dead_node);\n\t\tstatus = -EEXIST;\n\t} else if (ret == DLM_RECOVERING) {\n\t\tmlog(0, \"dlm=%s dlmlock says master node died (this=%u)\\n\",\n\t\t     dlm->name, dlm->node_num);\n\t\tgoto again;\n\t} else {\n\t\tstruct dlm_lock_resource *res;\n\n\t\t/* dlmlock returned something other than NOTQUEUED or NORMAL */\n\t\tmlog(ML_ERROR, \"%s: got %s from dlmlock($RECOVERY), \"\n\t\t     \"lksb.status=%s\\n\", dlm->name, dlm_errname(ret),\n\t\t     dlm_errname(lksb.status));\n\t\tres = dlm_lookup_lockres(dlm, DLM_RECOVERY_LOCK_NAME,\n\t\t\t\t\t DLM_RECOVERY_LOCK_NAME_LEN);\n\t\tif (res) {\n\t\t\tdlm_print_one_lock_resource(res);\n\t\t\tdlm_lockres_put(res);\n\t\t} else {\n\t\t\tmlog(ML_ERROR, \"recovery lock not found\\n\");\n\t\t}\n\t\tBUG();\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_begin_recovery",
          "args": [
            "dlm"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_begin_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "424-432",
          "snippet": "static void dlm_begin_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tprintk(KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\",\n\t       dlm->name, dlm->reco.dead_node);\n\tdlm->reco.state |= DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_begin_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tprintk(KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\",\n\t       dlm->name, dlm->reco.dead_node);\n\tdlm->reco.state |= DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s(%d):recovery thread found node %u in the recovery map!\\n\"",
            "dlm->name",
            "task_pid_nr(dlm->dlm_reco_thread_task)",
            "dlm->reco.dead_node"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_dead_node",
          "args": [
            "dlm",
            "O2NM_INVALID_NODE_NUM"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_dead_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "117-125",
          "snippet": "static inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"dead_node %u no longer in recovery map!\\n\"",
            "dlm->reco.dead_node"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "dlm->reco.dead_node",
            "dlm->recovery_map"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "dlm->recovery_map",
            "O2NM_MAX_NODES",
            "0"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "mb_find_next_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/mballoc.c",
          "lines": "427-438",
          "snippet": "static inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/log2.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/log2.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n\nstatic inline int mb_find_next_bit(void *addr, int max, int start)\n{\n\tint fix = 0, ret, tmpmax;\n\taddr = mb_correct_addr_and_bit(&fix, addr);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ext4_find_next_bit(addr, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_master",
          "args": [
            "dlm",
            "O2NM_INVALID_NODE_NUM"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "127-134",
          "snippet": "static inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"new master %u died while recovering %u!\\n\"",
            "dlm->reco.new_master",
            "dlm->reco.dead_node"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm)\n{\n\tint status = 0;\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\n\t/* check to see if the new master has died */\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\n\t    test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\tmlog(0, \"new master %u died while recovering %u!\\n\",\n\t\t     dlm->reco.new_master, dlm->reco.dead_node);\n\t\t/* unset the new_master, leave dead_node */\n\t\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\t/* select a target to recover */\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\tint bit;\n\n\t\tbit = find_next_bit (dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES || bit < 0)\n\t\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t\telse\n\t\t\tdlm_set_reco_dead_node(dlm, bit);\n\t} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\n\t\t/* BUG? */\n\t\tmlog(ML_ERROR, \"dead_node %u no longer in recovery map!\\n\",\n\t\t     dlm->reco.dead_node);\n\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t// mlog(0, \"nothing to recover!  sleeping now!\\n\");\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* return to main thread loop and sleep. */\n\t\treturn 0;\n\t}\n\tmlog(0, \"%s(%d):recovery thread found node %u in the recovery map!\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.dead_node);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* take write barrier */\n\t/* (stops the list reshuffling thread, proxy ast handling) */\n\tdlm_begin_recovery(dlm);\n\n\tif (dlm->reco.new_master == dlm->node_num)\n\t\tgoto master_here;\n\n\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t/* choose a new master, returns 0 if this node\n\t\t * is the master, -EEXIST if it's another node.\n\t\t * this does not return until a new master is chosen\n\t\t * or recovery completes entirely. */\n\t\tret = dlm_pick_recovery_master(dlm);\n\t\tif (!ret) {\n\t\t\t/* already notified everyone.  go. */\n\t\t\tgoto master_here;\n\t\t}\n\t\tmlog(0, \"another node will master this recovery session.\\n\");\n\t}\n\n\tdlm_print_recovery_master(dlm);\n\n\t/* it is safe to start everything back up here\n\t * because all of the dead node's lock resources\n\t * have been marked as in-recovery */\n\tdlm_end_recovery(dlm);\n\n\t/* sleep out in main dlm_recovery_thread loop. */\n\treturn 0;\n\nmaster_here:\n\tdlm_print_recovery_master(dlm);\n\n\tstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\n\tif (status < 0) {\n\t\t/* we should never hit this anymore */\n\t\tmlog(ML_ERROR, \"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\", dlm->name, status, dlm->reco.dead_node);\n\t\t/* yield a bit to allow any final network messages\n\t\t * to get handled on remaining nodes */\n\t\tmsleep(100);\n\t} else {\n\t\t/* success!  see if any other nodes need recovery */\n\t\tmlog(0, \"DONE mastering recovery of %s:%u here(this=%u)!\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dlm->node_num);\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_reset_recovery(dlm);\n\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tdlm_end_recovery(dlm);\n\n\t/* continue and look for another dead node */\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "dlm_print_recovery_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "444-450",
    "snippet": "static void dlm_print_recovery_master(struct dlm_ctxt *dlm)\n{\n\tprintk(KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\", dlm->reco.new_master,\n\t       (dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\"),\n\t       dlm->reco.dead_node, dlm->name);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\"",
            "dlm->reco.new_master",
            "(dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\")",
            "dlm->reco.dead_node",
            "dlm->name"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic void dlm_print_recovery_master(struct dlm_ctxt *dlm)\n{\n\tprintk(KERN_NOTICE \"o2dlm: Node %u (%s) is the Recovery Master for the \"\n\t       \"dead node %u in domain %s\\n\", dlm->reco.new_master,\n\t       (dlm->node_num == dlm->reco.new_master ? \"me\" : \"he\"),\n\t       dlm->reco.dead_node, dlm->name);\n}"
  },
  {
    "function_name": "dlm_end_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "434-442",
    "snippet": "static void dlm_end_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\n\tdlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n\tprintk(KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\", dlm->name);\n\twake_up(&dlm->reco.event);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->reco.event"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\"",
            "dlm->name"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(dlm->reco.state & DLM_RECO_STATE_ACTIVE)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic void dlm_end_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(!(dlm->reco.state & DLM_RECO_STATE_ACTIVE));\n\tdlm->reco.state &= ~DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n\tprintk(KERN_NOTICE \"o2dlm: End recovery on domain %s\\n\", dlm->name);\n\twake_up(&dlm->reco.event);\n}"
  },
  {
    "function_name": "dlm_begin_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "424-432",
    "snippet": "static void dlm_begin_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tprintk(KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\",\n\t       dlm->name, dlm->reco.dead_node);\n\tdlm->reco.state |= DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\"",
            "dlm->name",
            "dlm->reco.dead_node"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dlm->reco.state & DLM_RECO_STATE_ACTIVE"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic void dlm_begin_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\tBUG_ON(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tprintk(KERN_NOTICE \"o2dlm: Begin recovery on domain %s for node %u\\n\",\n\t       dlm->name, dlm->reco.dead_node);\n\tdlm->reco.state |= DLM_RECO_STATE_ACTIVE;\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "dlm_wait_for_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "412-422",
    "snippet": "void dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->reco.event",
            "!dlm_in_recovery(dlm)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_in_recovery",
          "args": [
            "dlm"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_in_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "402-409",
          "snippet": "static int dlm_in_recovery(struct dlm_ctxt *dlm)\n{\n\tint in_recovery;\n\tspin_lock(&dlm->spinlock);\n\tin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tspin_unlock(&dlm->spinlock);\n\treturn in_recovery;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_in_recovery(struct dlm_ctxt *dlm)\n{\n\tint in_recovery;\n\tspin_lock(&dlm->spinlock);\n\tin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tspin_unlock(&dlm->spinlock);\n\treturn in_recovery;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\"",
            "dlm->name",
            "task_pid_nr(dlm->dlm_reco_thread_task)",
            "dlm->reco.state",
            "dlm->reco.new_master",
            "dlm->reco.dead_node"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nvoid dlm_wait_for_recovery(struct dlm_ctxt *dlm)\n{\n\tif (dlm_in_recovery(dlm)) {\n\t\tmlog(0, \"%s: reco thread %d in recovery: \"\n\t\t     \"state=%d, master=%u, dead=%u\\n\",\n\t\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t\t     dlm->reco.state, dlm->reco.new_master,\n\t\t     dlm->reco.dead_node);\n\t}\n\twait_event(dlm->reco.event, !dlm_in_recovery(dlm));\n}"
  },
  {
    "function_name": "dlm_in_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "402-409",
    "snippet": "static int dlm_in_recovery(struct dlm_ctxt *dlm)\n{\n\tint in_recovery;\n\tspin_lock(&dlm->spinlock);\n\tin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tspin_unlock(&dlm->spinlock);\n\treturn in_recovery;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_in_recovery(struct dlm_ctxt *dlm)\n{\n\tint in_recovery;\n\tspin_lock(&dlm->spinlock);\n\tin_recovery = !!(dlm->reco.state & DLM_RECO_STATE_ACTIVE);\n\tspin_unlock(&dlm->spinlock);\n\treturn in_recovery;\n}"
  },
  {
    "function_name": "dlm_wait_for_node_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "379-394",
    "snippet": "void dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_recovered(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_recovered(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_recovered(dlm, node));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_is_node_recovered(dlm, node)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_node_recovered",
          "args": [
            "dlm",
            "node"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_node_recovered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "352-359",
          "snippet": "static int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\n{\n\tint recovered;\n\tspin_lock(&dlm->spinlock);\n\trecovered = !test_bit(node, dlm->recovery_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn recovered;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\n{\n\tint recovered;\n\tspin_lock(&dlm->spinlock);\n\trecovered = !test_bit(node, dlm->recovery_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn recovered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_is_node_recovered(dlm, node)",
            "msecs_to_jiffies(timeout)"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "timeout"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\"",
            "node",
            "dlm->name"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_recovery(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_recovered(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the recovery of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_recovered(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_recovered(dlm, node));\n}"
  },
  {
    "function_name": "dlm_wait_for_node_death",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "362-377",
    "snippet": "void dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_is_node_dead(dlm, node)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_is_node_dead",
          "args": [
            "dlm",
            "node"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_node_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "341-348",
          "snippet": "int dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "dlm_is_node_dead(dlm, node)",
            "msecs_to_jiffies(timeout)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "timeout"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\"",
            "node",
            "dlm->name"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}"
  },
  {
    "function_name": "dlm_is_node_recovered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "352-359",
    "snippet": "static int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\n{\n\tint recovered;\n\tspin_lock(&dlm->spinlock);\n\trecovered = !test_bit(node, dlm->recovery_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn recovered;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "node",
            "dlm->recovery_map"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic int dlm_is_node_recovered(struct dlm_ctxt *dlm, u8 node)\n{\n\tint recovered;\n\tspin_lock(&dlm->spinlock);\n\trecovered = !test_bit(node, dlm->recovery_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn recovered;\n}"
  },
  {
    "function_name": "dlm_is_node_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "341-348",
    "snippet": "int dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "node",
            "dlm->domain_map"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "byte_test_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "60-63",
          "snippet": "static inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic inline int byte_test_bit(u8 nr, u8 map[])\n{\n\treturn ((1UL << (nr & 7)) & (map[nr >> 3])) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_is_node_dead(struct dlm_ctxt *dlm, u8 node)\n{\n\tint dead;\n\tspin_lock(&dlm->spinlock);\n\tdead = !test_bit(node, dlm->domain_map);\n\tspin_unlock(&dlm->spinlock);\n\treturn dead;\n}"
  },
  {
    "function_name": "dlm_reco_master_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "330-337",
    "snippet": "static int dlm_reco_master_ready(struct dlm_ctxt *dlm)\n{\n\tint ready;\n\tspin_lock(&dlm->spinlock);\n\tready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\n\tspin_unlock(&dlm->spinlock);\n\treturn ready;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_reco_master_ready(struct dlm_ctxt *dlm)\n{\n\tint ready;\n\tspin_lock(&dlm->spinlock);\n\tready = (dlm->reco.new_master != O2NM_INVALID_NODE_NUM);\n\tspin_unlock(&dlm->spinlock);\n\treturn ready;\n}"
  },
  {
    "function_name": "dlm_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "301-327",
    "snippet": "static int dlm_recovery_thread(void *data)\n{\n\tint status;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (dlm_domain_fully_joined(dlm)) {\n\t\t\tstatus = dlm_do_recovery(dlm);\n\t\t\tif (status == -EAGAIN) {\n\t\t\t\t/* do not sleep, recheck immediately. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status < 0)\n\t\t\t\tmlog_errno(status);\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM recovery thread\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)"
    ],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"quitting DLM recovery thread\\n\""
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible_timeout",
          "args": [
            "dlm->dlm_reco_thread_wq",
            "kthread_should_stop()",
            "timeout"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_do_recovery",
          "args": [
            "dlm"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_do_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "452-549",
          "snippet": "static int dlm_do_recovery(struct dlm_ctxt *dlm)\n{\n\tint status = 0;\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\n\t/* check to see if the new master has died */\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\n\t    test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\tmlog(0, \"new master %u died while recovering %u!\\n\",\n\t\t     dlm->reco.new_master, dlm->reco.dead_node);\n\t\t/* unset the new_master, leave dead_node */\n\t\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\t/* select a target to recover */\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\tint bit;\n\n\t\tbit = find_next_bit (dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES || bit < 0)\n\t\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t\telse\n\t\t\tdlm_set_reco_dead_node(dlm, bit);\n\t} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\n\t\t/* BUG? */\n\t\tmlog(ML_ERROR, \"dead_node %u no longer in recovery map!\\n\",\n\t\t     dlm->reco.dead_node);\n\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t// mlog(0, \"nothing to recover!  sleeping now!\\n\");\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* return to main thread loop and sleep. */\n\t\treturn 0;\n\t}\n\tmlog(0, \"%s(%d):recovery thread found node %u in the recovery map!\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.dead_node);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* take write barrier */\n\t/* (stops the list reshuffling thread, proxy ast handling) */\n\tdlm_begin_recovery(dlm);\n\n\tif (dlm->reco.new_master == dlm->node_num)\n\t\tgoto master_here;\n\n\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t/* choose a new master, returns 0 if this node\n\t\t * is the master, -EEXIST if it's another node.\n\t\t * this does not return until a new master is chosen\n\t\t * or recovery completes entirely. */\n\t\tret = dlm_pick_recovery_master(dlm);\n\t\tif (!ret) {\n\t\t\t/* already notified everyone.  go. */\n\t\t\tgoto master_here;\n\t\t}\n\t\tmlog(0, \"another node will master this recovery session.\\n\");\n\t}\n\n\tdlm_print_recovery_master(dlm);\n\n\t/* it is safe to start everything back up here\n\t * because all of the dead node's lock resources\n\t * have been marked as in-recovery */\n\tdlm_end_recovery(dlm);\n\n\t/* sleep out in main dlm_recovery_thread loop. */\n\treturn 0;\n\nmaster_here:\n\tdlm_print_recovery_master(dlm);\n\n\tstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\n\tif (status < 0) {\n\t\t/* we should never hit this anymore */\n\t\tmlog(ML_ERROR, \"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\", dlm->name, status, dlm->reco.dead_node);\n\t\t/* yield a bit to allow any final network messages\n\t\t * to get handled on remaining nodes */\n\t\tmsleep(100);\n\t} else {\n\t\t/* success!  see if any other nodes need recovery */\n\t\tmlog(0, \"DONE mastering recovery of %s:%u here(this=%u)!\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dlm->node_num);\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_reset_recovery(dlm);\n\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tdlm_end_recovery(dlm);\n\n\t/* continue and look for another dead node */\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm)\n{\n\tint status = 0;\n\tint ret;\n\n\tspin_lock(&dlm->spinlock);\n\n\t/* check to see if the new master has died */\n\tif (dlm->reco.new_master != O2NM_INVALID_NODE_NUM &&\n\t    test_bit(dlm->reco.new_master, dlm->recovery_map)) {\n\t\tmlog(0, \"new master %u died while recovering %u!\\n\",\n\t\t     dlm->reco.new_master, dlm->reco.dead_node);\n\t\t/* unset the new_master, leave dead_node */\n\t\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\t/* select a target to recover */\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\tint bit;\n\n\t\tbit = find_next_bit (dlm->recovery_map, O2NM_MAX_NODES, 0);\n\t\tif (bit >= O2NM_MAX_NODES || bit < 0)\n\t\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t\telse\n\t\t\tdlm_set_reco_dead_node(dlm, bit);\n\t} else if (!test_bit(dlm->reco.dead_node, dlm->recovery_map)) {\n\t\t/* BUG? */\n\t\tmlog(ML_ERROR, \"dead_node %u no longer in recovery map!\\n\",\n\t\t     dlm->reco.dead_node);\n\t\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\t}\n\n\tif (dlm->reco.dead_node == O2NM_INVALID_NODE_NUM) {\n\t\t// mlog(0, \"nothing to recover!  sleeping now!\\n\");\n\t\tspin_unlock(&dlm->spinlock);\n\t\t/* return to main thread loop and sleep. */\n\t\treturn 0;\n\t}\n\tmlog(0, \"%s(%d):recovery thread found node %u in the recovery map!\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.dead_node);\n\tspin_unlock(&dlm->spinlock);\n\n\t/* take write barrier */\n\t/* (stops the list reshuffling thread, proxy ast handling) */\n\tdlm_begin_recovery(dlm);\n\n\tif (dlm->reco.new_master == dlm->node_num)\n\t\tgoto master_here;\n\n\tif (dlm->reco.new_master == O2NM_INVALID_NODE_NUM) {\n\t\t/* choose a new master, returns 0 if this node\n\t\t * is the master, -EEXIST if it's another node.\n\t\t * this does not return until a new master is chosen\n\t\t * or recovery completes entirely. */\n\t\tret = dlm_pick_recovery_master(dlm);\n\t\tif (!ret) {\n\t\t\t/* already notified everyone.  go. */\n\t\t\tgoto master_here;\n\t\t}\n\t\tmlog(0, \"another node will master this recovery session.\\n\");\n\t}\n\n\tdlm_print_recovery_master(dlm);\n\n\t/* it is safe to start everything back up here\n\t * because all of the dead node's lock resources\n\t * have been marked as in-recovery */\n\tdlm_end_recovery(dlm);\n\n\t/* sleep out in main dlm_recovery_thread loop. */\n\treturn 0;\n\nmaster_here:\n\tdlm_print_recovery_master(dlm);\n\n\tstatus = dlm_remaster_locks(dlm, dlm->reco.dead_node);\n\tif (status < 0) {\n\t\t/* we should never hit this anymore */\n\t\tmlog(ML_ERROR, \"%s: Error %d remastering locks for node %u, \"\n\t\t     \"retrying.\\n\", dlm->name, status, dlm->reco.dead_node);\n\t\t/* yield a bit to allow any final network messages\n\t\t * to get handled on remaining nodes */\n\t\tmsleep(100);\n\t} else {\n\t\t/* success!  see if any other nodes need recovery */\n\t\tmlog(0, \"DONE mastering recovery of %s:%u here(this=%u)!\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dlm->node_num);\n\t\tspin_lock(&dlm->spinlock);\n\t\t__dlm_reset_recovery(dlm);\n\t\tdlm->reco.state &= ~DLM_RECO_STATE_FINALIZE;\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\tdlm_end_recovery(dlm);\n\n\t/* continue and look for another dead node */\n\treturn -EAGAIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"dlm thread running for %s...\\n\"",
            "dlm->name"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "DLM_RECO_THREAD_TIMEOUT_MS"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define DLM_RECO_THREAD_TIMEOUT_MS (5 * 1000)\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nstatic int dlm_recovery_thread(void *data)\n{\n\tint status;\n\tstruct dlm_ctxt *dlm = data;\n\tunsigned long timeout = msecs_to_jiffies(DLM_RECO_THREAD_TIMEOUT_MS);\n\n\tmlog(0, \"dlm thread running for %s...\\n\", dlm->name);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (dlm_domain_fully_joined(dlm)) {\n\t\t\tstatus = dlm_do_recovery(dlm);\n\t\t\tif (status == -EAGAIN) {\n\t\t\t\t/* do not sleep, recheck immediately. */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (status < 0)\n\t\t\t\tmlog_errno(status);\n\t\t}\n\n\t\twait_event_interruptible_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t\t\t kthread_should_stop(),\n\t\t\t\t\t\t timeout);\n\t}\n\n\tmlog(0, \"quitting DLM recovery thread\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_print_reco_node_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "252-297",
    "snippet": "static void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);",
      "static void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: lockres %.*s on recovering list\\n\"",
            "dlm->name",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "res",
            "&dlm->reco.resources",
            "recovering"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s: reco state, node %u, state=%s\\n\"",
            "dlm->name",
            "ndata->node_num",
            "st"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ndata",
            "&dlm->reco.node_data",
            "list"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\"",
            "dlm->name",
            "task_pid_nr(dlm->dlm_reco_thread_task)",
            "dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\"",
            "dlm->reco.dead_node",
            "dlm->reco.new_master"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic inline int dlm_num_locks_in_lockres(struct dlm_lock_resource *res);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\nstatic void dlm_reco_unlock_ast(void *astdata, enum dlm_status st);\n\nstatic void dlm_print_reco_node_status(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_reco_node_data *ndata;\n\tstruct dlm_lock_resource *res;\n\n\tmlog(ML_NOTICE, \"%s(%d): recovery info, state=%s, dead=%u, master=%u\\n\",\n\t     dlm->name, task_pid_nr(dlm->dlm_reco_thread_task),\n\t     dlm->reco.state & DLM_RECO_STATE_ACTIVE ? \"ACTIVE\" : \"inactive\",\n\t     dlm->reco.dead_node, dlm->reco.new_master);\n\n\tlist_for_each_entry(ndata, &dlm->reco.node_data, list) {\n\t\tchar *st = \"unknown\";\n\t\tswitch (ndata->state) {\n\t\t\tcase DLM_RECO_NODE_DATA_INIT:\n\t\t\t\tst = \"init\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTING:\n\t\t\t\tst = \"requesting\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DEAD:\n\t\t\t\tst = \"dead\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_RECEIVING:\n\t\t\t\tst = \"receiving\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_REQUESTED:\n\t\t\t\tst = \"requested\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_DONE:\n\t\t\t\tst = \"done\";\n\t\t\t\tbreak;\n\t\t\tcase DLM_RECO_NODE_DATA_FINALIZE_SENT:\n\t\t\t\tst = \"finalize-sent\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tst = \"bad\";\n\t\t\t\tbreak;\n\t\t}\n\t\tmlog(ML_NOTICE, \"%s: reco state, node %u, state=%s\\n\",\n\t\t     dlm->name, ndata->node_num, st);\n\t}\n\tlist_for_each_entry(res, &dlm->reco.resources, recovering) {\n\t\tmlog(ML_NOTICE, \"%s: lockres %.*s on recovering list\\n\",\n\t\t     dlm->name, res->lockname.len, res->lockname.name);\n\t}\n}"
  },
  {
    "function_name": "dlm_complete_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "218-225",
    "snippet": "void dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"waiting for dlm recovery thread to exit\\n\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_complete_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tif (dlm->dlm_reco_thread_task) {\n\t\tmlog(0, \"waiting for dlm recovery thread to exit\\n\");\n\t\tkthread_stop(dlm->dlm_reco_thread_task);\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t}\n}"
  },
  {
    "function_name": "dlm_launch_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "203-216",
    "snippet": "int dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"starting dlm recovery thread...\\n\");\n\n\tdlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\n\t\t\t\t\t\t\"dlm_reco_thread\");\n\tif (IS_ERR(dlm->dlm_reco_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(dlm->dlm_reco_thread_task)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dlm->dlm_reco_thread_task"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "dlm_recovery_thread",
            "dlm",
            "\"dlm_reco_thread\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"starting dlm recovery thread...\\n\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nint dlm_launch_recovery_thread(struct dlm_ctxt *dlm)\n{\n\tmlog(0, \"starting dlm recovery thread...\\n\");\n\n\tdlm->dlm_reco_thread_task = kthread_run(dlm_recovery_thread, dlm,\n\t\t\t\t\t\t\"dlm_reco_thread\");\n\tif (IS_ERR(dlm->dlm_reco_thread_task)) {\n\t\tmlog_errno(PTR_ERR(dlm->dlm_reco_thread_task));\n\t\tdlm->dlm_reco_thread_task = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_kick_recovery_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "191-200",
    "snippet": "void dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&dlm->dlm_reco_thread_wq"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_kick_recovery_thread(struct dlm_ctxt *dlm)\n{\n\t/* wake the recovery thread\n\t * this will wake the reco thread in one of three places\n\t * 1) sleeping with no recovery happening\n\t * 2) sleeping with recovery mastered elsewhere\n\t * 3) recovery mastered here, waiting on reco data */\n\n\twake_up(&dlm->dlm_reco_thread_wq);\n}"
  },
  {
    "function_name": "dlm_dispatch_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "152-185",
    "snippet": "void dlm_dispatch_work(struct work_struct *work)\n{\n\tstruct dlm_ctxt *dlm =\n\t\tcontainer_of(work, struct dlm_ctxt, dispatched_work);\n\tLIST_HEAD(tmp_list);\n\tstruct dlm_work_item *item, *next;\n\tdlm_workfunc_t *workfunc;\n\tint tot=0;\n\n\tspin_lock(&dlm->work_lock);\n\tlist_splice_init(&dlm->work_list, &tmp_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tlist_for_each_entry(item, &tmp_list, list) {\n\t\ttot++;\n\t}\n\tmlog(0, \"%s: work thread has %d work items\\n\", dlm->name, tot);\n\n\tlist_for_each_entry_safe(item, next, &tmp_list, list) {\n\t\tworkfunc = item->func;\n\t\tlist_del_init(&item->list);\n\n\t\t/* already have ref on dlm to avoid having\n\t\t * it disappear.  just double-check. */\n\t\tBUG_ON(item->dlm != dlm);\n\n\t\t/* this is allowed to sleep and\n\t\t * call network stuff */\n\t\tworkfunc(item, item->data);\n\n\t\tdlm_put(dlm);\n\t\tkfree(item);\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_recovery_thread(void *data);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);",
      "static void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "item"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "workfunc",
          "args": [
            "item",
            "item->data"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "item->dlm != dlm"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&item->list"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "item",
            "next",
            "&tmp_list",
            "list"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: work thread has %d work items\\n\"",
            "dlm->name",
            "tot"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "item",
            "&tmp_list",
            "list"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&dlm->work_list",
            "&tmp_list"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->work_lock"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp_list"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structdlm_ctxt",
            "dispatched_work"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_recovery_thread(void *data);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_request_all_locks_worker(struct dlm_work_item *item,\n\t\t\t\t\t void *data);\nstatic void dlm_mig_lockres_worker(struct dlm_work_item *item, void *data);\n\nvoid dlm_dispatch_work(struct work_struct *work)\n{\n\tstruct dlm_ctxt *dlm =\n\t\tcontainer_of(work, struct dlm_ctxt, dispatched_work);\n\tLIST_HEAD(tmp_list);\n\tstruct dlm_work_item *item, *next;\n\tdlm_workfunc_t *workfunc;\n\tint tot=0;\n\n\tspin_lock(&dlm->work_lock);\n\tlist_splice_init(&dlm->work_list, &tmp_list);\n\tspin_unlock(&dlm->work_lock);\n\n\tlist_for_each_entry(item, &tmp_list, list) {\n\t\ttot++;\n\t}\n\tmlog(0, \"%s: work thread has %d work items\\n\", dlm->name, tot);\n\n\tlist_for_each_entry_safe(item, next, &tmp_list, list) {\n\t\tworkfunc = item->func;\n\t\tlist_del_init(&item->list);\n\n\t\t/* already have ref on dlm to avoid having\n\t\t * it disappear.  just double-check. */\n\t\tBUG_ON(item->dlm != dlm);\n\n\t\t/* this is allowed to sleep and\n\t\t * call network stuff */\n\t\tworkfunc(item, item->data);\n\n\t\tdlm_put(dlm);\n\t\tkfree(item);\n\t}\n}"
  },
  {
    "function_name": "dlm_reset_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "144-149",
    "snippet": "static inline void dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_reset_recovery(dlm);\n\tspin_unlock(&dlm->spinlock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_reset_recovery",
          "args": [
            "dlm"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_reset_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "136-142",
          "snippet": "static inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nstatic inline void dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tspin_lock(&dlm->spinlock);\n\t__dlm_reset_recovery(dlm);\n\tspin_unlock(&dlm->spinlock);\n}"
  },
  {
    "function_name": "__dlm_reset_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "136-142",
    "snippet": "static inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_set_reco_master",
          "args": [
            "dlm",
            "O2NM_INVALID_NODE_NUM"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "127-134",
          "snippet": "static inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_set_reco_dead_node",
          "args": [
            "dlm",
            "O2NM_INVALID_NODE_NUM"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_set_reco_dead_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "117-125",
          "snippet": "static inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
            "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
            "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
            "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "dlm->reco.dead_node",
            "dlm->recovery_map"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void __dlm_reset_recovery(struct dlm_ctxt *dlm)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tclear_bit(dlm->reco.dead_node, dlm->recovery_map);\n\tdlm_set_reco_dead_node(dlm, O2NM_INVALID_NODE_NUM);\n\tdlm_set_reco_master(dlm, O2NM_INVALID_NODE_NUM);\n}"
  },
  {
    "function_name": "dlm_set_reco_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "127-134",
    "snippet": "static inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: changing new_master from %u to %u\\n\"",
            "dlm->name",
            "dlm->reco.new_master",
            "master"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic void dlm_init_migratable_lockres(struct dlm_migratable_lockres *mres,\n\t\t\t\t\tconst char *lockname, int namelen,\n\t\t\t\t\tint total_locks, u64 cookie,\n\t\t\t\t\tu8 flags, u8 master);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic void dlm_finish_local_lockres_recovery(struct dlm_ctxt *dlm,\n\t\t\t\t\t      u8 dead_node, u8 new_master);\n\nstatic inline void dlm_set_reco_master(struct dlm_ctxt *dlm,\n\t\t\t\t       u8 master)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tmlog(0, \"%s: changing new_master from %u to %u\\n\",\n\t     dlm->name, dlm->reco.new_master, master);\n\tdlm->reco.new_master = master;\n}"
  },
  {
    "function_name": "dlm_set_reco_dead_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "117-125",
    "snippet": "static inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
      "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
      "static int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);",
      "static void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);",
      "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);",
      "static int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);",
      "static void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%s: changing dead_node from %u to %u\\n\"",
            "dlm->name",
            "dlm->reco.dead_node",
            "dead_node"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&dlm->spinlock"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_remaster_locks(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_init_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_request_all_locks(struct dlm_ctxt *dlm,\n\t\t\t\t u8 request_from, u8 dead_node);\nstatic void dlm_destroy_recovery_area(struct dlm_ctxt *dlm, u8 dead_node);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\nstatic int dlm_send_begin_reco_message(struct dlm_ctxt *dlm, u8 dead_node);\nstatic void dlm_move_reco_locks_to_list(struct dlm_ctxt *dlm,\n\t\t\t\t\tstruct list_head *list, u8 dead_node);\n\nstatic inline void dlm_set_reco_dead_node(struct dlm_ctxt *dlm,\n\t\t\t\t\t  u8 dead_node)\n{\n\tassert_spin_locked(&dlm->spinlock);\n\tif (dlm->reco.dead_node != dead_node)\n\t\tmlog(0, \"%s: changing dead_node from %u to %u\\n\",\n\t\t     dlm->name, dlm->reco.dead_node, dead_node);\n\tdlm->reco.dead_node = dead_node;\n}"
  },
  {
    "function_name": "dlm_get_next_mig_cookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
    "lines": "104-115",
    "snippet": "static u64 dlm_get_next_mig_cookie(void)\n{\n\tu64 c;\n\tspin_lock(&dlm_mig_cookie_lock);\n\tc = dlm_mig_cookie;\n\tif (dlm_mig_cookie == (~0ULL))\n\t\tdlm_mig_cookie = 1;\n\telse\n\t\tdlm_mig_cookie++;\n\tspin_unlock(&dlm_mig_cookie_lock);\n\treturn c;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmdomain.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/delay.h>",
      "#include <linux/kthread.h>",
      "#include <linux/timer.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 dlm_get_next_mig_cookie(void);",
      "static DEFINE_SPINLOCK(dlm_mig_cookie_lock);",
      "static u64 dlm_mig_cookie = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dlm_mig_cookie_lock"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dlm_mig_cookie_lock"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u64 dlm_get_next_mig_cookie(void);\nstatic DEFINE_SPINLOCK(dlm_mig_cookie_lock);\nstatic u64 dlm_mig_cookie = 1;\n\nstatic u64 dlm_get_next_mig_cookie(void)\n{\n\tu64 c;\n\tspin_lock(&dlm_mig_cookie_lock);\n\tc = dlm_mig_cookie;\n\tif (dlm_mig_cookie == (~0ULL))\n\t\tdlm_mig_cookie = 1;\n\telse\n\t\tdlm_mig_cookie++;\n\tspin_unlock(&dlm_mig_cookie_lock);\n\treturn c;\n}"
  }
]