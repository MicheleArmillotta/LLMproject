[
  {
    "function_name": "btrfs_reloc_post_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4619-4655",
    "snippet": "int btrfs_reloc_post_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root *new_root;\n\tstruct reloc_control *rc;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\treturn 0;\n\n\trc = root->fs_info->reloc_ctl;\n\trc->merging_rsv_size += rc->nodes_relocated;\n\n\tif (rc->merge_reloc_tree) {\n\t\tret = btrfs_block_rsv_migrate(&pending->block_rsv,\n\t\t\t\t\t      rc->block_rsv,\n\t\t\t\t\t      rc->nodes_relocated);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew_root = pending->snap;\n\treloc_root = create_reloc_root(trans, root->reloc_root,\n\t\t\t\t       new_root->root_key.objectid);\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\tnew_root->reloc_root = reloc_root;\n\n\tif (rc->create_reloc_tree)\n\t\tret = clone_backref_node(trans, rc, root, reloc_root);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clone_backref_node",
          "args": [
            "trans",
            "rc",
            "root",
            "reloc_root"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "clone_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1186-1270",
          "snippet": "static int clone_backref_node(struct btrfs_trans_handle *trans,\n\t\t\t      struct reloc_control *rc,\n\t\t\t      struct btrfs_root *src,\n\t\t\t      struct btrfs_root *dest)\n{\n\tstruct btrfs_root *reloc_root = src->reloc_root;\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node = NULL;\n\tstruct backref_node *new_node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *new_edge;\n\tstruct rb_node *rb_node;\n\n\tif (cache->last_trans > 0)\n\t\tupdate_backref_cache(trans, cache);\n\n\trb_node = tree_search(&cache->rb_root, src->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct backref_node, rb_node);\n\t\tif (node->detached)\n\t\t\tnode = NULL;\n\t\telse\n\t\t\tBUG_ON(node->new_bytenr != reloc_root->node->start);\n\t}\n\n\tif (!node) {\n\t\trb_node = tree_search(&cache->rb_root,\n\t\t\t\t      reloc_root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(node->detached);\n\t\t}\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\tnew_node = alloc_backref_node(cache);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->bytenr = dest->node->start;\n\tnew_node->level = node->level;\n\tnew_node->lowest = node->lowest;\n\tnew_node->checked = 1;\n\tnew_node->root = dest;\n\n\tif (!node->lowest) {\n\t\tlist_for_each_entry(edge, &node->lower, list[UPPER]) {\n\t\t\tnew_edge = alloc_backref_edge(cache);\n\t\t\tif (!new_edge)\n\t\t\t\tgoto fail;\n\n\t\t\tnew_edge->node[UPPER] = new_node;\n\t\t\tnew_edge->node[LOWER] = edge->node[LOWER];\n\t\t\tlist_add_tail(&new_edge->list[UPPER],\n\t\t\t\t      &new_node->lower);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&new_node->lower, &cache->leaves);\n\t}\n\n\trb_node = tree_insert(&cache->rb_root, new_node->bytenr,\n\t\t\t      &new_node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, new_node->bytenr);\n\n\tif (!new_node->lowest) {\n\t\tlist_for_each_entry(new_edge, &new_node->lower, list[UPPER]) {\n\t\t\tlist_add_tail(&new_edge->list[LOWER],\n\t\t\t\t      &new_edge->node[LOWER]->upper);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\twhile (!list_empty(&new_node->lower)) {\n\t\tnew_edge = list_entry(new_node->lower.next,\n\t\t\t\t      struct backref_edge, list[UPPER]);\n\t\tlist_del(&new_edge->list[UPPER]);\n\t\tfree_backref_edge(cache, new_edge);\n\t}\n\tfree_backref_node(cache, new_node);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int clone_backref_node(struct btrfs_trans_handle *trans,\n\t\t\t      struct reloc_control *rc,\n\t\t\t      struct btrfs_root *src,\n\t\t\t      struct btrfs_root *dest)\n{\n\tstruct btrfs_root *reloc_root = src->reloc_root;\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node = NULL;\n\tstruct backref_node *new_node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *new_edge;\n\tstruct rb_node *rb_node;\n\n\tif (cache->last_trans > 0)\n\t\tupdate_backref_cache(trans, cache);\n\n\trb_node = tree_search(&cache->rb_root, src->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct backref_node, rb_node);\n\t\tif (node->detached)\n\t\t\tnode = NULL;\n\t\telse\n\t\t\tBUG_ON(node->new_bytenr != reloc_root->node->start);\n\t}\n\n\tif (!node) {\n\t\trb_node = tree_search(&cache->rb_root,\n\t\t\t\t      reloc_root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(node->detached);\n\t\t}\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\tnew_node = alloc_backref_node(cache);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->bytenr = dest->node->start;\n\tnew_node->level = node->level;\n\tnew_node->lowest = node->lowest;\n\tnew_node->checked = 1;\n\tnew_node->root = dest;\n\n\tif (!node->lowest) {\n\t\tlist_for_each_entry(edge, &node->lower, list[UPPER]) {\n\t\t\tnew_edge = alloc_backref_edge(cache);\n\t\t\tif (!new_edge)\n\t\t\t\tgoto fail;\n\n\t\t\tnew_edge->node[UPPER] = new_node;\n\t\t\tnew_edge->node[LOWER] = edge->node[LOWER];\n\t\t\tlist_add_tail(&new_edge->list[UPPER],\n\t\t\t\t      &new_node->lower);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&new_node->lower, &cache->leaves);\n\t}\n\n\trb_node = tree_insert(&cache->rb_root, new_node->bytenr,\n\t\t\t      &new_node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, new_node->bytenr);\n\n\tif (!new_node->lowest) {\n\t\tlist_for_each_entry(new_edge, &new_node->lower, list[UPPER]) {\n\t\t\tlist_add_tail(&new_edge->list[LOWER],\n\t\t\t\t      &new_edge->node[LOWER]->upper);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\twhile (!list_empty(&new_node->lower)) {\n\t\tnew_edge = list_entry(new_node->lower.next,\n\t\t\t\t      struct backref_edge, list[UPPER]);\n\t\tlist_del(&new_edge->list[UPPER]);\n\t\tfree_backref_edge(cache, new_edge);\n\t}\n\tfree_backref_node(cache, new_node);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_reloc_root",
          "args": [
            "reloc_root"
          ],
          "line": 4648
        },
        "resolved": true,
        "details": {
          "function_name": "__add_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1275-1302",
          "snippet": "static int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "reloc_root"
          ],
          "line": 4646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reloc_root"
          ],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_reloc_root",
          "args": [
            "trans",
            "root->reloc_root",
            "new_root->root_key.objectid"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "create_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1366-1435",
          "snippet": "static struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_migrate",
          "args": [
            "&pending->block_rsv",
            "rc->block_rsv",
            "rc->nodes_relocated"
          ],
          "line": 4635
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_migrate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4769-4774",
          "snippet": "int btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_migrate(struct btrfs_block_rsv *src_rsv,\n\t\t\t    struct btrfs_block_rsv *dst_rsv,\n\t\t\t    u64 num_bytes)\n{\n\treturn block_rsv_migrate_bytes(src_rsv, dst_rsv, num_bytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_reloc_post_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_pending_snapshot *pending)\n{\n\tstruct btrfs_root *root = pending->root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root *new_root;\n\tstruct reloc_control *rc;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\treturn 0;\n\n\trc = root->fs_info->reloc_ctl;\n\trc->merging_rsv_size += rc->nodes_relocated;\n\n\tif (rc->merge_reloc_tree) {\n\t\tret = btrfs_block_rsv_migrate(&pending->block_rsv,\n\t\t\t\t\t      rc->block_rsv,\n\t\t\t\t\t      rc->nodes_relocated);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnew_root = pending->snap;\n\treloc_root = create_reloc_root(trans, root->reloc_root,\n\t\t\t\t       new_root->root_key.objectid);\n\tif (IS_ERR(reloc_root))\n\t\treturn PTR_ERR(reloc_root);\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\tnew_root->reloc_root = reloc_root;\n\n\tif (rc->create_reloc_tree)\n\t\tret = clone_backref_node(trans, rc, root, reloc_root);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_reloc_pre_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4585-4613",
    "snippet": "void btrfs_reloc_pre_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_pending_snapshot *pending,\n\t\t\t      u64 *bytes_to_reserve)\n{\n\tstruct btrfs_root *root;\n\tstruct reloc_control *rc;\n\n\troot = pending->root;\n\tif (!root->reloc_root)\n\t\treturn;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc->merge_reloc_tree)\n\t\treturn;\n\n\troot = root->reloc_root;\n\tBUG_ON(btrfs_root_refs(&root->root_item) == 0);\n\t/*\n\t * relocation is in the stage of merging trees. the space\n\t * used by merging a reloc tree is twice the size of\n\t * relocated tree nodes in the worst case. half for cowing\n\t * the reloc tree, half for cowing the fs tree. the space\n\t * used by cowing the reloc tree will be freed after the\n\t * tree is dropped. if we create snapshot, cowing the fs\n\t * tree may use more space than it frees. so we need\n\t * reserve extra space.\n\t */\n\t*bytes_to_reserve += rc->nodes_relocated;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_root_refs(&root->root_item) == 0"
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&root->root_item"
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nvoid btrfs_reloc_pre_snapshot(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_pending_snapshot *pending,\n\t\t\t      u64 *bytes_to_reserve)\n{\n\tstruct btrfs_root *root;\n\tstruct reloc_control *rc;\n\n\troot = pending->root;\n\tif (!root->reloc_root)\n\t\treturn;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc->merge_reloc_tree)\n\t\treturn;\n\n\troot = root->reloc_root;\n\tBUG_ON(btrfs_root_refs(&root->root_item) == 0);\n\t/*\n\t * relocation is in the stage of merging trees. the space\n\t * used by merging a reloc tree is twice the size of\n\t * relocated tree nodes in the worst case. half for cowing\n\t * the reloc tree, half for cowing the fs tree. the space\n\t * used by cowing the reloc tree will be freed after the\n\t * tree is dropped. if we create snapshot, cowing the fs\n\t * tree may use more space than it frees. so we need\n\t * reserve extra space.\n\t */\n\t*bytes_to_reserve += rc->nodes_relocated;\n}"
  },
  {
    "function_name": "btrfs_reloc_cow_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4523-4579",
    "snippet": "int btrfs_reloc_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t  struct extent_buffer *cow)\n{\n\tstruct reloc_control *rc;\n\tstruct backref_node *node;\n\tint first_cow = 0;\n\tint level;\n\tint ret = 0;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc)\n\t\treturn 0;\n\n\tBUG_ON(rc->stage == UPDATE_DATA_PTRS &&\n\t       root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (buf == root->node)\n\t\t\t__update_reloc_root(root, cow->start);\n\t}\n\n\tlevel = btrfs_header_level(buf);\n\tif (btrfs_header_generation(buf) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tfirst_cow = 1;\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t    rc->create_reloc_tree) {\n\t\tWARN_ON(!first_cow && level == 0);\n\n\t\tnode = rc->backref_cache.path[level];\n\t\tBUG_ON(node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start);\n\n\t\tdrop_node_buffer(node);\n\t\textent_buffer_get(cow);\n\t\tnode->eb = cow;\n\t\tnode->new_bytenr = cow->start;\n\n\t\tif (!node->pending) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &rc->backref_cache.pending[level]);\n\t\t\tnode->pending = 1;\n\t\t}\n\n\t\tif (first_cow)\n\t\t\t__mark_block_processed(rc, node);\n\n\t\tif (first_cow && level > 0)\n\t\t\trc->nodes_relocated += buf->len;\n\t}\n\n\tif (level == 0 && first_cow && rc->stage == UPDATE_DATA_PTRS)\n\t\tret = replace_file_extents(trans, rc, root, cow);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPDATE_DATA_PTRS\t1"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "replace_file_extents",
          "args": [
            "trans",
            "rc",
            "root",
            "cow"
          ],
          "line": 4577
        },
        "resolved": true,
        "details": {
          "function_name": "replace_file_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1625-1738",
          "snippet": "static noinline_for_stack\nint replace_file_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct inode *inode = NULL;\n\tu64 parent;\n\tu64 bytenr;\n\tu64 new_bytenr = 0;\n\tu64 num_bytes;\n\tu64 end;\n\tu32 nritems;\n\tu32 i;\n\tint ret = 0;\n\tint first = 1;\n\tint dirty = 0;\n\n\tif (rc->stage != UPDATE_DATA_PTRS)\n\t\treturn 0;\n\n\t/* reloc trees always use full backref */\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tparent = leaf->start;\n\telse\n\t\tparent = 0;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tfor (i = 0; i < nritems; i++) {\n\t\tcond_resched();\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tif (bytenr == 0)\n\t\t\tcontinue;\n\t\tif (!in_block_group(bytenr, rc->block_group))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are modifying block in fs tree, wait for readpage\n\t\t * to complete and drop the extent cache\n\t\t */\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tif (first) {\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t\tfirst = 0;\n\t\t\t} else if (inode && btrfs_ino(inode) < key.objectid) {\n\t\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t}\n\t\t\tif (inode && btrfs_ino(inode) == key.objectid) {\n\t\t\t\tend = key.offset +\n\t\t\t\t      btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tWARN_ON(!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    root->sectorsize));\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t\tret = try_lock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t\t      key.offset, end);\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbtrfs_drop_extent_cache(inode, key.offset, end,\n\t\t\t\t\t\t\t1);\n\t\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t      key.offset, end);\n\t\t\t}\n\t\t}\n\n\t\tret = get_new_location(rc->data_inode, &new_bytenr,\n\t\t\t\t       bytenr, num_bytes);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * Don't have to abort since we've not changed anything\n\t\t\t * in the file extent yet.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, new_bytenr);\n\t\tdirty = 1;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tret = btrfs_inc_extent_ref(trans, root, new_bytenr,\n\t\t\t\t\t   num_bytes, parent,\n\t\t\t\t\t   btrfs_header_owner(leaf),\n\t\t\t\t\t   key.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\tparent, btrfs_header_owner(leaf),\n\t\t\t\t\tkey.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirty)\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\tif (inode)\n\t\tbtrfs_add_delayed_iput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPDATE_DATA_PTRS\t1"
          ],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint replace_file_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct inode *inode = NULL;\n\tu64 parent;\n\tu64 bytenr;\n\tu64 new_bytenr = 0;\n\tu64 num_bytes;\n\tu64 end;\n\tu32 nritems;\n\tu32 i;\n\tint ret = 0;\n\tint first = 1;\n\tint dirty = 0;\n\n\tif (rc->stage != UPDATE_DATA_PTRS)\n\t\treturn 0;\n\n\t/* reloc trees always use full backref */\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tparent = leaf->start;\n\telse\n\t\tparent = 0;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tfor (i = 0; i < nritems; i++) {\n\t\tcond_resched();\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tif (bytenr == 0)\n\t\t\tcontinue;\n\t\tif (!in_block_group(bytenr, rc->block_group))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are modifying block in fs tree, wait for readpage\n\t\t * to complete and drop the extent cache\n\t\t */\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tif (first) {\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t\tfirst = 0;\n\t\t\t} else if (inode && btrfs_ino(inode) < key.objectid) {\n\t\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t}\n\t\t\tif (inode && btrfs_ino(inode) == key.objectid) {\n\t\t\t\tend = key.offset +\n\t\t\t\t      btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tWARN_ON(!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    root->sectorsize));\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t\tret = try_lock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t\t      key.offset, end);\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbtrfs_drop_extent_cache(inode, key.offset, end,\n\t\t\t\t\t\t\t1);\n\t\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t      key.offset, end);\n\t\t\t}\n\t\t}\n\n\t\tret = get_new_location(rc->data_inode, &new_bytenr,\n\t\t\t\t       bytenr, num_bytes);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * Don't have to abort since we've not changed anything\n\t\t\t * in the file extent yet.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, new_bytenr);\n\t\tdirty = 1;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tret = btrfs_inc_extent_ref(trans, root, new_bytenr,\n\t\t\t\t\t   num_bytes, parent,\n\t\t\t\t\t   btrfs_header_owner(leaf),\n\t\t\t\t\t   key.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\tparent, btrfs_header_owner(leaf),\n\t\t\t\t\tkey.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirty)\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\tif (inode)\n\t\tbtrfs_add_delayed_iput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_block_processed",
          "args": [
            "rc",
            "node"
          ],
          "line": 4570
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2814-2824",
          "snippet": "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&node->list",
            "&rc->backref_cache.pending[level]"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "cow"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_node_buffer",
          "args": [
            "node"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "drop_node_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "399-406",
          "snippet": "static void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!first_cow && level == 0"
          ],
          "line": 4552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&root->root_item"
          ],
          "line": 4547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__update_reloc_root",
          "args": [
            "root",
            "cow->start"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "__update_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1337-1364",
          "snippet": "static int __update_reloc_root(struct btrfs_root *root, u64 new_bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn 0;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\tnode->bytenr = new_bytenr;\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, node->bytenr);\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __update_reloc_root(struct btrfs_root *root, u64 new_bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn 0;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\tnode->bytenr = new_bytenr;\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, node->bytenr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rc->stage == UPDATE_DATA_PTRS &&\n\t       root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_reloc_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t  struct extent_buffer *cow)\n{\n\tstruct reloc_control *rc;\n\tstruct backref_node *node;\n\tint first_cow = 0;\n\tint level;\n\tint ret = 0;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc)\n\t\treturn 0;\n\n\tBUG_ON(rc->stage == UPDATE_DATA_PTRS &&\n\t       root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (buf == root->node)\n\t\t\t__update_reloc_root(root, cow->start);\n\t}\n\n\tlevel = btrfs_header_level(buf);\n\tif (btrfs_header_generation(buf) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tfirst_cow = 1;\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t    rc->create_reloc_tree) {\n\t\tWARN_ON(!first_cow && level == 0);\n\n\t\tnode = rc->backref_cache.path[level];\n\t\tBUG_ON(node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start);\n\n\t\tdrop_node_buffer(node);\n\t\textent_buffer_get(cow);\n\t\tnode->eb = cow;\n\t\tnode->new_bytenr = cow->start;\n\n\t\tif (!node->pending) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &rc->backref_cache.pending[level]);\n\t\t\tnode->pending = 1;\n\t\t}\n\n\t\tif (first_cow)\n\t\t\t__mark_block_processed(rc, node);\n\n\t\tif (first_cow && level > 0)\n\t\t\trc->nodes_relocated += buf->len;\n\t}\n\n\tif (level == 0 && first_cow && rc->stage == UPDATE_DATA_PTRS)\n\t\tret = replace_file_extents(trans, rc, root, cow);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_reloc_clone_csums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4478-4521",
    "snippet": "int btrfs_reloc_clone_csums(struct inode *inode, u64 file_pos, u64 len)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\tu64 disk_bytenr;\n\tu64 new_bytenr;\n\tLIST_HEAD(list);\n\n\tordered = btrfs_lookup_ordered_extent(inode, file_pos);\n\tBUG_ON(ordered->file_offset != file_pos || ordered->len != len);\n\n\tdisk_bytenr = file_pos + BTRFS_I(inode)->index_cnt;\n\tret = btrfs_lookup_csums_range(root->fs_info->csum_root, disk_bytenr,\n\t\t\t\t       disk_bytenr + len - 1, &list, 0);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (!list_empty(&list)) {\n\t\tsums = list_entry(list.next, struct btrfs_ordered_sum, list);\n\t\tlist_del_init(&sums->list);\n\n\t\t/*\n\t\t * We need to offset the new_bytenr based on where the csum is.\n\t\t * We need to do this because we will read in entire prealloc\n\t\t * extents but we may have written to say the middle of the\n\t\t * prealloc extent, so we need to make sure the csum goes with\n\t\t * the right disk offset.\n\t\t *\n\t\t * We can do this because the data reloc inode refers strictly\n\t\t * to the on disk bytes, so we don't have to worry about\n\t\t * disk_len vs real len like with real inodes since it's all\n\t\t * disk length.\n\t\t */\n\t\tnew_bytenr = ordered->start + (sums->bytenr - disk_bytenr);\n\t\tsums->bytenr = new_bytenr;\n\n\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t}\nout:\n\tbtrfs_put_ordered_extent(ordered);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_ordered_extent",
          "args": [
            "ordered"
          ],
          "line": 4519
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "540-558",
          "snippet": "void btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid btrfs_put_ordered_extent(struct btrfs_ordered_extent *entry)\n{\n\tstruct list_head *cur;\n\tstruct btrfs_ordered_sum *sum;\n\n\ttrace_btrfs_ordered_extent_put(entry->inode, entry);\n\n\tif (atomic_dec_and_test(&entry->refs)) {\n\t\tif (entry->inode)\n\t\t\tbtrfs_add_delayed_iput(entry->inode);\n\t\twhile (!list_empty(&entry->list)) {\n\t\t\tcur = entry->list.next;\n\t\t\tsum = list_entry(cur, struct btrfs_ordered_sum, list);\n\t\t\tlist_del(&sum->list);\n\t\t\tkfree(sum);\n\t\t}\n\t\tkmem_cache_free(btrfs_ordered_extent_cache, entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_add_ordered_sum",
          "args": [
            "inode",
            "ordered",
            "sums"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_ordered_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "280-294",
          "snippet": "void btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_add_ordered_sum(struct inode *inode,\n\t\t\t   struct btrfs_ordered_extent *entry,\n\t\t\t   struct btrfs_ordered_sum *sum)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tlist_add_tail(&sum->list, &entry->list);\n\tWARN_ON(entry->csum_bytes_left < sum->len);\n\tentry->csum_bytes_left -= sum->len;\n\tif (entry->csum_bytes_left == 0)\n\t\twake_up(&entry->wait);\n\tspin_unlock_irq(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&sums->list"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list.next",
            "structbtrfs_ordered_sum",
            "list"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&list"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_csums_range",
          "args": [
            "root->fs_info->csum_root",
            "disk_bytenr",
            "disk_bytenr + len - 1",
            "&list",
            "0"
          ],
          "line": 4492
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_csums_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "307-424",
          "snippet": "int btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_csums_range(struct btrfs_root *root, u64 start, u64 end,\n\t\t\t     struct list_head *list, int search_commit)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_csum_item *item;\n\tLIST_HEAD(tmplist);\n\tunsigned long offset;\n\tint ret;\n\tsize_t size;\n\tu64 csum_end;\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\tASSERT(IS_ALIGNED(start, root->sectorsize) &&\n\t       IS_ALIGNED(end + 1, root->sectorsize));\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (search_commit) {\n\t\tpath->skip_locking = 1;\n\t\tpath->reada = 2;\n\t\tpath->search_commit_root = 1;\n\t}\n\n\tkey.objectid = BTRFS_EXTENT_CSUM_OBJECTID;\n\tkey.offset = start;\n\tkey.type = BTRFS_EXTENT_CSUM_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret > 0 && path->slots[0] > 0) {\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0] - 1);\n\t\tif (key.objectid == BTRFS_EXTENT_CSUM_OBJECTID &&\n\t\t    key.type == BTRFS_EXTENT_CSUM_KEY) {\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\t root->fs_info->sb->s_blocksize_bits;\n\t\t\tif (offset * csum_size <\n\t\t\t    btrfs_item_size_nr(leaf, path->slots[0] - 1))\n\t\t\t\tpath->slots[0]--;\n\t\t}\n\t}\n\n\twhile (start <= end) {\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto fail;\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid != BTRFS_EXTENT_CSUM_OBJECTID ||\n\t\t    key.type != BTRFS_EXTENT_CSUM_KEY ||\n\t\t    key.offset > end)\n\t\t\tbreak;\n\n\t\tif (key.offset > start)\n\t\t\tstart = key.offset;\n\n\t\tsize = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tcsum_end = key.offset + (size / csum_size) * root->sectorsize;\n\t\tif (csum_end <= start) {\n\t\t\tpath->slots[0]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcsum_end = min(csum_end, end + 1);\n\t\titem = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t      struct btrfs_csum_item);\n\t\twhile (start < csum_end) {\n\t\t\tsize = min_t(size_t, csum_end - start,\n\t\t\t\t     MAX_ORDERED_SUM_BYTES(root));\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, size),\n\t\t\t\t       GFP_NOFS);\n\t\t\tif (!sums) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsums->bytenr = start;\n\t\t\tsums->len = (int)size;\n\n\t\t\toffset = (start - key.offset) >>\n\t\t\t\troot->fs_info->sb->s_blocksize_bits;\n\t\t\toffset *= csum_size;\n\t\t\tsize >>= root->fs_info->sb->s_blocksize_bits;\n\n\t\t\tread_extent_buffer(path->nodes[0],\n\t\t\t\t\t   sums->sums,\n\t\t\t\t\t   ((unsigned long)item) + offset,\n\t\t\t\t\t   csum_size * size);\n\n\t\t\tstart += root->sectorsize * size;\n\t\t\tlist_add_tail(&sums->list, &tmplist);\n\t\t}\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nfail:\n\twhile (ret < 0 && !list_empty(&tmplist)) {\n\t\tsums = list_entry(tmplist.next, struct btrfs_ordered_sum, list);\n\t\tlist_del(&sums->list);\n\t\tkfree(sums);\n\t}\n\tlist_splice_tail(&tmplist, list);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ordered->file_offset != file_pos || ordered->len != len"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_ordered_extent",
          "args": [
            "inode",
            "file_pos"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_ordered_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "777-798",
          "snippet": "struct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstruct btrfs_ordered_extent *btrfs_lookup_ordered_extent(struct inode *inode,\n\t\t\t\t\t\t\t u64 file_offset)\n{\n\tstruct btrfs_ordered_inode_tree *tree;\n\tstruct rb_node *node;\n\tstruct btrfs_ordered_extent *entry = NULL;\n\n\ttree = &BTRFS_I(inode)->ordered_tree;\n\tspin_lock_irq(&tree->lock);\n\tnode = tree_search(tree, file_offset);\n\tif (!node)\n\t\tgoto out;\n\n\tentry = rb_entry(node, struct btrfs_ordered_extent, rb_node);\n\tif (!offset_in_entry(entry, file_offset))\n\t\tentry = NULL;\n\tif (entry)\n\t\tatomic_inc(&entry->refs);\nout:\n\tspin_unlock_irq(&tree->lock);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 4486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_reloc_clone_csums(struct inode *inode, u64 file_pos, u64 len)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\tu64 disk_bytenr;\n\tu64 new_bytenr;\n\tLIST_HEAD(list);\n\n\tordered = btrfs_lookup_ordered_extent(inode, file_pos);\n\tBUG_ON(ordered->file_offset != file_pos || ordered->len != len);\n\n\tdisk_bytenr = file_pos + BTRFS_I(inode)->index_cnt;\n\tret = btrfs_lookup_csums_range(root->fs_info->csum_root, disk_bytenr,\n\t\t\t\t       disk_bytenr + len - 1, &list, 0);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (!list_empty(&list)) {\n\t\tsums = list_entry(list.next, struct btrfs_ordered_sum, list);\n\t\tlist_del_init(&sums->list);\n\n\t\t/*\n\t\t * We need to offset the new_bytenr based on where the csum is.\n\t\t * We need to do this because we will read in entire prealloc\n\t\t * extents but we may have written to say the middle of the\n\t\t * prealloc extent, so we need to make sure the csum goes with\n\t\t * the right disk offset.\n\t\t *\n\t\t * We can do this because the data reloc inode refers strictly\n\t\t * to the on disk bytes, so we don't have to worry about\n\t\t * disk_len vs real len like with real inodes since it's all\n\t\t * disk length.\n\t\t */\n\t\tnew_bytenr = ordered->start + (sums->bytenr - disk_bytenr);\n\t\tsums->bytenr = new_bytenr;\n\n\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t}\nout:\n\tbtrfs_put_ordered_extent(ordered);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_recover_relocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4320-4470",
    "snippet": "int btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_orphan_cleanup",
          "args": [
            "fs_root"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3300-3498",
          "snippet": "int btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic struct extent_map *create_pinned_em(struct inode *inode, u64 start,\n\t\t\t\t\t   u64 len, u64 orig_start,\n\t\t\t\t\t   u64 block_start, u64 block_len,\n\t\t\t\t\t   u64 orig_block_len, u64 ram_bytes,\n\t\t\t\t\t   int type);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_orphan_cleanup(struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key, found_key;\n\tstruct btrfs_trans_handle *trans;\n\tstruct inode *inode;\n\tu64 last_objectid = 0;\n\tint ret = 0, nr_unlink = 0, nr_truncate = 0;\n\n\tif (cmpxchg(&root->orphan_cleanup_state, 0, ORPHAN_CLEANUP_STARTED))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t/*\n\t\t * if ret == 0 means we found what we were searching for, which\n\t\t * is weird, but possible, so only screw with path if we didn't\n\t\t * find the key and see if we have stuff that matches\n\t\t */\n\t\tif (ret > 0) {\n\t\t\tret = 0;\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\n\t\t/* pull out the item */\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\n\t\t/* make sure the item matches what we want */\n\t\tif (found_key.objectid != BTRFS_ORPHAN_OBJECTID)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_ORPHAN_ITEM_KEY)\n\t\t\tbreak;\n\n\t\t/* release the path since we're done with it */\n\t\tbtrfs_release_path(path);\n\n\t\t/*\n\t\t * this is where we are basically btrfs_lookup, without the\n\t\t * crossing root thing.  we store the inode number in the\n\t\t * offset of the orphan item.\n\t\t */\n\n\t\tif (found_key.offset == last_objectid) {\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"Error removing orphan entry, stopping orphan cleanup\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlast_objectid = found_key.offset;\n\n\t\tfound_key.objectid = found_key.offset;\n\t\tfound_key.type = BTRFS_INODE_ITEM_KEY;\n\t\tfound_key.offset = 0;\n\t\tinode = btrfs_iget(root->fs_info->sb, &found_key, root, NULL);\n\t\tret = PTR_ERR_OR_ZERO(inode);\n\t\tif (ret && ret != -ESTALE)\n\t\t\tgoto out;\n\n\t\tif (ret == -ESTALE && root == root->fs_info->tree_root) {\n\t\t\tstruct btrfs_root *dead_root;\n\t\t\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\t\t\tint is_dead_root = 0;\n\n\t\t\t/*\n\t\t\t * this is an orphan in the tree root. Currently these\n\t\t\t * could come from 2 sources:\n\t\t\t *  a) a snapshot deletion in progress\n\t\t\t *  b) a free space cache inode\n\t\t\t * We need to distinguish those two, as the snapshot\n\t\t\t * orphan must not get deleted.\n\t\t\t * find_dead_roots already ran before us, so if this\n\t\t\t * is a snapshot deletion, we should find the root\n\t\t\t * in the dead_roots list\n\t\t\t */\n\t\t\tspin_lock(&fs_info->trans_lock);\n\t\t\tlist_for_each_entry(dead_root, &fs_info->dead_roots,\n\t\t\t\t\t    root_list) {\n\t\t\t\tif (dead_root->root_key.objectid ==\n\t\t\t\t    found_key.objectid) {\n\t\t\t\t\tis_dead_root = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&fs_info->trans_lock);\n\t\t\tif (is_dead_root) {\n\t\t\t\t/* prevent this orphan from being found again */\n\t\t\t\tkey.offset = found_key.objectid - 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Inode is already gone but the orphan item is still there,\n\t\t * kill the orphan item.\n\t\t */\n\t\tif (ret == -ESTALE) {\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbtrfs_debug(root->fs_info, \"auto deleting %Lu\",\n\t\t\t\tfound_key.objectid);\n\t\t\tret = btrfs_del_orphan_item(trans, root,\n\t\t\t\t\t\t    found_key.objectid);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * add this inode to the orphan list so btrfs_orphan_del does\n\t\t * the proper thing when we hit it\n\t\t */\n\t\tset_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tatomic_inc(&root->orphan_inodes);\n\n\t\t/* if we have links, this was a truncate, lets do that */\n\t\tif (inode->i_nlink) {\n\t\t\tif (WARN_ON(!S_ISREG(inode->i_mode))) {\n\t\t\t\tiput(inode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnr_truncate++;\n\n\t\t\t/* 1 for the orphan item deletion. */\n\t\t\ttrans = btrfs_start_transaction(root, 1);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\tiput(inode);\n\t\t\t\tret = PTR_ERR(trans);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = btrfs_orphan_add(trans, inode);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret) {\n\t\t\t\tiput(inode);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = btrfs_truncate(inode);\n\t\t\tif (ret)\n\t\t\t\tbtrfs_orphan_del(NULL, inode);\n\t\t} else {\n\t\t\tnr_unlink++;\n\t\t}\n\n\t\t/* this will do delete_inode and everything for us */\n\t\tiput(inode);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\t/* release the path since we're done with it */\n\tbtrfs_release_path(path);\n\n\troot->orphan_cleanup_state = ORPHAN_CLEANUP_DONE;\n\n\tif (root->orphan_block_rsv)\n\t\tbtrfs_block_rsv_release(root, root->orphan_block_rsv,\n\t\t\t\t\t(u64)-1);\n\n\tif (root->orphan_block_rsv ||\n\t    test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state)) {\n\t\ttrans = btrfs_join_transaction(root);\n\t\tif (!IS_ERR(trans))\n\t\t\tbtrfs_end_transaction(trans, root);\n\t}\n\n\tif (nr_unlink)\n\t\tbtrfs_debug(root->fs_info, \"unlinked %d orphans\", nr_unlink);\n\tif (nr_truncate)\n\t\tbtrfs_debug(root->fs_info, \"truncated %d orphans\", nr_truncate);\n\nout:\n\tif (ret)\n\t\tbtrfs_err(root->fs_info,\n\t\t\t\"could not do orphan cleanup %d\", ret);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "root->fs_info",
            "BTRFS_DATA_RELOC_TREE_OBJECTID"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_reloc_roots",
          "args": [
            "&reloc_roots"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "free_reloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2336-2346",
          "snippet": "static noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reloc_roots"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rc"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 4451
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "rc->extent_root"
          ],
          "line": 4447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_reloc_control",
          "args": [
            "rc"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "unset_reloc_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3837-3844",
          "snippet": "static void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_reloc_roots",
          "args": [
            "rc"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "merge_reloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2348-2430",
          "snippet": "static noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err < 0"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_reloc_root",
          "args": [
            "reloc_root"
          ],
          "line": 4434
        },
        "resolved": true,
        "details": {
          "function_name": "__add_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1275-1302",
          "snippet": "static int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&reloc_root->root_list",
            "&rc->reloc_roots"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&reloc_root->root_list"
          ],
          "line": 4419
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reloc_roots.next",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_reloc_control",
          "args": [
            "root->fs_info"
          ],
          "line": 4397
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_reloc_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4168-4182",
          "snippet": "static struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4392
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_garbage_root",
          "args": [
            "reloc_root"
          ],
          "line": 4379
        },
        "resolved": true,
        "details": {
          "function_name": "mark_garbage_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4292-4312",
          "snippet": "static noinline_for_stack int mark_garbage_root(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret, err;\n\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tmemset(&root->root_item.drop_progress, 0,\n\t\tsizeof(root->root_item.drop_progress));\n\troot->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&root->root_item, 0);\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\terr = btrfs_end_transaction(trans, root->fs_info->tree_root);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int mark_garbage_root(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret, err;\n\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tmemset(&root->root_item.drop_progress, 0,\n\t\tsizeof(root->root_item.drop_progress));\n\troot->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&root->root_item, 0);\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\terr = btrfs_end_transaction(trans, root->fs_info->tree_root);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fs_root"
          ],
          "line": 4373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&reloc_root->root_list",
            "&reloc_roots"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "reloc_root"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reloc_root"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root",
          "args": [
            "root",
            "&key"
          ],
          "line": 4362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 4355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root->fs_info->tree_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4333
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reloc_roots"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "mark_garbage_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4292-4312",
    "snippet": "static noinline_for_stack int mark_garbage_root(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret, err;\n\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tmemset(&root->root_item.drop_progress, 0,\n\t\tsizeof(root->root_item.drop_progress));\n\troot->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&root->root_item, 0);\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\terr = btrfs_end_transaction(trans, root->fs_info->tree_root);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root->fs_info->tree_root"
          ],
          "line": 4308
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&root->root_key",
            "&root->root_item"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&root->root_item",
            "0"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root->root_item.drop_progress",
            "0",
            "sizeof(root->root_item.drop_progress)"
          ],
          "line": 4301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root->fs_info->tree_root",
            "0"
          ],
          "line": 4297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int mark_garbage_root(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\tint ret, err;\n\n\ttrans = btrfs_start_transaction(root->fs_info->tree_root, 0);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tmemset(&root->root_item.drop_progress, 0,\n\t\tsizeof(root->root_item.drop_progress));\n\troot->root_item.drop_level = 0;\n\tbtrfs_set_root_refs(&root->root_item, 0);\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root->root_key, &root->root_item);\n\n\terr = btrfs_end_transaction(trans, root->fs_info->tree_root);\n\tif (err)\n\t\treturn err;\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_relocate_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4187-4290",
    "snippet": "int btrfs_relocate_block_group(struct btrfs_root *extent_root, u64 group_start)\n{\n\tstruct btrfs_fs_info *fs_info = extent_root->fs_info;\n\tstruct reloc_control *rc;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint rw = 0;\n\tint err = 0;\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->extent_root = extent_root;\n\n\trc->block_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!rc->block_group);\n\n\tif (!rc->block_group->ro) {\n\t\tret = btrfs_set_block_group_ro(extent_root, rc->block_group);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trw = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(fs_info->tree_root, rc->block_group,\n\t\t\t\t\tpath);\n\tbtrfs_free_path(path);\n\n\tif (!IS_ERR(inode))\n\t\tret = delete_block_group_cache(fs_info, inode, 0);\n\telse\n\t\tret = PTR_ERR(inode);\n\n\tif (ret && ret != -ENOENT) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\trc->data_inode = create_reloc_inode(fs_info, rc->block_group);\n\tif (IS_ERR(rc->data_inode)) {\n\t\terr = PTR_ERR(rc->data_inode);\n\t\trc->data_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_info(extent_root->fs_info, \"relocating block group %llu flags %llu\",\n\t       rc->block_group->key.objectid, rc->block_group->flags);\n\n\tret = btrfs_start_delalloc_roots(fs_info, 0, -1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = relocate_block_group(rc);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rc->extents_found == 0)\n\t\t\tbreak;\n\n\t\tbtrfs_info(extent_root->fs_info, \"found %llu extents\",\n\t\t\trc->extents_found);\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS && rc->found_file_extent) {\n\t\t\tret = btrfs_wait_ordered_range(rc->data_inode, 0,\n\t\t\t\t\t\t       (u64)-1);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinvalidate_mapping_pages(rc->data_inode->i_mapping,\n\t\t\t\t\t\t 0, -1);\n\t\t\trc->stage = UPDATE_DATA_PTRS;\n\t\t}\n\t}\n\n\tWARN_ON(rc->block_group->pinned > 0);\n\tWARN_ON(rc->block_group->reserved > 0);\n\tWARN_ON(btrfs_block_group_used(&rc->block_group->item) > 0);\nout:\n\tif (err && rw)\n\t\tbtrfs_set_block_group_rw(extent_root, rc->block_group);\n\tiput(rc->data_inode);\n\tbtrfs_put_block_group(rc->block_group);\n\tkfree(rc);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPDATE_DATA_PTRS\t1",
      "#define MOVE_DATA_EXTENTS\t0"
    ],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rc"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "rc->block_group"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "rc->data_inode"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_block_group_rw",
          "args": [
            "extent_root",
            "rc->block_group"
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_block_group_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8608-8625",
          "snippet": "void btrfs_set_block_group_rw(struct btrfs_root *root,\n\t\t\t      struct btrfs_block_group_cache *cache)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\n\tBUG_ON(!cache->ro);\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\tnum_bytes = cache->key.offset - cache->reserved - cache->pinned -\n\t\t    cache->bytes_super - btrfs_block_group_used(&cache->item);\n\tsinfo->bytes_readonly -= num_bytes;\n\tcache->ro = 0;\n\tlist_del_init(&cache->ro_list);\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nvoid btrfs_set_block_group_rw(struct btrfs_root *root,\n\t\t\t      struct btrfs_block_group_cache *cache)\n{\n\tstruct btrfs_space_info *sinfo = cache->space_info;\n\tu64 num_bytes;\n\n\tBUG_ON(!cache->ro);\n\n\tspin_lock(&sinfo->lock);\n\tspin_lock(&cache->lock);\n\tnum_bytes = cache->key.offset - cache->reserved - cache->pinned -\n\t\t    cache->bytes_super - btrfs_block_group_used(&cache->item);\n\tsinfo->bytes_readonly -= num_bytes;\n\tcache->ro = 0;\n\tlist_del_init(&cache->ro_list);\n\tspin_unlock(&cache->lock);\n\tspin_unlock(&sinfo->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_block_group_used(&rc->block_group->item) > 0"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_group_used",
          "args": [
            "&rc->block_group->item"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc->block_group->reserved > 0"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc->block_group->pinned > 0"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "rc->data_inode->i_mapping",
            "0",
            "-1"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_range",
          "args": [
            "rc->data_inode",
            "0",
            "(u64)-1"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "722-771",
          "snippet": "int btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nint btrfs_wait_ordered_range(struct inode *inode, u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 end;\n\tu64 orig_end;\n\tstruct btrfs_ordered_extent *ordered;\n\n\tif (start + len < start) {\n\t\torig_end = INT_LIMIT(loff_t);\n\t} else {\n\t\torig_end = start + len - 1;\n\t\tif (orig_end > INT_LIMIT(loff_t))\n\t\t\torig_end = INT_LIMIT(loff_t);\n\t}\n\n\t/* start IO across the range first to instantiate any delalloc\n\t * extents\n\t */\n\tret = btrfs_fdatawrite_range(inode, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tret = filemap_fdatawait_range(inode->i_mapping, start, orig_end);\n\tif (ret)\n\t\treturn ret;\n\n\tend = orig_end;\n\twhile (1) {\n\t\tordered = btrfs_lookup_first_ordered_extent(inode, end);\n\t\tif (!ordered)\n\t\t\tbreak;\n\t\tif (ordered->file_offset > orig_end) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tif (ordered->file_offset + ordered->len <= start) {\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_start_ordered_extent(inode, ordered, 1);\n\t\tend = ordered->file_offset;\n\t\tif (test_bit(BTRFS_ORDERED_IOERR, &ordered->flags))\n\t\t\tret = -EIO;\n\t\tbtrfs_put_ordered_extent(ordered);\n\t\tif (ret || end == 0 || end == start)\n\t\t\tbreak;\n\t\tend--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "extent_root->fs_info",
            "\"found %llu extents\"",
            "rc->extents_found"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relocate_block_group",
          "args": [
            "rc"
          ],
          "line": 4254
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3896-4087",
          "snippet": "static noinline_for_stack int relocate_block_group(struct reloc_control *rc)\n{\n\tstruct rb_root blocks = RB_ROOT;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu32 item_size;\n\tint ret;\n\tint err = 0;\n\tint progress = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tret = prepare_to_relocate(rc);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_free;\n\t}\n\n\twhile (1) {\n\t\trc->reserved_bytes = 0;\n\t\tret = btrfs_block_rsv_refill(rc->extent_root,\n\t\t\t\t\trc->block_rsv, rc->block_rsv->size,\n\t\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tprogress++;\n\t\ttrans = btrfs_start_transaction(rc->extent_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\nrestart:\n\t\tif (update_backref_cache(trans, &rc->backref_cache)) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = find_next_extent(trans, rc, path, &key);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\trc->extents_found++;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_extent_item);\n\t\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tflags = btrfs_extent_flags(path->nodes[0], ei);\n\t\t\tret = check_extent_flags(flags);\n\t\t\tBUG_ON(ret);\n\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tu64 ref_owner;\n\t\t\tint path_change = 0;\n\n\t\t\tBUG_ON(item_size !=\n\t\t\t       sizeof(struct btrfs_extent_item_v0));\n\t\t\tret = get_ref_objectid_v0(rc, path, &key, &ref_owner,\n\t\t\t\t\t\t  &path_change);\n\t\t\tif (ref_owner < BTRFS_FIRST_FREE_OBJECTID)\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\t\telse\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_DATA;\n\n\t\t\tif (path_change) {\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tpath->search_commit_root = 1;\n\t\t\t\tpath->skip_locking = 1;\n\t\t\t\tret = btrfs_search_slot(NULL, rc->extent_root,\n\t\t\t\t\t\t\t&key, path, 0, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBUG_ON(ret > 0);\n\t\t\t}\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tret = add_tree_block(rc, &key, path, &blocks);\n\t\t} else if (rc->stage == UPDATE_DATA_PTRS &&\n\t\t\t   (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\tret = add_data_references(rc, &key, path, &blocks);\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&blocks)) {\n\t\t\tret = relocate_tree_blocks(trans, rc, &blocks);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * if we fail to relocate tree blocks, force to update\n\t\t\t\t * backref cache when committing transaction.\n\t\t\t\t */\n\t\t\t\trc->backref_cache.last_trans = trans->transid - 1;\n\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc->extents_found--;\n\t\t\t\trc->search_start = key.objectid;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t\ttrans = NULL;\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS &&\n\t\t    (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\trc->found_file_extent = 1;\n\t\t\tret = relocate_data_extent(rc->data_inode,\n\t\t\t\t\t\t   &key, &rc->cluster);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (trans && progress && err == -ENOSPC) {\n\t\tret = btrfs_force_chunk_alloc(trans, rc->extent_root,\n\t\t\t\t\t      rc->block_group->flags);\n\t\tif (ret == 0) {\n\t\t\terr = 0;\n\t\t\tprogress = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tclear_extent_bits(&rc->processed_blocks, 0, (u64)-1, EXTENT_DIRTY,\n\t\t\t  GFP_NOFS);\n\n\tif (trans) {\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t}\n\n\tif (!err) {\n\t\tret = relocate_file_extent_cluster(rc->data_inode,\n\t\t\t\t\t\t   &rc->cluster);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\trc->create_reloc_tree = 0;\n\tset_reloc_control(rc);\n\n\tbackref_cache_cleanup(&rc->backref_cache);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\terr = prepare_to_merge(rc, err);\n\n\tmerge_reloc_roots(rc);\n\n\trc->merge_reloc_tree = 0;\n\tunset_reloc_control(rc);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\t/* get rid of pinned extents */\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tbtrfs_free_block_rsv(rc->extent_root, rc->block_rsv);\n\tbtrfs_free_path(path);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPDATE_DATA_PTRS\t1",
            "#define MOVE_DATA_EXTENTS\t0"
          ],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n#define MOVE_DATA_EXTENTS\t0\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int relocate_block_group(struct reloc_control *rc)\n{\n\tstruct rb_root blocks = RB_ROOT;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu32 item_size;\n\tint ret;\n\tint err = 0;\n\tint progress = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tret = prepare_to_relocate(rc);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_free;\n\t}\n\n\twhile (1) {\n\t\trc->reserved_bytes = 0;\n\t\tret = btrfs_block_rsv_refill(rc->extent_root,\n\t\t\t\t\trc->block_rsv, rc->block_rsv->size,\n\t\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tprogress++;\n\t\ttrans = btrfs_start_transaction(rc->extent_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\nrestart:\n\t\tif (update_backref_cache(trans, &rc->backref_cache)) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = find_next_extent(trans, rc, path, &key);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\trc->extents_found++;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_extent_item);\n\t\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tflags = btrfs_extent_flags(path->nodes[0], ei);\n\t\t\tret = check_extent_flags(flags);\n\t\t\tBUG_ON(ret);\n\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tu64 ref_owner;\n\t\t\tint path_change = 0;\n\n\t\t\tBUG_ON(item_size !=\n\t\t\t       sizeof(struct btrfs_extent_item_v0));\n\t\t\tret = get_ref_objectid_v0(rc, path, &key, &ref_owner,\n\t\t\t\t\t\t  &path_change);\n\t\t\tif (ref_owner < BTRFS_FIRST_FREE_OBJECTID)\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\t\telse\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_DATA;\n\n\t\t\tif (path_change) {\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tpath->search_commit_root = 1;\n\t\t\t\tpath->skip_locking = 1;\n\t\t\t\tret = btrfs_search_slot(NULL, rc->extent_root,\n\t\t\t\t\t\t\t&key, path, 0, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBUG_ON(ret > 0);\n\t\t\t}\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tret = add_tree_block(rc, &key, path, &blocks);\n\t\t} else if (rc->stage == UPDATE_DATA_PTRS &&\n\t\t\t   (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\tret = add_data_references(rc, &key, path, &blocks);\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&blocks)) {\n\t\t\tret = relocate_tree_blocks(trans, rc, &blocks);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * if we fail to relocate tree blocks, force to update\n\t\t\t\t * backref cache when committing transaction.\n\t\t\t\t */\n\t\t\t\trc->backref_cache.last_trans = trans->transid - 1;\n\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc->extents_found--;\n\t\t\t\trc->search_start = key.objectid;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t\ttrans = NULL;\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS &&\n\t\t    (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\trc->found_file_extent = 1;\n\t\t\tret = relocate_data_extent(rc->data_inode,\n\t\t\t\t\t\t   &key, &rc->cluster);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (trans && progress && err == -ENOSPC) {\n\t\tret = btrfs_force_chunk_alloc(trans, rc->extent_root,\n\t\t\t\t\t      rc->block_group->flags);\n\t\tif (ret == 0) {\n\t\t\terr = 0;\n\t\t\tprogress = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tclear_extent_bits(&rc->processed_blocks, 0, (u64)-1, EXTENT_DIRTY,\n\t\t\t  GFP_NOFS);\n\n\tif (trans) {\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t}\n\n\tif (!err) {\n\t\tret = relocate_file_extent_cluster(rc->data_inode,\n\t\t\t\t\t\t   &rc->cluster);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\trc->create_reloc_tree = 0;\n\tset_reloc_control(rc);\n\n\tbackref_cache_cleanup(&rc->backref_cache);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\terr = prepare_to_merge(rc, err);\n\n\tmerge_reloc_roots(rc);\n\n\trc->merge_reloc_tree = 0;\n\tunset_reloc_control(rc);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\t/* get rid of pinned extents */\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tbtrfs_free_block_rsv(rc->extent_root, rc->block_rsv);\n\tbtrfs_free_path(path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_roots",
          "args": [
            "fs_info",
            "-1"
          ],
          "line": 4250
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "656-688",
          "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_start_delalloc_roots",
          "args": [
            "fs_info",
            "0",
            "-1"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_delalloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9228-9282",
          "snippet": "int btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_start_delalloc_roots(struct btrfs_fs_info *fs_info, int delay_iput,\n\t\t\t       int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint ret;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\treturn -EROFS;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->delalloc_root_mutex);\n\tspin_lock(&fs_info->delalloc_root_lock);\n\tlist_splice_init(&fs_info->delalloc_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tdelalloc_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->delalloc_root,\n\t\t\t       &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\t\tret = __start_delalloc_inodes(root, delay_iput, nr);\n\t\tbtrfs_put_fs_root(root);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (nr != -1) {\n\t\t\tnr -= ret;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t}\n\tspin_unlock(&fs_info->delalloc_root_lock);\n\n\tret = 0;\n\tatomic_inc(&fs_info->async_submit_draining);\n\twhile (atomic_read(&fs_info->nr_async_submits) ||\n\t      atomic_read(&fs_info->async_delalloc_pages)) {\n\t\twait_event(fs_info->async_submit_wait,\n\t\t   (atomic_read(&fs_info->nr_async_submits) == 0 &&\n\t\t    atomic_read(&fs_info->async_delalloc_pages) == 0));\n\t}\n\tatomic_dec(&fs_info->async_submit_draining);\nout:\n\tif (!list_empty_careful(&splice)) {\n\t\tspin_lock(&fs_info->delalloc_root_lock);\n\t\tlist_splice_tail(&splice, &fs_info->delalloc_roots);\n\t\tspin_unlock(&fs_info->delalloc_root_lock);\n\t}\n\tmutex_unlock(&fs_info->delalloc_root_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "extent_root->fs_info",
            "\"relocating block group %llu flags %llu\"",
            "rc->block_group->key.objectid",
            "rc->block_group->flags"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rc->data_inode"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rc->data_inode"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_reloc_inode",
          "args": [
            "fs_info",
            "rc->block_group"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "create_reloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4124-4166",
          "snippet": "inode *create_reloc_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_group_cache *group)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tu64 objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tint err = 0;\n\n\troot = read_fs_root(fs_info, BTRFS_DATA_RELOC_TREE_OBJECTID);\n\tif (IS_ERR(root))\n\t\treturn ERR_CAST(root);\n\n\ttrans = btrfs_start_transaction(root, 6);\n\tif (IS_ERR(trans))\n\t\treturn ERR_CAST(trans);\n\n\terr = btrfs_find_free_objectid(root, &objectid);\n\tif (err)\n\t\tgoto out;\n\n\terr = __insert_orphan_inode(trans, root, objectid);\n\tBUG_ON(err);\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tBUG_ON(IS_ERR(inode) || is_bad_inode(inode));\n\tBTRFS_I(inode)->index_cnt = group->key.objectid;\n\n\terr = btrfs_orphan_add(trans, inode);\nout:\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\n\tif (err) {\n\t\tif (inode)\n\t\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\ninode *create_reloc_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_group_cache *group)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tu64 objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tint err = 0;\n\n\troot = read_fs_root(fs_info, BTRFS_DATA_RELOC_TREE_OBJECTID);\n\tif (IS_ERR(root))\n\t\treturn ERR_CAST(root);\n\n\ttrans = btrfs_start_transaction(root, 6);\n\tif (IS_ERR(trans))\n\t\treturn ERR_CAST(trans);\n\n\terr = btrfs_find_free_objectid(root, &objectid);\n\tif (err)\n\t\tgoto out;\n\n\terr = __insert_orphan_inode(trans, root, objectid);\n\tBUG_ON(err);\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tBUG_ON(IS_ERR(inode) || is_bad_inode(inode));\n\tBTRFS_I(inode)->index_cnt = group->key.objectid;\n\n\terr = btrfs_orphan_add(trans, inode);\nout:\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\n\tif (err) {\n\t\tif (inode)\n\t\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_block_group_cache",
          "args": [
            "fs_info",
            "inode",
            "0"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "delete_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3432-3473",
          "snippet": "static int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4223
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_free_space_inode",
          "args": [
            "fs_info->tree_root",
            "rc->block_group",
            "path"
          ],
          "line": 4221
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_free_space_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "93-128",
          "snippet": "struct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstruct inode *lookup_free_space_inode(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_block_group_cache\n\t\t\t\t      *block_group, struct btrfs_path *path)\n{\n\tstruct inode *inode = NULL;\n\tu32 flags = BTRFS_INODE_NODATASUM | BTRFS_INODE_NODATACOW;\n\n\tspin_lock(&block_group->lock);\n\tif (block_group->inode)\n\t\tinode = igrab(block_group->inode);\n\tspin_unlock(&block_group->lock);\n\tif (inode)\n\t\treturn inode;\n\n\tinode = __lookup_free_space_inode(root, path,\n\t\t\t\t\t  block_group->key.objectid);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\tspin_lock(&block_group->lock);\n\tif (!((BTRFS_I(inode)->flags & flags) == flags)) {\n\t\tbtrfs_info(root->fs_info,\n\t\t\t\"Old style space inode found, converting.\");\n\t\tBTRFS_I(inode)->flags |= BTRFS_INODE_NODATASUM |\n\t\t\tBTRFS_INODE_NODATACOW;\n\t\tblock_group->disk_cache_state = BTRFS_DC_CLEAR;\n\t}\n\n\tif (!block_group->iref) {\n\t\tblock_group->inode = igrab(inode);\n\t\tblock_group->iref = 1;\n\t}\n\tspin_unlock(&block_group->lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4215
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_block_group_ro",
          "args": [
            "extent_root",
            "rc->block_group"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_block_group_ro",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8526-8557",
          "snippet": "int btrfs_set_block_group_ro(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_group_cache *cache)\n\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 alloc_flags;\n\tint ret;\n\n\tBUG_ON(cache->ro);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = set_block_group_ro(cache, 0);\n\tif (!ret)\n\t\tgoto out;\n\talloc_flags = get_alloc_profile(root, cache->space_info->flags);\n\tret = do_chunk_alloc(trans, root, alloc_flags,\n\t\t\t     CHUNK_ALLOC_FORCE);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = set_block_group_ro(cache, 0);\nout:\n\tif (cache->flags & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\talloc_flags = update_block_group_flags(root, cache->flags);\n\t\tcheck_system_chunk(trans, root, alloc_flags);\n\t}\n\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_set_block_group_ro(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_group_cache *cache)\n\n{\n\tstruct btrfs_trans_handle *trans;\n\tu64 alloc_flags;\n\tint ret;\n\n\tBUG_ON(cache->ro);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tret = set_block_group_ro(cache, 0);\n\tif (!ret)\n\t\tgoto out;\n\talloc_flags = get_alloc_profile(root, cache->space_info->flags);\n\tret = do_chunk_alloc(trans, root, alloc_flags,\n\t\t\t     CHUNK_ALLOC_FORCE);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = set_block_group_ro(cache, 0);\nout:\n\tif (cache->flags & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\talloc_flags = update_block_group_flags(root, cache->flags);\n\t\tcheck_system_chunk(trans, root, alloc_flags);\n\t}\n\n\tbtrfs_end_transaction(trans, root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rc->block_group"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_block_group",
          "args": [
            "fs_info",
            "group_start"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "669-678",
          "snippet": "struct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_reloc_control",
          "args": [
            "fs_info"
          ],
          "line": 4197
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_reloc_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4168-4182",
          "snippet": "static struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n#define MOVE_DATA_EXTENTS\t0\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_relocate_block_group(struct btrfs_root *extent_root, u64 group_start)\n{\n\tstruct btrfs_fs_info *fs_info = extent_root->fs_info;\n\tstruct reloc_control *rc;\n\tstruct inode *inode;\n\tstruct btrfs_path *path;\n\tint ret;\n\tint rw = 0;\n\tint err = 0;\n\n\trc = alloc_reloc_control(fs_info);\n\tif (!rc)\n\t\treturn -ENOMEM;\n\n\trc->extent_root = extent_root;\n\n\trc->block_group = btrfs_lookup_block_group(fs_info, group_start);\n\tBUG_ON(!rc->block_group);\n\n\tif (!rc->block_group->ro) {\n\t\tret = btrfs_set_block_group_ro(extent_root, rc->block_group);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trw = 1;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tinode = lookup_free_space_inode(fs_info->tree_root, rc->block_group,\n\t\t\t\t\tpath);\n\tbtrfs_free_path(path);\n\n\tif (!IS_ERR(inode))\n\t\tret = delete_block_group_cache(fs_info, inode, 0);\n\telse\n\t\tret = PTR_ERR(inode);\n\n\tif (ret && ret != -ENOENT) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\trc->data_inode = create_reloc_inode(fs_info, rc->block_group);\n\tif (IS_ERR(rc->data_inode)) {\n\t\terr = PTR_ERR(rc->data_inode);\n\t\trc->data_inode = NULL;\n\t\tgoto out;\n\t}\n\n\tbtrfs_info(extent_root->fs_info, \"relocating block group %llu flags %llu\",\n\t       rc->block_group->key.objectid, rc->block_group->flags);\n\n\tret = btrfs_start_delalloc_roots(fs_info, 0, -1);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\twhile (1) {\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = relocate_block_group(rc);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rc->extents_found == 0)\n\t\t\tbreak;\n\n\t\tbtrfs_info(extent_root->fs_info, \"found %llu extents\",\n\t\t\trc->extents_found);\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS && rc->found_file_extent) {\n\t\t\tret = btrfs_wait_ordered_range(rc->data_inode, 0,\n\t\t\t\t\t\t       (u64)-1);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinvalidate_mapping_pages(rc->data_inode->i_mapping,\n\t\t\t\t\t\t 0, -1);\n\t\t\trc->stage = UPDATE_DATA_PTRS;\n\t\t}\n\t}\n\n\tWARN_ON(rc->block_group->pinned > 0);\n\tWARN_ON(rc->block_group->reserved > 0);\n\tWARN_ON(btrfs_block_group_used(&rc->block_group->item) > 0);\nout:\n\tif (err && rw)\n\t\tbtrfs_set_block_group_rw(extent_root, rc->block_group);\n\tiput(rc->data_inode);\n\tbtrfs_put_block_group(rc->block_group);\n\tkfree(rc);\n\treturn err;\n}"
  },
  {
    "function_name": "alloc_reloc_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4168-4182",
    "snippet": "static struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extent_io_tree_init",
          "args": [
            "&rc->processed_blocks",
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "198-206",
          "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tree_init",
          "args": [
            "&rc->reloc_root_tree"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "201-205",
          "snippet": "static void mapping_tree_init(struct mapping_tree *tree)\n{\n\ttree->rb_root = RB_ROOT;\n\tspin_lock_init(&tree->lock);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void mapping_tree_init(struct mapping_tree *tree)\n{\n\ttree->rb_root = RB_ROOT;\n\tspin_lock_init(&tree->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "backref_cache_init",
          "args": [
            "&rc->backref_cache"
          ],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "backref_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "207-216",
          "snippet": "static void backref_cache_init(struct backref_cache *cache)\n{\n\tint i;\n\tcache->rb_root = RB_ROOT;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tINIT_LIST_HEAD(&cache->pending[i]);\n\tINIT_LIST_HEAD(&cache->changed);\n\tINIT_LIST_HEAD(&cache->detached);\n\tINIT_LIST_HEAD(&cache->leaves);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_cache_init(struct backref_cache *cache)\n{\n\tint i;\n\tcache->rb_root = RB_ROOT;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tINIT_LIST_HEAD(&cache->pending[i]);\n\tINIT_LIST_HEAD(&cache->changed);\n\tINIT_LIST_HEAD(&cache->detached);\n\tINIT_LIST_HEAD(&cache->leaves);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rc->reloc_roots"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rc)",
            "GFP_NOFS"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct reloc_control *alloc_reloc_control(struct btrfs_fs_info *fs_info)\n{\n\tstruct reloc_control *rc;\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rc->reloc_roots);\n\tbackref_cache_init(&rc->backref_cache);\n\tmapping_tree_init(&rc->reloc_root_tree);\n\textent_io_tree_init(&rc->processed_blocks,\n\t\t\t    fs_info->btree_inode->i_mapping);\n\treturn rc;\n}"
  },
  {
    "function_name": "create_reloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4124-4166",
    "snippet": "inode *create_reloc_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_group_cache *group)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tu64 objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tint err = 0;\n\n\troot = read_fs_root(fs_info, BTRFS_DATA_RELOC_TREE_OBJECTID);\n\tif (IS_ERR(root))\n\t\treturn ERR_CAST(root);\n\n\ttrans = btrfs_start_transaction(root, 6);\n\tif (IS_ERR(trans))\n\t\treturn ERR_CAST(trans);\n\n\terr = btrfs_find_free_objectid(root, &objectid);\n\tif (err)\n\t\tgoto out;\n\n\terr = __insert_orphan_inode(trans, root, objectid);\n\tBUG_ON(err);\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tBUG_ON(IS_ERR(inode) || is_bad_inode(inode));\n\tBTRFS_I(inode)->index_cnt = group->key.objectid;\n\n\terr = btrfs_orphan_add(trans, inode);\nout:\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\n\tif (err) {\n\t\tif (inode)\n\t\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 4162
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "root"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 4158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_orphan_add",
          "args": [
            "trans",
            "inode"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_orphan_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3179-3259",
          "snippet": "int btrfs_orphan_add(struct btrfs_trans_handle *trans, struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = NULL;\n\tint reserve = 0;\n\tint insert = 0;\n\tint ret;\n\n\tif (!root->orphan_block_rsv) {\n\t\tblock_rsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\t\tif (!block_rsv)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&root->orphan_lock);\n\tif (!root->orphan_block_rsv) {\n\t\troot->orphan_block_rsv = block_rsv;\n\t} else if (block_rsv) {\n\t\tbtrfs_free_block_rsv(root, block_rsv);\n\t\tblock_rsv = NULL;\n\t}\n\n\tif (!test_and_set_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t      &BTRFS_I(inode)->runtime_flags)) {\n#if 0\n\t\t/*\n\t\t * For proper ENOSPC handling, we should do orphan\n\t\t * cleanup when mounting. But this introduces backward\n\t\t * compatibility issue.\n\t\t */\n\t\tif (!xchg(&root->orphan_item_inserted, 1))\n\t\t\tinsert = 2;\n\t\telse\n\t\t\tinsert = 1;\n#endif\n\t\tinsert = 1;\n\t\tatomic_inc(&root->orphan_inodes);\n\t}\n\n\tif (!test_and_set_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t      &BTRFS_I(inode)->runtime_flags))\n\t\treserve = 1;\n\tspin_unlock(&root->orphan_lock);\n\n\t/* grab metadata reservation from transaction handle */\n\tif (reserve) {\n\t\tret = btrfs_orphan_reserve_metadata(trans, inode);\n\t\tBUG_ON(ret); /* -ENOSPC in reservation; Logic error? JDM */\n\t}\n\n\t/* insert an orphan item to track this unlinked/truncated file */\n\tif (insert >= 1) {\n\t\tret = btrfs_insert_orphan_item(trans, root, btrfs_ino(inode));\n\t\tif (ret) {\n\t\t\tatomic_dec(&root->orphan_inodes);\n\t\t\tif (reserve) {\n\t\t\t\tclear_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tbtrfs_orphan_release_metadata(inode);\n\t\t\t}\n\t\t\tif (ret != -EEXIST) {\n\t\t\t\tclear_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t}\n\n\t/* insert an orphan item to track subvolume contains orphan files */\n\tif (insert >= 2) {\n\t\tret = btrfs_insert_orphan_item(trans, root->fs_info->tree_root,\n\t\t\t\t\t       root->root_key.objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_orphan_add(struct btrfs_trans_handle *trans, struct inode *inode)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = NULL;\n\tint reserve = 0;\n\tint insert = 0;\n\tint ret;\n\n\tif (!root->orphan_block_rsv) {\n\t\tblock_rsv = btrfs_alloc_block_rsv(root, BTRFS_BLOCK_RSV_TEMP);\n\t\tif (!block_rsv)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&root->orphan_lock);\n\tif (!root->orphan_block_rsv) {\n\t\troot->orphan_block_rsv = block_rsv;\n\t} else if (block_rsv) {\n\t\tbtrfs_free_block_rsv(root, block_rsv);\n\t\tblock_rsv = NULL;\n\t}\n\n\tif (!test_and_set_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t      &BTRFS_I(inode)->runtime_flags)) {\n#if 0\n\t\t/*\n\t\t * For proper ENOSPC handling, we should do orphan\n\t\t * cleanup when mounting. But this introduces backward\n\t\t * compatibility issue.\n\t\t */\n\t\tif (!xchg(&root->orphan_item_inserted, 1))\n\t\t\tinsert = 2;\n\t\telse\n\t\t\tinsert = 1;\n#endif\n\t\tinsert = 1;\n\t\tatomic_inc(&root->orphan_inodes);\n\t}\n\n\tif (!test_and_set_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t      &BTRFS_I(inode)->runtime_flags))\n\t\treserve = 1;\n\tspin_unlock(&root->orphan_lock);\n\n\t/* grab metadata reservation from transaction handle */\n\tif (reserve) {\n\t\tret = btrfs_orphan_reserve_metadata(trans, inode);\n\t\tBUG_ON(ret); /* -ENOSPC in reservation; Logic error? JDM */\n\t}\n\n\t/* insert an orphan item to track this unlinked/truncated file */\n\tif (insert >= 1) {\n\t\tret = btrfs_insert_orphan_item(trans, root, btrfs_ino(inode));\n\t\tif (ret) {\n\t\t\tatomic_dec(&root->orphan_inodes);\n\t\t\tif (reserve) {\n\t\t\t\tclear_bit(BTRFS_INODE_ORPHAN_META_RESERVED,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tbtrfs_orphan_release_metadata(inode);\n\t\t\t}\n\t\t\tif (ret != -EEXIST) {\n\t\t\t\tclear_bit(BTRFS_INODE_HAS_ORPHAN_ITEM,\n\t\t\t\t\t  &BTRFS_I(inode)->runtime_flags);\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t}\n\n\t/* insert an orphan item to track subvolume contains orphan files */\n\tif (insert >= 2) {\n\t\tret = btrfs_insert_orphan_item(trans, root->fs_info->tree_root,\n\t\t\t\t\t       root->root_key.objectid);\n\t\tif (ret && ret != -EEXIST) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(inode) || is_bad_inode(inode)"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 4153
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "root->fs_info->sb",
            "&key",
            "root",
            "NULL"
          ],
          "line": 4152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err"
          ],
          "line": 4147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__insert_orphan_inode",
          "args": [
            "trans",
            "root",
            "objectid"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_orphan_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4089-4117",
          "snippet": "static int __insert_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *item;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_inode_item);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\tbtrfs_set_inode_generation(leaf, item, 1);\n\tbtrfs_set_inode_size(leaf, item, 0);\n\tbtrfs_set_inode_mode(leaf, item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int __insert_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *item;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_inode_item);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\tbtrfs_set_inode_generation(leaf, item, 1);\n\tbtrfs_set_inode_size(leaf, item, 0);\n\tbtrfs_set_inode_mode(leaf, item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_free_objectid",
          "args": [
            "root",
            "&objectid"
          ],
          "line": 4142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_free_objectid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-map.c",
          "lines": "546-568",
          "snippet": "int btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n\nint btrfs_find_free_objectid(struct btrfs_root *root, u64 *objectid)\n{\n\tint ret;\n\tmutex_lock(&root->objectid_mutex);\n\n\tif (unlikely(root->highest_objectid < BTRFS_FIRST_FREE_OBJECTID)) {\n\t\tret = btrfs_find_highest_objectid(root,\n\t\t\t\t\t\t  &root->highest_objectid);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (unlikely(root->highest_objectid >= BTRFS_LAST_FREE_OBJECTID)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t*objectid = ++root->highest_objectid;\n\tret = 0;\nout:\n\tmutex_unlock(&root->objectid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "trans"
          ],
          "line": 4140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "6"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "root"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "fs_info",
            "BTRFS_DATA_RELOC_TREE_OBJECTID"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\ninode *create_reloc_inode(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct btrfs_block_group_cache *group)\n{\n\tstruct inode *inode = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tu64 objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tint err = 0;\n\n\troot = read_fs_root(fs_info, BTRFS_DATA_RELOC_TREE_OBJECTID);\n\tif (IS_ERR(root))\n\t\treturn ERR_CAST(root);\n\n\ttrans = btrfs_start_transaction(root, 6);\n\tif (IS_ERR(trans))\n\t\treturn ERR_CAST(trans);\n\n\terr = btrfs_find_free_objectid(root, &objectid);\n\tif (err)\n\t\tgoto out;\n\n\terr = __insert_orphan_inode(trans, root, objectid);\n\tBUG_ON(err);\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(root->fs_info->sb, &key, root, NULL);\n\tBUG_ON(IS_ERR(inode) || is_bad_inode(inode));\n\tBTRFS_I(inode)->index_cnt = group->key.objectid;\n\n\terr = btrfs_orphan_add(trans, inode);\nout:\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\n\tif (err) {\n\t\tif (inode)\n\t\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "__insert_orphan_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "4089-4117",
    "snippet": "static int __insert_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *item;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_inode_item);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\tbtrfs_set_inode_generation(leaf, item, 1);\n\tbtrfs_set_inode_size(leaf, item, 0);\n\tbtrfs_set_inode_mode(leaf, item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4113
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_flags",
          "args": [
            "leaf",
            "item",
            "BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC"
          ],
          "line": 4111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_mode",
          "args": [
            "leaf",
            "item",
            "S_IFREG | 0600"
          ],
          "line": 4110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_size",
          "args": [
            "leaf",
            "item",
            "0"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_inode_generation",
          "args": [
            "leaf",
            "item",
            "1"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "leaf",
            "0",
            "(unsigned long)item",
            "sizeof(*item)"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_inode_item"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_inode",
          "args": [
            "trans",
            "root",
            "path",
            "objectid"
          ],
          "line": 4101
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode-item.c",
          "lines": "401-414",
          "snippet": "int btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_inode_item));\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nint btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid)\n{\n\tstruct btrfs_key key;\n\tint ret;\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, root, path, &key,\n\t\t\t\t      sizeof(struct btrfs_inode_item));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4097
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int __insert_orphan_inode(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_inode_item *item;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_insert_empty_inode(trans, root, path, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\titem = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_inode_item);\n\tmemset_extent_buffer(leaf, 0, (unsigned long)item, sizeof(*item));\n\tbtrfs_set_inode_generation(leaf, item, 1);\n\tbtrfs_set_inode_size(leaf, item, 0);\n\tbtrfs_set_inode_mode(leaf, item, S_IFREG | 0600);\n\tbtrfs_set_inode_flags(leaf, item, BTRFS_INODE_NOCOMPRESS |\n\t\t\t\t\t  BTRFS_INODE_PREALLOC);\n\tbtrfs_mark_buffer_dirty(leaf);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "relocate_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3896-4087",
    "snippet": "static noinline_for_stack int relocate_block_group(struct reloc_control *rc)\n{\n\tstruct rb_root blocks = RB_ROOT;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu32 item_size;\n\tint ret;\n\tint err = 0;\n\tint progress = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tret = prepare_to_relocate(rc);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_free;\n\t}\n\n\twhile (1) {\n\t\trc->reserved_bytes = 0;\n\t\tret = btrfs_block_rsv_refill(rc->extent_root,\n\t\t\t\t\trc->block_rsv, rc->block_rsv->size,\n\t\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tprogress++;\n\t\ttrans = btrfs_start_transaction(rc->extent_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\nrestart:\n\t\tif (update_backref_cache(trans, &rc->backref_cache)) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = find_next_extent(trans, rc, path, &key);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\trc->extents_found++;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_extent_item);\n\t\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tflags = btrfs_extent_flags(path->nodes[0], ei);\n\t\t\tret = check_extent_flags(flags);\n\t\t\tBUG_ON(ret);\n\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tu64 ref_owner;\n\t\t\tint path_change = 0;\n\n\t\t\tBUG_ON(item_size !=\n\t\t\t       sizeof(struct btrfs_extent_item_v0));\n\t\t\tret = get_ref_objectid_v0(rc, path, &key, &ref_owner,\n\t\t\t\t\t\t  &path_change);\n\t\t\tif (ref_owner < BTRFS_FIRST_FREE_OBJECTID)\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\t\telse\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_DATA;\n\n\t\t\tif (path_change) {\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tpath->search_commit_root = 1;\n\t\t\t\tpath->skip_locking = 1;\n\t\t\t\tret = btrfs_search_slot(NULL, rc->extent_root,\n\t\t\t\t\t\t\t&key, path, 0, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBUG_ON(ret > 0);\n\t\t\t}\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tret = add_tree_block(rc, &key, path, &blocks);\n\t\t} else if (rc->stage == UPDATE_DATA_PTRS &&\n\t\t\t   (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\tret = add_data_references(rc, &key, path, &blocks);\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&blocks)) {\n\t\t\tret = relocate_tree_blocks(trans, rc, &blocks);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * if we fail to relocate tree blocks, force to update\n\t\t\t\t * backref cache when committing transaction.\n\t\t\t\t */\n\t\t\t\trc->backref_cache.last_trans = trans->transid - 1;\n\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc->extents_found--;\n\t\t\t\trc->search_start = key.objectid;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t\ttrans = NULL;\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS &&\n\t\t    (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\trc->found_file_extent = 1;\n\t\t\tret = relocate_data_extent(rc->data_inode,\n\t\t\t\t\t\t   &key, &rc->cluster);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (trans && progress && err == -ENOSPC) {\n\t\tret = btrfs_force_chunk_alloc(trans, rc->extent_root,\n\t\t\t\t\t      rc->block_group->flags);\n\t\tif (ret == 0) {\n\t\t\terr = 0;\n\t\t\tprogress = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tclear_extent_bits(&rc->processed_blocks, 0, (u64)-1, EXTENT_DIRTY,\n\t\t\t  GFP_NOFS);\n\n\tif (trans) {\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t}\n\n\tif (!err) {\n\t\tret = relocate_file_extent_cluster(rc->data_inode,\n\t\t\t\t\t\t   &rc->cluster);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\trc->create_reloc_tree = 0;\n\tset_reloc_control(rc);\n\n\tbackref_cache_cleanup(&rc->backref_cache);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\terr = prepare_to_merge(rc, err);\n\n\tmerge_reloc_roots(rc);\n\n\trc->merge_reloc_tree = 0;\n\tunset_reloc_control(rc);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\t/* get rid of pinned extents */\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tbtrfs_free_block_rsv(rc->extent_root, rc->block_rsv);\n\tbtrfs_free_path(path);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPDATE_DATA_PTRS\t1",
      "#define MOVE_DATA_EXTENTS\t0"
    ],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_block_rsv",
          "args": [
            "rc->extent_root",
            "rc->block_rsv"
          ],
          "line": 4084
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4694-4701",
          "snippet": "void btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_block_rsv(struct btrfs_root *root,\n\t\t\t  struct btrfs_block_rsv *rsv)\n{\n\tif (!rsv)\n\t\treturn;\n\tbtrfs_block_rsv_release(root, rsv, (u64)-1);\n\tkfree(rsv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 4082
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "rc->extent_root"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "rc->extent_root",
            "rc->block_rsv",
            "(u64)-1"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unset_reloc_control",
          "args": [
            "rc"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "unset_reloc_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3837-3844",
          "snippet": "static void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_reloc_roots",
          "args": [
            "rc"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "merge_reloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2348-2430",
          "snippet": "static noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_merge",
          "args": [
            "rc",
            "err"
          ],
          "line": 4069
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2263-2334",
          "snippet": "static noinline_for_stack\nint prepare_to_merge(struct reloc_control *rc, int err)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_trans_handle *trans;\n\tLIST_HEAD(reloc_roots);\n\tu64 num_bytes = 0;\n\tint ret;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trc->merging_rsv_size += root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\trc->merging_rsv_size += rc->nodes_relocated * 2;\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\nagain:\n\tif (!err) {\n\t\tnum_bytes = rc->merging_rsv_size;\n\t\tret = btrfs_block_rsv_add(root, rc->block_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tif (!err)\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tif (!err) {\n\t\tif (num_bytes != rc->merging_rsv_size) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&rc->reloc_roots)) {\n\t\treloc_root = list_entry(rc->reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&reloc_root->root_list);\n\n\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t    reloc_root->root_key.offset);\n\t\tBUG_ON(IS_ERR(root));\n\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t/*\n\t\t * set reference count to 1, so btrfs_recover_relocation\n\t\t * knows it should resumes merging\n\t\t */\n\t\tif (!err)\n\t\t\tbtrfs_set_root_refs(&reloc_root->root_item, 1);\n\t\tbtrfs_update_reloc_root(trans, root);\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t}\n\n\tlist_splice(&reloc_roots, &rc->reloc_roots);\n\n\tif (!err)\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\n\telse\n\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prepare_to_merge(struct reloc_control *rc, int err)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_trans_handle *trans;\n\tLIST_HEAD(reloc_roots);\n\tu64 num_bytes = 0;\n\tint ret;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trc->merging_rsv_size += root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\trc->merging_rsv_size += rc->nodes_relocated * 2;\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\nagain:\n\tif (!err) {\n\t\tnum_bytes = rc->merging_rsv_size;\n\t\tret = btrfs_block_rsv_add(root, rc->block_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tif (!err)\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tif (!err) {\n\t\tif (num_bytes != rc->merging_rsv_size) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&rc->reloc_roots)) {\n\t\treloc_root = list_entry(rc->reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&reloc_root->root_list);\n\n\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t    reloc_root->root_key.offset);\n\t\tBUG_ON(IS_ERR(root));\n\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t/*\n\t\t * set reference count to 1, so btrfs_recover_relocation\n\t\t * knows it should resumes merging\n\t\t */\n\t\tif (!err)\n\t\t\tbtrfs_set_root_refs(&reloc_root->root_item, 1);\n\t\tbtrfs_update_reloc_root(trans, root);\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t}\n\n\tlist_splice(&reloc_roots, &rc->reloc_roots);\n\n\tif (!err)\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\n\telse\n\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backref_cache_cleanup",
          "args": [
            "&rc->backref_cache"
          ],
          "line": 4066
        },
        "resolved": true,
        "details": {
          "function_name": "backref_cache_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "218-244",
          "snippet": "static void backref_cache_cleanup(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint i;\n\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->leaves)) {\n\t\tnode = list_entry(cache->leaves.next,\n\t\t\t\t  struct backref_node, lower);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\tcache->last_trans = 0;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tBUG_ON(!list_empty(&cache->pending[i]));\n\tBUG_ON(!list_empty(&cache->changed));\n\tBUG_ON(!list_empty(&cache->detached));\n\tBUG_ON(!RB_EMPTY_ROOT(&cache->rb_root));\n\tBUG_ON(cache->nr_nodes);\n\tBUG_ON(cache->nr_edges);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_cache_cleanup(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint i;\n\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->leaves)) {\n\t\tnode = list_entry(cache->leaves.next,\n\t\t\t\t  struct backref_node, lower);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\tcache->last_trans = 0;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tBUG_ON(!list_empty(&cache->pending[i]));\n\tBUG_ON(!list_empty(&cache->changed));\n\tBUG_ON(!list_empty(&cache->detached));\n\tBUG_ON(!RB_EMPTY_ROOT(&cache->rb_root));\n\tBUG_ON(cache->nr_nodes);\n\tBUG_ON(cache->nr_edges);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relocate_file_extent_cluster",
          "args": [
            "rc->data_inode",
            "&rc->cluster"
          ],
          "line": 4057
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_file_extent_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3093-3197",
          "snippet": "static int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "rc->extent_root"
          ],
          "line": 4053
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction_throttle",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "&rc->processed_blocks",
            "0",
            "(u64)-1",
            "EXTENT_DIRTY",
            "GFP_NOFS"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4047
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_force_chunk_alloc",
          "args": [
            "trans",
            "rc->extent_root",
            "rc->block_group->flags"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_force_chunk_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8559-8565",
          "snippet": "int btrfs_force_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, u64 type)\n{\n\tu64 alloc_flags = get_alloc_profile(root, type);\n\treturn do_chunk_alloc(trans, root, alloc_flags,\n\t\t\t      CHUNK_ALLOC_FORCE);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_force_chunk_alloc(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root, u64 type)\n{\n\tu64 alloc_flags = get_alloc_profile(root, type);\n\treturn do_chunk_alloc(trans, root, alloc_flags,\n\t\t\t      CHUNK_ALLOC_FORCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "relocate_data_extent",
          "args": [
            "rc->data_inode",
            "&key",
            "&rc->cluster"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_data_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3199-3227",
          "snippet": "static noinline_for_stack\nint relocate_data_extent(struct inode *inode, struct btrfs_key *extent_key,\n\t\t\t struct file_extent_cluster *cluster)\n{\n\tint ret;\n\n\tif (cluster->nr > 0 && extent_key->objectid != cluster->end + 1) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\n\tif (!cluster->nr)\n\t\tcluster->start = extent_key->objectid;\n\telse\n\t\tBUG_ON(cluster->nr >= MAX_EXTENTS);\n\tcluster->end = extent_key->objectid + extent_key->offset - 1;\n\tcluster->boundary[cluster->nr] = extent_key->objectid;\n\tcluster->nr++;\n\n\tif (cluster->nr >= MAX_EXTENTS) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define MAX_EXTENTS 128"
          ],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define MAX_EXTENTS 128\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint relocate_data_extent(struct inode *inode, struct btrfs_key *extent_key,\n\t\t\t struct file_extent_cluster *cluster)\n{\n\tint ret;\n\n\tif (cluster->nr > 0 && extent_key->objectid != cluster->end + 1) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\n\tif (!cluster->nr)\n\t\tcluster->start = extent_key->objectid;\n\telse\n\t\tBUG_ON(cluster->nr >= MAX_EXTENTS);\n\tcluster->end = extent_key->objectid + extent_key->offset - 1;\n\tcluster->boundary[cluster->nr] = extent_key->objectid;\n\tcluster->nr++;\n\n\tif (cluster->nr >= MAX_EXTENTS) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "relocate_tree_blocks",
          "args": [
            "trans",
            "rc",
            "&blocks"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_tree_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2948-3012",
          "snippet": "static noinline_for_stack\nint relocate_tree_blocks(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc, struct rb_root *blocks)\n{\n\tstruct backref_node *node;\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_blocks;\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready)\n\t\t\treadahead_tree_block(rc->extent_root, block->bytenr);\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready) {\n\t\t\terr = get_tree_block_key(rc, block);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_path;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\n\t\tnode = build_backref_tree(rc, &block->key,\n\t\t\t\t\t  block->level, block->bytenr);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = relocate_tree_block(trans, rc, node, &block->key,\n\t\t\t\t\t  path);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EAGAIN || rb_node == rb_first(blocks))\n\t\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\nout:\n\terr = finish_pending_nodes(trans, rc, path, err);\n\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_blocks:\n\tfree_block_list(blocks);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint relocate_tree_blocks(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc, struct rb_root *blocks)\n{\n\tstruct backref_node *node;\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_blocks;\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready)\n\t\t\treadahead_tree_block(rc->extent_root, block->bytenr);\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready) {\n\t\t\terr = get_tree_block_key(rc, block);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_path;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\n\t\tnode = build_backref_tree(rc, &block->key,\n\t\t\t\t\t  block->level, block->bytenr);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = relocate_tree_block(trans, rc, node, &block->key,\n\t\t\t\t\t  path);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EAGAIN || rb_node == rb_first(blocks))\n\t\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\nout:\n\terr = finish_pending_nodes(trans, rc, path, err);\n\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_blocks:\n\tfree_block_list(blocks);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&blocks"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_data_references",
          "args": [
            "rc",
            "&key",
            "path",
            "&blocks"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_tree_block",
          "args": [
            "rc",
            "&key",
            "path",
            "&blocks"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "__add_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3346-3405",
          "snippet": "static int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(rc->extent_root->fs_info,\n\t\t\t\t\tSKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (tree_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tBUG_ON(ret);\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(rc->extent_root->fs_info,\n\t\t\t\t\tSKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (tree_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tBUG_ON(ret);\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 0"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "rc->extent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ref_objectid_v0",
          "args": [
            "rc",
            "path",
            "&key",
            "&ref_owner",
            "&path_change"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "get_ref_objectid_v0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3230-3268",
          "snippet": "static int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "item_size !=\n\t\t\t       sizeof(struct btrfs_extent_item_v0)"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_extent_flags",
          "args": [
            "flags"
          ],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "check_extent_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3846-3858",
          "snippet": "static int check_extent_flags(u64 flags)\n{\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif (!(flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    !(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int check_extent_flags(u64 flags)\n{\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif (!(flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    !(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "path->nodes[0]",
            "ei"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "path->nodes[0]",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_extent",
          "args": [
            "trans",
            "rc",
            "path",
            "&key"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3745-3826",
          "snippet": "static noinline_for_stack\nint find_next_extent(struct btrfs_trans_handle *trans,\n\t\t     struct reloc_control *rc, struct btrfs_path *path,\n\t\t     struct btrfs_key *extent_key)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end, last;\n\tint ret;\n\n\tlast = rc->block_group->key.objectid + rc->block_group->key.offset;\n\twhile (1) {\n\t\tcond_resched();\n\t\tif (rc->search_start >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = rc->search_start;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = 0;\n\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path,\n\t\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\nnext:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.type != BTRFS_METADATA_ITEM_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.objectid + key.offset <= rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t\t    key.objectid + rc->extent_root->nodesize <=\n\t\t    rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = find_first_extent_bit(&rc->processed_blocks,\n\t\t\t\t\t    key.objectid, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\n\t\tif (ret == 0 && start <= key.objectid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\trc->search_start = end + 1;\n\t\t} else {\n\t\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY)\n\t\t\t\trc->search_start = key.objectid + key.offset;\n\t\t\telse\n\t\t\t\trc->search_start = key.objectid +\n\t\t\t\t\trc->extent_root->nodesize;\n\t\t\tmemcpy(extent_key, &key, sizeof(key));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint find_next_extent(struct btrfs_trans_handle *trans,\n\t\t     struct reloc_control *rc, struct btrfs_path *path,\n\t\t     struct btrfs_key *extent_key)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end, last;\n\tint ret;\n\n\tlast = rc->block_group->key.objectid + rc->block_group->key.offset;\n\twhile (1) {\n\t\tcond_resched();\n\t\tif (rc->search_start >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = rc->search_start;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = 0;\n\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path,\n\t\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\nnext:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.type != BTRFS_METADATA_ITEM_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.objectid + key.offset <= rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t\t    key.objectid + rc->extent_root->nodesize <=\n\t\t    rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = find_first_extent_bit(&rc->processed_blocks,\n\t\t\t\t\t    key.objectid, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\n\t\tif (ret == 0 && start <= key.objectid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\trc->search_start = end + 1;\n\t\t} else {\n\t\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY)\n\t\t\t\trc->search_start = key.objectid + key.offset;\n\t\t\telse\n\t\t\t\trc->search_start = key.objectid +\n\t\t\t\t\trc->extent_root->nodesize;\n\t\t\tmemcpy(extent_key, &key, sizeof(key));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_backref_cache",
          "args": [
            "trans",
            "&rc->backref_cache"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "update_backref_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "476-524",
          "snippet": "static int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "rc->extent_root",
            "0"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_refill",
          "args": [
            "rc->extent_root",
            "rc->block_rsv",
            "rc->block_rsv->size",
            "BTRFS_RESERVE_FLUSH_ALL"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4739-4767",
          "snippet": "int btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_relocate",
          "args": [
            "rc"
          ],
          "line": 3914
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_to_relocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3860-3894",
          "snippet": "static noinline_for_stack\nint prepare_to_relocate(struct reloc_control *rc)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\trc->block_rsv = btrfs_alloc_block_rsv(rc->extent_root,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_TEMP);\n\tif (!rc->block_rsv)\n\t\treturn -ENOMEM;\n\n\tmemset(&rc->cluster, 0, sizeof(rc->cluster));\n\trc->search_start = rc->block_group->key.objectid;\n\trc->extents_found = 0;\n\trc->nodes_relocated = 0;\n\trc->merging_rsv_size = 0;\n\trc->reserved_bytes = 0;\n\trc->block_rsv->size = rc->extent_root->nodesize *\n\t\t\t      RELOCATION_RESERVED_NODES;\n\n\trc->create_reloc_tree = 1;\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\t/*\n\t\t * extent tree is not a ref_cow tree and has no reloc_root to\n\t\t * cleanup.  And callers are responsible to free the above\n\t\t * block rsv.\n\t\t */\n\t\treturn PTR_ERR(trans);\n\t}\n\tbtrfs_commit_transaction(trans, rc->extent_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RELOCATION_RESERVED_NODES\t256"
          ],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define RELOCATION_RESERVED_NODES\t256\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prepare_to_relocate(struct reloc_control *rc)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\trc->block_rsv = btrfs_alloc_block_rsv(rc->extent_root,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_TEMP);\n\tif (!rc->block_rsv)\n\t\treturn -ENOMEM;\n\n\tmemset(&rc->cluster, 0, sizeof(rc->cluster));\n\trc->search_start = rc->block_group->key.objectid;\n\trc->extents_found = 0;\n\trc->nodes_relocated = 0;\n\trc->merging_rsv_size = 0;\n\trc->reserved_bytes = 0;\n\trc->block_rsv->size = rc->extent_root->nodesize *\n\t\t\t      RELOCATION_RESERVED_NODES;\n\n\trc->create_reloc_tree = 1;\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\t/*\n\t\t * extent tree is not a ref_cow tree and has no reloc_root to\n\t\t * cleanup.  And callers are responsible to free the above\n\t\t * block rsv.\n\t\t */\n\t\treturn PTR_ERR(trans);\n\t}\n\tbtrfs_commit_transaction(trans, rc->extent_root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n#define MOVE_DATA_EXTENTS\t0\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int relocate_block_group(struct reloc_control *rc)\n{\n\tstruct rb_root blocks = RB_ROOT;\n\tstruct btrfs_key key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu32 item_size;\n\tint ret;\n\tint err = 0;\n\tint progress = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\tret = prepare_to_relocate(rc);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto out_free;\n\t}\n\n\twhile (1) {\n\t\trc->reserved_bytes = 0;\n\t\tret = btrfs_block_rsv_refill(rc->extent_root,\n\t\t\t\t\trc->block_rsv, rc->block_rsv->size,\n\t\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\t\tprogress++;\n\t\ttrans = btrfs_start_transaction(rc->extent_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tbreak;\n\t\t}\nrestart:\n\t\tif (update_backref_cache(trans, &rc->backref_cache)) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = find_next_extent(trans, rc, path, &key);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t\tif (ret != 0)\n\t\t\tbreak;\n\n\t\trc->extents_found++;\n\n\t\tei = btrfs_item_ptr(path->nodes[0], path->slots[0],\n\t\t\t\t    struct btrfs_extent_item);\n\t\titem_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tflags = btrfs_extent_flags(path->nodes[0], ei);\n\t\t\tret = check_extent_flags(flags);\n\t\t\tBUG_ON(ret);\n\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tu64 ref_owner;\n\t\t\tint path_change = 0;\n\n\t\t\tBUG_ON(item_size !=\n\t\t\t       sizeof(struct btrfs_extent_item_v0));\n\t\t\tret = get_ref_objectid_v0(rc, path, &key, &ref_owner,\n\t\t\t\t\t\t  &path_change);\n\t\t\tif (ref_owner < BTRFS_FIRST_FREE_OBJECTID)\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\t\telse\n\t\t\t\tflags = BTRFS_EXTENT_FLAG_DATA;\n\n\t\t\tif (path_change) {\n\t\t\t\tbtrfs_release_path(path);\n\n\t\t\t\tpath->search_commit_root = 1;\n\t\t\t\tpath->skip_locking = 1;\n\t\t\t\tret = btrfs_search_slot(NULL, rc->extent_root,\n\t\t\t\t\t\t\t&key, path, 0, 0);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tBUG_ON(ret > 0);\n\t\t\t}\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tret = add_tree_block(rc, &key, path, &blocks);\n\t\t} else if (rc->stage == UPDATE_DATA_PTRS &&\n\t\t\t   (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\tret = add_data_references(rc, &key, path, &blocks);\n\t\t} else {\n\t\t\tbtrfs_release_path(path);\n\t\t\tret = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!RB_EMPTY_ROOT(&blocks)) {\n\t\t\tret = relocate_tree_blocks(trans, rc, &blocks);\n\t\t\tif (ret < 0) {\n\t\t\t\t/*\n\t\t\t\t * if we fail to relocate tree blocks, force to update\n\t\t\t\t * backref cache when committing transaction.\n\t\t\t\t */\n\t\t\t\trc->backref_cache.last_trans = trans->transid - 1;\n\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trc->extents_found--;\n\t\t\t\trc->search_start = key.objectid;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t\ttrans = NULL;\n\n\t\tif (rc->stage == MOVE_DATA_EXTENTS &&\n\t\t    (flags & BTRFS_EXTENT_FLAG_DATA)) {\n\t\t\trc->found_file_extent = 1;\n\t\t\tret = relocate_data_extent(rc->data_inode,\n\t\t\t\t\t\t   &key, &rc->cluster);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (trans && progress && err == -ENOSPC) {\n\t\tret = btrfs_force_chunk_alloc(trans, rc->extent_root,\n\t\t\t\t\t      rc->block_group->flags);\n\t\tif (ret == 0) {\n\t\t\terr = 0;\n\t\t\tprogress = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\tbtrfs_release_path(path);\n\tclear_extent_bits(&rc->processed_blocks, 0, (u64)-1, EXTENT_DIRTY,\n\t\t\t  GFP_NOFS);\n\n\tif (trans) {\n\t\tbtrfs_end_transaction_throttle(trans, rc->extent_root);\n\t\tbtrfs_btree_balance_dirty(rc->extent_root);\n\t}\n\n\tif (!err) {\n\t\tret = relocate_file_extent_cluster(rc->data_inode,\n\t\t\t\t\t\t   &rc->cluster);\n\t\tif (ret < 0)\n\t\t\terr = ret;\n\t}\n\n\trc->create_reloc_tree = 0;\n\tset_reloc_control(rc);\n\n\tbackref_cache_cleanup(&rc->backref_cache);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\terr = prepare_to_merge(rc, err);\n\n\tmerge_reloc_roots(rc);\n\n\trc->merge_reloc_tree = 0;\n\tunset_reloc_control(rc);\n\tbtrfs_block_rsv_release(rc->extent_root, rc->block_rsv, (u64)-1);\n\n\t/* get rid of pinned extents */\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tbtrfs_free_block_rsv(rc->extent_root, rc->block_rsv);\n\tbtrfs_free_path(path);\n\treturn err;\n}"
  },
  {
    "function_name": "prepare_to_relocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3860-3894",
    "snippet": "static noinline_for_stack\nint prepare_to_relocate(struct reloc_control *rc)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\trc->block_rsv = btrfs_alloc_block_rsv(rc->extent_root,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_TEMP);\n\tif (!rc->block_rsv)\n\t\treturn -ENOMEM;\n\n\tmemset(&rc->cluster, 0, sizeof(rc->cluster));\n\trc->search_start = rc->block_group->key.objectid;\n\trc->extents_found = 0;\n\trc->nodes_relocated = 0;\n\trc->merging_rsv_size = 0;\n\trc->reserved_bytes = 0;\n\trc->block_rsv->size = rc->extent_root->nodesize *\n\t\t\t      RELOCATION_RESERVED_NODES;\n\n\trc->create_reloc_tree = 1;\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\t/*\n\t\t * extent tree is not a ref_cow tree and has no reloc_root to\n\t\t * cleanup.  And callers are responsible to free the above\n\t\t * block rsv.\n\t\t */\n\t\treturn PTR_ERR(trans);\n\t}\n\tbtrfs_commit_transaction(trans, rc->extent_root);\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RELOCATION_RESERVED_NODES\t256"
    ],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 3892
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unset_reloc_control",
          "args": [
            "rc"
          ],
          "line": 3884
        },
        "resolved": true,
        "details": {
          "function_name": "unset_reloc_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3837-3844",
          "snippet": "static void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "rc->extent_root"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rc->cluster",
            "0",
            "sizeof(rc->cluster)"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_block_rsv",
          "args": [
            "rc->extent_root",
            "BTRFS_BLOCK_RSV_TEMP"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_block_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4678-4692",
          "snippet": "struct btrfs_block_rsv *btrfs_alloc_block_rsv(struct btrfs_root *root,\n\t\t\t\t\t      unsigned short type)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tblock_rsv = kmalloc(sizeof(*block_rsv), GFP_NOFS);\n\tif (!block_rsv)\n\t\treturn NULL;\n\n\tbtrfs_init_block_rsv(block_rsv, type);\n\tblock_rsv->space_info = __find_space_info(fs_info,\n\t\t\t\t\t\t  BTRFS_BLOCK_GROUP_METADATA);\n\treturn block_rsv;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_rsv *btrfs_alloc_block_rsv(struct btrfs_root *root,\n\t\t\t\t\t      unsigned short type)\n{\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tblock_rsv = kmalloc(sizeof(*block_rsv), GFP_NOFS);\n\tif (!block_rsv)\n\t\treturn NULL;\n\n\tbtrfs_init_block_rsv(block_rsv, type);\n\tblock_rsv->space_info = __find_space_info(fs_info,\n\t\t\t\t\t\t  BTRFS_BLOCK_GROUP_METADATA);\n\treturn block_rsv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define RELOCATION_RESERVED_NODES\t256\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prepare_to_relocate(struct reloc_control *rc)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\trc->block_rsv = btrfs_alloc_block_rsv(rc->extent_root,\n\t\t\t\t\t      BTRFS_BLOCK_RSV_TEMP);\n\tif (!rc->block_rsv)\n\t\treturn -ENOMEM;\n\n\tmemset(&rc->cluster, 0, sizeof(rc->cluster));\n\trc->search_start = rc->block_group->key.objectid;\n\trc->extents_found = 0;\n\trc->nodes_relocated = 0;\n\trc->merging_rsv_size = 0;\n\trc->reserved_bytes = 0;\n\trc->block_rsv->size = rc->extent_root->nodesize *\n\t\t\t      RELOCATION_RESERVED_NODES;\n\n\trc->create_reloc_tree = 1;\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\t/*\n\t\t * extent tree is not a ref_cow tree and has no reloc_root to\n\t\t * cleanup.  And callers are responsible to free the above\n\t\t * block rsv.\n\t\t */\n\t\treturn PTR_ERR(trans);\n\t}\n\tbtrfs_commit_transaction(trans, rc->extent_root);\n\treturn 0;\n}"
  },
  {
    "function_name": "check_extent_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3846-3858",
    "snippet": "static int check_extent_flags(u64 flags)\n{\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif (!(flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    !(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int check_extent_flags(u64 flags)\n{\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif (!(flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    !(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))\n\t\treturn 1;\n\tif ((flags & BTRFS_EXTENT_FLAG_DATA) &&\n\t    (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "unset_reloc_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3837-3844",
    "snippet": "static void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->reloc_mutex"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->reloc_mutex"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void unset_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = NULL;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}"
  },
  {
    "function_name": "set_reloc_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3828-3835",
    "snippet": "static void set_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = rc;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->reloc_mutex"
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->reloc_mutex"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void set_reloc_control(struct reloc_control *rc)\n{\n\tstruct btrfs_fs_info *fs_info = rc->extent_root->fs_info;\n\n\tmutex_lock(&fs_info->reloc_mutex);\n\tfs_info->reloc_ctl = rc;\n\tmutex_unlock(&fs_info->reloc_mutex);\n}"
  },
  {
    "function_name": "find_next_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3745-3826",
    "snippet": "static noinline_for_stack\nint find_next_extent(struct btrfs_trans_handle *trans,\n\t\t     struct reloc_control *rc, struct btrfs_path *path,\n\t\t     struct btrfs_key *extent_key)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end, last;\n\tint ret;\n\n\tlast = rc->block_group->key.objectid + rc->block_group->key.offset;\n\twhile (1) {\n\t\tcond_resched();\n\t\tif (rc->search_start >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = rc->search_start;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = 0;\n\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path,\n\t\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\nnext:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.type != BTRFS_METADATA_ITEM_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.objectid + key.offset <= rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t\t    key.objectid + rc->extent_root->nodesize <=\n\t\t    rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = find_first_extent_bit(&rc->processed_blocks,\n\t\t\t\t\t    key.objectid, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\n\t\tif (ret == 0 && start <= key.objectid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\trc->search_start = end + 1;\n\t\t} else {\n\t\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY)\n\t\t\t\trc->search_start = key.objectid + key.offset;\n\t\t\telse\n\t\t\t\trc->search_start = key.objectid +\n\t\t\t\t\trc->extent_root->nodesize;\n\t\t\tmemcpy(extent_key, &key, sizeof(key));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "extent_key",
            "&key",
            "sizeof(key)"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_extent_bit",
          "args": [
            "&rc->processed_blocks",
            "key.objectid",
            "&start",
            "&end",
            "EXTENT_DIRTY",
            "NULL"
          ],
          "line": 3807
        },
        "resolved": true,
        "details": {
          "function_name": "find_first_extent_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1477-1516",
          "snippet": "int find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint find_first_extent_bit(struct extent_io_tree *tree, u64 start,\n\t\t\t  u64 *start_ret, u64 *end_ret, unsigned bits,\n\t\t\t  struct extent_state **cached_state)\n{\n\tstruct extent_state *state;\n\tstruct rb_node *n;\n\tint ret = 1;\n\n\tspin_lock(&tree->lock);\n\tif (cached_state && *cached_state) {\n\t\tstate = *cached_state;\n\t\tif (state->end == start - 1 && extent_state_in_tree(state)) {\n\t\t\tn = rb_next(&state->rb_node);\n\t\t\twhile (n) {\n\t\t\t\tstate = rb_entry(n, struct extent_state,\n\t\t\t\t\t\t rb_node);\n\t\t\t\tif (state->state & bits)\n\t\t\t\t\tgoto got_it;\n\t\t\t\tn = rb_next(n);\n\t\t\t}\n\t\t\tfree_extent_state(*cached_state);\n\t\t\t*cached_state = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tfree_extent_state(*cached_state);\n\t\t*cached_state = NULL;\n\t}\n\n\tstate = find_first_extent_bit_state(tree, start, bits);\ngot_it:\n\tif (state) {\n\t\tcache_state_if_flags(state, cached_state, 0);\n\t\t*start_ret = state->start;\n\t\t*end_ret = state->end;\n\t\tret = 0;\n\t}\nout:\n\tspin_unlock(&tree->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 3782
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "rc->extent_root",
            "path"
          ],
          "line": 3776
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "rc->extent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint find_next_extent(struct btrfs_trans_handle *trans,\n\t\t     struct reloc_control *rc, struct btrfs_path *path,\n\t\t     struct btrfs_key *extent_key)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tu64 start, end, last;\n\tint ret;\n\n\tlast = rc->block_group->key.objectid + rc->block_group->key.offset;\n\twhile (1) {\n\t\tcond_resched();\n\t\tif (rc->search_start >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tkey.objectid = rc->search_start;\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = 0;\n\n\t\tpath->search_commit_root = 1;\n\t\tpath->skip_locking = 1;\n\t\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path,\n\t\t\t\t\t0, 0);\n\t\tif (ret < 0)\n\t\t\tbreak;\nnext:\n\t\tleaf = path->nodes[0];\n\t\tif (path->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret != 0)\n\t\t\t\tbreak;\n\t\t\tleaf = path->nodes[0];\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (key.objectid >= last) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.type != BTRFS_METADATA_ITEM_KEY) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t    key.objectid + key.offset <= rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t\t    key.objectid + rc->extent_root->nodesize <=\n\t\t    rc->search_start) {\n\t\t\tpath->slots[0]++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = find_first_extent_bit(&rc->processed_blocks,\n\t\t\t\t\t    key.objectid, &start, &end,\n\t\t\t\t\t    EXTENT_DIRTY, NULL);\n\n\t\tif (ret == 0 && start <= key.objectid) {\n\t\t\tbtrfs_release_path(path);\n\t\t\trc->search_start = end + 1;\n\t\t} else {\n\t\t\tif (key.type == BTRFS_EXTENT_ITEM_KEY)\n\t\t\t\trc->search_start = key.objectid + key.offset;\n\t\t\telse\n\t\t\t\trc->search_start = key.objectid +\n\t\t\t\t\trc->extent_root->nodesize;\n\t\t\tmemcpy(extent_key, &key, sizeof(key));\n\t\t\treturn 0;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_data_references",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3479-3641",
    "snippet": "static int find_data_references(struct reloc_control *rc,\n\t\t\t\tstruct btrfs_key *extent_key,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_extent_data_ref *ref,\n\t\t\t\tstruct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct btrfs_root *root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct rb_node *rb_node;\n\tstruct btrfs_key key;\n\tu64 ref_root;\n\tu64 ref_objectid;\n\tu64 ref_offset;\n\tu32 ref_count;\n\tu32 nritems;\n\tint err = 0;\n\tint added = 0;\n\tint counted;\n\tint ret;\n\n\tref_root = btrfs_extent_data_ref_root(leaf, ref);\n\tref_objectid = btrfs_extent_data_ref_objectid(leaf, ref);\n\tref_offset = btrfs_extent_data_ref_offset(leaf, ref);\n\tref_count = btrfs_extent_data_ref_count(leaf, ref);\n\n\t/*\n\t * This is an extent belonging to the free space cache, lets just delete\n\t * it and redo the search.\n\t */\n\tif (ref_root == BTRFS_ROOT_TREE_OBJECTID) {\n\t\tret = delete_block_group_cache(rc->extent_root->fs_info,\n\t\t\t\t\t       NULL, ref_objectid);\n\t\tif (ret != -ENOENT)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\troot = read_fs_root(rc->extent_root->fs_info, ref_root);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ref_objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tif (ref_offset > ((u64)-1 << 32))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = ref_offset;\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tnritems = btrfs_header_nritems(leaf);\n\t/*\n\t * the references in tree blocks that use full backrefs\n\t * are not counted in\n\t */\n\tif (block_use_full_backref(rc, leaf))\n\t\tcounted = 0;\n\telse\n\t\tcounted = 1;\n\trb_node = tree_search(blocks, leaf->start);\n\tif (rb_node) {\n\t\tif (counted)\n\t\t\tadded = 1;\n\t\telse\n\t\t\tpath->slots[0] = nritems;\n\t}\n\n\twhile (ref_count > 0) {\n\t\twhile (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (WARN_ON(ret > 0))\n\t\t\t\tgoto out;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tnritems = btrfs_header_nritems(leaf);\n\t\t\tadded = 0;\n\n\t\t\tif (block_use_full_backref(rc, leaf))\n\t\t\t\tcounted = 0;\n\t\t\telse\n\t\t\t\tcounted = 1;\n\t\t\trb_node = tree_search(blocks, leaf->start);\n\t\t\tif (rb_node) {\n\t\t\t\tif (counted)\n\t\t\t\t\tadded = 1;\n\t\t\t\telse\n\t\t\t\t\tpath->slots[0] = nritems;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (WARN_ON(key.objectid != ref_objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY))\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tgoto next;\n\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, fi) !=\n\t\t    extent_key->objectid)\n\t\t\tgoto next;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tif (key.offset != ref_offset)\n\t\t\tgoto next;\n\n\t\tif (counted)\n\t\t\tref_count--;\n\t\tif (added)\n\t\t\tgoto next;\n\n\t\tif (!tree_block_processed(leaf->start, rc)) {\n\t\t\tblock = kmalloc(sizeof(*block), GFP_NOFS);\n\t\t\tif (!block) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblock->bytenr = leaf->start;\n\t\t\tbtrfs_item_key_to_cpu(leaf, &block->key, 0);\n\t\t\tblock->level = 0;\n\t\t\tblock->key_ready = 1;\n\t\t\trb_node = tree_insert(blocks, block->bytenr,\n\t\t\t\t\t      &block->rb_node);\n\t\t\tif (rb_node)\n\t\t\t\tbackref_tree_panic(rb_node, -EEXIST,\n\t\t\t\t\t\t   block->bytenr);\n\t\t}\n\t\tif (counted)\n\t\t\tadded = 1;\n\t\telse\n\t\t\tpath->slots[0] = nritems;\nnext:\n\t\tpath->slots[0]++;\n\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "backref_tree_panic",
          "args": [
            "rb_node",
            "-EEXIST",
            "block->bytenr"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "backref_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "331-341",
          "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "blocks",
            "block->bytenr",
            "&block->rb_node"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&block->key",
            "0"
          ],
          "line": 3621
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*block)",
            "GFP_NOFS"
          ],
          "line": 3615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_block_processed",
          "args": [
            "leaf->start",
            "rc"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "tree_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2858-2866",
          "snippet": "static int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 3597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "key.objectid != ref_objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "blocks",
            "leaf->start"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_use_full_backref",
          "args": [
            "rc",
            "leaf"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "block_use_full_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3410-3430",
          "snippet": "static int block_use_full_backref(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *eb)\n{\n\tu64 flags;\n\tint ret;\n\n\tif (btrfs_header_flag(eb, BTRFS_HEADER_FLAG_RELOC) ||\n\t    btrfs_header_backref_rev(eb) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n\n\tret = btrfs_lookup_extent_info(NULL, rc->extent_root,\n\t\t\t\t       eb->start, btrfs_header_level(eb), 1,\n\t\t\t\t       NULL, &flags);\n\tBUG_ON(ret);\n\n\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int block_use_full_backref(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *eb)\n{\n\tu64 flags;\n\tint ret;\n\n\tif (btrfs_header_flag(eb, BTRFS_HEADER_FLAG_RELOC) ||\n\t    btrfs_header_backref_rev(eb) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n\n\tret = btrfs_lookup_extent_info(NULL, rc->extent_root,\n\t\t\t\t       eb->start, btrfs_header_level(eb), 1,\n\t\t\t\t       NULL, &flags);\n\tBUG_ON(ret);\n\n\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret > 0"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "rc->extent_root->fs_info",
            "ref_root"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delete_block_group_cache",
          "args": [
            "rc->extent_root->fs_info",
            "NULL",
            "ref_objectid"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "delete_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3432-3473",
          "snippet": "static int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_count",
          "args": [
            "leaf",
            "ref"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_offset",
          "args": [
            "leaf",
            "ref"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_objectid",
          "args": [
            "leaf",
            "ref"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_root",
          "args": [
            "leaf",
            "ref"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int find_data_references(struct reloc_control *rc,\n\t\t\t\tstruct btrfs_key *extent_key,\n\t\t\t\tstruct extent_buffer *leaf,\n\t\t\t\tstruct btrfs_extent_data_ref *ref,\n\t\t\t\tstruct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct btrfs_root *root;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct rb_node *rb_node;\n\tstruct btrfs_key key;\n\tu64 ref_root;\n\tu64 ref_objectid;\n\tu64 ref_offset;\n\tu32 ref_count;\n\tu32 nritems;\n\tint err = 0;\n\tint added = 0;\n\tint counted;\n\tint ret;\n\n\tref_root = btrfs_extent_data_ref_root(leaf, ref);\n\tref_objectid = btrfs_extent_data_ref_objectid(leaf, ref);\n\tref_offset = btrfs_extent_data_ref_offset(leaf, ref);\n\tref_count = btrfs_extent_data_ref_count(leaf, ref);\n\n\t/*\n\t * This is an extent belonging to the free space cache, lets just delete\n\t * it and redo the search.\n\t */\n\tif (ref_root == BTRFS_ROOT_TREE_OBJECTID) {\n\t\tret = delete_block_group_cache(rc->extent_root->fs_info,\n\t\t\t\t\t       NULL, ref_objectid);\n\t\tif (ret != -ENOENT)\n\t\t\treturn ret;\n\t\tret = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\troot = read_fs_root(rc->extent_root->fs_info, ref_root);\n\tif (IS_ERR(root)) {\n\t\terr = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\n\tkey.objectid = ref_objectid;\n\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\tif (ref_offset > ((u64)-1 << 32))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = ref_offset;\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0) {\n\t\terr = ret;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tnritems = btrfs_header_nritems(leaf);\n\t/*\n\t * the references in tree blocks that use full backrefs\n\t * are not counted in\n\t */\n\tif (block_use_full_backref(rc, leaf))\n\t\tcounted = 0;\n\telse\n\t\tcounted = 1;\n\trb_node = tree_search(blocks, leaf->start);\n\tif (rb_node) {\n\t\tif (counted)\n\t\t\tadded = 1;\n\t\telse\n\t\t\tpath->slots[0] = nritems;\n\t}\n\n\twhile (ref_count > 0) {\n\t\twhile (path->slots[0] >= nritems) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (WARN_ON(ret > 0))\n\t\t\t\tgoto out;\n\n\t\t\tleaf = path->nodes[0];\n\t\t\tnritems = btrfs_header_nritems(leaf);\n\t\t\tadded = 0;\n\n\t\t\tif (block_use_full_backref(rc, leaf))\n\t\t\t\tcounted = 0;\n\t\t\telse\n\t\t\t\tcounted = 1;\n\t\t\trb_node = tree_search(blocks, leaf->start);\n\t\t\tif (rb_node) {\n\t\t\t\tif (counted)\n\t\t\t\t\tadded = 1;\n\t\t\t\telse\n\t\t\t\t\tpath->slots[0] = nritems;\n\t\t\t}\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tif (WARN_ON(key.objectid != ref_objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY))\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tgoto next;\n\n\t\tif (btrfs_file_extent_disk_bytenr(leaf, fi) !=\n\t\t    extent_key->objectid)\n\t\t\tgoto next;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tif (key.offset != ref_offset)\n\t\t\tgoto next;\n\n\t\tif (counted)\n\t\t\tref_count--;\n\t\tif (added)\n\t\t\tgoto next;\n\n\t\tif (!tree_block_processed(leaf->start, rc)) {\n\t\t\tblock = kmalloc(sizeof(*block), GFP_NOFS);\n\t\t\tif (!block) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tblock->bytenr = leaf->start;\n\t\t\tbtrfs_item_key_to_cpu(leaf, &block->key, 0);\n\t\t\tblock->level = 0;\n\t\t\tblock->key_ready = 1;\n\t\t\trb_node = tree_insert(blocks, block->bytenr,\n\t\t\t\t\t      &block->rb_node);\n\t\t\tif (rb_node)\n\t\t\t\tbackref_tree_panic(rb_node, -EEXIST,\n\t\t\t\t\t\t   block->bytenr);\n\t\t}\n\t\tif (counted)\n\t\t\tadded = 1;\n\t\telse\n\t\t\tpath->slots[0] = nritems;\nnext:\n\t\tpath->slots[0]++;\n\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn err;\n}"
  },
  {
    "function_name": "delete_block_group_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3432-3473",
    "snippet": "static int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "root"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_truncate_free_space_cache",
          "args": [
            "root",
            "trans",
            "inode"
          ],
          "line": 3466
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_truncate_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "226-251",
          "snippet": "int btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_truncate_free_space_cache(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_trans_handle *trans,\n\t\t\t\t    struct inode *inode)\n{\n\tint ret = 0;\n\n\tbtrfs_i_size_write(inode, 0);\n\ttruncate_pagecache(inode, 0);\n\n\t/*\n\t * We don't need an orphan item because truncating the free space cache\n\t * will never be split across transactions.\n\t */\n\tret = btrfs_truncate_inode_items(trans, root, inode,\n\t\t\t\t\t 0, BTRFS_EXTENT_DATA_KEY);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret)\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 3462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "root"
          ],
          "line": 3460
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_trunc_cache_free_space",
          "args": [
            "root",
            "&fs_info->global_block_rsv"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_trunc_cache_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "207-224",
          "snippet": "int btrfs_check_trunc_cache_free_space(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_block_rsv *rsv)\n{\n\tu64 needed_bytes;\n\tint ret;\n\n\t/* 1 for slack space, 1 for updating the inode */\n\tneeded_bytes = btrfs_calc_trunc_metadata_size(root, 1) +\n\t\tbtrfs_calc_trans_metadata_size(root, 1);\n\n\tspin_lock(&rsv->lock);\n\tif (rsv->reserved < needed_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\tspin_unlock(&rsv->lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_check_trunc_cache_free_space(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_block_rsv *rsv)\n{\n\tu64 needed_bytes;\n\tint ret;\n\n\t/* 1 for slack space, 1 for updating the inode */\n\tneeded_bytes = btrfs_calc_trunc_metadata_size(root, 1) +\n\t\tbtrfs_calc_trans_metadata_size(root, 1);\n\n\tspin_lock(&rsv->lock);\n\tif (rsv->reserved < needed_bytes)\n\t\tret = -ENOSPC;\n\telse\n\t\tret = 0;\n\tspin_unlock(&rsv->lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 3449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 3448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "fs_info->sb",
            "&key",
            "root",
            "NULL"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int delete_block_group_cache(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct inode *inode, u64 ino)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tint ret = 0;\n\n\tif (inode)\n\t\tgoto truncate;\n\n\tkey.objectid = ino;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\n\tinode = btrfs_iget(fs_info->sb, &key, root, NULL);\n\tif (IS_ERR(inode) || is_bad_inode(inode)) {\n\t\tif (!IS_ERR(inode))\n\t\t\tiput(inode);\n\t\treturn -ENOENT;\n\t}\n\ntruncate:\n\tret = btrfs_check_trunc_cache_free_space(root,\n\t\t\t\t\t\t &fs_info->global_block_rsv);\n\tif (ret)\n\t\tgoto out;\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\n\tret = btrfs_truncate_free_space_cache(root, trans, inode);\n\n\tbtrfs_end_transaction(trans, root);\n\tbtrfs_btree_balance_dirty(root);\nout:\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "block_use_full_backref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3410-3430",
    "snippet": "static int block_use_full_backref(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *eb)\n{\n\tu64 flags;\n\tint ret;\n\n\tif (btrfs_header_flag(eb, BTRFS_HEADER_FLAG_RELOC) ||\n\t    btrfs_header_backref_rev(eb) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n\n\tret = btrfs_lookup_extent_info(NULL, rc->extent_root,\n\t\t\t\t       eb->start, btrfs_header_level(eb), 1,\n\t\t\t\t       NULL, &flags);\n\tBUG_ON(ret);\n\n\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_extent_info",
          "args": [
            "NULL",
            "rc->extent_root",
            "eb->start",
            "btrfs_header_level(eb)",
            "1",
            "NULL",
            "&flags"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_extent_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "743-871",
          "snippet": "int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 offset, int metadata, u64 *refs, u64 *flags)\n{\n\tstruct btrfs_delayed_ref_head *head;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tu64 num_refs;\n\tu64 extent_flags;\n\tint ret;\n\n\t/*\n\t * If we don't have skinny metadata, don't bother doing anything\n\t * different\n\t */\n\tif (metadata && !btrfs_fs_incompat(root->fs_info, SKINNY_METADATA)) {\n\t\toffset = root->nodesize;\n\t\tmetadata = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!trans) {\n\t\tpath->skip_locking = 1;\n\t\tpath->search_commit_root = 1;\n\t}\n\nsearch_again:\n\tkey.objectid = bytenr;\n\tkey.offset = offset;\n\tif (metadata)\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root->fs_info->extent_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (ret > 0 && metadata && key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.offset == root->nodesize)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_extent_item);\n\t\t\tnum_refs = btrfs_extent_refs(leaf, ei);\n\t\t\textent_flags = btrfs_extent_flags(leaf, ei);\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tstruct btrfs_extent_item_v0 *ei0;\n\t\t\tBUG_ON(item_size != sizeof(*ei0));\n\t\t\tei0 = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t     struct btrfs_extent_item_v0);\n\t\t\tnum_refs = btrfs_extent_refs_v0(leaf, ei0);\n\t\t\t/* FIXME: this isn't correct for data */\n\t\t\textent_flags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\t\tBUG_ON(num_refs == 0);\n\t} else {\n\t\tnum_refs = 0;\n\t\textent_flags = 0;\n\t\tret = 0;\n\t}\n\n\tif (!trans)\n\t\tgoto out;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\thead = btrfs_find_delayed_ref_head(trans, bytenr);\n\tif (head) {\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t/*\n\t\t\t * Mutex was contended, block until it's released and try\n\t\t\t * again\n\t\t\t */\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tgoto search_again;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\tif (head->extent_op && head->extent_op->update_flags)\n\t\t\textent_flags |= head->extent_op->flags_to_set;\n\t\telse\n\t\t\tBUG_ON(num_refs == 0);\n\n\t\tnum_refs += head->node.ref_mod;\n\t\tspin_unlock(&head->lock);\n\t\tmutex_unlock(&head->mutex);\n\t}\n\tspin_unlock(&delayed_refs->lock);\nout:\n\tWARN_ON(num_refs == 0);\n\tif (refs)\n\t\t*refs = num_refs;\n\tif (flags)\n\t\t*flags = extent_flags;\nout_free:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __run_delayed_extent_op(struct btrfs_delayed_extent_op *extent_op,\n\t\t\t\t    struct extent_buffer *leaf,\n\t\t\t\t    struct btrfs_extent_item *ei);",
            "static int alloc_reserved_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      u64 parent, u64 root_objectid,\n\t\t\t\t      u64 flags, u64 owner, u64 offset,\n\t\t\t\t      struct btrfs_key *ins, int ref_mod);",
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void __run_delayed_extent_op(struct btrfs_delayed_extent_op *extent_op,\n\t\t\t\t    struct extent_buffer *leaf,\n\t\t\t\t    struct btrfs_extent_item *ei);\nstatic int alloc_reserved_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      u64 parent, u64 root_objectid,\n\t\t\t\t      u64 flags, u64 owner, u64 offset,\n\t\t\t\t      struct btrfs_key *ins, int ref_mod);\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 offset, int metadata, u64 *refs, u64 *flags)\n{\n\tstruct btrfs_delayed_ref_head *head;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tu64 num_refs;\n\tu64 extent_flags;\n\tint ret;\n\n\t/*\n\t * If we don't have skinny metadata, don't bother doing anything\n\t * different\n\t */\n\tif (metadata && !btrfs_fs_incompat(root->fs_info, SKINNY_METADATA)) {\n\t\toffset = root->nodesize;\n\t\tmetadata = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!trans) {\n\t\tpath->skip_locking = 1;\n\t\tpath->search_commit_root = 1;\n\t}\n\nsearch_again:\n\tkey.objectid = bytenr;\n\tkey.offset = offset;\n\tif (metadata)\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root->fs_info->extent_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (ret > 0 && metadata && key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.offset == root->nodesize)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_extent_item);\n\t\t\tnum_refs = btrfs_extent_refs(leaf, ei);\n\t\t\textent_flags = btrfs_extent_flags(leaf, ei);\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tstruct btrfs_extent_item_v0 *ei0;\n\t\t\tBUG_ON(item_size != sizeof(*ei0));\n\t\t\tei0 = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t     struct btrfs_extent_item_v0);\n\t\t\tnum_refs = btrfs_extent_refs_v0(leaf, ei0);\n\t\t\t/* FIXME: this isn't correct for data */\n\t\t\textent_flags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\t\tBUG_ON(num_refs == 0);\n\t} else {\n\t\tnum_refs = 0;\n\t\textent_flags = 0;\n\t\tret = 0;\n\t}\n\n\tif (!trans)\n\t\tgoto out;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\thead = btrfs_find_delayed_ref_head(trans, bytenr);\n\tif (head) {\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t/*\n\t\t\t * Mutex was contended, block until it's released and try\n\t\t\t * again\n\t\t\t */\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tgoto search_again;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\tif (head->extent_op && head->extent_op->update_flags)\n\t\t\textent_flags |= head->extent_op->flags_to_set;\n\t\telse\n\t\t\tBUG_ON(num_refs == 0);\n\n\t\tnum_refs += head->node.ref_mod;\n\t\tspin_unlock(&head->lock);\n\t\tmutex_unlock(&head->mutex);\n\t}\n\tspin_unlock(&delayed_refs->lock);\nout:\n\tWARN_ON(num_refs == 0);\n\tif (refs)\n\t\t*refs = num_refs;\n\tif (flags)\n\t\t*flags = extent_flags;\nout_free:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 3421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "eb"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_flag",
          "args": [
            "eb",
            "BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2798-2801",
          "snippet": "static inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int block_use_full_backref(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *eb)\n{\n\tu64 flags;\n\tint ret;\n\n\tif (btrfs_header_flag(eb, BTRFS_HEADER_FLAG_RELOC) ||\n\t    btrfs_header_backref_rev(eb) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n\n\tret = btrfs_lookup_extent_info(NULL, rc->extent_root,\n\t\t\t\t       eb->start, btrfs_header_level(eb), 1,\n\t\t\t\t       NULL, &flags);\n\tBUG_ON(ret);\n\n\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)\n\t\tret = 1;\n\telse\n\t\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "__add_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3346-3405",
    "snippet": "static int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(rc->extent_root->fs_info,\n\t\t\t\t\tSKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (tree_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tBUG_ON(ret);\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_tree_block",
          "args": [
            "rc",
            "&key",
            "path",
            "blocks"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "__add_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3346-3405",
          "snippet": "static int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(rc->extent_root->fs_info,\n\t\t\t\t\tSKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (tree_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tBUG_ON(ret);\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "path->slots[0]"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "rc->extent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "blocks",
            "bytenr"
          ],
          "line": 3359
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_block_processed",
          "args": [
            "bytenr",
            "rc"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "tree_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2858-2866",
          "snippet": "static int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "rc->extent_root->fs_info",
            "SKINNY_METADATA"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int __add_tree_block(struct reloc_control *rc,\n\t\t\t    u64 bytenr, u32 blocksize,\n\t\t\t    struct rb_root *blocks)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\tbool skinny = btrfs_fs_incompat(rc->extent_root->fs_info,\n\t\t\t\t\tSKINNY_METADATA);\n\n\tif (tree_block_processed(bytenr, rc))\n\t\treturn 0;\n\n\tif (tree_search(blocks, bytenr))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = bytenr;\n\tif (skinny) {\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\t\tkey.offset = blocksize;\n\t}\n\n\tpath->search_commit_root = 1;\n\tpath->skip_locking = 1;\n\tret = btrfs_search_slot(NULL, rc->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0 && skinny) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    (key.type == BTRFS_METADATA_ITEM_KEY ||\n\t\t\t     (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t      key.offset == blocksize)))\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tskinny = false;\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tBUG_ON(ret);\n\n\tret = add_tree_block(rc, &key, path, blocks);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3275-3341",
    "snippet": "static int add_tree_block(struct reloc_control *rc,\n\t\t\t  struct btrfs_key *extent_key,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct rb_root *blocks)\n{\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_tree_block_info *bi;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tu32 item_size;\n\tint level = -1;\n\tu64 generation;\n\n\teb =  path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (extent_key->type == BTRFS_METADATA_ITEM_KEY ||\n\t    item_size >= sizeof(*ei) + sizeof(*bi)) {\n\t\tei = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t\tstruct btrfs_extent_item);\n\t\tif (extent_key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\t\tbi = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\tlevel = btrfs_tree_block_level(eb, bi);\n\t\t} else {\n\t\t\tlevel = (int)extent_key->offset;\n\t\t}\n\t\tgeneration = btrfs_extent_generation(eb, ei);\n\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\tu64 ref_owner;\n\t\tint ret;\n\n\t\tBUG_ON(item_size != sizeof(struct btrfs_extent_item_v0));\n\t\tret = get_ref_objectid_v0(rc, path, extent_key,\n\t\t\t\t\t  &ref_owner, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tBUG_ON(ref_owner >= BTRFS_MAX_LEVEL);\n\t\tlevel = (int)ref_owner;\n\t\t/* FIXME: get real generation */\n\t\tgeneration = 0;\n#else\n\t\tBUG();\n#endif\n\t}\n\n\tbtrfs_release_path(path);\n\n\tBUG_ON(level == -1);\n\n\tblock = kmalloc(sizeof(*block), GFP_NOFS);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tblock->bytenr = extent_key->objectid;\n\tblock->key.objectid = rc->extent_root->nodesize;\n\tblock->key.offset = generation;\n\tblock->level = level;\n\tblock->key_ready = 0;\n\n\trb_node = tree_insert(blocks, block->bytenr, &block->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, block->bytenr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backref_tree_panic",
          "args": [
            "rb_node",
            "-EEXIST",
            "block->bytenr"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "backref_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "331-341",
          "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "blocks",
            "block->bytenr",
            "&block->rb_node"
          ],
          "line": 3336
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*block)",
            "GFP_NOFS"
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == -1"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ref_owner >= BTRFS_MAX_LEVEL"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ref_objectid_v0",
          "args": [
            "rc",
            "path",
            "extent_key",
            "&ref_owner",
            "NULL"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "get_ref_objectid_v0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3230-3268",
          "snippet": "static int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "item_size != sizeof(struct btrfs_extent_item_v0)"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_generation",
          "args": [
            "eb",
            "ei"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_block_level",
          "args": [
            "eb",
            "bi"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "path->slots[0]"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int add_tree_block(struct reloc_control *rc,\n\t\t\t  struct btrfs_key *extent_key,\n\t\t\t  struct btrfs_path *path,\n\t\t\t  struct rb_root *blocks)\n{\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_tree_block_info *bi;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tu32 item_size;\n\tint level = -1;\n\tu64 generation;\n\n\teb =  path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\n\tif (extent_key->type == BTRFS_METADATA_ITEM_KEY ||\n\t    item_size >= sizeof(*ei) + sizeof(*bi)) {\n\t\tei = btrfs_item_ptr(eb, path->slots[0],\n\t\t\t\tstruct btrfs_extent_item);\n\t\tif (extent_key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\t\tbi = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\tlevel = btrfs_tree_block_level(eb, bi);\n\t\t} else {\n\t\t\tlevel = (int)extent_key->offset;\n\t\t}\n\t\tgeneration = btrfs_extent_generation(eb, ei);\n\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\tu64 ref_owner;\n\t\tint ret;\n\n\t\tBUG_ON(item_size != sizeof(struct btrfs_extent_item_v0));\n\t\tret = get_ref_objectid_v0(rc, path, extent_key,\n\t\t\t\t\t  &ref_owner, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tBUG_ON(ref_owner >= BTRFS_MAX_LEVEL);\n\t\tlevel = (int)ref_owner;\n\t\t/* FIXME: get real generation */\n\t\tgeneration = 0;\n#else\n\t\tBUG();\n#endif\n\t}\n\n\tbtrfs_release_path(path);\n\n\tBUG_ON(level == -1);\n\n\tblock = kmalloc(sizeof(*block), GFP_NOFS);\n\tif (!block)\n\t\treturn -ENOMEM;\n\n\tblock->bytenr = extent_key->objectid;\n\tblock->key.objectid = rc->extent_root->nodesize;\n\tblock->key.offset = generation;\n\tblock->level = level;\n\tblock->key_ready = 0;\n\n\trb_node = tree_insert(blocks, block->bytenr, &block->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, block->bytenr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_ref_objectid_v0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3230-3268",
    "snippet": "static int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_ref_objectid_v0",
          "args": [
            "leaf",
            "ref0"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_extent_ref_v0"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 3254
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 0"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "rc->extent_root",
            "path"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_ref_objectid_v0(struct reloc_control *rc,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *extent_key,\n\t\t\t       u64 *ref_objectid, int *path_change)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_extent_ref_v0 *ref0;\n\tint ret;\n\tint slot;\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\twhile (1) {\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(rc->extent_root, path);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tBUG_ON(ret > 0);\n\t\t\tleaf = path->nodes[0];\n\t\t\tslot = path->slots[0];\n\t\t\tif (path_change)\n\t\t\t\t*path_change = 1;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\t\tif (key.objectid != extent_key->objectid)\n\t\t\treturn -ENOENT;\n\n\t\tif (key.type != BTRFS_EXTENT_REF_V0_KEY) {\n\t\t\tslot++;\n\t\t\tcontinue;\n\t\t}\n\t\tref0 = btrfs_item_ptr(leaf, slot,\n\t\t\t\tstruct btrfs_extent_ref_v0);\n\t\t*ref_objectid = btrfs_ref_objectid_v0(leaf, ref0);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "relocate_data_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3199-3227",
    "snippet": "static noinline_for_stack\nint relocate_data_extent(struct inode *inode, struct btrfs_key *extent_key,\n\t\t\t struct file_extent_cluster *cluster)\n{\n\tint ret;\n\n\tif (cluster->nr > 0 && extent_key->objectid != cluster->end + 1) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\n\tif (!cluster->nr)\n\t\tcluster->start = extent_key->objectid;\n\telse\n\t\tBUG_ON(cluster->nr >= MAX_EXTENTS);\n\tcluster->end = extent_key->objectid + extent_key->offset - 1;\n\tcluster->boundary[cluster->nr] = extent_key->objectid;\n\tcluster->nr++;\n\n\tif (cluster->nr >= MAX_EXTENTS) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define MAX_EXTENTS 128"
    ],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "relocate_file_extent_cluster",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 3221
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_file_extent_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3093-3197",
          "snippet": "static int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cluster->nr >= MAX_EXTENTS"
          ],
          "line": 3215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define MAX_EXTENTS 128\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint relocate_data_extent(struct inode *inode, struct btrfs_key *extent_key,\n\t\t\t struct file_extent_cluster *cluster)\n{\n\tint ret;\n\n\tif (cluster->nr > 0 && extent_key->objectid != cluster->end + 1) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\n\tif (!cluster->nr)\n\t\tcluster->start = extent_key->objectid;\n\telse\n\t\tBUG_ON(cluster->nr >= MAX_EXTENTS);\n\tcluster->end = extent_key->objectid + extent_key->offset - 1;\n\tcluster->boundary[cluster->nr] = extent_key->objectid;\n\tcluster->nr++;\n\n\tif (cluster->nr >= MAX_EXTENTS) {\n\t\tret = relocate_file_extent_cluster(inode, cluster);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcluster->nr = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "relocate_file_extent_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3093-3197",
    "snippet": "static int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ra"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "nr != cluster->nr"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_throttle",
          "args": [
            "BTRFS_I(inode)->root"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "693-697",
          "snippet": "void btrfs_throttle(struct btrfs_root *root)\n{\n\tif (!atomic_read(&root->fs_info->open_ioctl_trans))\n\t\twait_current_trans(root);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid btrfs_throttle(struct btrfs_root *root)\n{\n\tif (!atomic_read(&root->fs_info->open_ioctl_trans))\n\t\twait_current_trans(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "inode->i_mapping"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end"
          ],
          "line": 3184
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9538-9541",
          "snippet": "static int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_set_page_dirty(struct page *page)\n{\n\treturn __set_page_dirty_nobuffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_extent_delalloc",
          "args": [
            "inode",
            "page_start",
            "page_end",
            "NULL"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_extent_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "1933-1939",
          "snippet": "int btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_set_extent_delalloc(struct inode *inode, u64 start, u64 end,\n\t\t\t      struct extent_state **cached_state)\n{\n\tWARN_ON((end & (PAGE_CACHE_SIZE - 1)) == 0);\n\treturn set_extent_delalloc(&BTRFS_I(inode)->io_tree, start, end,\n\t\t\t\t   cached_state, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_extent_bits",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end",
            "EXTENT_BOUNDARY",
            "GFP_NOFS"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1270-1275",
          "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "page"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "page_start",
            "page_end"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_release_metadata",
          "args": [
            "inode",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_release_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5272-5300",
          "snippet": "void btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_delalloc_release_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\n\tif (num_bytes)\n\t\tto_free = calc_csum_metadata_size(inode, num_bytes, 0);\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped > 0)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn;\n\n\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\tif (root->fs_info->quota_enabled) {\n\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\tdropped * root->nodesize);\n\t}\n\n\tbtrfs_block_rsv_release(root, &root->fs_info->delalloc_block_rsv,\n\t\t\t\tto_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_readpage",
          "args": [
            "NULL",
            "page"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_readpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8212-8217",
          "snippet": "int btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_readpage(struct file *file, struct page *page)\n{\n\tstruct extent_io_tree *tree;\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\treturn extent_read_full_page(tree, page, btrfs_get_extent, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_async_readahead",
          "args": [
            "inode->i_mapping",
            "ra",
            "NULL",
            "page",
            "index",
            "last_index + 1 - index"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReadahead",
          "args": [
            "page"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "mask"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "inode->i_mapping",
            "ra",
            "NULL",
            "index",
            "last_index + 1 - index"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "index"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_delalloc_reserve_metadata",
          "args": [
            "inode",
            "PAGE_CACHE_SIZE"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delalloc_reserve_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "5105-5261",
          "snippet": "int btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->delalloc_block_rsv;\n\tu64 to_reserve = 0;\n\tu64 csum_bytes;\n\tunsigned nr_extents = 0;\n\tint extra_reserve = 0;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_ALL;\n\tint ret = 0;\n\tbool delalloc_lock = true;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\t/* If we are a free space inode we need to not flush since we will be in\n\t * the middle of a transaction commit.  We also don't need the delalloc\n\t * mutex since we won't race with anybody.  We need this mostly to make\n\t * lockdep shut its filthy mouth.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\t\tdelalloc_lock = false;\n\t}\n\n\tif (flush != BTRFS_RESERVE_NO_FLUSH &&\n\t    btrfs_transaction_in_commit(root->fs_info))\n\t\tschedule_timeout(1);\n\n\tif (delalloc_lock)\n\t\tmutex_lock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tnr_extents = (unsigned)div64_u64(num_bytes +\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE);\n\tBTRFS_I(inode)->outstanding_extents += nr_extents;\n\tnr_extents = 0;\n\n\tif (BTRFS_I(inode)->outstanding_extents >\n\t    BTRFS_I(inode)->reserved_extents)\n\t\tnr_extents = BTRFS_I(inode)->outstanding_extents -\n\t\t\tBTRFS_I(inode)->reserved_extents;\n\n\t/*\n\t * Add an item to reserve for updating the inode when we complete the\n\t * delalloc io.\n\t */\n\tif (!test_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t      &BTRFS_I(inode)->runtime_flags)) {\n\t\tnr_extents++;\n\t\textra_reserve = 1;\n\t}\n\n\tto_reserve = btrfs_calc_trans_metadata_size(root, nr_extents);\n\tto_reserve += calc_csum_metadata_size(inode, num_bytes, 1);\n\tcsum_bytes = BTRFS_I(inode)->csum_bytes;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, num_bytes +\n\t\t\t\t\t   nr_extents * root->nodesize);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tret = reserve_metadata_bytes(root, block_rsv, to_reserve, flush);\n\tif (unlikely(ret)) {\n\t\tif (root->fs_info->quota_enabled)\n\t\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\t\tnr_extents * root->nodesize);\n\t\tgoto out_fail;\n\t}\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tif (extra_reserve) {\n\t\tset_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tnr_extents--;\n\t}\n\tBTRFS_I(inode)->reserved_extents += nr_extents;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tif (to_reserve)\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_reserve, 1);\n\tblock_rsv_add_bytes(block_rsv, to_reserve, 1);\n\n\treturn 0;\n\nout_fail:\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\t/*\n\t * If the inodes csum_bytes is the same as the original\n\t * csum_bytes then we know we haven't raced with any free()ers\n\t * so we can just reduce our inodes csum bytes and carry on.\n\t */\n\tif (BTRFS_I(inode)->csum_bytes == csum_bytes) {\n\t\tcalc_csum_metadata_size(inode, num_bytes, 0);\n\t} else {\n\t\tu64 orig_csum_bytes = BTRFS_I(inode)->csum_bytes;\n\t\tu64 bytes;\n\n\t\t/*\n\t\t * This is tricky, but first we need to figure out how much we\n\t\t * free'd from any free-ers that occured during this\n\t\t * reservation, so we reset ->csum_bytes to the csum_bytes\n\t\t * before we dropped our lock, and then call the free for the\n\t\t * number of bytes that were freed while we were trying our\n\t\t * reservation.\n\t\t */\n\t\tbytes = csum_bytes - BTRFS_I(inode)->csum_bytes;\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes;\n\t\tto_free = calc_csum_metadata_size(inode, bytes, 0);\n\n\n\t\t/*\n\t\t * Now we need to see how much we would have freed had we not\n\t\t * been making this reservation and our ->csum_bytes were not\n\t\t * artificially inflated.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes - num_bytes;\n\t\tbytes = csum_bytes - orig_csum_bytes;\n\t\tbytes = calc_csum_metadata_size(inode, bytes, 0);\n\n\t\t/*\n\t\t * Now reset ->csum_bytes to what it should be.  If bytes is\n\t\t * more than to_free then we would have free'd more space had we\n\t\t * not had an artificially high ->csum_bytes, so we need to free\n\t\t * the remainder.  If bytes is the same or less then we don't\n\t\t * need to do anything, the other free-ers did the correct\n\t\t * thing.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = orig_csum_bytes - num_bytes;\n\t\tif (bytes > to_free)\n\t\t\tto_free = bytes - to_free;\n\t\telse\n\t\t\tto_free = 0;\n\t}\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (to_free) {\n\t\tbtrfs_block_rsv_release(root, block_rsv, to_free);\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\t}\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int btrfs_update_reserved_bytes(struct btrfs_block_group_cache *cache,\n\t\t\t\t       u64 num_bytes, int reserve,\n\t\t\t\t       int delalloc);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_delalloc_reserve_metadata(struct inode *inode, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_block_rsv *block_rsv = &root->fs_info->delalloc_block_rsv;\n\tu64 to_reserve = 0;\n\tu64 csum_bytes;\n\tunsigned nr_extents = 0;\n\tint extra_reserve = 0;\n\tenum btrfs_reserve_flush_enum flush = BTRFS_RESERVE_FLUSH_ALL;\n\tint ret = 0;\n\tbool delalloc_lock = true;\n\tu64 to_free = 0;\n\tunsigned dropped;\n\n\t/* If we are a free space inode we need to not flush since we will be in\n\t * the middle of a transaction commit.  We also don't need the delalloc\n\t * mutex since we won't race with anybody.  We need this mostly to make\n\t * lockdep shut its filthy mouth.\n\t */\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tflush = BTRFS_RESERVE_NO_FLUSH;\n\t\tdelalloc_lock = false;\n\t}\n\n\tif (flush != BTRFS_RESERVE_NO_FLUSH &&\n\t    btrfs_transaction_in_commit(root->fs_info))\n\t\tschedule_timeout(1);\n\n\tif (delalloc_lock)\n\t\tmutex_lock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tnum_bytes = ALIGN(num_bytes, root->sectorsize);\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tnr_extents = (unsigned)div64_u64(num_bytes +\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE - 1,\n\t\t\t\t\t BTRFS_MAX_EXTENT_SIZE);\n\tBTRFS_I(inode)->outstanding_extents += nr_extents;\n\tnr_extents = 0;\n\n\tif (BTRFS_I(inode)->outstanding_extents >\n\t    BTRFS_I(inode)->reserved_extents)\n\t\tnr_extents = BTRFS_I(inode)->outstanding_extents -\n\t\t\tBTRFS_I(inode)->reserved_extents;\n\n\t/*\n\t * Add an item to reserve for updating the inode when we complete the\n\t * delalloc io.\n\t */\n\tif (!test_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t      &BTRFS_I(inode)->runtime_flags)) {\n\t\tnr_extents++;\n\t\textra_reserve = 1;\n\t}\n\n\tto_reserve = btrfs_calc_trans_metadata_size(root, nr_extents);\n\tto_reserve += calc_csum_metadata_size(inode, num_bytes, 1);\n\tcsum_bytes = BTRFS_I(inode)->csum_bytes;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (root->fs_info->quota_enabled) {\n\t\tret = btrfs_qgroup_reserve(root, num_bytes +\n\t\t\t\t\t   nr_extents * root->nodesize);\n\t\tif (ret)\n\t\t\tgoto out_fail;\n\t}\n\n\tret = reserve_metadata_bytes(root, block_rsv, to_reserve, flush);\n\tif (unlikely(ret)) {\n\t\tif (root->fs_info->quota_enabled)\n\t\t\tbtrfs_qgroup_free(root, num_bytes +\n\t\t\t\t\t\tnr_extents * root->nodesize);\n\t\tgoto out_fail;\n\t}\n\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tif (extra_reserve) {\n\t\tset_bit(BTRFS_INODE_DELALLOC_META_RESERVED,\n\t\t\t&BTRFS_I(inode)->runtime_flags);\n\t\tnr_extents--;\n\t}\n\tBTRFS_I(inode)->reserved_extents += nr_extents;\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\n\tif (to_reserve)\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_reserve, 1);\n\tblock_rsv_add_bytes(block_rsv, to_reserve, 1);\n\n\treturn 0;\n\nout_fail:\n\tspin_lock(&BTRFS_I(inode)->lock);\n\tdropped = drop_outstanding_extent(inode, num_bytes);\n\t/*\n\t * If the inodes csum_bytes is the same as the original\n\t * csum_bytes then we know we haven't raced with any free()ers\n\t * so we can just reduce our inodes csum bytes and carry on.\n\t */\n\tif (BTRFS_I(inode)->csum_bytes == csum_bytes) {\n\t\tcalc_csum_metadata_size(inode, num_bytes, 0);\n\t} else {\n\t\tu64 orig_csum_bytes = BTRFS_I(inode)->csum_bytes;\n\t\tu64 bytes;\n\n\t\t/*\n\t\t * This is tricky, but first we need to figure out how much we\n\t\t * free'd from any free-ers that occured during this\n\t\t * reservation, so we reset ->csum_bytes to the csum_bytes\n\t\t * before we dropped our lock, and then call the free for the\n\t\t * number of bytes that were freed while we were trying our\n\t\t * reservation.\n\t\t */\n\t\tbytes = csum_bytes - BTRFS_I(inode)->csum_bytes;\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes;\n\t\tto_free = calc_csum_metadata_size(inode, bytes, 0);\n\n\n\t\t/*\n\t\t * Now we need to see how much we would have freed had we not\n\t\t * been making this reservation and our ->csum_bytes were not\n\t\t * artificially inflated.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = csum_bytes - num_bytes;\n\t\tbytes = csum_bytes - orig_csum_bytes;\n\t\tbytes = calc_csum_metadata_size(inode, bytes, 0);\n\n\t\t/*\n\t\t * Now reset ->csum_bytes to what it should be.  If bytes is\n\t\t * more than to_free then we would have free'd more space had we\n\t\t * not had an artificially high ->csum_bytes, so we need to free\n\t\t * the remainder.  If bytes is the same or less then we don't\n\t\t * need to do anything, the other free-ers did the correct\n\t\t * thing.\n\t\t */\n\t\tBTRFS_I(inode)->csum_bytes = orig_csum_bytes - num_bytes;\n\t\tif (bytes > to_free)\n\t\t\tto_free = bytes - to_free;\n\t\telse\n\t\t\tto_free = 0;\n\t}\n\tspin_unlock(&BTRFS_I(inode)->lock);\n\tif (dropped)\n\t\tto_free += btrfs_calc_trans_metadata_size(root, dropped);\n\n\tif (to_free) {\n\t\tbtrfs_block_rsv_release(root, block_rsv, to_free);\n\t\ttrace_btrfs_space_reservation(root->fs_info, \"delalloc\",\n\t\t\t\t\t      btrfs_ino(inode), to_free, 0);\n\t}\n\tif (delalloc_lock)\n\t\tmutex_unlock(&BTRFS_I(inode)->delalloc_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_extent_mapping",
          "args": [
            "inode",
            "cluster->start - offset",
            "cluster->end - offset",
            "cluster->start"
          ],
          "line": 3120
        },
        "resolved": true,
        "details": {
          "function_name": "setup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3058-3091",
          "snippet": "static noinline_for_stack\nint setup_extent_mapping(struct inode *inode, u64 start, u64 end,\n\t\t\t u64 block_start)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\n\tem->start = start;\n\tem->len = end + 1 - start;\n\tem->block_len = em->len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\n\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 0);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, start, end, 0);\n\t}\n\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint setup_extent_mapping(struct inode *inode, u64 start, u64 end,\n\t\t\t u64 block_start)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\n\tem->start = start;\n\tem->len = end + 1 - start;\n\tem->block_len = em->len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\n\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 0);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, start, end, 0);\n\t}\n\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ra_state_init",
          "args": [
            "ra",
            "inode->i_mapping"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prealloc_file_extent_cluster",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 3114
        },
        "resolved": true,
        "details": {
          "function_name": "prealloc_file_extent_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "3014-3056",
          "snippet": "static noinline_for_stack\nint prealloc_file_extent_cluster(struct inode *inode,\n\t\t\t\t struct file_extent_cluster *cluster)\n{\n\tu64 alloc_hint = 0;\n\tu64 start;\n\tu64 end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tu64 num_bytes;\n\tint nr = 0;\n\tint ret = 0;\n\n\tBUG_ON(cluster->start != cluster->boundary[0]);\n\tmutex_lock(&inode->i_mutex);\n\n\tret = btrfs_check_data_free_space(inode, cluster->end +\n\t\t\t\t\t  1 - cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (nr < cluster->nr) {\n\t\tstart = cluster->boundary[nr] - offset;\n\t\tif (nr + 1 < cluster->nr)\n\t\t\tend = cluster->boundary[nr + 1] - 1 - offset;\n\t\telse\n\t\t\tend = cluster->end - offset;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tnum_bytes = end + 1 - start;\n\t\tret = btrfs_prealloc_file_range(inode, 0, start,\n\t\t\t\t\t\tnum_bytes, num_bytes,\n\t\t\t\t\t\tend + 1, &alloc_hint);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tnr++;\n\t}\n\tbtrfs_free_reserved_data_space(inode, cluster->end +\n\t\t\t\t       1 - cluster->start);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prealloc_file_extent_cluster(struct inode *inode,\n\t\t\t\t struct file_extent_cluster *cluster)\n{\n\tu64 alloc_hint = 0;\n\tu64 start;\n\tu64 end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tu64 num_bytes;\n\tint nr = 0;\n\tint ret = 0;\n\n\tBUG_ON(cluster->start != cluster->boundary[0]);\n\tmutex_lock(&inode->i_mutex);\n\n\tret = btrfs_check_data_free_space(inode, cluster->end +\n\t\t\t\t\t  1 - cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (nr < cluster->nr) {\n\t\tstart = cluster->boundary[nr] - offset;\n\t\tif (nr + 1 < cluster->nr)\n\t\t\tend = cluster->boundary[nr + 1] - 1 - offset;\n\t\telse\n\t\t\tend = cluster->end - offset;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tnum_bytes = end + 1 - start;\n\t\tret = btrfs_prealloc_file_range(inode, 0, start,\n\t\t\t\t\t\tnum_bytes, num_bytes,\n\t\t\t\t\t\tend + 1, &alloc_hint);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tnr++;\n\t}\n\tbtrfs_free_reserved_data_space(inode, cluster->end +\n\t\t\t\t       1 - cluster->start);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ra)",
            "GFP_NOFS"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_write_mask",
          "args": [
            "inode->i_mapping"
          ],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_write_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3292-3295",
          "snippet": "static inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline gfp_t btrfs_alloc_write_mask(struct address_space *mapping)\n{\n\treturn mapping_gfp_mask(mapping) & ~__GFP_FS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int relocate_file_extent_cluster(struct inode *inode,\n\t\t\t\t\tstruct file_extent_cluster *cluster)\n{\n\tu64 page_start;\n\tu64 page_end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tunsigned long index;\n\tunsigned long last_index;\n\tstruct page *page;\n\tstruct file_ra_state *ra;\n\tgfp_t mask = btrfs_alloc_write_mask(inode->i_mapping);\n\tint nr = 0;\n\tint ret = 0;\n\n\tif (!cluster->nr)\n\t\treturn 0;\n\n\tra = kzalloc(sizeof(*ra), GFP_NOFS);\n\tif (!ra)\n\t\treturn -ENOMEM;\n\n\tret = prealloc_file_extent_cluster(inode, cluster);\n\tif (ret)\n\t\tgoto out;\n\n\tfile_ra_state_init(ra, inode->i_mapping);\n\n\tret = setup_extent_mapping(inode, cluster->start - offset,\n\t\t\t\t   cluster->end - offset, cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\tindex = (cluster->start - offset) >> PAGE_CACHE_SHIFT;\n\tlast_index = (cluster->end - offset) >> PAGE_CACHE_SHIFT;\n\twhile (index <= last_index) {\n\t\tret = btrfs_delalloc_reserve_metadata(inode, PAGE_CACHE_SIZE);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (!page) {\n\t\t\tpage_cache_sync_readahead(inode->i_mapping,\n\t\t\t\t\t\t  ra, NULL, index,\n\t\t\t\t\t\t  last_index + 1 - index);\n\t\t\tpage = find_or_create_page(inode->i_mapping, index,\n\t\t\t\t\t\t   mask);\n\t\t\tif (!page) {\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (PageReadahead(page)) {\n\t\t\tpage_cache_async_readahead(inode->i_mapping,\n\t\t\t\t\t\t   ra, NULL, page, index,\n\t\t\t\t\t\t   last_index + 1 - index);\n\t\t}\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tbtrfs_readpage(NULL, page);\n\t\t\tlock_page(page);\n\t\t\tif (!PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tbtrfs_delalloc_release_metadata(inode,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tpage_start = page_offset(page);\n\t\tpage_end = page_start + PAGE_CACHE_SIZE - 1;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, page_start, page_end);\n\n\t\tset_page_extent_mapped(page);\n\n\t\tif (nr < cluster->nr &&\n\t\t    page_start + offset == cluster->boundary[nr]) {\n\t\t\tset_extent_bits(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\tpage_start, page_end,\n\t\t\t\t\tEXTENT_BOUNDARY, GFP_NOFS);\n\t\t\tnr++;\n\t\t}\n\n\t\tbtrfs_set_extent_delalloc(inode, page_start, page_end, NULL);\n\t\tset_page_dirty(page);\n\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t      page_start, page_end);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\tindex++;\n\t\tbalance_dirty_pages_ratelimited(inode->i_mapping);\n\t\tbtrfs_throttle(BTRFS_I(inode)->root);\n\t}\n\tWARN_ON(nr != cluster->nr);\nout:\n\tkfree(ra);\n\treturn ret;\n}"
  },
  {
    "function_name": "setup_extent_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3058-3091",
    "snippet": "static noinline_for_stack\nint setup_extent_mapping(struct inode *inode, u64 start, u64 end,\n\t\t\t u64 block_start)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\n\tem->start = start;\n\tem->len = end + 1 - start;\n\tem->block_len = em->len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\n\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 0);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, start, end, 0);\n\t}\n\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "start",
            "end",
            "0"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_extent_mapping",
          "args": [
            "em_tree",
            "em",
            "0"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "add_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "345-357",
          "snippet": "int add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nint add_extent_mapping(struct extent_map_tree *tree,\n\t\t       struct extent_map *em, int modified)\n{\n\tint ret = 0;\n\n\tret = tree_insert(&tree->map, em);\n\tif (ret)\n\t\tgoto out;\n\n\tsetup_extent_mapping(tree, em, modified);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "EXTENT_FLAG_PINNED",
            "&em->flags"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_extent_map",
          "args": [],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "48-61",
          "snippet": "struct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nstruct extent_map *alloc_extent_map(void)\n{\n\tstruct extent_map *em;\n\tem = kmem_cache_zalloc(extent_map_cache, GFP_NOFS);\n\tif (!em)\n\t\treturn NULL;\n\tRB_CLEAR_NODE(&em->rb_node);\n\tem->flags = 0;\n\tem->compress_type = BTRFS_COMPRESS_NONE;\n\tem->generation = 0;\n\tatomic_set(&em->refs, 1);\n\tINIT_LIST_HEAD(&em->list);\n\treturn em;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint setup_extent_mapping(struct inode *inode, u64 start, u64 end,\n\t\t\t u64 block_start)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tstruct extent_map *em;\n\tint ret = 0;\n\n\tem = alloc_extent_map();\n\tif (!em)\n\t\treturn -ENOMEM;\n\n\tem->start = start;\n\tem->len = end + 1 - start;\n\tem->block_len = em->len;\n\tem->block_start = block_start;\n\tem->bdev = root->fs_info->fs_devices->latest_bdev;\n\tset_bit(EXTENT_FLAG_PINNED, &em->flags);\n\n\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\twhile (1) {\n\t\twrite_lock(&em_tree->lock);\n\t\tret = add_extent_mapping(em_tree, em, 0);\n\t\twrite_unlock(&em_tree->lock);\n\t\tif (ret != -EEXIST) {\n\t\t\tfree_extent_map(em);\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_drop_extent_cache(inode, start, end, 0);\n\t}\n\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\treturn ret;\n}"
  },
  {
    "function_name": "prealloc_file_extent_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "3014-3056",
    "snippet": "static noinline_for_stack\nint prealloc_file_extent_cluster(struct inode *inode,\n\t\t\t\t struct file_extent_cluster *cluster)\n{\n\tu64 alloc_hint = 0;\n\tu64 start;\n\tu64 end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tu64 num_bytes;\n\tint nr = 0;\n\tint ret = 0;\n\n\tBUG_ON(cluster->start != cluster->boundary[0]);\n\tmutex_lock(&inode->i_mutex);\n\n\tret = btrfs_check_data_free_space(inode, cluster->end +\n\t\t\t\t\t  1 - cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (nr < cluster->nr) {\n\t\tstart = cluster->boundary[nr] - offset;\n\t\tif (nr + 1 < cluster->nr)\n\t\t\tend = cluster->boundary[nr + 1] - 1 - offset;\n\t\telse\n\t\t\tend = cluster->end - offset;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tnum_bytes = end + 1 - start;\n\t\tret = btrfs_prealloc_file_range(inode, 0, start,\n\t\t\t\t\t\tnum_bytes, num_bytes,\n\t\t\t\t\t\tend + 1, &alloc_hint);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tnr++;\n\t}\n\tbtrfs_free_reserved_data_space(inode, cluster->end +\n\t\t\t\t       1 - cluster->start);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_reserved_data_space",
          "args": [
            "inode",
            "cluster->end +\n\t\t\t\t       1 - cluster->start"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_reserved_data_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3750-3765",
          "snippet": "void btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_reserved_data_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_space_info *data_sinfo;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tdata_sinfo = root->fs_info->data_sinfo;\n\tspin_lock(&data_sinfo->lock);\n\tWARN_ON(data_sinfo->bytes_may_use < bytes);\n\tdata_sinfo->bytes_may_use -= bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 0);\n\tspin_unlock(&data_sinfo->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_prealloc_file_range",
          "args": [
            "inode",
            "0",
            "start",
            "num_bytes",
            "num_bytes",
            "end + 1",
            "&alloc_hint"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prealloc_file_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "9520-9527",
          "snippet": "int btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t      u64 start, u64 num_bytes, u64 min_size,\n\t\t\t      loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint,\n\t\t\t\t\t   NULL);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nint btrfs_prealloc_file_range(struct inode *inode, int mode,\n\t\t\t      u64 start, u64 num_bytes, u64 min_size,\n\t\t\t      loff_t actual_len, u64 *alloc_hint)\n{\n\treturn __btrfs_prealloc_file_range(inode, mode, start, num_bytes,\n\t\t\t\t\t   min_size, actual_len, alloc_hint,\n\t\t\t\t\t   NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 3041
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_check_data_free_space",
          "args": [
            "inode",
            "cluster->end +\n\t\t\t\t\t  1 - cluster->start"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_check_data_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3638-3745",
          "snippet": "int btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_block_group(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root, u64 bytenr,\n\t\t\t      u64 num_bytes, int alloc);\nstatic noinline struct;\n\nint btrfs_check_data_free_space(struct inode *inode, u64 bytes)\n{\n\tstruct btrfs_space_info *data_sinfo;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 used;\n\tint ret = 0, committed = 0, alloc_chunk = 1;\n\n\t/* make sure bytes are sectorsize aligned */\n\tbytes = ALIGN(bytes, root->sectorsize);\n\n\tif (btrfs_is_free_space_inode(inode)) {\n\t\tcommitted = 1;\n\t\tASSERT(current->journal_info);\n\t}\n\n\tdata_sinfo = fs_info->data_sinfo;\n\tif (!data_sinfo)\n\t\tgoto alloc;\n\nagain:\n\t/* make sure we have enough space to handle the data first */\n\tspin_lock(&data_sinfo->lock);\n\tused = data_sinfo->bytes_used + data_sinfo->bytes_reserved +\n\t\tdata_sinfo->bytes_pinned + data_sinfo->bytes_readonly +\n\t\tdata_sinfo->bytes_may_use;\n\n\tif (used + bytes > data_sinfo->total_bytes) {\n\t\tstruct btrfs_trans_handle *trans;\n\n\t\t/*\n\t\t * if we don't have enough free bytes in this space then we need\n\t\t * to alloc a new chunk.\n\t\t */\n\t\tif (!data_sinfo->full && alloc_chunk) {\n\t\t\tu64 alloc_target;\n\n\t\t\tdata_sinfo->force_alloc = CHUNK_ALLOC_FORCE;\n\t\t\tspin_unlock(&data_sinfo->lock);\nalloc:\n\t\t\talloc_target = btrfs_get_alloc_profile(root, 1);\n\t\t\t/*\n\t\t\t * It is ugly that we don't call nolock join\n\t\t\t * transaction for the free space inode case here.\n\t\t\t * But it is safe because we only do the data space\n\t\t\t * reservation for the free space cache in the\n\t\t\t * transaction context, the common join transaction\n\t\t\t * just increase the counter of the current transaction\n\t\t\t * handler, doesn't try to acquire the trans_lock of\n\t\t\t * the fs.\n\t\t\t */\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = do_chunk_alloc(trans, root->fs_info->extent_root,\n\t\t\t\t\t     alloc_target,\n\t\t\t\t\t     CHUNK_ALLOC_NO_FORCE);\n\t\t\tbtrfs_end_transaction(trans, root);\n\t\t\tif (ret < 0) {\n\t\t\t\tif (ret != -ENOSPC)\n\t\t\t\t\treturn ret;\n\t\t\t\telse\n\t\t\t\t\tgoto commit_trans;\n\t\t\t}\n\n\t\t\tif (!data_sinfo)\n\t\t\t\tdata_sinfo = fs_info->data_sinfo;\n\n\t\t\tgoto again;\n\t\t}\n\n\t\t/*\n\t\t * If we don't have enough pinned space to deal with this\n\t\t * allocation don't bother committing the transaction.\n\t\t */\n\t\tif (percpu_counter_compare(&data_sinfo->total_bytes_pinned,\n\t\t\t\t\t   bytes) < 0)\n\t\t\tcommitted = 1;\n\t\tspin_unlock(&data_sinfo->lock);\n\n\t\t/* commit the current transaction and try again */\ncommit_trans:\n\t\tif (!committed &&\n\t\t    !atomic_read(&root->fs_info->open_ioctl_trans)) {\n\t\t\tcommitted = 1;\n\n\t\t\ttrans = btrfs_join_transaction(root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\t\t\tret = btrfs_commit_transaction(trans, root);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tgoto again;\n\t\t}\n\n\t\ttrace_btrfs_space_reservation(root->fs_info,\n\t\t\t\t\t      \"space_info:enospc\",\n\t\t\t\t\t      data_sinfo->flags, bytes, 1);\n\t\treturn -ENOSPC;\n\t}\n\tdata_sinfo->bytes_may_use += bytes;\n\ttrace_btrfs_space_reservation(root->fs_info, \"space_info\",\n\t\t\t\t      data_sinfo->flags, bytes, 1);\n\tspin_unlock(&data_sinfo->lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cluster->start != cluster->boundary[0]"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prealloc_file_extent_cluster(struct inode *inode,\n\t\t\t\t struct file_extent_cluster *cluster)\n{\n\tu64 alloc_hint = 0;\n\tu64 start;\n\tu64 end;\n\tu64 offset = BTRFS_I(inode)->index_cnt;\n\tu64 num_bytes;\n\tint nr = 0;\n\tint ret = 0;\n\n\tBUG_ON(cluster->start != cluster->boundary[0]);\n\tmutex_lock(&inode->i_mutex);\n\n\tret = btrfs_check_data_free_space(inode, cluster->end +\n\t\t\t\t\t  1 - cluster->start);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (nr < cluster->nr) {\n\t\tstart = cluster->boundary[nr] - offset;\n\t\tif (nr + 1 < cluster->nr)\n\t\t\tend = cluster->boundary[nr + 1] - 1 - offset;\n\t\telse\n\t\t\tend = cluster->end - offset;\n\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tnum_bytes = end + 1 - start;\n\t\tret = btrfs_prealloc_file_range(inode, 0, start,\n\t\t\t\t\t\tnum_bytes, num_bytes,\n\t\t\t\t\t\tend + 1, &alloc_hint);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tnr++;\n\t}\n\tbtrfs_free_reserved_data_space(inode, cluster->end +\n\t\t\t\t       1 - cluster->start);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "relocate_tree_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2948-3012",
    "snippet": "static noinline_for_stack\nint relocate_tree_blocks(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc, struct rb_root *blocks)\n{\n\tstruct backref_node *node;\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_blocks;\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready)\n\t\t\treadahead_tree_block(rc->extent_root, block->bytenr);\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready) {\n\t\t\terr = get_tree_block_key(rc, block);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_path;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\n\t\tnode = build_backref_tree(rc, &block->key,\n\t\t\t\t\t  block->level, block->bytenr);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = relocate_tree_block(trans, rc, node, &block->key,\n\t\t\t\t\t  path);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EAGAIN || rb_node == rb_first(blocks))\n\t\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\nout:\n\terr = finish_pending_nodes(trans, rc, path, err);\n\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_blocks:\n\tfree_block_list(blocks);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_block_list",
          "args": [
            "blocks"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "free_block_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2432-2441",
          "snippet": "static void free_block_list(struct rb_root *blocks)\n{\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\twhile ((rb_node = rb_first(blocks))) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\trb_erase(rb_node, blocks);\n\t\tkfree(block);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void free_block_list(struct rb_root *blocks)\n{\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\twhile ((rb_node = rb_first(blocks))) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\trb_erase(rb_node, blocks);\n\t\tkfree(block);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_pending_nodes",
          "args": [
            "trans",
            "rc",
            "path",
            "err"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "finish_pending_nodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2779-2805",
          "snippet": "static int finish_pending_nodes(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_path *path, int err)\n{\n\tLIST_HEAD(list);\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node;\n\tint level;\n\tint ret;\n\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\twhile (!list_empty(&cache->pending[level])) {\n\t\t\tnode = list_entry(cache->pending[level].next,\n\t\t\t\t\t  struct backref_node, list);\n\t\t\tlist_move_tail(&node->list, &list);\n\t\t\tBUG_ON(!node->pending);\n\n\t\t\tif (!err) {\n\t\t\t\tret = link_to_upper(trans, rc, node, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tlist_splice_init(&list, &cache->pending[level]);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int finish_pending_nodes(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_path *path, int err)\n{\n\tLIST_HEAD(list);\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node;\n\tint level;\n\tint ret;\n\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\twhile (!list_empty(&cache->pending[level])) {\n\t\t\tnode = list_entry(cache->pending[level].next,\n\t\t\t\t\t  struct backref_node, list);\n\t\t\tlist_move_tail(&node->list, &list);\n\t\t\tBUG_ON(!node->pending);\n\n\t\t\tif (!err) {\n\t\t\t\tret = link_to_upper(trans, rc, node, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tlist_splice_init(&list, &cache->pending[level]);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "blocks"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relocate_tree_block",
          "args": [
            "trans",
            "rc",
            "node",
            "&block->key",
            "path"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "relocate_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2893-2943",
          "snippet": "static int relocate_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct backref_node *node,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct btrfs_root *root;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\tBUG_ON(node->processed);\n\troot = select_one_root(trans, node);\n\tif (root == ERR_PTR(-ENOENT)) {\n\t\tupdate_processed_blocks(rc, node);\n\t\tgoto out;\n\t}\n\n\tif (!root || test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = reserve_metadata_space(trans, rc, node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (root) {\n\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\t\tBUG_ON(node->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&node->list));\n\t\t\tbtrfs_record_root_in_trans(trans, root);\n\t\t\troot = root->reloc_root;\n\t\t\tnode->new_bytenr = root->node->start;\n\t\t\tnode->root = root;\n\t\t\tlist_add_tail(&node->list, &rc->backref_cache.changed);\n\t\t} else {\n\t\t\tpath->lowest_level = node->level;\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tupdate_processed_blocks(rc, node);\n\t} else {\n\t\tret = do_relocation(trans, rc, node, key, path, 1);\n\t}\nout:\n\tif (ret || node->level == 0 || node->cowonly)\n\t\tremove_backref_node(&rc->backref_cache, node);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int relocate_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct backref_node *node,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct btrfs_root *root;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\tBUG_ON(node->processed);\n\troot = select_one_root(trans, node);\n\tif (root == ERR_PTR(-ENOENT)) {\n\t\tupdate_processed_blocks(rc, node);\n\t\tgoto out;\n\t}\n\n\tif (!root || test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = reserve_metadata_space(trans, rc, node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (root) {\n\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\t\tBUG_ON(node->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&node->list));\n\t\t\tbtrfs_record_root_in_trans(trans, root);\n\t\t\troot = root->reloc_root;\n\t\t\tnode->new_bytenr = root->node->start;\n\t\t\tnode->root = root;\n\t\t\tlist_add_tail(&node->list, &rc->backref_cache.changed);\n\t\t} else {\n\t\t\tpath->lowest_level = node->level;\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tupdate_processed_blocks(rc, node);\n\t} else {\n\t\tret = do_relocation(trans, rc, node, key, path, 1);\n\t}\nout:\n\tif (ret || node->level == 0 || node->cowonly)\n\t\tremove_backref_node(&rc->backref_cache, node);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "node"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "node"
          ],
          "line": 2990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_backref_tree",
          "args": [
            "rc",
            "&block->key",
            "block->level",
            "block->bytenr"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structtree_block",
            "rb_node"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "blocks"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tree_block_key",
          "args": [
            "rc",
            "block"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "get_tree_block_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2868-2888",
          "snippet": "static int get_tree_block_key(struct reloc_control *rc,\n\t\t\t      struct tree_block *block)\n{\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(block->key_ready);\n\teb = read_tree_block(rc->extent_root, block->bytenr,\n\t\t\t     block->key.offset);\n\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn -EIO;\n\t}\n\tWARN_ON(btrfs_header_level(eb) != block->level);\n\tif (block->level == 0)\n\t\tbtrfs_item_key_to_cpu(eb, &block->key, 0);\n\telse\n\t\tbtrfs_node_key_to_cpu(eb, &block->key, 0);\n\tfree_extent_buffer(eb);\n\tblock->key_ready = 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_tree_block_key(struct reloc_control *rc,\n\t\t\t      struct tree_block *block)\n{\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(block->key_ready);\n\teb = read_tree_block(rc->extent_root, block->bytenr,\n\t\t\t     block->key.offset);\n\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn -EIO;\n\t}\n\tWARN_ON(btrfs_header_level(eb) != block->level);\n\tif (block->level == 0)\n\t\tbtrfs_item_key_to_cpu(eb, &block->key, 0);\n\telse\n\t\tbtrfs_node_key_to_cpu(eb, &block->key, 0);\n\tfree_extent_buffer(eb);\n\tblock->key_ready = 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structtree_block",
            "rb_node"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "blocks"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readahead_tree_block",
          "args": [
            "rc->extent_root",
            "block->bytenr"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "readahead_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1077-1088",
          "snippet": "void readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structtree_block",
            "rb_node"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "blocks"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint relocate_tree_blocks(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc, struct rb_root *blocks)\n{\n\tstruct backref_node *node;\n\tstruct btrfs_path *path;\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out_free_blocks;\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready)\n\t\t\treadahead_tree_block(rc->extent_root, block->bytenr);\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\tif (!block->key_ready) {\n\t\t\terr = get_tree_block_key(rc, block);\n\t\t\tif (err)\n\t\t\t\tgoto out_free_path;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\n\n\trb_node = rb_first(blocks);\n\twhile (rb_node) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\n\t\tnode = build_backref_tree(rc, &block->key,\n\t\t\t\t\t  block->level, block->bytenr);\n\t\tif (IS_ERR(node)) {\n\t\t\terr = PTR_ERR(node);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = relocate_tree_block(trans, rc, node, &block->key,\n\t\t\t\t\t  path);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EAGAIN || rb_node == rb_first(blocks))\n\t\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\trb_node = rb_next(rb_node);\n\t}\nout:\n\terr = finish_pending_nodes(trans, rc, path, err);\n\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_blocks:\n\tfree_block_list(blocks);\n\treturn err;\n}"
  },
  {
    "function_name": "relocate_tree_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2893-2943",
    "snippet": "static int relocate_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct backref_node *node,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct btrfs_root *root;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\tBUG_ON(node->processed);\n\troot = select_one_root(trans, node);\n\tif (root == ERR_PTR(-ENOENT)) {\n\t\tupdate_processed_blocks(rc, node);\n\t\tgoto out;\n\t}\n\n\tif (!root || test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = reserve_metadata_space(trans, rc, node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (root) {\n\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\t\tBUG_ON(node->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&node->list));\n\t\t\tbtrfs_record_root_in_trans(trans, root);\n\t\t\troot = root->reloc_root;\n\t\t\tnode->new_bytenr = root->node->start;\n\t\t\tnode->root = root;\n\t\t\tlist_add_tail(&node->list, &rc->backref_cache.changed);\n\t\t} else {\n\t\t\tpath->lowest_level = node->level;\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tupdate_processed_blocks(rc, node);\n\t} else {\n\t\tret = do_relocation(trans, rc, node, key, path, 1);\n\t}\nout:\n\tif (ret || node->level == 0 || node->cowonly)\n\t\tremove_backref_node(&rc->backref_cache, node);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_backref_node",
          "args": [
            "&rc->backref_cache",
            "node"
          ],
          "line": 2941
        },
        "resolved": true,
        "details": {
          "function_name": "remove_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "424-460",
          "snippet": "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_relocation",
          "args": [
            "trans",
            "rc",
            "node",
            "key",
            "path",
            "1"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "do_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2635-2766",
          "snippet": "static int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_processed_blocks",
          "args": [
            "rc",
            "node"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "update_processed_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2830-2856",
          "snippet": "static void update_processed_blocks(struct reloc_control *rc,\n\t\t\t\t    struct backref_node *node)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed)\n\t\t\t\tbreak;\n\n\t\t\t__mark_block_processed(rc, next);\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void update_processed_blocks(struct reloc_control *rc,\n\t\t\t\t    struct backref_node *node)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed)\n\t\t\t\tbreak;\n\n\t\t\t__mark_block_processed(rc, next);\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "key",
            "path",
            "0",
            "1"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&node->list",
            "&rc->backref_cache.changed"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&node->list)"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->list"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->new_bytenr"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_metadata_space",
          "args": [
            "trans",
            "rc",
            "node"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_metadata_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2591-2626",
          "snippet": "static int reserve_metadata_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct reloc_control *rc,\n\t\t\t\t  struct backref_node *node)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tu64 num_bytes;\n\tint ret;\n\tu64 tmp;\n\n\tnum_bytes = calcu_metadata_size(rc, node, 1) * 2;\n\n\ttrans->block_rsv = rc->block_rsv;\n\trc->reserved_bytes += num_bytes;\n\tret = btrfs_block_rsv_refill(root, rc->block_rsv, num_bytes,\n\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\tif (ret) {\n\t\tif (ret == -EAGAIN) {\n\t\t\ttmp = rc->extent_root->nodesize *\n\t\t\t\tRELOCATION_RESERVED_NODES;\n\t\t\twhile (tmp <= rc->reserved_bytes)\n\t\t\t\ttmp <<= 1;\n\t\t\t/*\n\t\t\t * only one thread can access block_rsv at this point,\n\t\t\t * so we don't need hold lock to protect block_rsv.\n\t\t\t * we expand more reservation size here to allow enough\n\t\t\t * space for relocation and we will return eailer in\n\t\t\t * enospc case.\n\t\t\t */\n\t\t\trc->block_rsv->size = tmp + rc->extent_root->nodesize *\n\t\t\t\t\t      RELOCATION_RESERVED_NODES;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RELOCATION_RESERVED_NODES\t256"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define RELOCATION_RESERVED_NODES\t256\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int reserve_metadata_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct reloc_control *rc,\n\t\t\t\t  struct backref_node *node)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tu64 num_bytes;\n\tint ret;\n\tu64 tmp;\n\n\tnum_bytes = calcu_metadata_size(rc, node, 1) * 2;\n\n\ttrans->block_rsv = rc->block_rsv;\n\trc->reserved_bytes += num_bytes;\n\tret = btrfs_block_rsv_refill(root, rc->block_rsv, num_bytes,\n\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\tif (ret) {\n\t\tif (ret == -EAGAIN) {\n\t\t\ttmp = rc->extent_root->nodesize *\n\t\t\t\tRELOCATION_RESERVED_NODES;\n\t\t\twhile (tmp <= rc->reserved_bytes)\n\t\t\t\ttmp <<= 1;\n\t\t\t/*\n\t\t\t * only one thread can access block_rsv at this point,\n\t\t\t * so we don't need hold lock to protect block_rsv.\n\t\t\t * we expand more reservation size here to allow enough\n\t\t\t * space for relocation and we will return eailer in\n\t\t\t * enospc case.\n\t\t\t */\n\t\t\trc->block_rsv->size = tmp + rc->extent_root->nodesize *\n\t\t\t\t\t      RELOCATION_RESERVED_NODES;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_one_root",
          "args": [
            "trans",
            "node"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "select_one_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2522-2556",
          "snippet": "btrfs_root *select_one_root(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct backref_node *node)\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\n\t\t/* no other choice for non-references counted tree */\n\t\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\treturn root;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tfs_root = root;\n\n\t\tif (next != node)\n\t\t\treturn NULL;\n\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\n\tif (!fs_root)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn fs_root;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nbtrfs_root *select_one_root(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct backref_node *node)\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\n\t\t/* no other choice for non-references counted tree */\n\t\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\treturn root;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tfs_root = root;\n\n\t\tif (next != node)\n\t\t\treturn NULL;\n\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\n\tif (!fs_root)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn fs_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->processed"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int relocate_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct backref_node *node,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct btrfs_root *root;\n\tint ret = 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\tBUG_ON(node->processed);\n\troot = select_one_root(trans, node);\n\tif (root == ERR_PTR(-ENOENT)) {\n\t\tupdate_processed_blocks(rc, node);\n\t\tgoto out;\n\t}\n\n\tif (!root || test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = reserve_metadata_space(trans, rc, node);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (root) {\n\t\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\t\tBUG_ON(node->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&node->list));\n\t\t\tbtrfs_record_root_in_trans(trans, root);\n\t\t\troot = root->reloc_root;\n\t\t\tnode->new_bytenr = root->node->start;\n\t\t\tnode->root = root;\n\t\t\tlist_add_tail(&node->list, &rc->backref_cache.changed);\n\t\t} else {\n\t\t\tpath->lowest_level = node->level;\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tbtrfs_release_path(path);\n\t\t\tif (ret > 0)\n\t\t\t\tret = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\tupdate_processed_blocks(rc, node);\n\t} else {\n\t\tret = do_relocation(trans, rc, node, key, path, 1);\n\t}\nout:\n\tif (ret || node->level == 0 || node->cowonly)\n\t\tremove_backref_node(&rc->backref_cache, node);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_tree_block_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2868-2888",
    "snippet": "static int get_tree_block_key(struct reloc_control *rc,\n\t\t\t      struct tree_block *block)\n{\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(block->key_ready);\n\teb = read_tree_block(rc->extent_root, block->bytenr,\n\t\t\t     block->key.offset);\n\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn -EIO;\n\t}\n\tWARN_ON(btrfs_header_level(eb) != block->level);\n\tif (block->level == 0)\n\t\tbtrfs_item_key_to_cpu(eb, &block->key, 0);\n\telse\n\t\tbtrfs_node_key_to_cpu(eb, &block->key, 0);\n\tfree_extent_buffer(eb);\n\tblock->key_ready = 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "eb",
            "&block->key",
            "0"
          ],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&block->key",
            "0"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_level(eb) != block->level"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "rc->extent_root",
            "block->bytenr",
            "block->key.offset"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "block->key_ready"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_tree_block_key(struct reloc_control *rc,\n\t\t\t      struct tree_block *block)\n{\n\tstruct extent_buffer *eb;\n\n\tBUG_ON(block->key_ready);\n\teb = read_tree_block(rc->extent_root, block->bytenr,\n\t\t\t     block->key.offset);\n\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\treturn -EIO;\n\t}\n\tWARN_ON(btrfs_header_level(eb) != block->level);\n\tif (block->level == 0)\n\t\tbtrfs_item_key_to_cpu(eb, &block->key, 0);\n\telse\n\t\tbtrfs_node_key_to_cpu(eb, &block->key, 0);\n\tfree_extent_buffer(eb);\n\tblock->key_ready = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_block_processed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2858-2866",
    "snippet": "static int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_range_bit",
          "args": [
            "&rc->processed_blocks",
            "bytenr",
            "bytenr + blocksize - 1",
            "EXTENT_DIRTY",
            "1",
            "NULL"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "test_range_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1931-1979",
          "snippet": "int test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint test_range_bit(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t   unsigned bits, int filled, struct extent_state *cached)\n{\n\tstruct extent_state *state = NULL;\n\tstruct rb_node *node;\n\tint bitset = 0;\n\n\tspin_lock(&tree->lock);\n\tif (cached && extent_state_in_tree(cached) && cached->start <= start &&\n\t    cached->end > start)\n\t\tnode = &cached->rb_node;\n\telse\n\t\tnode = tree_search(tree, start);\n\twhile (node && start <= end) {\n\t\tstate = rb_entry(node, struct extent_state, rb_node);\n\n\t\tif (filled && state->start > start) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->start > end)\n\t\t\tbreak;\n\n\t\tif (state->state & bits) {\n\t\t\tbitset = 1;\n\t\t\tif (!filled)\n\t\t\t\tbreak;\n\t\t} else if (filled) {\n\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (state->end == (u64)-1)\n\t\t\tbreak;\n\n\t\tstart = state->end + 1;\n\t\tif (start > end)\n\t\t\tbreak;\n\t\tnode = rb_next(node);\n\t\tif (!node) {\n\t\t\tif (filled)\n\t\t\t\tbitset = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&tree->lock);\n\treturn bitset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int tree_block_processed(u64 bytenr, struct reloc_control *rc)\n{\n\tu32 blocksize = rc->extent_root->nodesize;\n\n\tif (test_range_bit(&rc->processed_blocks, bytenr,\n\t\t\t   bytenr + blocksize - 1, EXTENT_DIRTY, 1, NULL))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "update_processed_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2830-2856",
    "snippet": "static void update_processed_blocks(struct reloc_control *rc,\n\t\t\t\t    struct backref_node *node)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed)\n\t\t\t\tbreak;\n\n\t\t\t__mark_block_processed(rc, next);\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_down_backref",
          "args": [
            "edges",
            "&index"
          ],
          "line": 2854
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "367-389",
          "snippet": "static struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next->upper.next",
            "structbackref_edge",
            "list[LOWER]"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&next->upper"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_block_processed",
          "args": [
            "rc",
            "next"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2814-2824",
          "snippet": "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void update_processed_blocks(struct reloc_control *rc,\n\t\t\t\t    struct backref_node *node)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed)\n\t\t\t\tbreak;\n\n\t\t\t__mark_block_processed(rc, next);\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n}"
  },
  {
    "function_name": "__mark_block_processed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2814-2824",
    "snippet": "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_block_processed",
          "args": [
            "rc",
            "node->bytenr",
            "blocksize"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "mark_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2807-2812",
          "snippet": "static void mark_block_processed(struct reloc_control *rc,\n\t\t\t\t u64 bytenr, u32 blocksize)\n{\n\tset_extent_bits(&rc->processed_blocks, bytenr, bytenr + blocksize - 1,\n\t\t\tEXTENT_DIRTY, GFP_NOFS);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void mark_block_processed(struct reloc_control *rc,\n\t\t\t\t u64 bytenr, u32 blocksize)\n{\n\tset_extent_bits(&rc->processed_blocks, bytenr, bytenr + blocksize - 1,\n\t\t\tEXTENT_DIRTY, GFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_block_group",
          "args": [
            "node->bytenr",
            "rc->block_group"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "in_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1565-1572",
          "snippet": "static int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}"
  },
  {
    "function_name": "mark_block_processed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2807-2812",
    "snippet": "static void mark_block_processed(struct reloc_control *rc,\n\t\t\t\t u64 bytenr, u32 blocksize)\n{\n\tset_extent_bits(&rc->processed_blocks, bytenr, bytenr + blocksize - 1,\n\t\t\tEXTENT_DIRTY, GFP_NOFS);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_extent_bits",
          "args": [
            "&rc->processed_blocks",
            "bytenr",
            "bytenr + blocksize - 1",
            "EXTENT_DIRTY",
            "GFP_NOFS"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1270-1275",
          "snippet": "int set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint set_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t    unsigned bits, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end, bits, NULL,\n\t\t\t      NULL, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void mark_block_processed(struct reloc_control *rc,\n\t\t\t\t u64 bytenr, u32 blocksize)\n{\n\tset_extent_bits(&rc->processed_blocks, bytenr, bytenr + blocksize - 1,\n\t\t\tEXTENT_DIRTY, GFP_NOFS);\n}"
  },
  {
    "function_name": "finish_pending_nodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2779-2805",
    "snippet": "static int finish_pending_nodes(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_path *path, int err)\n{\n\tLIST_HEAD(list);\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node;\n\tint level;\n\tint ret;\n\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\twhile (!list_empty(&cache->pending[level])) {\n\t\t\tnode = list_entry(cache->pending[level].next,\n\t\t\t\t\t  struct backref_node, list);\n\t\t\tlist_move_tail(&node->list, &list);\n\t\t\tBUG_ON(!node->pending);\n\n\t\t\tif (!err) {\n\t\t\t\tret = link_to_upper(trans, rc, node, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tlist_splice_init(&list, &cache->pending[level]);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&list",
            "&cache->pending[level]"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "link_to_upper",
          "args": [
            "trans",
            "rc",
            "node",
            "path"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "link_to_upper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2768-2777",
          "snippet": "static int link_to_upper(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\n\tbtrfs_node_key_to_cpu(node->eb, &key, 0);\n\treturn do_relocation(trans, rc, node, &key, path, 0);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int link_to_upper(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\n\tbtrfs_node_key_to_cpu(node->eb, &key, 0);\n\treturn do_relocation(trans, rc, node, &key, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!node->pending"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&node->list",
            "&list"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->pending[level].next",
            "structbackref_node",
            "list"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->pending[level]"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int finish_pending_nodes(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct reloc_control *rc,\n\t\t\t\tstruct btrfs_path *path, int err)\n{\n\tLIST_HEAD(list);\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node;\n\tint level;\n\tint ret;\n\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\twhile (!list_empty(&cache->pending[level])) {\n\t\t\tnode = list_entry(cache->pending[level].next,\n\t\t\t\t\t  struct backref_node, list);\n\t\t\tlist_move_tail(&node->list, &list);\n\t\t\tBUG_ON(!node->pending);\n\n\t\t\tif (!err) {\n\t\t\t\tret = link_to_upper(trans, rc, node, path);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\terr = ret;\n\t\t\t}\n\t\t}\n\t\tlist_splice_init(&list, &cache->pending[level]);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "link_to_upper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2768-2777",
    "snippet": "static int link_to_upper(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\n\tbtrfs_node_key_to_cpu(node->eb, &key, 0);\n\treturn do_relocation(trans, rc, node, &key, path, 0);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_relocation",
          "args": [
            "trans",
            "rc",
            "node",
            "&key",
            "path",
            "0"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "do_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2635-2766",
          "snippet": "static int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "node->eb",
            "&key",
            "0"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int link_to_upper(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\n\tbtrfs_node_key_to_cpu(node->eb, &key, 0);\n\treturn do_relocation(trans, rc, node, &key, path, 0);\n}"
  },
  {
    "function_name": "do_relocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2635-2766",
    "snippet": "static int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err == -ENOSPC"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&node->list",
            "&rc->backref_cache.changed"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_node_buffer",
          "args": [
            "node"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "drop_node_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "399-406",
          "snippet": "static void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_node_buffer",
          "args": [
            "upper"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_node_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "391-397",
          "snippet": "static void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_drop_subtree",
          "args": [
            "trans",
            "root",
            "eb",
            "upper->eb"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8367-8430",
          "snippet": "int btrfs_drop_subtree(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tstruct extent_buffer *node,\n\t\t\tstruct extent_buffer *parent)\n{\n\tstruct btrfs_path *path;\n\tstruct walk_control *wc;\n\tint level;\n\tint parent_level;\n\tint ret = 0;\n\tint wret;\n\n\tBUG_ON(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_assert_tree_locked(parent);\n\tparent_level = btrfs_header_level(parent);\n\textent_buffer_get(parent);\n\tpath->nodes[parent_level] = parent;\n\tpath->slots[parent_level] = btrfs_header_nritems(parent);\n\n\tbtrfs_assert_tree_locked(node);\n\tlevel = btrfs_header_level(node);\n\tpath->nodes[level] = node;\n\tpath->slots[level] = 0;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\twc->refs[parent_level] = 1;\n\twc->flags[parent_level] = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = 0;\n\twc->keep_locks = 1;\n\twc->for_reloc = 1;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\t\twret = walk_down_tree(trans, root, path, wc);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tbreak;\n\t\t}\n\n\t\twret = walk_up_tree(trans, root, path, wc, parent_level);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret != 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(wc);\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define DROP_REFERENCE\t1"
          ],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define DROP_REFERENCE\t1\n\nstatic noinline struct;\n\nint btrfs_drop_subtree(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_root *root,\n\t\t\tstruct extent_buffer *node,\n\t\t\tstruct extent_buffer *parent)\n{\n\tstruct btrfs_path *path;\n\tstruct walk_control *wc;\n\tint level;\n\tint parent_level;\n\tint ret = 0;\n\tint wret;\n\n\tBUG_ON(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_assert_tree_locked(parent);\n\tparent_level = btrfs_header_level(parent);\n\textent_buffer_get(parent);\n\tpath->nodes[parent_level] = parent;\n\tpath->slots[parent_level] = btrfs_header_nritems(parent);\n\n\tbtrfs_assert_tree_locked(node);\n\tlevel = btrfs_header_level(node);\n\tpath->nodes[level] = node;\n\tpath->slots[level] = 0;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\twc->refs[parent_level] = 1;\n\twc->flags[parent_level] = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = 0;\n\twc->keep_locks = 1;\n\twc->for_reloc = 1;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\t\twret = walk_down_tree(trans, root, path, wc);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tbreak;\n\t\t}\n\n\t\twret = walk_up_tree(trans, root, path, wc, parent_level);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret != 0)\n\t\t\tbreak;\n\t}\n\n\tkfree(wc);\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "node->eb->start",
            "blocksize",
            "upper->eb->start",
            "btrfs_header_owner(upper->eb)",
            "node->level",
            "0",
            "1"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "upper->eb"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "upper->eb"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "upper->eb",
            "slot",
            "trans->transid"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "upper->eb",
            "slot",
            "node->eb->start"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->eb != eb"
          ],
          "line": 2730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "eb"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "eb",
            "upper->eb",
            "slot",
            "&eb"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "eb"
          ],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "eb"
          ],
          "line": 2718
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "bytenr",
            "generation"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "upper->eb",
            "slot"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bytenr != node->bytenr"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "upper->eb",
            "slot"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bin_search",
          "args": [
            "upper->eb",
            "key",
            "upper->level",
            "&slot"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "upper->eb != path->nodes[upper->level]"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret > 0"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "key",
            "path",
            "0",
            "1"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_reloc_root",
          "args": [
            "trans",
            "rc",
            "upper",
            "edges"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "select_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2459-2513",
          "snippet": "btrfs_root *select_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct reloc_control *rc,\n\t\t\t\t     struct backref_node *node,\n\t\t\t\t     struct backref_edge *edges[])\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\t\tBUG_ON(!test_bit(BTRFS_ROOT_REF_COWS, &root->state));\n\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\trecord_reloc_root_in_trans(trans, root);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_record_root_in_trans(trans, root);\n\t\troot = root->reloc_root;\n\n\t\tif (next->new_bytenr != root->node->start) {\n\t\t\tBUG_ON(next->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&next->list));\n\t\t\tnext->new_bytenr = root->node->start;\n\t\t\tnext->root = root;\n\t\t\tlist_add_tail(&next->list,\n\t\t\t\t      &rc->backref_cache.changed);\n\t\t\t__mark_block_processed(rc, next);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(1);\n\t\troot = NULL;\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\tif (!root)\n\t\treturn NULL;\n\n\tnext = node;\n\t/* setup backref node path for btrfs_reloc_cow_block */\n\twhile (1) {\n\t\trc->backref_cache.path[next->level] = next;\n\t\tif (--index < 0)\n\t\t\tbreak;\n\t\tnext = edges[index]->node[UPPER];\n\t}\n\treturn root;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nbtrfs_root *select_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct reloc_control *rc,\n\t\t\t\t     struct backref_node *node,\n\t\t\t\t     struct backref_edge *edges[])\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\t\tBUG_ON(!test_bit(BTRFS_ROOT_REF_COWS, &root->state));\n\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\trecord_reloc_root_in_trans(trans, root);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_record_root_in_trans(trans, root);\n\t\troot = root->reloc_root;\n\n\t\tif (next->new_bytenr != root->node->start) {\n\t\t\tBUG_ON(next->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&next->list));\n\t\t\tnext->new_bytenr = root->node->start;\n\t\t\tnext->root = root;\n\t\t\tlist_add_tail(&next->list,\n\t\t\t\t      &rc->backref_cache.changed);\n\t\t\t__mark_block_processed(rc, next);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(1);\n\t\troot = NULL;\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\tif (!root)\n\t\treturn NULL;\n\n\tnext = node;\n\t/* setup backref node path for btrfs_reloc_cow_block */\n\twhile (1) {\n\t\trc->backref_cache.path[next->level] = next;\n\t\tif (--index < 0)\n\t\t\tbreak;\n\t\tnext = edges[index]->node[UPPER];\n\t}\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "edge",
            "&node->upper",
            "list[LOWER]"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lowest && node->eb"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int do_relocation(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct backref_node *node,\n\t\t\t struct btrfs_key *key,\n\t\t\t struct btrfs_path *path, int lowest)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tstruct btrfs_root *root;\n\tstruct extent_buffer *eb;\n\tu32 blocksize;\n\tu64 bytenr;\n\tu64 generation;\n\tint slot;\n\tint ret;\n\tint err = 0;\n\n\tBUG_ON(lowest && node->eb);\n\n\tpath->lowest_level = node->level + 1;\n\trc->backref_cache.path[node->level] = node;\n\tlist_for_each_entry(edge, &node->upper, list[LOWER]) {\n\t\tcond_resched();\n\n\t\tupper = edge->node[UPPER];\n\t\troot = select_reloc_root(trans, rc, upper, edges);\n\t\tBUG_ON(!root);\n\n\t\tif (upper->eb && !upper->locked) {\n\t\t\tif (!lowest) {\n\t\t\t\tret = btrfs_bin_search(upper->eb, key,\n\t\t\t\t\t\t       upper->level, &slot);\n\t\t\t\tBUG_ON(ret);\n\t\t\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\t\t\tif (node->eb->start == bytenr)\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdrop_node_buffer(upper);\n\t\t}\n\n\t\tif (!upper->eb) {\n\t\t\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBUG_ON(ret > 0);\n\n\t\t\tif (!upper->eb) {\n\t\t\t\tupper->eb = path->nodes[upper->level];\n\t\t\t\tpath->nodes[upper->level] = NULL;\n\t\t\t} else {\n\t\t\t\tBUG_ON(upper->eb != path->nodes[upper->level]);\n\t\t\t}\n\n\t\t\tupper->locked = 1;\n\t\t\tpath->locks[upper->level] = 0;\n\n\t\t\tslot = path->slots[upper->level];\n\t\t\tbtrfs_release_path(path);\n\t\t} else {\n\t\t\tret = btrfs_bin_search(upper->eb, key, upper->level,\n\t\t\t\t\t       &slot);\n\t\t\tBUG_ON(ret);\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(upper->eb, slot);\n\t\tif (lowest) {\n\t\t\tBUG_ON(bytenr != node->bytenr);\n\t\t} else {\n\t\t\tif (node->eb->start == bytenr)\n\t\t\t\tgoto next;\n\t\t}\n\n\t\tblocksize = root->nodesize;\n\t\tgeneration = btrfs_node_ptr_generation(upper->eb, slot);\n\t\teb = read_tree_block(root, bytenr, generation);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\terr = -EIO;\n\t\t\tgoto next;\n\t\t}\n\t\tbtrfs_tree_lock(eb);\n\t\tbtrfs_set_lock_blocking(eb);\n\n\t\tif (!node->eb) {\n\t\t\tret = btrfs_cow_block(trans, root, eb, upper->eb,\n\t\t\t\t\t      slot, &eb);\n\t\t\tbtrfs_tree_unlock(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tBUG_ON(node->eb != eb);\n\t\t} else {\n\t\t\tbtrfs_set_node_blockptr(upper->eb, slot,\n\t\t\t\t\t\tnode->eb->start);\n\t\t\tbtrfs_set_node_ptr_generation(upper->eb, slot,\n\t\t\t\t\t\t      trans->transid);\n\t\t\tbtrfs_mark_buffer_dirty(upper->eb);\n\n\t\t\tret = btrfs_inc_extent_ref(trans, root,\n\t\t\t\t\t\tnode->eb->start, blocksize,\n\t\t\t\t\t\tupper->eb->start,\n\t\t\t\t\t\tbtrfs_header_owner(upper->eb),\n\t\t\t\t\t\tnode->level, 0, 1);\n\t\t\tBUG_ON(ret);\n\n\t\t\tret = btrfs_drop_subtree(trans, root, eb, upper->eb);\n\t\t\tBUG_ON(ret);\n\t\t}\nnext:\n\t\tif (!upper->pending)\n\t\t\tdrop_node_buffer(upper);\n\t\telse\n\t\t\tunlock_node_buffer(upper);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!err && node->pending) {\n\t\tdrop_node_buffer(node);\n\t\tlist_move_tail(&node->list, &rc->backref_cache.changed);\n\t\tnode->pending = 0;\n\t}\n\n\tpath->lowest_level = 0;\n\tBUG_ON(err == -ENOSPC);\n\treturn err;\n}"
  },
  {
    "function_name": "reserve_metadata_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2591-2626",
    "snippet": "static int reserve_metadata_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct reloc_control *rc,\n\t\t\t\t  struct backref_node *node)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tu64 num_bytes;\n\tint ret;\n\tu64 tmp;\n\n\tnum_bytes = calcu_metadata_size(rc, node, 1) * 2;\n\n\ttrans->block_rsv = rc->block_rsv;\n\trc->reserved_bytes += num_bytes;\n\tret = btrfs_block_rsv_refill(root, rc->block_rsv, num_bytes,\n\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\tif (ret) {\n\t\tif (ret == -EAGAIN) {\n\t\t\ttmp = rc->extent_root->nodesize *\n\t\t\t\tRELOCATION_RESERVED_NODES;\n\t\t\twhile (tmp <= rc->reserved_bytes)\n\t\t\t\ttmp <<= 1;\n\t\t\t/*\n\t\t\t * only one thread can access block_rsv at this point,\n\t\t\t * so we don't need hold lock to protect block_rsv.\n\t\t\t * we expand more reservation size here to allow enough\n\t\t\t * space for relocation and we will return eailer in\n\t\t\t * enospc case.\n\t\t\t */\n\t\t\trc->block_rsv->size = tmp + rc->extent_root->nodesize *\n\t\t\t\t\t      RELOCATION_RESERVED_NODES;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define RELOCATION_RESERVED_NODES\t256"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_block_rsv_refill",
          "args": [
            "root",
            "rc->block_rsv",
            "num_bytes",
            "BTRFS_RESERVE_FLUSH_ALL"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4739-4767",
          "snippet": "int btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calcu_metadata_size",
          "args": [
            "rc",
            "node",
            "1"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "calcu_metadata_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2558-2589",
          "snippet": "static noinline_for_stack\nu64 calcu_metadata_size(struct reloc_control *rc,\n\t\t\tstruct backref_node *node, int reserve)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tu64 num_bytes = 0;\n\tint index = 0;\n\n\tBUG_ON(reserve && node->processed);\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed && (reserve || next != node))\n\t\t\t\tbreak;\n\n\t\t\tnum_bytes += rc->extent_root->nodesize;\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n\treturn num_bytes;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nu64 calcu_metadata_size(struct reloc_control *rc,\n\t\t\tstruct backref_node *node, int reserve)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tu64 num_bytes = 0;\n\tint index = 0;\n\n\tBUG_ON(reserve && node->processed);\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed && (reserve || next != node))\n\t\t\t\tbreak;\n\n\t\t\tnum_bytes += rc->extent_root->nodesize;\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n\treturn num_bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define RELOCATION_RESERVED_NODES\t256\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int reserve_metadata_space(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct reloc_control *rc,\n\t\t\t\t  struct backref_node *node)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tu64 num_bytes;\n\tint ret;\n\tu64 tmp;\n\n\tnum_bytes = calcu_metadata_size(rc, node, 1) * 2;\n\n\ttrans->block_rsv = rc->block_rsv;\n\trc->reserved_bytes += num_bytes;\n\tret = btrfs_block_rsv_refill(root, rc->block_rsv, num_bytes,\n\t\t\t\tBTRFS_RESERVE_FLUSH_ALL);\n\tif (ret) {\n\t\tif (ret == -EAGAIN) {\n\t\t\ttmp = rc->extent_root->nodesize *\n\t\t\t\tRELOCATION_RESERVED_NODES;\n\t\t\twhile (tmp <= rc->reserved_bytes)\n\t\t\t\ttmp <<= 1;\n\t\t\t/*\n\t\t\t * only one thread can access block_rsv at this point,\n\t\t\t * so we don't need hold lock to protect block_rsv.\n\t\t\t * we expand more reservation size here to allow enough\n\t\t\t * space for relocation and we will return eailer in\n\t\t\t * enospc case.\n\t\t\t */\n\t\t\trc->block_rsv->size = tmp + rc->extent_root->nodesize *\n\t\t\t\t\t      RELOCATION_RESERVED_NODES;\n\t\t}\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "calcu_metadata_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2558-2589",
    "snippet": "static noinline_for_stack\nu64 calcu_metadata_size(struct reloc_control *rc,\n\t\t\tstruct backref_node *node, int reserve)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tu64 num_bytes = 0;\n\tint index = 0;\n\n\tBUG_ON(reserve && node->processed);\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed && (reserve || next != node))\n\t\t\t\tbreak;\n\n\t\t\tnum_bytes += rc->extent_root->nodesize;\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n\treturn num_bytes;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_down_backref",
          "args": [
            "edges",
            "&index"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "367-389",
          "snippet": "static struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next->upper.next",
            "structbackref_edge",
            "list[LOWER]"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&next->upper"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "reserve && node->processed"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nu64 calcu_metadata_size(struct reloc_control *rc,\n\t\t\tstruct backref_node *node, int reserve)\n{\n\tstruct backref_node *next = node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tu64 num_bytes = 0;\n\tint index = 0;\n\n\tBUG_ON(reserve && node->processed);\n\n\twhile (next) {\n\t\tcond_resched();\n\t\twhile (1) {\n\t\t\tif (next->processed && (reserve || next != node))\n\t\t\t\tbreak;\n\n\t\t\tnum_bytes += rc->extent_root->nodesize;\n\n\t\t\tif (list_empty(&next->upper))\n\t\t\t\tbreak;\n\n\t\t\tedge = list_entry(next->upper.next,\n\t\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\t\tedges[index++] = edge;\n\t\t\tnext = edge->node[UPPER];\n\t\t}\n\t\tnext = walk_down_backref(edges, &index);\n\t}\n\treturn num_bytes;\n}"
  },
  {
    "function_name": "select_one_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2522-2556",
    "snippet": "btrfs_root *select_one_root(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct backref_node *node)\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\n\t\t/* no other choice for non-references counted tree */\n\t\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\treturn root;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tfs_root = root;\n\n\t\tif (next != node)\n\t\t\treturn NULL;\n\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\n\tif (!fs_root)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn fs_root;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_down_backref",
          "args": [
            "edges",
            "&index"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "367-389",
          "snippet": "static struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_up_backref",
          "args": [
            "next",
            "edges",
            "&index"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "walk_up_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "346-362",
          "snippet": "static struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nbtrfs_root *select_one_root(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct backref_node *node)\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *fs_root = NULL;\n\tstruct backref_edge *edges[BTRFS_MAX_LEVEL - 1];\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\n\t\t/* no other choice for non-references counted tree */\n\t\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\t\treturn root;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tfs_root = root;\n\n\t\tif (next != node)\n\t\t\treturn NULL;\n\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\n\tif (!fs_root)\n\t\treturn ERR_PTR(-ENOENT);\n\treturn fs_root;\n}"
  },
  {
    "function_name": "select_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2459-2513",
    "snippet": "btrfs_root *select_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct reloc_control *rc,\n\t\t\t\t     struct backref_node *node,\n\t\t\t\t     struct backref_edge *edges[])\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\t\tBUG_ON(!test_bit(BTRFS_ROOT_REF_COWS, &root->state));\n\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\trecord_reloc_root_in_trans(trans, root);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_record_root_in_trans(trans, root);\n\t\troot = root->reloc_root;\n\n\t\tif (next->new_bytenr != root->node->start) {\n\t\t\tBUG_ON(next->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&next->list));\n\t\t\tnext->new_bytenr = root->node->start;\n\t\t\tnext->root = root;\n\t\t\tlist_add_tail(&next->list,\n\t\t\t\t      &rc->backref_cache.changed);\n\t\t\t__mark_block_processed(rc, next);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(1);\n\t\troot = NULL;\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\tif (!root)\n\t\treturn NULL;\n\n\tnext = node;\n\t/* setup backref node path for btrfs_reloc_cow_block */\n\twhile (1) {\n\t\trc->backref_cache.path[next->level] = next;\n\t\tif (--index < 0)\n\t\t\tbreak;\n\t\tnext = edges[index]->node[UPPER];\n\t}\n\treturn root;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_down_backref",
          "args": [
            "edges",
            "&index"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "367-389",
          "snippet": "static struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mark_block_processed",
          "args": [
            "rc",
            "next"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_block_processed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2814-2824",
          "snippet": "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node)\n{\n\tu32 blocksize;\n\tif (node->level == 0 ||\n\t    in_block_group(node->bytenr, rc->block_group)) {\n\t\tblocksize = rc->extent_root->nodesize;\n\t\tmark_block_processed(rc, node->bytenr, blocksize);\n\t}\n\tnode->processed = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&next->list",
            "&rc->backref_cache.changed"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&next->list)"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&next->list"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "next->new_bytenr"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "record_reloc_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "record_reloc_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2443-2456",
          "snippet": "static int record_reloc_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *reloc_root)\n{\n\tstruct btrfs_root *root;\n\n\tif (reloc_root->last_trans == trans->transid)\n\t\treturn 0;\n\n\troot = read_fs_root(reloc_root->fs_info, reloc_root->root_key.offset);\n\tBUG_ON(IS_ERR(root));\n\tBUG_ON(root->reloc_root != reloc_root);\n\n\treturn btrfs_record_root_in_trans(trans, root);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int record_reloc_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *reloc_root)\n{\n\tstruct btrfs_root *root;\n\n\tif (reloc_root->last_trans == trans->transid)\n\t\treturn 0;\n\n\troot = read_fs_root(reloc_root->fs_info, reloc_root->root_key.offset);\n\tBUG_ON(IS_ERR(root));\n\tBUG_ON(root->reloc_root != reloc_root);\n\n\treturn btrfs_record_root_in_trans(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_bit(BTRFS_ROOT_REF_COWS, &root->state)"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_up_backref",
          "args": [
            "next",
            "edges",
            "&index"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "walk_up_backref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "346-362",
          "snippet": "static struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nbtrfs_root *select_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct reloc_control *rc,\n\t\t\t\t     struct backref_node *node,\n\t\t\t\t     struct backref_edge *edges[])\n{\n\tstruct backref_node *next;\n\tstruct btrfs_root *root;\n\tint index = 0;\n\n\tnext = node;\n\twhile (1) {\n\t\tcond_resched();\n\t\tnext = walk_up_backref(next, edges, &index);\n\t\troot = next->root;\n\t\tBUG_ON(!root);\n\t\tBUG_ON(!test_bit(BTRFS_ROOT_REF_COWS, &root->state));\n\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\trecord_reloc_root_in_trans(trans, root);\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_record_root_in_trans(trans, root);\n\t\troot = root->reloc_root;\n\n\t\tif (next->new_bytenr != root->node->start) {\n\t\t\tBUG_ON(next->new_bytenr);\n\t\t\tBUG_ON(!list_empty(&next->list));\n\t\t\tnext->new_bytenr = root->node->start;\n\t\t\tnext->root = root;\n\t\t\tlist_add_tail(&next->list,\n\t\t\t\t      &rc->backref_cache.changed);\n\t\t\t__mark_block_processed(rc, next);\n\t\t\tbreak;\n\t\t}\n\n\t\tWARN_ON(1);\n\t\troot = NULL;\n\t\tnext = walk_down_backref(edges, &index);\n\t\tif (!next || next->level <= node->level)\n\t\t\tbreak;\n\t}\n\tif (!root)\n\t\treturn NULL;\n\n\tnext = node;\n\t/* setup backref node path for btrfs_reloc_cow_block */\n\twhile (1) {\n\t\trc->backref_cache.path[next->level] = next;\n\t\tif (--index < 0)\n\t\t\tbreak;\n\t\tnext = edges[index]->node[UPPER];\n\t}\n\treturn root;\n}"
  },
  {
    "function_name": "record_reloc_root_in_trans",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2443-2456",
    "snippet": "static int record_reloc_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *reloc_root)\n{\n\tstruct btrfs_root *root;\n\n\tif (reloc_root->last_trans == trans->transid)\n\t\treturn 0;\n\n\troot = read_fs_root(reloc_root->fs_info, reloc_root->root_key.offset);\n\tBUG_ON(IS_ERR(root));\n\tBUG_ON(root->reloc_root != reloc_root);\n\n\treturn btrfs_record_root_in_trans(trans, root);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_record_root_in_trans",
          "args": [
            "trans",
            "root"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_record_root_in_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "330-350",
          "snippet": "int btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_record_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root)\n{\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\t/*\n\t * see record_root_in_trans for comments about IN_TRANS_SETUP usage\n\t * and barriers\n\t */\n\tsmp_rmb();\n\tif (root->last_trans == trans->transid &&\n\t    !test_bit(BTRFS_ROOT_IN_TRANS_SETUP, &root->state))\n\t\treturn 0;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trecord_root_in_trans(trans, root);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root->reloc_root != reloc_root"
          ],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(root)"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "reloc_root->fs_info",
            "reloc_root->root_key.offset"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int record_reloc_root_in_trans(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *reloc_root)\n{\n\tstruct btrfs_root *root;\n\n\tif (reloc_root->last_trans == trans->transid)\n\t\treturn 0;\n\n\troot = read_fs_root(reloc_root->fs_info, reloc_root->root_key.offset);\n\tBUG_ON(IS_ERR(root));\n\tBUG_ON(root->reloc_root != reloc_root);\n\n\treturn btrfs_record_root_in_trans(trans, root);\n}"
  },
  {
    "function_name": "free_block_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2432-2441",
    "snippet": "static void free_block_list(struct rb_root *blocks)\n{\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\twhile ((rb_node = rb_first(blocks))) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\trb_erase(rb_node, blocks);\n\t\tkfree(block);\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "block"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "rb_node",
            "blocks"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structtree_block",
            "rb_node"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "blocks"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void free_block_list(struct rb_root *blocks)\n{\n\tstruct tree_block *block;\n\tstruct rb_node *rb_node;\n\twhile ((rb_node = rb_first(blocks))) {\n\t\tblock = rb_entry(rb_node, struct tree_block, rb_node);\n\t\trb_erase(rb_node, blocks);\n\t\tkfree(block);\n\t}\n}"
  },
  {
    "function_name": "merge_reloc_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2348-2430",
    "snippet": "static noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root)"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&rc->reloc_root_tree.rb_root"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_reloc_roots",
          "args": [
            "&reloc_roots"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "free_reloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2336-2346",
          "snippet": "static noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reloc_roots"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&rc->reloc_roots",
            "&reloc_roots"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&reloc_root->root_list",
            "&reloc_roots"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_drop_snapshot",
          "args": [
            "reloc_root",
            "rc->block_rsv",
            "0",
            "1"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_snapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8121-8359",
          "snippet": "int btrfs_drop_snapshot(struct btrfs_root *root,\n\t\t\t struct btrfs_block_rsv *block_rsv, int update_ref,\n\t\t\t int for_reloc)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct walk_control *wc;\n\tstruct btrfs_key key;\n\tint err = 0;\n\tint ret;\n\tint level;\n\tbool root_dropped = false;\n\n\tbtrfs_debug(root->fs_info, \"Drop subvolume %llu\", root->objectid);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tif (block_rsv)\n\t\ttrans->block_rsv = block_rsv;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_header_level(root->node);\n\t\tpath->nodes[level] = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\tpath->slots[level] = 0;\n\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\t\tmemset(&wc->update_progress, 0,\n\t\t       sizeof(wc->update_progress));\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\t\tmemcpy(&wc->update_progress, &key,\n\t\t       sizeof(wc->update_progress));\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t\tWARN_ON(ret > 0);\n\n\t\t/*\n\t\t * unlock our path, this is safe because only this\n\t\t * function is allowed to delete this snapshot\n\t\t */\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tlevel = btrfs_header_level(root->node);\n\t\twhile (1) {\n\t\t\tbtrfs_tree_lock(path->nodes[level]);\n\t\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\t\t\tret = btrfs_lookup_extent_info(trans, root,\n\t\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\t\tlevel, 1, &wc->refs[level],\n\t\t\t\t\t\t&wc->flags[level]);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\t\t\tBUG_ON(wc->refs[level] == 0);\n\n\t\t\tif (level == root_item->drop_level)\n\t\t\t\tbreak;\n\n\t\t\tbtrfs_tree_unlock(path->nodes[level]);\n\t\t\tpath->locks[level] = 0;\n\t\t\tWARN_ON(wc->refs[level] != 1);\n\t\t\tlevel--;\n\t\t}\n\t}\n\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = update_ref;\n\twc->keep_locks = 0;\n\twc->for_reloc = for_reloc;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\n\t\tret = walk_down_tree(trans, root, path, wc);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = walk_up_tree(trans, root, path, wc, BTRFS_MAX_LEVEL);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tBUG_ON(wc->stage != DROP_REFERENCE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage == DROP_REFERENCE) {\n\t\t\tlevel = wc->level;\n\t\t\tbtrfs_node_key(path->nodes[level],\n\t\t\t\t       &root_item->drop_progress,\n\t\t\t\t       path->slots[level]);\n\t\t\troot_item->drop_level = level;\n\t\t}\n\n\t\tBUG_ON(wc->level == 0);\n\t\tif (btrfs_should_end_transaction(trans, tree_root) ||\n\t\t    (!for_reloc && btrfs_need_cleaner_sleep(root))) {\n\t\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\troot_item);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Qgroup update accounting is run from\n\t\t\t * delayed ref handling. This usually works\n\t\t\t * out because delayed refs are normally the\n\t\t\t * only way qgroup updates are added. However,\n\t\t\t * we may have added updates during our tree\n\t\t\t * walk so run qgroups here to make sure we\n\t\t\t * don't lose any updates.\n\t\t\t */\n\t\t\tret = btrfs_delayed_qgroup_accounting(trans,\n\t\t\t\t\t\t\t      root->fs_info);\n\t\t\tif (ret)\n\t\t\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t\t\t   \"rescan required.\\n\", ret);\n\n\t\t\tbtrfs_end_transaction_throttle(trans, tree_root);\n\t\t\tif (!for_reloc && btrfs_need_cleaner_sleep(root)) {\n\t\t\t\tpr_debug(\"BTRFS: drop snapshot early exit\\n\");\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\ttrans = btrfs_start_transaction(tree_root, 0);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tif (block_rsv)\n\t\t\t\ttrans->block_rsv = block_rsv;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tif (err)\n\t\tgoto out_end_trans;\n\n\tret = btrfs_del_root(trans, tree_root, &root->root_key);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\tret = btrfs_find_root(tree_root, &root->root_key, path,\n\t\t\t\t      NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t} else if (ret > 0) {\n\t\t\t/* if we fail to delete the orphan item this time\n\t\t\t * around, it'll get picked up the next time.\n\t\t\t *\n\t\t\t * The most common failure here is just -ENOENT.\n\t\t\t */\n\t\t\tbtrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t      root->root_key.objectid);\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_ROOT_IN_RADIX, &root->state)) {\n\t\tbtrfs_drop_and_free_fs_root(tree_root->fs_info, root);\n\t} else {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tbtrfs_put_fs_root(root);\n\t}\n\troot_dropped = true;\nout_end_trans:\n\tret = btrfs_delayed_qgroup_accounting(trans, tree_root->fs_info);\n\tif (ret)\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t   \"rescan required.\\n\", ret);\n\n\tbtrfs_end_transaction_throttle(trans, tree_root);\nout_free:\n\tkfree(wc);\n\tbtrfs_free_path(path);\nout:\n\t/*\n\t * So if we need to stop dropping the snapshot for whatever reason we\n\t * need to make sure to add it back to the dead root list so that we\n\t * keep trying to do the work later.  This also cleans up roots if we\n\t * don't have it in the radix (like when we recover after a power fail\n\t * or unmount) so we don't leak memory.\n\t */\n\tif (!for_reloc && root_dropped == false)\n\t\tbtrfs_add_dead_root(root);\n\tif (err && err != -EAGAIN)\n\t\tbtrfs_std_error(root->fs_info, err);\n\treturn err;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define DROP_REFERENCE\t1"
          ],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define DROP_REFERENCE\t1\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_drop_snapshot(struct btrfs_root *root,\n\t\t\t struct btrfs_block_rsv *block_rsv, int update_ref,\n\t\t\t int for_reloc)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = root->fs_info->tree_root;\n\tstruct btrfs_root_item *root_item = &root->root_item;\n\tstruct walk_control *wc;\n\tstruct btrfs_key key;\n\tint err = 0;\n\tint ret;\n\tint level;\n\tbool root_dropped = false;\n\n\tbtrfs_debug(root->fs_info, \"Drop subvolume %llu\", root->objectid);\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\twc = kzalloc(sizeof(*wc), GFP_NOFS);\n\tif (!wc) {\n\t\tbtrfs_free_path(path);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrans = btrfs_start_transaction(tree_root, 0);\n\tif (IS_ERR(trans)) {\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\tif (block_rsv)\n\t\ttrans->block_rsv = block_rsv;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_header_level(root->node);\n\t\tpath->nodes[level] = btrfs_lock_root_node(root);\n\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\tpath->slots[level] = 0;\n\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\t\tmemset(&wc->update_progress, 0,\n\t\t       sizeof(wc->update_progress));\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\t\tmemcpy(&wc->update_progress, &key,\n\t\t       sizeof(wc->update_progress));\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t}\n\t\tWARN_ON(ret > 0);\n\n\t\t/*\n\t\t * unlock our path, this is safe because only this\n\t\t * function is allowed to delete this snapshot\n\t\t */\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tlevel = btrfs_header_level(root->node);\n\t\twhile (1) {\n\t\t\tbtrfs_tree_lock(path->nodes[level]);\n\t\t\tbtrfs_set_lock_blocking(path->nodes[level]);\n\t\t\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\n\t\t\tret = btrfs_lookup_extent_info(trans, root,\n\t\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\t\tlevel, 1, &wc->refs[level],\n\t\t\t\t\t\t&wc->flags[level]);\n\t\t\tif (ret < 0) {\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\t\t\tBUG_ON(wc->refs[level] == 0);\n\n\t\t\tif (level == root_item->drop_level)\n\t\t\t\tbreak;\n\n\t\t\tbtrfs_tree_unlock(path->nodes[level]);\n\t\t\tpath->locks[level] = 0;\n\t\t\tWARN_ON(wc->refs[level] != 1);\n\t\t\tlevel--;\n\t\t}\n\t}\n\n\twc->level = level;\n\twc->shared_level = -1;\n\twc->stage = DROP_REFERENCE;\n\twc->update_ref = update_ref;\n\twc->keep_locks = 0;\n\twc->for_reloc = for_reloc;\n\twc->reada_count = BTRFS_NODEPTRS_PER_BLOCK(root);\n\n\twhile (1) {\n\n\t\tret = walk_down_tree(trans, root, path, wc);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = walk_up_tree(trans, root, path, wc, BTRFS_MAX_LEVEL);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tBUG_ON(wc->stage != DROP_REFERENCE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wc->stage == DROP_REFERENCE) {\n\t\t\tlevel = wc->level;\n\t\t\tbtrfs_node_key(path->nodes[level],\n\t\t\t\t       &root_item->drop_progress,\n\t\t\t\t       path->slots[level]);\n\t\t\troot_item->drop_level = level;\n\t\t}\n\n\t\tBUG_ON(wc->level == 0);\n\t\tif (btrfs_should_end_transaction(trans, tree_root) ||\n\t\t    (!for_reloc && btrfs_need_cleaner_sleep(root))) {\n\t\t\tret = btrfs_update_root(trans, tree_root,\n\t\t\t\t\t\t&root->root_key,\n\t\t\t\t\t\troot_item);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out_end_trans;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Qgroup update accounting is run from\n\t\t\t * delayed ref handling. This usually works\n\t\t\t * out because delayed refs are normally the\n\t\t\t * only way qgroup updates are added. However,\n\t\t\t * we may have added updates during our tree\n\t\t\t * walk so run qgroups here to make sure we\n\t\t\t * don't lose any updates.\n\t\t\t */\n\t\t\tret = btrfs_delayed_qgroup_accounting(trans,\n\t\t\t\t\t\t\t      root->fs_info);\n\t\t\tif (ret)\n\t\t\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t\t\t   \"rescan required.\\n\", ret);\n\n\t\t\tbtrfs_end_transaction_throttle(trans, tree_root);\n\t\t\tif (!for_reloc && btrfs_need_cleaner_sleep(root)) {\n\t\t\t\tpr_debug(\"BTRFS: drop snapshot early exit\\n\");\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto out_free;\n\t\t\t}\n\n\t\t\ttrans = btrfs_start_transaction(tree_root, 0);\n\t\t\tif (IS_ERR(trans)) {\n\t\t\t\terr = PTR_ERR(trans);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\tif (block_rsv)\n\t\t\t\ttrans->block_rsv = block_rsv;\n\t\t}\n\t}\n\tbtrfs_release_path(path);\n\tif (err)\n\t\tgoto out_end_trans;\n\n\tret = btrfs_del_root(trans, tree_root, &root->root_key);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\tgoto out_end_trans;\n\t}\n\n\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\tret = btrfs_find_root(tree_root, &root->root_key, path,\n\t\t\t\t      NULL, NULL);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, tree_root, ret);\n\t\t\terr = ret;\n\t\t\tgoto out_end_trans;\n\t\t} else if (ret > 0) {\n\t\t\t/* if we fail to delete the orphan item this time\n\t\t\t * around, it'll get picked up the next time.\n\t\t\t *\n\t\t\t * The most common failure here is just -ENOENT.\n\t\t\t */\n\t\t\tbtrfs_del_orphan_item(trans, tree_root,\n\t\t\t\t\t      root->root_key.objectid);\n\t\t}\n\t}\n\n\tif (test_bit(BTRFS_ROOT_IN_RADIX, &root->state)) {\n\t\tbtrfs_drop_and_free_fs_root(tree_root->fs_info, root);\n\t} else {\n\t\tfree_extent_buffer(root->node);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tbtrfs_put_fs_root(root);\n\t}\n\troot_dropped = true;\nout_end_trans:\n\tret = btrfs_delayed_qgroup_accounting(trans, tree_root->fs_info);\n\tif (ret)\n\t\tprintk_ratelimited(KERN_ERR \"BTRFS: Failure %d \"\n\t\t\t\t   \"running qgroup updates \"\n\t\t\t\t   \"during snapshot delete. \"\n\t\t\t\t   \"Quota is out of sync, \"\n\t\t\t\t   \"rescan required.\\n\", ret);\n\n\tbtrfs_end_transaction_throttle(trans, tree_root);\nout_free:\n\tkfree(wc);\n\tbtrfs_free_path(path);\nout:\n\t/*\n\t * So if we need to stop dropping the snapshot for whatever reason we\n\t * need to make sure to add it back to the dead root list so that we\n\t * keep trying to do the work later.  This also cleans up roots if we\n\t * don't have it in the radix (like when we recover after a power fail\n\t * or unmount) so we don't leak memory.\n\t */\n\tif (!for_reloc && root_dropped == false)\n\t\tbtrfs_add_dead_root(root);\n\tif (err && err != -EAGAIN)\n\t\tbtrfs_std_error(root->fs_info, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_otransid",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_rtransid",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&reloc_root->root_list"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&reloc_root->root_list",
            "&reloc_roots"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "merge_reloc_root",
          "args": [
            "rc",
            "root"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "merge_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2110-2261",
          "snippet": "static noinline_for_stack int merge_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t       struct btrfs_root *root)\n{\n\tLIST_HEAD(inode_list);\n\tstruct btrfs_key key;\n\tstruct btrfs_key next_key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint level;\n\tint max_level;\n\tint replaced = 0;\n\tint ret;\n\tint err = 0;\n\tu32 min_reserved;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_root_level(root_item);\n\t\textent_buffer_get(reloc_root->node);\n\t\tpath->nodes[level] = reloc_root->node;\n\t\tpath->slots[level] = 0;\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, reloc_root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &next_key,\n\t\t\t\t      path->slots[level]);\n\t\tWARN_ON(memcmp(&key, &next_key, sizeof(key)));\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\t}\n\n\tmin_reserved = root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\tmemset(&next_key, 0, sizeof(next_key));\n\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(root, rc->block_rsv, min_reserved,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->block_rsv = rc->block_rsv;\n\n\t\treplaced = 0;\n\t\tmax_level = level;\n\n\t\tret = walk_down_reloc_tree(reloc_root, path, &level);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tif (!find_next_key(path, level, &key) &&\n\t\t    btrfs_comp_cpu_keys(&next_key, &key) >= 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = replace_path(trans, root, reloc_root, path,\n\t\t\t\t\t   &next_key, level, max_level);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tlevel = ret;\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t\t      path->slots[level]);\n\t\t\treplaced = 1;\n\t\t}\n\n\t\tret = walk_up_reloc_tree(reloc_root, path, &level);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tBUG_ON(level == 0);\n\t\t/*\n\t\t * save the merging progress in the drop_progress.\n\t\t * this is OK since root refs == 1 in this case.\n\t\t */\n\t\tbtrfs_node_key(path->nodes[level], &root_item->drop_progress,\n\t\t\t       path->slots[level]);\n\t\troot_item->drop_level = level;\n\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\t\ttrans = NULL;\n\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\t\tinvalidate_extent_cache(root, &key, &next_key);\n\t}\n\n\t/*\n\t * handle the case only one block in the fs tree need to be\n\t * relocated and the block is tree root.\n\t */\n\tleaf = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, leaf, NULL, 0, &leaf);\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tif (ret < 0)\n\t\terr = ret;\nout:\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(root_item->drop_progress));\n\t\troot_item->drop_level = 0;\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tbtrfs_update_reloc_root(trans, root);\n\t}\n\n\tif (trans)\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\n\tbtrfs_btree_balance_dirty(root);\n\n\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\tinvalidate_extent_cache(root, &key, &next_key);\n\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPDATE_DATA_PTRS\t1"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int merge_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t       struct btrfs_root *root)\n{\n\tLIST_HEAD(inode_list);\n\tstruct btrfs_key key;\n\tstruct btrfs_key next_key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint level;\n\tint max_level;\n\tint replaced = 0;\n\tint ret;\n\tint err = 0;\n\tu32 min_reserved;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_root_level(root_item);\n\t\textent_buffer_get(reloc_root->node);\n\t\tpath->nodes[level] = reloc_root->node;\n\t\tpath->slots[level] = 0;\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, reloc_root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &next_key,\n\t\t\t\t      path->slots[level]);\n\t\tWARN_ON(memcmp(&key, &next_key, sizeof(key)));\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\t}\n\n\tmin_reserved = root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\tmemset(&next_key, 0, sizeof(next_key));\n\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(root, rc->block_rsv, min_reserved,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->block_rsv = rc->block_rsv;\n\n\t\treplaced = 0;\n\t\tmax_level = level;\n\n\t\tret = walk_down_reloc_tree(reloc_root, path, &level);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tif (!find_next_key(path, level, &key) &&\n\t\t    btrfs_comp_cpu_keys(&next_key, &key) >= 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = replace_path(trans, root, reloc_root, path,\n\t\t\t\t\t   &next_key, level, max_level);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tlevel = ret;\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t\t      path->slots[level]);\n\t\t\treplaced = 1;\n\t\t}\n\n\t\tret = walk_up_reloc_tree(reloc_root, path, &level);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tBUG_ON(level == 0);\n\t\t/*\n\t\t * save the merging progress in the drop_progress.\n\t\t * this is OK since root refs == 1 in this case.\n\t\t */\n\t\tbtrfs_node_key(path->nodes[level], &root_item->drop_progress,\n\t\t\t       path->slots[level]);\n\t\troot_item->drop_level = level;\n\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\t\ttrans = NULL;\n\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\t\tinvalidate_extent_cache(root, &key, &next_key);\n\t}\n\n\t/*\n\t * handle the case only one block in the fs tree need to be\n\t * relocated and the block is tree root.\n\t */\n\tleaf = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, leaf, NULL, 0, &leaf);\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tif (ret < 0)\n\t\terr = ret;\nout:\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(root_item->drop_progress));\n\t\troot_item->drop_level = 0;\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tbtrfs_update_reloc_root(trans, root);\n\t}\n\n\tif (trans)\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\n\tbtrfs_btree_balance_dirty(root);\n\n\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\tinvalidate_extent_cache(root, &key, &next_key);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root->reloc_root != reloc_root"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(root)"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "reloc_root->fs_info",
            "reloc_root->root_key.offset"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reloc_roots.next",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&rc->reloc_roots",
            "&reloc_roots"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reloc_roots"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid merge_reloc_roots(struct reloc_control *rc)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *reloc_root;\n\tu64 last_snap;\n\tu64 otransid;\n\tu64 objectid;\n\tLIST_HEAD(reloc_roots);\n\tint found = 0;\n\tint ret = 0;\nagain:\n\troot = rc->extent_root;\n\n\t/*\n\t * this serializes us with btrfs_record_root_in_transaction,\n\t * we have to make sure nobody is in the middle of\n\t * adding their roots to the list while we are\n\t * doing this splice\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\tfound = 1;\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t\t    reloc_root->root_key.offset);\n\t\t\tBUG_ON(IS_ERR(root));\n\t\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t\tret = merge_reloc_root(rc, root);\n\t\t\tif (ret) {\n\t\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t\t      &reloc_roots);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tlist_del_init(&reloc_root->root_list);\n\t\t}\n\n\t\t/*\n\t\t * we keep the old last snapshod transid in rtranid when we\n\t\t * created the relocation tree.\n\t\t */\n\t\tlast_snap = btrfs_root_rtransid(&reloc_root->root_item);\n\t\totransid = btrfs_root_otransid(&reloc_root->root_item);\n\t\tobjectid = reloc_root->root_key.offset;\n\n\t\tret = btrfs_drop_snapshot(reloc_root, rc->block_rsv, 0, 1);\n\t\tif (ret < 0) {\n\t\t\tif (list_empty(&reloc_root->root_list))\n\t\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t\t      &reloc_roots);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tfound = 0;\n\t\tgoto again;\n\t}\nout:\n\tif (ret) {\n\t\tbtrfs_std_error(root->fs_info, ret);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\n\t\t/* new reloc root may be added */\n\t\tmutex_lock(&root->fs_info->reloc_mutex);\n\t\tlist_splice_init(&rc->reloc_roots, &reloc_roots);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tif (!list_empty(&reloc_roots))\n\t\t\tfree_reloc_roots(&reloc_roots);\n\t}\n\n\tBUG_ON(!RB_EMPTY_ROOT(&rc->reloc_root_tree.rb_root));\n}"
  },
  {
    "function_name": "free_reloc_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2336-2346",
    "snippet": "static noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__del_reloc_root",
          "args": [
            "reloc_root"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "__del_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1308-1331",
          "snippet": "static void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->next",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nvoid free_reloc_roots(struct list_head *list)\n{\n\tstruct btrfs_root *reloc_root;\n\n\twhile (!list_empty(list)) {\n\t\treloc_root = list_entry(list->next, struct btrfs_root,\n\t\t\t\t\troot_list);\n\t\t__del_reloc_root(reloc_root);\n\t}\n}"
  },
  {
    "function_name": "prepare_to_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2263-2334",
    "snippet": "static noinline_for_stack\nint prepare_to_merge(struct reloc_control *rc, int err)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_trans_handle *trans;\n\tLIST_HEAD(reloc_roots);\n\tu64 num_bytes = 0;\n\tint ret;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trc->merging_rsv_size += root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\trc->merging_rsv_size += rc->nodes_relocated * 2;\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\nagain:\n\tif (!err) {\n\t\tnum_bytes = rc->merging_rsv_size;\n\t\tret = btrfs_block_rsv_add(root, rc->block_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tif (!err)\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tif (!err) {\n\t\tif (num_bytes != rc->merging_rsv_size) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&rc->reloc_roots)) {\n\t\treloc_root = list_entry(rc->reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&reloc_root->root_list);\n\n\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t    reloc_root->root_key.offset);\n\t\tBUG_ON(IS_ERR(root));\n\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t/*\n\t\t * set reference count to 1, so btrfs_recover_relocation\n\t\t * knows it should resumes merging\n\t\t */\n\t\tif (!err)\n\t\t\tbtrfs_set_root_refs(&reloc_root->root_item, 1);\n\t\tbtrfs_update_reloc_root(trans, root);\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t}\n\n\tlist_splice(&reloc_roots, &rc->reloc_roots);\n\n\tif (!err)\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\n\telse\n\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "rc->extent_root"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&reloc_roots",
            "&rc->reloc_roots"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&reloc_root->root_list",
            "&reloc_roots"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_reloc_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1478-1509",
          "snippet": "int btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "&reloc_root->root_item",
            "1"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root->reloc_root != reloc_root"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(root)"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "reloc_root->fs_info",
            "reloc_root->root_key.offset"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&reloc_root->root_list"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rc->reloc_roots.next",
            "structbtrfs_root",
            "root_list"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&rc->reloc_roots"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_release",
          "args": [
            "rc->extent_root",
            "rc->block_rsv",
            "num_bytes"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4776-4786",
          "snippet": "void btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nvoid btrfs_block_rsv_release(struct btrfs_root *root,\n\t\t\t     struct btrfs_block_rsv *block_rsv,\n\t\t\t     u64 num_bytes)\n{\n\tstruct btrfs_block_rsv *global_rsv = &root->fs_info->global_block_rsv;\n\tif (global_rsv == block_rsv ||\n\t    block_rsv->space_info != global_rsv->space_info)\n\t\tglobal_rsv = NULL;\n\tblock_rsv_release_bytes(root->fs_info, block_rsv, global_rsv,\n\t\t\t\tnum_bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "rc->extent_root"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_add",
          "args": [
            "root",
            "rc->block_rsv",
            "num_bytes",
            "BTRFS_RESERVE_FLUSH_ALL"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4703-4719",
          "snippet": "int btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_block_rsv_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_block_rsv *block_rsv, u64 num_bytes,\n\t\t\tenum btrfs_reserve_flush_enum flush)\n{\n\tint ret;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 1);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&root->fs_info->reloc_mutex"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reloc_roots"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint prepare_to_merge(struct reloc_control *rc, int err)\n{\n\tstruct btrfs_root *root = rc->extent_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_trans_handle *trans;\n\tLIST_HEAD(reloc_roots);\n\tu64 num_bytes = 0;\n\tint ret;\n\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\trc->merging_rsv_size += root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\trc->merging_rsv_size += rc->nodes_relocated * 2;\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\nagain:\n\tif (!err) {\n\t\tnum_bytes = rc->merging_rsv_size;\n\t\tret = btrfs_block_rsv_add(root, rc->block_rsv, num_bytes,\n\t\t\t\t\t  BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret)\n\t\t\terr = ret;\n\t}\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tif (!err)\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\treturn PTR_ERR(trans);\n\t}\n\n\tif (!err) {\n\t\tif (num_bytes != rc->merging_rsv_size) {\n\t\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\t\t\tbtrfs_block_rsv_release(rc->extent_root,\n\t\t\t\t\t\trc->block_rsv, num_bytes);\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&rc->reloc_roots)) {\n\t\treloc_root = list_entry(rc->reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del_init(&reloc_root->root_list);\n\n\t\troot = read_fs_root(reloc_root->fs_info,\n\t\t\t\t    reloc_root->root_key.offset);\n\t\tBUG_ON(IS_ERR(root));\n\t\tBUG_ON(root->reloc_root != reloc_root);\n\n\t\t/*\n\t\t * set reference count to 1, so btrfs_recover_relocation\n\t\t * knows it should resumes merging\n\t\t */\n\t\tif (!err)\n\t\t\tbtrfs_set_root_refs(&reloc_root->root_item, 1);\n\t\tbtrfs_update_reloc_root(trans, root);\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\t}\n\n\tlist_splice(&reloc_roots, &rc->reloc_roots);\n\n\tif (!err)\n\t\tbtrfs_commit_transaction(trans, rc->extent_root);\n\telse\n\t\tbtrfs_end_transaction(trans, rc->extent_root);\n\treturn err;\n}"
  },
  {
    "function_name": "merge_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2110-2261",
    "snippet": "static noinline_for_stack int merge_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t       struct btrfs_root *root)\n{\n\tLIST_HEAD(inode_list);\n\tstruct btrfs_key key;\n\tstruct btrfs_key next_key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint level;\n\tint max_level;\n\tint replaced = 0;\n\tint ret;\n\tint err = 0;\n\tu32 min_reserved;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_root_level(root_item);\n\t\textent_buffer_get(reloc_root->node);\n\t\tpath->nodes[level] = reloc_root->node;\n\t\tpath->slots[level] = 0;\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, reloc_root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &next_key,\n\t\t\t\t      path->slots[level]);\n\t\tWARN_ON(memcmp(&key, &next_key, sizeof(key)));\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\t}\n\n\tmin_reserved = root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\tmemset(&next_key, 0, sizeof(next_key));\n\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(root, rc->block_rsv, min_reserved,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->block_rsv = rc->block_rsv;\n\n\t\treplaced = 0;\n\t\tmax_level = level;\n\n\t\tret = walk_down_reloc_tree(reloc_root, path, &level);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tif (!find_next_key(path, level, &key) &&\n\t\t    btrfs_comp_cpu_keys(&next_key, &key) >= 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = replace_path(trans, root, reloc_root, path,\n\t\t\t\t\t   &next_key, level, max_level);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tlevel = ret;\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t\t      path->slots[level]);\n\t\t\treplaced = 1;\n\t\t}\n\n\t\tret = walk_up_reloc_tree(reloc_root, path, &level);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tBUG_ON(level == 0);\n\t\t/*\n\t\t * save the merging progress in the drop_progress.\n\t\t * this is OK since root refs == 1 in this case.\n\t\t */\n\t\tbtrfs_node_key(path->nodes[level], &root_item->drop_progress,\n\t\t\t       path->slots[level]);\n\t\troot_item->drop_level = level;\n\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\t\ttrans = NULL;\n\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\t\tinvalidate_extent_cache(root, &key, &next_key);\n\t}\n\n\t/*\n\t * handle the case only one block in the fs tree need to be\n\t * relocated and the block is tree root.\n\t */\n\tleaf = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, leaf, NULL, 0, &leaf);\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tif (ret < 0)\n\t\terr = ret;\nout:\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(root_item->drop_progress));\n\t\troot_item->drop_level = 0;\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tbtrfs_update_reloc_root(trans, root);\n\t}\n\n\tif (trans)\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\n\tbtrfs_btree_balance_dirty(root);\n\n\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\tinvalidate_extent_cache(root, &key, &next_key);\n\n\treturn err;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPDATE_DATA_PTRS\t1"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_extent_cache",
          "args": [
            "root",
            "&key",
            "&next_key"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2020-2086",
          "snippet": "static int invalidate_extent_cache(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   struct btrfs_key *max_key)\n{\n\tstruct inode *inode = NULL;\n\tu64 objectid;\n\tu64 start, end;\n\tu64 ino;\n\n\tobjectid = min_key->objectid;\n\twhile (1) {\n\t\tcond_resched();\n\t\tiput(inode);\n\n\t\tif (objectid > max_key->objectid)\n\t\t\tbreak;\n\n\t\tinode = find_next_inode(root, objectid);\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tino = btrfs_ino(inode);\n\n\t\tif (ino > max_key->objectid) {\n\t\t\tiput(inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectid = ino + 1;\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tcontinue;\n\n\t\tif (unlikely(min_key->objectid == ino)) {\n\t\t\tif (min_key->type > BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (min_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tstart = 0;\n\t\t\telse {\n\t\t\t\tstart = min_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(start, root->sectorsize));\n\t\t\t}\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (unlikely(max_key->objectid == ino)) {\n\t\t\tif (max_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (max_key->type > BTRFS_EXTENT_DATA_KEY) {\n\t\t\t\tend = (u64)-1;\n\t\t\t} else {\n\t\t\t\tif (max_key->offset == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tend = max_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t}\n\t\t} else {\n\t\t\tend = (u64)-1;\n\t\t}\n\n\t\t/* the lock_extent waits for readpage to complete */\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tbtrfs_drop_extent_cache(inode, start, end, 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int invalidate_extent_cache(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   struct btrfs_key *max_key)\n{\n\tstruct inode *inode = NULL;\n\tu64 objectid;\n\tu64 start, end;\n\tu64 ino;\n\n\tobjectid = min_key->objectid;\n\twhile (1) {\n\t\tcond_resched();\n\t\tiput(inode);\n\n\t\tif (objectid > max_key->objectid)\n\t\t\tbreak;\n\n\t\tinode = find_next_inode(root, objectid);\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tino = btrfs_ino(inode);\n\n\t\tif (ino > max_key->objectid) {\n\t\t\tiput(inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectid = ino + 1;\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tcontinue;\n\n\t\tif (unlikely(min_key->objectid == ino)) {\n\t\t\tif (min_key->type > BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (min_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tstart = 0;\n\t\t\telse {\n\t\t\t\tstart = min_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(start, root->sectorsize));\n\t\t\t}\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (unlikely(max_key->objectid == ino)) {\n\t\t\tif (max_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (max_key->type > BTRFS_EXTENT_DATA_KEY) {\n\t\t\t\tend = (u64)-1;\n\t\t\t} else {\n\t\t\t\tif (max_key->offset == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tend = max_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t}\n\t\t} else {\n\t\t\tend = (u64)-1;\n\t\t}\n\n\t\t/* the lock_extent waits for readpage to complete */\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tbtrfs_drop_extent_cache(inode, start, end, 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_btree_balance_dirty",
          "args": [
            "root"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_btree_balance_dirty_nodelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3826-3829",
          "snippet": "void btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_btree_balance_dirty_nodelay(struct btrfs_root *root)\n{\n\t__btrfs_btree_balance_dirty(root, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction_throttle",
          "args": [
            "trans",
            "root"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_update_reloc_root",
          "args": [
            "trans",
            "root"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1478-1509",
          "snippet": "int btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "root_item",
            "0"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_item->drop_progress",
            "0",
            "sizeof(root_item->drop_progress)"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "leaf"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "leaf"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "leaf",
            "NULL",
            "0",
            "&leaf"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "root"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "path->nodes[level]",
            "&root_item->drop_progress",
            "path->slots[level]"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "136-142",
          "snippet": "void btrfs_node_key(struct extent_buffer *eb,\n\t\t    struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr = btrfs_node_key_ptr_offset(nr);\n\tread_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nvoid btrfs_node_key(struct extent_buffer *eb,\n\t\t    struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr = btrfs_node_key_ptr_offset(nr);\n\tread_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == 0"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_up_reloc_tree",
          "args": [
            "reloc_root",
            "path",
            "&level"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "walk_up_reloc_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1933-1965",
          "snippet": "static noinline_for_stack\nint walk_up_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       int *level)\n{\n\tstruct extent_buffer *eb;\n\tint i;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = 0; i < *level; i++) {\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL && path->nodes[i]; i++) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] + 1 < nritems) {\n\t\t\tpath->slots[i]++;\n\t\t\tif (btrfs_node_ptr_generation(eb, path->slots[i]) <=\n\t\t\t    last_snapshot)\n\t\t\t\tcontinue;\n\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint walk_up_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       int *level)\n{\n\tstruct extent_buffer *eb;\n\tint i;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = 0; i < *level; i++) {\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL && path->nodes[i]; i++) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] + 1 < nritems) {\n\t\t\tpath->slots[i]++;\n\t\t\tif (btrfs_node_ptr_generation(eb, path->slots[i]) <=\n\t\t\t    last_snapshot)\n\t\t\t\tcontinue;\n\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "path->nodes[level]",
            "&key",
            "path->slots[level]"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_path",
          "args": [
            "trans",
            "root",
            "reloc_root",
            "path",
            "&next_key",
            "level",
            "max_level"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "replace_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1760-1928",
          "snippet": "static noinline_for_stack\nint replace_path(struct btrfs_trans_handle *trans,\n\t\t struct btrfs_root *dest, struct btrfs_root *src,\n\t\t struct btrfs_path *path, struct btrfs_key *next_key,\n\t\t int lowest_level, int max_level)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent;\n\tstruct btrfs_key key;\n\tu64 old_bytenr;\n\tu64 new_bytenr;\n\tu64 old_ptr_gen;\n\tu64 new_ptr_gen;\n\tu64 last_snapshot;\n\tu32 blocksize;\n\tint cow = 0;\n\tint level;\n\tint ret;\n\tint slot;\n\n\tBUG_ON(src->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\tBUG_ON(dest->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\tlast_snapshot = btrfs_root_last_snapshot(&src->root_item);\nagain:\n\tslot = path->slots[lowest_level];\n\tbtrfs_node_key_to_cpu(path->nodes[lowest_level], &key, slot);\n\n\teb = btrfs_lock_root_node(dest);\n\tbtrfs_set_lock_blocking(eb);\n\tlevel = btrfs_header_level(eb);\n\n\tif (level < lowest_level) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t\treturn 0;\n\t}\n\n\tif (cow) {\n\t\tret = btrfs_cow_block(trans, dest, eb, NULL, 0, &eb);\n\t\tBUG_ON(ret);\n\t}\n\tbtrfs_set_lock_blocking(eb);\n\n\tif (next_key) {\n\t\tnext_key->objectid = (u64)-1;\n\t\tnext_key->type = (u8)-1;\n\t\tnext_key->offset = (u64)-1;\n\t}\n\n\tparent = eb;\n\twhile (1) {\n\t\tlevel = btrfs_header_level(parent);\n\t\tBUG_ON(level < lowest_level);\n\n\t\tret = btrfs_bin_search(parent, &key, level, &slot);\n\t\tif (ret && slot > 0)\n\t\t\tslot--;\n\n\t\tif (next_key && slot + 1 < btrfs_header_nritems(parent))\n\t\t\tbtrfs_node_key_to_cpu(parent, next_key, slot + 1);\n\n\t\told_bytenr = btrfs_node_blockptr(parent, slot);\n\t\tblocksize = dest->nodesize;\n\t\told_ptr_gen = btrfs_node_ptr_generation(parent, slot);\n\n\t\tif (level <= max_level) {\n\t\t\teb = path->nodes[level];\n\t\t\tnew_bytenr = btrfs_node_blockptr(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t\tnew_ptr_gen = btrfs_node_ptr_generation(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t} else {\n\t\t\tnew_bytenr = 0;\n\t\t\tnew_ptr_gen = 0;\n\t\t}\n\n\t\tif (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {\n\t\t\tret = level;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (new_bytenr == 0 || old_ptr_gen > last_snapshot ||\n\t\t    memcmp_node_keys(parent, slot, path, level)) {\n\t\t\tif (level <= lowest_level) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\teb = read_tree_block(dest, old_bytenr, old_ptr_gen);\n\t\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\t\tret = (!eb) ? -ENOMEM : -EIO;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (cow) {\n\t\t\t\tret = btrfs_cow_block(trans, dest, eb, parent,\n\t\t\t\t\t\t      slot, &eb);\n\t\t\t\tBUG_ON(ret);\n\t\t\t}\n\t\t\tbtrfs_set_lock_blocking(eb);\n\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\n\t\t\tparent = eb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cow) {\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\t\t\tcow = 1;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t      path->slots[level]);\n\t\tbtrfs_release_path(path);\n\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(trans, src, &key, path, 0, 1);\n\t\tpath->lowest_level = 0;\n\t\tBUG_ON(ret);\n\n\t\t/*\n\t\t * swap blocks in fs tree and reloc tree.\n\t\t */\n\t\tbtrfs_set_node_blockptr(parent, slot, new_bytenr);\n\t\tbtrfs_set_node_ptr_generation(parent, slot, new_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\tbtrfs_set_node_blockptr(path->nodes[level],\n\t\t\t\t\tpath->slots[level], old_bytenr);\n\t\tbtrfs_set_node_ptr_generation(path->nodes[level],\n\t\t\t\t\t      path->slots[level], old_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[level]);\n\n\t\tret = btrfs_inc_extent_ref(trans, src, old_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\t\tret = btrfs_inc_extent_ref(trans, dest, new_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, src, new_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, dest, old_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tret = level;\n\t\tbreak;\n\t}\n\tbtrfs_tree_unlock(parent);\n\tfree_extent_buffer(parent);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint replace_path(struct btrfs_trans_handle *trans,\n\t\t struct btrfs_root *dest, struct btrfs_root *src,\n\t\t struct btrfs_path *path, struct btrfs_key *next_key,\n\t\t int lowest_level, int max_level)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent;\n\tstruct btrfs_key key;\n\tu64 old_bytenr;\n\tu64 new_bytenr;\n\tu64 old_ptr_gen;\n\tu64 new_ptr_gen;\n\tu64 last_snapshot;\n\tu32 blocksize;\n\tint cow = 0;\n\tint level;\n\tint ret;\n\tint slot;\n\n\tBUG_ON(src->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\tBUG_ON(dest->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\tlast_snapshot = btrfs_root_last_snapshot(&src->root_item);\nagain:\n\tslot = path->slots[lowest_level];\n\tbtrfs_node_key_to_cpu(path->nodes[lowest_level], &key, slot);\n\n\teb = btrfs_lock_root_node(dest);\n\tbtrfs_set_lock_blocking(eb);\n\tlevel = btrfs_header_level(eb);\n\n\tif (level < lowest_level) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t\treturn 0;\n\t}\n\n\tif (cow) {\n\t\tret = btrfs_cow_block(trans, dest, eb, NULL, 0, &eb);\n\t\tBUG_ON(ret);\n\t}\n\tbtrfs_set_lock_blocking(eb);\n\n\tif (next_key) {\n\t\tnext_key->objectid = (u64)-1;\n\t\tnext_key->type = (u8)-1;\n\t\tnext_key->offset = (u64)-1;\n\t}\n\n\tparent = eb;\n\twhile (1) {\n\t\tlevel = btrfs_header_level(parent);\n\t\tBUG_ON(level < lowest_level);\n\n\t\tret = btrfs_bin_search(parent, &key, level, &slot);\n\t\tif (ret && slot > 0)\n\t\t\tslot--;\n\n\t\tif (next_key && slot + 1 < btrfs_header_nritems(parent))\n\t\t\tbtrfs_node_key_to_cpu(parent, next_key, slot + 1);\n\n\t\told_bytenr = btrfs_node_blockptr(parent, slot);\n\t\tblocksize = dest->nodesize;\n\t\told_ptr_gen = btrfs_node_ptr_generation(parent, slot);\n\n\t\tif (level <= max_level) {\n\t\t\teb = path->nodes[level];\n\t\t\tnew_bytenr = btrfs_node_blockptr(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t\tnew_ptr_gen = btrfs_node_ptr_generation(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t} else {\n\t\t\tnew_bytenr = 0;\n\t\t\tnew_ptr_gen = 0;\n\t\t}\n\n\t\tif (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {\n\t\t\tret = level;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (new_bytenr == 0 || old_ptr_gen > last_snapshot ||\n\t\t    memcmp_node_keys(parent, slot, path, level)) {\n\t\t\tif (level <= lowest_level) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\teb = read_tree_block(dest, old_bytenr, old_ptr_gen);\n\t\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\t\tret = (!eb) ? -ENOMEM : -EIO;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (cow) {\n\t\t\t\tret = btrfs_cow_block(trans, dest, eb, parent,\n\t\t\t\t\t\t      slot, &eb);\n\t\t\t\tBUG_ON(ret);\n\t\t\t}\n\t\t\tbtrfs_set_lock_blocking(eb);\n\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\n\t\t\tparent = eb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cow) {\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\t\t\tcow = 1;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t      path->slots[level]);\n\t\tbtrfs_release_path(path);\n\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(trans, src, &key, path, 0, 1);\n\t\tpath->lowest_level = 0;\n\t\tBUG_ON(ret);\n\n\t\t/*\n\t\t * swap blocks in fs tree and reloc tree.\n\t\t */\n\t\tbtrfs_set_node_blockptr(parent, slot, new_bytenr);\n\t\tbtrfs_set_node_ptr_generation(parent, slot, new_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\tbtrfs_set_node_blockptr(path->nodes[level],\n\t\t\t\t\tpath->slots[level], old_bytenr);\n\t\tbtrfs_set_node_ptr_generation(path->nodes[level],\n\t\t\t\t\t      path->slots[level], old_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[level]);\n\n\t\tret = btrfs_inc_extent_ref(trans, src, old_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\t\tret = btrfs_inc_extent_ref(trans, dest, new_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, src, new_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, dest, old_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tret = level;\n\t\tbreak;\n\t}\n\tbtrfs_tree_unlock(parent);\n\tfree_extent_buffer(parent);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&next_key",
            "&key"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_key",
          "args": [
            "path",
            "level",
            "&key"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "2088-2104",
          "snippet": "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key)\n\n{\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\tbreak;\n\t\tif (path->slots[level] + 1 <\n\t\t    btrfs_header_nritems(path->nodes[level])) {\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], key,\n\t\t\t\t\t      path->slots[level] + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tlevel++;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key)\n\n{\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\tbreak;\n\t\tif (path->slots[level] + 1 <\n\t\t    btrfs_header_nritems(path->nodes[level])) {\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], key,\n\t\t\t\t\t      path->slots[level] + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tlevel++;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_down_reloc_tree",
          "args": [
            "reloc_root",
            "path",
            "&level"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "walk_down_reloc_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1970-2014",
          "snippet": "static noinline_for_stack\nint walk_down_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t int *level)\n{\n\tstruct extent_buffer *eb = NULL;\n\tint i;\n\tu64 bytenr;\n\tu64 ptr_gen = 0;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = *level; i > 0; i--) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] < nritems) {\n\t\t\tptr_gen = btrfs_node_ptr_generation(eb, path->slots[i]);\n\t\t\tif (ptr_gen > last_snapshot)\n\t\t\t\tbreak;\n\t\t\tpath->slots[i]++;\n\t\t}\n\t\tif (path->slots[i] >= nritems) {\n\t\t\tif (i == *level)\n\t\t\t\tbreak;\n\t\t\t*level = i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == 1) {\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(eb, path->slots[i]);\n\t\teb = read_tree_block(root, bytenr, ptr_gen);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBUG_ON(btrfs_header_level(eb) != i - 1);\n\t\tpath->nodes[i - 1] = eb;\n\t\tpath->slots[i - 1] = 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint walk_down_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t int *level)\n{\n\tstruct extent_buffer *eb = NULL;\n\tint i;\n\tu64 bytenr;\n\tu64 ptr_gen = 0;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = *level; i > 0; i--) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] < nritems) {\n\t\t\tptr_gen = btrfs_node_ptr_generation(eb, path->slots[i]);\n\t\t\tif (ptr_gen > last_snapshot)\n\t\t\t\tbreak;\n\t\t\tpath->slots[i]++;\n\t\t}\n\t\tif (path->slots[i] >= nritems) {\n\t\t\tif (i == *level)\n\t\t\t\tbreak;\n\t\t\t*level = i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == 1) {\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(eb, path->slots[i]);\n\t\teb = read_tree_block(root, bytenr, ptr_gen);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBUG_ON(btrfs_header_level(eb) != i - 1);\n\t\tpath->nodes[i - 1] = eb;\n\t\tpath->slots[i - 1] = 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_block_rsv_refill",
          "args": [
            "root",
            "rc->block_rsv",
            "min_reserved",
            "BTRFS_RESERVE_FLUSH_ALL"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_rsv_refill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "4739-4767",
          "snippet": "int btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "int btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nint btrfs_pin_extent(struct btrfs_root *root,\n\t\t     u64 bytenr, u64 num_bytes, int reserved);\nstatic noinline struct;\n\nint btrfs_block_rsv_refill(struct btrfs_root *root,\n\t\t\t   struct btrfs_block_rsv *block_rsv, u64 min_reserved,\n\t\t\t   enum btrfs_reserve_flush_enum flush)\n{\n\tu64 num_bytes = 0;\n\tint ret = -ENOSPC;\n\n\tif (!block_rsv)\n\t\treturn 0;\n\n\tspin_lock(&block_rsv->lock);\n\tnum_bytes = min_reserved;\n\tif (block_rsv->reserved >= num_bytes)\n\t\tret = 0;\n\telse\n\t\tnum_bytes -= block_rsv->reserved;\n\tspin_unlock(&block_rsv->lock);\n\n\tif (!ret)\n\t\treturn 0;\n\n\tret = reserve_metadata_bytes(root, block_rsv, num_bytes, flush);\n\tif (!ret) {\n\t\tblock_rsv_add_bytes(block_rsv, num_bytes, 0);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&next_key",
            "0",
            "sizeof(next_key)"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "0"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "memcmp(&key, &next_key, sizeof(key))"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&key",
            "&next_key",
            "sizeof(key)"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "reloc_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == 0"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&key",
            "&root_item->drop_progress"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "reloc_root->node"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_level",
          "args": [
            "root_item"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_objectid",
          "args": [
            "&root_item->drop_progress"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "inode_list"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack int merge_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t       struct btrfs_root *root)\n{\n\tLIST_HEAD(inode_list);\n\tstruct btrfs_key key;\n\tstruct btrfs_key next_key;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tint level;\n\tint max_level;\n\tint replaced = 0;\n\tint ret;\n\tint err = 0;\n\tu32 min_reserved;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 1;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (btrfs_disk_key_objectid(&root_item->drop_progress) == 0) {\n\t\tlevel = btrfs_root_level(root_item);\n\t\textent_buffer_get(reloc_root->node);\n\t\tpath->nodes[level] = reloc_root->node;\n\t\tpath->slots[level] = 0;\n\t} else {\n\t\tbtrfs_disk_key_to_cpu(&key, &root_item->drop_progress);\n\n\t\tlevel = root_item->drop_level;\n\t\tBUG_ON(level == 0);\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(NULL, reloc_root, &key, path, 0, 0);\n\t\tpath->lowest_level = 0;\n\t\tif (ret < 0) {\n\t\t\tbtrfs_free_path(path);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &next_key,\n\t\t\t\t      path->slots[level]);\n\t\tWARN_ON(memcmp(&key, &next_key, sizeof(key)));\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\t}\n\n\tmin_reserved = root->nodesize * (BTRFS_MAX_LEVEL - 1) * 2;\n\tmemset(&next_key, 0, sizeof(next_key));\n\n\twhile (1) {\n\t\tret = btrfs_block_rsv_refill(root, rc->block_rsv, min_reserved,\n\t\t\t\t\t     BTRFS_RESERVE_FLUSH_ALL);\n\t\tif (ret) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans = btrfs_start_transaction(root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\ttrans = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\ttrans->block_rsv = rc->block_rsv;\n\n\t\treplaced = 0;\n\t\tmax_level = level;\n\n\t\tret = walk_down_reloc_tree(reloc_root, path, &level);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tif (!find_next_key(path, level, &key) &&\n\t\t    btrfs_comp_cpu_keys(&next_key, &key) >= 0) {\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = replace_path(trans, root, reloc_root, path,\n\t\t\t\t\t   &next_key, level, max_level);\n\t\t}\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\tlevel = ret;\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t\t      path->slots[level]);\n\t\t\treplaced = 1;\n\t\t}\n\n\t\tret = walk_up_reloc_tree(reloc_root, path, &level);\n\t\tif (ret > 0)\n\t\t\tbreak;\n\n\t\tBUG_ON(level == 0);\n\t\t/*\n\t\t * save the merging progress in the drop_progress.\n\t\t * this is OK since root refs == 1 in this case.\n\t\t */\n\t\tbtrfs_node_key(path->nodes[level], &root_item->drop_progress,\n\t\t\t       path->slots[level]);\n\t\troot_item->drop_level = level;\n\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\t\ttrans = NULL;\n\n\t\tbtrfs_btree_balance_dirty(root);\n\n\t\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\t\tinvalidate_extent_cache(root, &key, &next_key);\n\t}\n\n\t/*\n\t * handle the case only one block in the fs tree need to be\n\t * relocated and the block is tree root.\n\t */\n\tleaf = btrfs_lock_root_node(root);\n\tret = btrfs_cow_block(trans, root, leaf, NULL, 0, &leaf);\n\tbtrfs_tree_unlock(leaf);\n\tfree_extent_buffer(leaf);\n\tif (ret < 0)\n\t\terr = ret;\nout:\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(root_item->drop_progress));\n\t\troot_item->drop_level = 0;\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tbtrfs_update_reloc_root(trans, root);\n\t}\n\n\tif (trans)\n\t\tbtrfs_end_transaction_throttle(trans, root);\n\n\tbtrfs_btree_balance_dirty(root);\n\n\tif (replaced && rc->stage == UPDATE_DATA_PTRS)\n\t\tinvalidate_extent_cache(root, &key, &next_key);\n\n\treturn err;\n}"
  },
  {
    "function_name": "find_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2088-2104",
    "snippet": "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key)\n\n{\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\tbreak;\n\t\tif (path->slots[level] + 1 <\n\t\t    btrfs_header_nritems(path->nodes[level])) {\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], key,\n\t\t\t\t\t      path->slots[level] + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tlevel++;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "path->nodes[level]",
            "key",
            "path->slots[level] + 1"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[level]"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key)\n\n{\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\tbreak;\n\t\tif (path->slots[level] + 1 <\n\t\t    btrfs_header_nritems(path->nodes[level])) {\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[level], key,\n\t\t\t\t\t      path->slots[level] + 1);\n\t\t\treturn 0;\n\t\t}\n\t\tlevel++;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "invalidate_extent_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "2020-2086",
    "snippet": "static int invalidate_extent_cache(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   struct btrfs_key *max_key)\n{\n\tstruct inode *inode = NULL;\n\tu64 objectid;\n\tu64 start, end;\n\tu64 ino;\n\n\tobjectid = min_key->objectid;\n\twhile (1) {\n\t\tcond_resched();\n\t\tiput(inode);\n\n\t\tif (objectid > max_key->objectid)\n\t\t\tbreak;\n\n\t\tinode = find_next_inode(root, objectid);\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tino = btrfs_ino(inode);\n\n\t\tif (ino > max_key->objectid) {\n\t\t\tiput(inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectid = ino + 1;\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tcontinue;\n\n\t\tif (unlikely(min_key->objectid == ino)) {\n\t\t\tif (min_key->type > BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (min_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tstart = 0;\n\t\t\telse {\n\t\t\t\tstart = min_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(start, root->sectorsize));\n\t\t\t}\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (unlikely(max_key->objectid == ino)) {\n\t\t\tif (max_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (max_key->type > BTRFS_EXTENT_DATA_KEY) {\n\t\t\t\tend = (u64)-1;\n\t\t\t} else {\n\t\t\t\tif (max_key->offset == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tend = max_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t}\n\t\t} else {\n\t\t\tend = (u64)-1;\n\t\t}\n\n\t\t/* the lock_extent waits for readpage to complete */\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tbtrfs_drop_extent_cache(inode, start, end, 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "start",
            "end",
            "1"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "start",
            "end"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_ALIGNED(end, root->sectorsize)"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end",
            "root->sectorsize"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "max_key->objectid == ino"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_ALIGNED(start, root->sectorsize)"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "start",
            "root->sectorsize"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "min_key->objectid == ino"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_inode",
          "args": [
            "root",
            "objectid"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1515-1563",
          "snippet": "static struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int invalidate_extent_cache(struct btrfs_root *root,\n\t\t\t\t   struct btrfs_key *min_key,\n\t\t\t\t   struct btrfs_key *max_key)\n{\n\tstruct inode *inode = NULL;\n\tu64 objectid;\n\tu64 start, end;\n\tu64 ino;\n\n\tobjectid = min_key->objectid;\n\twhile (1) {\n\t\tcond_resched();\n\t\tiput(inode);\n\n\t\tif (objectid > max_key->objectid)\n\t\t\tbreak;\n\n\t\tinode = find_next_inode(root, objectid);\n\t\tif (!inode)\n\t\t\tbreak;\n\t\tino = btrfs_ino(inode);\n\n\t\tif (ino > max_key->objectid) {\n\t\t\tiput(inode);\n\t\t\tbreak;\n\t\t}\n\n\t\tobjectid = ino + 1;\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tcontinue;\n\n\t\tif (unlikely(min_key->objectid == ino)) {\n\t\t\tif (min_key->type > BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (min_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tstart = 0;\n\t\t\telse {\n\t\t\t\tstart = min_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(start, root->sectorsize));\n\t\t\t}\n\t\t} else {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif (unlikely(max_key->objectid == ino)) {\n\t\t\tif (max_key->type < BTRFS_EXTENT_DATA_KEY)\n\t\t\t\tcontinue;\n\t\t\tif (max_key->type > BTRFS_EXTENT_DATA_KEY) {\n\t\t\t\tend = (u64)-1;\n\t\t\t} else {\n\t\t\t\tif (max_key->offset == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tend = max_key->offset;\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t}\n\t\t} else {\n\t\t\tend = (u64)-1;\n\t\t}\n\n\t\t/* the lock_extent waits for readpage to complete */\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t\tbtrfs_drop_extent_cache(inode, start, end, 1);\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, start, end);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_down_reloc_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1970-2014",
    "snippet": "static noinline_for_stack\nint walk_down_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t int *level)\n{\n\tstruct extent_buffer *eb = NULL;\n\tint i;\n\tu64 bytenr;\n\tu64 ptr_gen = 0;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = *level; i > 0; i--) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] < nritems) {\n\t\t\tptr_gen = btrfs_node_ptr_generation(eb, path->slots[i]);\n\t\t\tif (ptr_gen > last_snapshot)\n\t\t\t\tbreak;\n\t\t\tpath->slots[i]++;\n\t\t}\n\t\tif (path->slots[i] >= nritems) {\n\t\t\tif (i == *level)\n\t\t\t\tbreak;\n\t\t\t*level = i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == 1) {\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(eb, path->slots[i]);\n\t\teb = read_tree_block(root, bytenr, ptr_gen);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBUG_ON(btrfs_header_level(eb) != i - 1);\n\t\tpath->nodes[i - 1] = eb;\n\t\tpath->slots[i - 1] = 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_header_level(eb) != i - 1"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "bytenr",
            "ptr_gen"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "eb",
            "path->slots[i]"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "eb",
            "path->slots[i]"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&root->root_item"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint walk_down_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t int *level)\n{\n\tstruct extent_buffer *eb = NULL;\n\tint i;\n\tu64 bytenr;\n\tu64 ptr_gen = 0;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = *level; i > 0; i--) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] < nritems) {\n\t\t\tptr_gen = btrfs_node_ptr_generation(eb, path->slots[i]);\n\t\t\tif (ptr_gen > last_snapshot)\n\t\t\t\tbreak;\n\t\t\tpath->slots[i]++;\n\t\t}\n\t\tif (path->slots[i] >= nritems) {\n\t\t\tif (i == *level)\n\t\t\t\tbreak;\n\t\t\t*level = i + 1;\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == 1) {\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbytenr = btrfs_node_blockptr(eb, path->slots[i]);\n\t\teb = read_tree_block(root, bytenr, ptr_gen);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tBUG_ON(btrfs_header_level(eb) != i - 1);\n\t\tpath->nodes[i - 1] = eb;\n\t\tpath->slots[i - 1] = 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "walk_up_reloc_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1933-1965",
    "snippet": "static noinline_for_stack\nint walk_up_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       int *level)\n{\n\tstruct extent_buffer *eb;\n\tint i;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = 0; i < *level; i++) {\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL && path->nodes[i]; i++) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] + 1 < nritems) {\n\t\t\tpath->slots[i]++;\n\t\t\tif (btrfs_node_ptr_generation(eb, path->slots[i]) <=\n\t\t\t    last_snapshot)\n\t\t\t\tcontinue;\n\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "path->nodes[i]"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "eb",
            "path->slots[i]"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&root->root_item"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint walk_up_reloc_tree(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       int *level)\n{\n\tstruct extent_buffer *eb;\n\tint i;\n\tu64 last_snapshot;\n\tu32 nritems;\n\n\tlast_snapshot = btrfs_root_last_snapshot(&root->root_item);\n\n\tfor (i = 0; i < *level; i++) {\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\n\tfor (i = *level; i < BTRFS_MAX_LEVEL && path->nodes[i]; i++) {\n\t\teb = path->nodes[i];\n\t\tnritems = btrfs_header_nritems(eb);\n\t\twhile (path->slots[i] + 1 < nritems) {\n\t\t\tpath->slots[i]++;\n\t\t\tif (btrfs_node_ptr_generation(eb, path->slots[i]) <=\n\t\t\t    last_snapshot)\n\t\t\t\tcontinue;\n\n\t\t\t*level = i;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(path->nodes[i]);\n\t\tpath->nodes[i] = NULL;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "replace_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1760-1928",
    "snippet": "static noinline_for_stack\nint replace_path(struct btrfs_trans_handle *trans,\n\t\t struct btrfs_root *dest, struct btrfs_root *src,\n\t\t struct btrfs_path *path, struct btrfs_key *next_key,\n\t\t int lowest_level, int max_level)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent;\n\tstruct btrfs_key key;\n\tu64 old_bytenr;\n\tu64 new_bytenr;\n\tu64 old_ptr_gen;\n\tu64 new_ptr_gen;\n\tu64 last_snapshot;\n\tu32 blocksize;\n\tint cow = 0;\n\tint level;\n\tint ret;\n\tint slot;\n\n\tBUG_ON(src->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\tBUG_ON(dest->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\tlast_snapshot = btrfs_root_last_snapshot(&src->root_item);\nagain:\n\tslot = path->slots[lowest_level];\n\tbtrfs_node_key_to_cpu(path->nodes[lowest_level], &key, slot);\n\n\teb = btrfs_lock_root_node(dest);\n\tbtrfs_set_lock_blocking(eb);\n\tlevel = btrfs_header_level(eb);\n\n\tif (level < lowest_level) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t\treturn 0;\n\t}\n\n\tif (cow) {\n\t\tret = btrfs_cow_block(trans, dest, eb, NULL, 0, &eb);\n\t\tBUG_ON(ret);\n\t}\n\tbtrfs_set_lock_blocking(eb);\n\n\tif (next_key) {\n\t\tnext_key->objectid = (u64)-1;\n\t\tnext_key->type = (u8)-1;\n\t\tnext_key->offset = (u64)-1;\n\t}\n\n\tparent = eb;\n\twhile (1) {\n\t\tlevel = btrfs_header_level(parent);\n\t\tBUG_ON(level < lowest_level);\n\n\t\tret = btrfs_bin_search(parent, &key, level, &slot);\n\t\tif (ret && slot > 0)\n\t\t\tslot--;\n\n\t\tif (next_key && slot + 1 < btrfs_header_nritems(parent))\n\t\t\tbtrfs_node_key_to_cpu(parent, next_key, slot + 1);\n\n\t\told_bytenr = btrfs_node_blockptr(parent, slot);\n\t\tblocksize = dest->nodesize;\n\t\told_ptr_gen = btrfs_node_ptr_generation(parent, slot);\n\n\t\tif (level <= max_level) {\n\t\t\teb = path->nodes[level];\n\t\t\tnew_bytenr = btrfs_node_blockptr(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t\tnew_ptr_gen = btrfs_node_ptr_generation(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t} else {\n\t\t\tnew_bytenr = 0;\n\t\t\tnew_ptr_gen = 0;\n\t\t}\n\n\t\tif (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {\n\t\t\tret = level;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (new_bytenr == 0 || old_ptr_gen > last_snapshot ||\n\t\t    memcmp_node_keys(parent, slot, path, level)) {\n\t\t\tif (level <= lowest_level) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\teb = read_tree_block(dest, old_bytenr, old_ptr_gen);\n\t\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\t\tret = (!eb) ? -ENOMEM : -EIO;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (cow) {\n\t\t\t\tret = btrfs_cow_block(trans, dest, eb, parent,\n\t\t\t\t\t\t      slot, &eb);\n\t\t\t\tBUG_ON(ret);\n\t\t\t}\n\t\t\tbtrfs_set_lock_blocking(eb);\n\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\n\t\t\tparent = eb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cow) {\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\t\t\tcow = 1;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t      path->slots[level]);\n\t\tbtrfs_release_path(path);\n\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(trans, src, &key, path, 0, 1);\n\t\tpath->lowest_level = 0;\n\t\tBUG_ON(ret);\n\n\t\t/*\n\t\t * swap blocks in fs tree and reloc tree.\n\t\t */\n\t\tbtrfs_set_node_blockptr(parent, slot, new_bytenr);\n\t\tbtrfs_set_node_ptr_generation(parent, slot, new_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\tbtrfs_set_node_blockptr(path->nodes[level],\n\t\t\t\t\tpath->slots[level], old_bytenr);\n\t\tbtrfs_set_node_ptr_generation(path->nodes[level],\n\t\t\t\t\t      path->slots[level], old_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[level]);\n\n\t\tret = btrfs_inc_extent_ref(trans, src, old_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\t\tret = btrfs_inc_extent_ref(trans, dest, new_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, src, new_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, dest, old_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tret = level;\n\t\tbreak;\n\t}\n\tbtrfs_tree_unlock(parent);\n\tfree_extent_buffer(parent);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "parent"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "parent"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "0"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_extent",
          "args": [
            "trans",
            "dest",
            "old_bytenr",
            "blocksize",
            "0",
            "dest->root_key.objectid",
            "level - 1",
            "0",
            "1"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6249-6283",
          "snippet": "int btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "dest",
            "new_bytenr",
            "blocksize",
            "0",
            "dest->root_key.objectid",
            "level - 1",
            "0",
            "1"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[level]"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "path->nodes[level]",
            "path->slots[level]",
            "old_ptr_gen"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "path->nodes[level]",
            "path->slots[level]",
            "old_bytenr"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "src",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "path->nodes[level]",
            "&key",
            "path->slots[level]"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "eb"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "dest",
            "eb",
            "parent",
            "slot",
            "&eb"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "eb"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "dest",
            "old_bytenr",
            "old_ptr_gen"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp_node_keys",
          "args": [
            "parent",
            "slot",
            "path",
            "level"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_node_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1740-1749",
          "snippet": "static noinline_for_stack\nint memcmp_node_keys(struct extent_buffer *eb, int slot,\n\t\t     struct btrfs_path *path, int level)\n{\n\tstruct btrfs_disk_key key1;\n\tstruct btrfs_disk_key key2;\n\tbtrfs_node_key(eb, &key1, slot);\n\tbtrfs_node_key(path->nodes[level], &key2, path->slots[level]);\n\treturn memcmp(&key1, &key2, sizeof(key1));\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint memcmp_node_keys(struct extent_buffer *eb, int slot,\n\t\t     struct btrfs_path *path, int level)\n{\n\tstruct btrfs_disk_key key1;\n\tstruct btrfs_disk_key key2;\n\tbtrfs_node_key(eb, &key1, slot);\n\tbtrfs_node_key(path->nodes[level], &key2, path->slots[level]);\n\treturn memcmp(&key1, &key2, sizeof(key1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "new_bytenr > 0 && new_bytenr == old_bytenr"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "eb",
            "path->slots[level]"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "eb",
            "path->slots[level]"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "parent"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bin_search",
          "args": [
            "parent",
            "&key",
            "level",
            "&slot"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level < lowest_level"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "parent"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "dest"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&src->root_item"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dest->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "src->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint replace_path(struct btrfs_trans_handle *trans,\n\t\t struct btrfs_root *dest, struct btrfs_root *src,\n\t\t struct btrfs_path *path, struct btrfs_key *next_key,\n\t\t int lowest_level, int max_level)\n{\n\tstruct extent_buffer *eb;\n\tstruct extent_buffer *parent;\n\tstruct btrfs_key key;\n\tu64 old_bytenr;\n\tu64 new_bytenr;\n\tu64 old_ptr_gen;\n\tu64 new_ptr_gen;\n\tu64 last_snapshot;\n\tu32 blocksize;\n\tint cow = 0;\n\tint level;\n\tint ret;\n\tint slot;\n\n\tBUG_ON(src->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID);\n\tBUG_ON(dest->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\tlast_snapshot = btrfs_root_last_snapshot(&src->root_item);\nagain:\n\tslot = path->slots[lowest_level];\n\tbtrfs_node_key_to_cpu(path->nodes[lowest_level], &key, slot);\n\n\teb = btrfs_lock_root_node(dest);\n\tbtrfs_set_lock_blocking(eb);\n\tlevel = btrfs_header_level(eb);\n\n\tif (level < lowest_level) {\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t\treturn 0;\n\t}\n\n\tif (cow) {\n\t\tret = btrfs_cow_block(trans, dest, eb, NULL, 0, &eb);\n\t\tBUG_ON(ret);\n\t}\n\tbtrfs_set_lock_blocking(eb);\n\n\tif (next_key) {\n\t\tnext_key->objectid = (u64)-1;\n\t\tnext_key->type = (u8)-1;\n\t\tnext_key->offset = (u64)-1;\n\t}\n\n\tparent = eb;\n\twhile (1) {\n\t\tlevel = btrfs_header_level(parent);\n\t\tBUG_ON(level < lowest_level);\n\n\t\tret = btrfs_bin_search(parent, &key, level, &slot);\n\t\tif (ret && slot > 0)\n\t\t\tslot--;\n\n\t\tif (next_key && slot + 1 < btrfs_header_nritems(parent))\n\t\t\tbtrfs_node_key_to_cpu(parent, next_key, slot + 1);\n\n\t\told_bytenr = btrfs_node_blockptr(parent, slot);\n\t\tblocksize = dest->nodesize;\n\t\told_ptr_gen = btrfs_node_ptr_generation(parent, slot);\n\n\t\tif (level <= max_level) {\n\t\t\teb = path->nodes[level];\n\t\t\tnew_bytenr = btrfs_node_blockptr(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t\tnew_ptr_gen = btrfs_node_ptr_generation(eb,\n\t\t\t\t\t\t\tpath->slots[level]);\n\t\t} else {\n\t\t\tnew_bytenr = 0;\n\t\t\tnew_ptr_gen = 0;\n\t\t}\n\n\t\tif (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {\n\t\t\tret = level;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (new_bytenr == 0 || old_ptr_gen > last_snapshot ||\n\t\t    memcmp_node_keys(parent, slot, path, level)) {\n\t\t\tif (level <= lowest_level) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\teb = read_tree_block(dest, old_bytenr, old_ptr_gen);\n\t\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\t\tret = (!eb) ? -ENOMEM : -EIO;\n\t\t\t\tfree_extent_buffer(eb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbtrfs_tree_lock(eb);\n\t\t\tif (cow) {\n\t\t\t\tret = btrfs_cow_block(trans, dest, eb, parent,\n\t\t\t\t\t\t      slot, &eb);\n\t\t\t\tBUG_ON(ret);\n\t\t\t}\n\t\t\tbtrfs_set_lock_blocking(eb);\n\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\n\t\t\tparent = eb;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cow) {\n\t\t\tbtrfs_tree_unlock(parent);\n\t\t\tfree_extent_buffer(parent);\n\t\t\tcow = 1;\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_node_key_to_cpu(path->nodes[level], &key,\n\t\t\t\t      path->slots[level]);\n\t\tbtrfs_release_path(path);\n\n\t\tpath->lowest_level = level;\n\t\tret = btrfs_search_slot(trans, src, &key, path, 0, 1);\n\t\tpath->lowest_level = 0;\n\t\tBUG_ON(ret);\n\n\t\t/*\n\t\t * swap blocks in fs tree and reloc tree.\n\t\t */\n\t\tbtrfs_set_node_blockptr(parent, slot, new_bytenr);\n\t\tbtrfs_set_node_ptr_generation(parent, slot, new_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\tbtrfs_set_node_blockptr(path->nodes[level],\n\t\t\t\t\tpath->slots[level], old_bytenr);\n\t\tbtrfs_set_node_ptr_generation(path->nodes[level],\n\t\t\t\t\t      path->slots[level], old_ptr_gen);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[level]);\n\n\t\tret = btrfs_inc_extent_ref(trans, src, old_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\t\tret = btrfs_inc_extent_ref(trans, dest, new_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, src, new_bytenr, blocksize,\n\t\t\t\t\tpath->nodes[level]->start,\n\t\t\t\t\tsrc->root_key.objectid, level - 1, 0,\n\t\t\t\t\t1);\n\t\tBUG_ON(ret);\n\n\t\tret = btrfs_free_extent(trans, dest, old_bytenr, blocksize,\n\t\t\t\t\t0, dest->root_key.objectid, level - 1,\n\t\t\t\t\t0, 1);\n\t\tBUG_ON(ret);\n\n\t\tbtrfs_unlock_up_safe(path, 0);\n\n\t\tret = level;\n\t\tbreak;\n\t}\n\tbtrfs_tree_unlock(parent);\n\tfree_extent_buffer(parent);\n\treturn ret;\n}"
  },
  {
    "function_name": "memcmp_node_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1740-1749",
    "snippet": "static noinline_for_stack\nint memcmp_node_keys(struct extent_buffer *eb, int slot,\n\t\t     struct btrfs_path *path, int level)\n{\n\tstruct btrfs_disk_key key1;\n\tstruct btrfs_disk_key key2;\n\tbtrfs_node_key(eb, &key1, slot);\n\tbtrfs_node_key(path->nodes[level], &key2, path->slots[level]);\n\treturn memcmp(&key1, &key2, sizeof(key1));\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&key1",
            "&key2",
            "sizeof(key1)"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "path->nodes[level]",
            "&key2",
            "path->slots[level]"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "136-142",
          "snippet": "void btrfs_node_key(struct extent_buffer *eb,\n\t\t    struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr = btrfs_node_key_ptr_offset(nr);\n\tread_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nvoid btrfs_node_key(struct extent_buffer *eb,\n\t\t    struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr = btrfs_node_key_ptr_offset(nr);\n\tread_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint memcmp_node_keys(struct extent_buffer *eb, int slot,\n\t\t     struct btrfs_path *path, int level)\n{\n\tstruct btrfs_disk_key key1;\n\tstruct btrfs_disk_key key2;\n\tbtrfs_node_key(eb, &key1, slot);\n\tbtrfs_node_key(path->nodes[level], &key2, path->slots[level]);\n\treturn memcmp(&key1, &key2, sizeof(key1));\n}"
  },
  {
    "function_name": "replace_file_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1625-1738",
    "snippet": "static noinline_for_stack\nint replace_file_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct inode *inode = NULL;\n\tu64 parent;\n\tu64 bytenr;\n\tu64 new_bytenr = 0;\n\tu64 num_bytes;\n\tu64 end;\n\tu32 nritems;\n\tu32 i;\n\tint ret = 0;\n\tint first = 1;\n\tint dirty = 0;\n\n\tif (rc->stage != UPDATE_DATA_PTRS)\n\t\treturn 0;\n\n\t/* reloc trees always use full backref */\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tparent = leaf->start;\n\telse\n\t\tparent = 0;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tfor (i = 0; i < nritems; i++) {\n\t\tcond_resched();\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tif (bytenr == 0)\n\t\t\tcontinue;\n\t\tif (!in_block_group(bytenr, rc->block_group))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are modifying block in fs tree, wait for readpage\n\t\t * to complete and drop the extent cache\n\t\t */\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tif (first) {\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t\tfirst = 0;\n\t\t\t} else if (inode && btrfs_ino(inode) < key.objectid) {\n\t\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t}\n\t\t\tif (inode && btrfs_ino(inode) == key.objectid) {\n\t\t\t\tend = key.offset +\n\t\t\t\t      btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tWARN_ON(!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    root->sectorsize));\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t\tret = try_lock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t\t      key.offset, end);\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbtrfs_drop_extent_cache(inode, key.offset, end,\n\t\t\t\t\t\t\t1);\n\t\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t      key.offset, end);\n\t\t\t}\n\t\t}\n\n\t\tret = get_new_location(rc->data_inode, &new_bytenr,\n\t\t\t\t       bytenr, num_bytes);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * Don't have to abort since we've not changed anything\n\t\t\t * in the file extent yet.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, new_bytenr);\n\t\tdirty = 1;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tret = btrfs_inc_extent_ref(trans, root, new_bytenr,\n\t\t\t\t\t   num_bytes, parent,\n\t\t\t\t\t   btrfs_header_owner(leaf),\n\t\t\t\t\t   key.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\tparent, btrfs_header_owner(leaf),\n\t\t\t\t\tkey.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirty)\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\tif (inode)\n\t\tbtrfs_add_delayed_iput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPDATE_DATA_PTRS\t1"
    ],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_add_delayed_iput",
          "args": [
            "inode"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_add_delayed_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3084-3098",
          "snippet": "void btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_add_delayed_iput(struct inode *inode)\n{\n\tstruct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;\n\tstruct delayed_iput *delayed;\n\n\tif (atomic_add_unless(&inode->i_count, -1, 1))\n\t\treturn;\n\n\tdelayed = kmalloc(sizeof(*delayed), GFP_NOFS | __GFP_NOFAIL);\n\tdelayed->inode = inode;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_add_tail(&delayed->list, &fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_extent",
          "args": [
            "trans",
            "root",
            "bytenr",
            "num_bytes",
            "parent",
            "btrfs_header_owner(leaf)",
            "key.objectid",
            "key.offset",
            "1"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6249-6283",
          "snippet": "int btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_free_extent(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      u64 bytenr, u64 num_bytes, u64 parent, u64 root_objectid,\n\t\t      u64 owner, u64 offset, int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tadd_pinned_bytes(root->fs_info, num_bytes, owner, root_objectid);\n\n\t/*\n\t * tree log blocks never actually go into the extent allocation\n\t * tree, just update pinning info and exit early.\n\t */\n\tif (root_objectid == BTRFS_TREE_LOG_OBJECTID) {\n\t\tWARN_ON(owner >= BTRFS_FIRST_FREE_OBJECTID);\n\t\t/* unlocks the pinned mutex */\n\t\tbtrfs_pin_extent(root, bytenr, num_bytes, 1);\n\t\tret = 0;\n\t} else if (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\t\tnum_bytes,\n\t\t\t\t\t\tparent, root_objectid, owner,\n\t\t\t\t\t\toffset, BTRFS_DROP_DELAYED_REF,\n\t\t\t\t\t\tNULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "leaf"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_extent_ref",
          "args": [
            "trans",
            "root",
            "new_bytenr",
            "num_bytes",
            "parent",
            "btrfs_header_owner(leaf)",
            "key.objectid",
            "key.offset",
            "1"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_extent_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "1942-1966",
          "snippet": "int btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);",
            "static int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);",
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int __btrfs_free_extent(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t\tu64 root_objectid, u64 owner_objectid,\n\t\t\t\tu64 owner_offset, int refs_to_drop,\n\t\t\t\tstruct btrfs_delayed_extent_op *extra_op,\n\t\t\t\tint no_quota);\nstatic int alloc_reserved_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     u64 parent, u64 root_objectid,\n\t\t\t\t     u64 flags, struct btrfs_disk_key *key,\n\t\t\t\t     int level, struct btrfs_key *ins,\n\t\t\t\t     int no_quota);\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_inc_extent_ref(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t u64 bytenr, u64 num_bytes, u64 parent,\n\t\t\t u64 root_objectid, u64 owner, u64 offset,\n\t\t\t int no_quota)\n{\n\tint ret;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tBUG_ON(owner < BTRFS_FIRST_FREE_OBJECTID &&\n\t       root_objectid == BTRFS_TREE_LOG_OBJECTID);\n\n\tif (owner < BTRFS_FIRST_FREE_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, (int)owner,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t} else {\n\t\tret = btrfs_add_delayed_data_ref(fs_info, trans, bytenr,\n\t\t\t\t\tnum_bytes,\n\t\t\t\t\tparent, root_objectid, owner, offset,\n\t\t\t\t\tBTRFS_ADD_DELAYED_REF, NULL, no_quota);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "leaf"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi",
            "new_bytenr"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_new_location",
          "args": [
            "rc->data_inode",
            "&new_bytenr",
            "bytenr",
            "num_bytes"
          ],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "get_new_location",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1577-1619",
          "snippet": "static int get_new_location(struct inode *reloc_inode, u64 *new_bytenr,\n\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(reloc_inode)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbytenr -= BTRFS_I(reloc_inode)->index_cnt;\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(reloc_inode),\n\t\t\t\t       bytenr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tBUG_ON(btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi));\n\n\tif (num_bytes != btrfs_file_extent_disk_num_bytes(leaf, fi)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*new_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_new_location(struct inode *reloc_inode, u64 *new_bytenr,\n\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(reloc_inode)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbytenr -= BTRFS_I(reloc_inode)->index_cnt;\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(reloc_inode),\n\t\t\t\t       bytenr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tBUG_ON(btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi));\n\n\tif (num_bytes != btrfs_file_extent_disk_num_bytes(leaf, fi)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*new_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "key.offset",
            "end"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_drop_extent_cache",
          "args": [
            "inode",
            "key.offset",
            "end",
            "1"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_drop_extent_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "535-684",
          "snippet": "void btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nvoid btrfs_drop_extent_cache(struct inode *inode, u64 start, u64 end,\n\t\t\t     int skip_pinned)\n{\n\tstruct extent_map *em;\n\tstruct extent_map *split = NULL;\n\tstruct extent_map *split2 = NULL;\n\tstruct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;\n\tu64 len = end - start + 1;\n\tu64 gen;\n\tint ret;\n\tint testend = 1;\n\tunsigned long flags;\n\tint compressed = 0;\n\tbool modified;\n\n\tWARN_ON(end < start);\n\tif (end == (u64)-1) {\n\t\tlen = (u64)-1;\n\t\ttestend = 0;\n\t}\n\twhile (1) {\n\t\tint no_splits = 0;\n\n\t\tmodified = false;\n\t\tif (!split)\n\t\t\tsplit = alloc_extent_map();\n\t\tif (!split2)\n\t\t\tsplit2 = alloc_extent_map();\n\t\tif (!split || !split2)\n\t\t\tno_splits = 1;\n\n\t\twrite_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, start, len);\n\t\tif (!em) {\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tbreak;\n\t\t}\n\t\tflags = em->flags;\n\t\tgen = em->generation;\n\t\tif (skip_pinned && test_bit(EXTENT_FLAG_PINNED, &em->flags)) {\n\t\t\tif (testend && em->start + em->len >= start + len) {\n\t\t\t\tfree_extent_map(em);\n\t\t\t\twrite_unlock(&em_tree->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = em->start + em->len;\n\t\t\tif (testend)\n\t\t\t\tlen = start + len - (em->start + em->len);\n\t\t\tfree_extent_map(em);\n\t\t\twrite_unlock(&em_tree->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tcompressed = test_bit(EXTENT_FLAG_COMPRESSED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_PINNED, &em->flags);\n\t\tclear_bit(EXTENT_FLAG_LOGGING, &flags);\n\t\tmodified = !list_empty(&em->list);\n\t\tif (no_splits)\n\t\t\tgoto next;\n\n\t\tif (em->start < start) {\n\t\t\tsplit->start = em->start;\n\t\t\tsplit->len = start - em->start;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\tsplit->block_start = em->block_start;\n\n\t\t\t\tif (compressed)\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\telse\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\tsplit->orig_block_len = max(split->block_len,\n\t\t\t\t\t\tem->orig_block_len);\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t} else {\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t}\n\n\t\t\tsplit->generation = gen;\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\treplace_extent_mapping(em_tree, em, split, modified);\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = split2;\n\t\t\tsplit2 = NULL;\n\t\t}\n\t\tif (testend && em->start + em->len > start + len) {\n\t\t\tu64 diff = start + len - em->start;\n\n\t\t\tsplit->start = start + len;\n\t\t\tsplit->len = em->start + em->len - (start + len);\n\t\t\tsplit->bdev = em->bdev;\n\t\t\tsplit->flags = flags;\n\t\t\tsplit->compress_type = em->compress_type;\n\t\t\tsplit->generation = gen;\n\n\t\t\tif (em->block_start < EXTENT_MAP_LAST_BYTE) {\n\t\t\t\tsplit->orig_block_len = max(em->block_len,\n\t\t\t\t\t\t    em->orig_block_len);\n\n\t\t\t\tsplit->ram_bytes = em->ram_bytes;\n\t\t\t\tif (compressed) {\n\t\t\t\t\tsplit->block_len = em->block_len;\n\t\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t} else {\n\t\t\t\t\tsplit->block_len = split->len;\n\t\t\t\t\tsplit->block_start = em->block_start\n\t\t\t\t\t\t+ diff;\n\t\t\t\t\tsplit->orig_start = em->orig_start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsplit->ram_bytes = split->len;\n\t\t\t\tsplit->orig_start = split->start;\n\t\t\t\tsplit->block_len = 0;\n\t\t\t\tsplit->block_start = em->block_start;\n\t\t\t\tsplit->orig_block_len = 0;\n\t\t\t}\n\n\t\t\tif (extent_map_in_tree(em)) {\n\t\t\t\treplace_extent_mapping(em_tree, em, split,\n\t\t\t\t\t\t       modified);\n\t\t\t} else {\n\t\t\t\tret = add_extent_mapping(em_tree, split,\n\t\t\t\t\t\t\t modified);\n\t\t\t\tASSERT(ret == 0); /* Logic error */\n\t\t\t}\n\t\t\tfree_extent_map(split);\n\t\t\tsplit = NULL;\n\t\t}\nnext:\n\t\tif (extent_map_in_tree(em))\n\t\t\tremove_extent_mapping(em_tree, em);\n\t\twrite_unlock(&em_tree->lock);\n\n\t\t/* once for us */\n\t\tfree_extent_map(em);\n\t\t/* once for the tree*/\n\t\tfree_extent_map(em);\n\t}\n\tif (split)\n\t\tfree_extent_map(split);\n\tif (split2)\n\t\tfree_extent_map(split2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_lock_extent",
          "args": [
            "&BTRFS_I(inode)->io_tree",
            "key.offset",
            "end"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "try_lock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1357-1371",
          "snippet": "int try_lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tint err;\n\tu64 failed_start;\n\n\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED, EXTENT_LOCKED,\n\t\t\t       &failed_start, NULL, GFP_NOFS);\n\tif (err == -EEXIST) {\n\t\tif (failed_start > start)\n\t\t\tclear_extent_bit(tree, start, failed_start - 1,\n\t\t\t\t\t EXTENT_LOCKED, 1, 0, NULL, GFP_NOFS);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint try_lock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\tint err;\n\tu64 failed_start;\n\n\terr = __set_extent_bit(tree, start, end, EXTENT_LOCKED, EXTENT_LOCKED,\n\t\t\t       &failed_start, NULL, GFP_NOFS);\n\tif (err == -EEXIST) {\n\t\tif (failed_start > start)\n\t\t\tclear_extent_bit(tree, start, failed_start - 1,\n\t\t\t\t\t EXTENT_LOCKED, 1, 0, NULL, GFP_NOFS);\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_ALIGNED(end, root->sectorsize)"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "end",
            "root->sectorsize"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    root->sectorsize)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "key.offset",
            "root->sectorsize"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_inode",
          "args": [
            "root",
            "key.objectid"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1515-1563",
          "snippet": "static struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_block_group",
          "args": [
            "bytenr",
            "rc->block_group"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "in_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1565-1572",
          "snippet": "static int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "i",
            "structbtrfs_file_extent_item"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "i"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint replace_file_extents(struct btrfs_trans_handle *trans,\n\t\t\t struct reloc_control *rc,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct extent_buffer *leaf)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct inode *inode = NULL;\n\tu64 parent;\n\tu64 bytenr;\n\tu64 new_bytenr = 0;\n\tu64 num_bytes;\n\tu64 end;\n\tu32 nritems;\n\tu32 i;\n\tint ret = 0;\n\tint first = 1;\n\tint dirty = 0;\n\n\tif (rc->stage != UPDATE_DATA_PTRS)\n\t\treturn 0;\n\n\t/* reloc trees always use full backref */\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tparent = leaf->start;\n\telse\n\t\tparent = 0;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tfor (i = 0; i < nritems; i++) {\n\t\tcond_resched();\n\t\tbtrfs_item_key_to_cpu(leaf, &key, i);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(leaf, i, struct btrfs_file_extent_item);\n\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t    BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\tbytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\t\tnum_bytes = btrfs_file_extent_disk_num_bytes(leaf, fi);\n\t\tif (bytenr == 0)\n\t\t\tcontinue;\n\t\tif (!in_block_group(bytenr, rc->block_group))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are modifying block in fs tree, wait for readpage\n\t\t * to complete and drop the extent cache\n\t\t */\n\t\tif (root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\tif (first) {\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t\tfirst = 0;\n\t\t\t} else if (inode && btrfs_ino(inode) < key.objectid) {\n\t\t\t\tbtrfs_add_delayed_iput(inode);\n\t\t\t\tinode = find_next_inode(root, key.objectid);\n\t\t\t}\n\t\t\tif (inode && btrfs_ino(inode) == key.objectid) {\n\t\t\t\tend = key.offset +\n\t\t\t\t      btrfs_file_extent_num_bytes(leaf, fi);\n\t\t\t\tWARN_ON(!IS_ALIGNED(key.offset,\n\t\t\t\t\t\t    root->sectorsize));\n\t\t\t\tWARN_ON(!IS_ALIGNED(end, root->sectorsize));\n\t\t\t\tend--;\n\t\t\t\tret = try_lock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t\t      key.offset, end);\n\t\t\t\tif (!ret)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tbtrfs_drop_extent_cache(inode, key.offset, end,\n\t\t\t\t\t\t\t1);\n\t\t\t\tunlock_extent(&BTRFS_I(inode)->io_tree,\n\t\t\t\t\t      key.offset, end);\n\t\t\t}\n\t\t}\n\n\t\tret = get_new_location(rc->data_inode, &new_bytenr,\n\t\t\t\t       bytenr, num_bytes);\n\t\tif (ret) {\n\t\t\t/*\n\t\t\t * Don't have to abort since we've not changed anything\n\t\t\t * in the file extent yet.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\tbtrfs_set_file_extent_disk_bytenr(leaf, fi, new_bytenr);\n\t\tdirty = 1;\n\n\t\tkey.offset -= btrfs_file_extent_offset(leaf, fi);\n\t\tret = btrfs_inc_extent_ref(trans, root, new_bytenr,\n\t\t\t\t\t   num_bytes, parent,\n\t\t\t\t\t   btrfs_header_owner(leaf),\n\t\t\t\t\t   key.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = btrfs_free_extent(trans, root, bytenr, num_bytes,\n\t\t\t\t\tparent, btrfs_header_owner(leaf),\n\t\t\t\t\tkey.objectid, key.offset, 1);\n\t\tif (ret) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (dirty)\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\tif (inode)\n\t\tbtrfs_add_delayed_iput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_new_location",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1577-1619",
    "snippet": "static int get_new_location(struct inode *reloc_inode, u64 *new_bytenr,\n\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(reloc_inode)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbytenr -= BTRFS_I(reloc_inode)->index_cnt;\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(reloc_inode),\n\t\t\t\t       bytenr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tBUG_ON(btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi));\n\n\tif (num_bytes != btrfs_file_extent_disk_num_bytes(leaf, fi)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*new_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_other_encoding",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_encryption",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_file_extent",
          "args": [
            "NULL",
            "root",
            "path",
            "btrfs_ino(reloc_inode)",
            "bytenr",
            "0"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_file_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "139-154",
          "snippet": "int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path, u64 objectid,\n\t\t\t     u64 offset, int mod)\n{\n\tint ret;\n\tstruct btrfs_key file_key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tfile_key.objectid = objectid;\n\tfile_key.offset = offset;\n\tfile_key.type = BTRFS_EXTENT_DATA_KEY;\n\tret = btrfs_search_slot(trans, root, &file_key, path, ins_len, cow);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "reloc_inode"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "reloc_inode"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int get_new_location(struct inode *reloc_inode, u64 *new_bytenr,\n\t\t\t    u64 bytenr, u64 num_bytes)\n{\n\tstruct btrfs_root *root = BTRFS_I(reloc_inode)->root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_buffer *leaf;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tbytenr -= BTRFS_I(reloc_inode)->index_cnt;\n\tret = btrfs_lookup_file_extent(NULL, root, path, btrfs_ino(reloc_inode),\n\t\t\t\t       bytenr, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tleaf = path->nodes[0];\n\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t    struct btrfs_file_extent_item);\n\n\tBUG_ON(btrfs_file_extent_offset(leaf, fi) ||\n\t       btrfs_file_extent_compression(leaf, fi) ||\n\t       btrfs_file_extent_encryption(leaf, fi) ||\n\t       btrfs_file_extent_other_encoding(leaf, fi));\n\n\tif (num_bytes != btrfs_file_extent_disk_num_bytes(leaf, fi)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t*new_bytenr = btrfs_file_extent_disk_bytenr(leaf, fi);\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "in_block_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1565-1572",
    "snippet": "static int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic int in_block_group(u64 bytenr,\n\t\t\t  struct btrfs_block_group_cache *block_group)\n{\n\tif (bytenr >= block_group->key.objectid &&\n\t    bytenr < block_group->key.objectid + block_group->key.offset)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_next_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1515-1563",
    "snippet": "static struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "&entry->vfs_inode"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "&entry->vfs_inode"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_inode",
            "rb_node"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "prev"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "prev",
            "structbtrfs_inode",
            "rb_node"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structbtrfs_inode",
            "rb_node"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->inode_lock"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct inode *find_next_inode(struct btrfs_root *root, u64 objectid)\n{\n\tstruct rb_node *node;\n\tstruct rb_node *prev;\n\tstruct btrfs_inode *entry;\n\tstruct inode *inode;\n\n\tspin_lock(&root->inode_lock);\nagain:\n\tnode = root->inode_tree.rb_node;\n\tprev = NULL;\n\twhile (node) {\n\t\tprev = node;\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\n\t\tif (objectid < btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_left;\n\t\telse if (objectid > btrfs_ino(&entry->vfs_inode))\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\tbreak;\n\t}\n\tif (!node) {\n\t\twhile (prev) {\n\t\t\tentry = rb_entry(prev, struct btrfs_inode, rb_node);\n\t\t\tif (objectid <= btrfs_ino(&entry->vfs_inode)) {\n\t\t\t\tnode = prev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev = rb_next(prev);\n\t\t}\n\t}\n\twhile (node) {\n\t\tentry = rb_entry(node, struct btrfs_inode, rb_node);\n\t\tinode = igrab(&entry->vfs_inode);\n\t\tif (inode) {\n\t\t\tspin_unlock(&root->inode_lock);\n\t\t\treturn inode;\n\t\t}\n\n\t\tobjectid = btrfs_ino(&entry->vfs_inode) + 1;\n\t\tif (cond_resched_lock(&root->inode_lock))\n\t\t\tgoto again;\n\n\t\tnode = rb_next(node);\n\t}\n\tspin_unlock(&root->inode_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "btrfs_update_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1478-1509",
    "snippet": "int btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_update_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&reloc_root->root_key",
            "root_item"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_update_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "135-210",
          "snippet": "int btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_root_item\n\t\t      *item)\n{\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *l;\n\tint ret;\n\tint slot;\n\tunsigned long ptr;\n\tint old_len;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, key, path, 0, 1);\n\tif (ret < 0) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\tgoto out;\n\t}\n\n\tif (ret != 0) {\n\t\tbtrfs_print_leaf(root, path->nodes[0]);\n\t\tbtrfs_crit(root->fs_info, \"unable to update root key %llu %u %llu\",\n\t\t       key->objectid, key->type, key->offset);\n\t\tBUG_ON(1);\n\t}\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr_offset(l, slot);\n\told_len = btrfs_item_size_nr(l, slot);\n\n\t/*\n\t * If this is the first time we update the root item which originated\n\t * from an older kernel, we need to enlarge the item size to make room\n\t * for the added fields.\n\t */\n\tif (old_len < sizeof(*item)) {\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_search_slot(trans, root, key, path,\n\t\t\t\t-1, 1);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = btrfs_del_item(trans, root, path);\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tret = btrfs_insert_empty_item(trans, root, path,\n\t\t\t\tkey, sizeof(*item));\n\t\tif (ret < 0) {\n\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\tgoto out;\n\t\t}\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tptr = btrfs_item_ptr_offset(l, slot);\n\t}\n\n\t/*\n\t * Update generation_v2 so at the next mount we know the new root\n\t * fields are valid.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\n\twrite_extent_buffer(l, item, ptr, sizeof(*item));\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "reloc_root"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "reloc_root->commit_root"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_node",
          "args": [
            "root_item",
            "reloc_root->node"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "124-130",
          "snippet": "void btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\n\t\t\t struct extent_buffer *node)\n{\n\tbtrfs_set_root_bytenr(item, node->start);\n\tbtrfs_set_root_level(item, btrfs_header_level(node));\n\tbtrfs_set_root_generation(item, btrfs_header_generation(node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__del_reloc_root",
          "args": [
            "reloc_root"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "__del_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1308-1331",
          "snippet": "static void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_refs",
          "args": [
            "root_item"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_update_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_root_item *root_item;\n\tint ret;\n\n\tif (!root->reloc_root)\n\t\tgoto out;\n\n\treloc_root = root->reloc_root;\n\troot_item = &reloc_root->root_item;\n\n\tif (root->fs_info->reloc_ctl->merge_reloc_tree &&\n\t    btrfs_root_refs(root_item) == 0) {\n\t\troot->reloc_root = NULL;\n\t\t__del_reloc_root(reloc_root);\n\t}\n\n\tif (reloc_root->commit_root != reloc_root->node) {\n\t\tbtrfs_set_root_node(root_item, reloc_root->node);\n\t\tfree_extent_buffer(reloc_root->commit_root);\n\t\treloc_root->commit_root = btrfs_root_node(reloc_root);\n\t}\n\n\tret = btrfs_update_root(trans, root->fs_info->tree_root,\n\t\t\t\t&reloc_root->root_key, root_item);\n\tBUG_ON(ret);\n\nout:\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_init_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1441-1473",
    "snippet": "int btrfs_init_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\tstruct btrfs_block_rsv *rsv;\n\tint clear_rsv = 0;\n\tint ret;\n\n\tif (root->reloc_root) {\n\t\treloc_root = root->reloc_root;\n\t\treloc_root->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (!rc || !rc->create_reloc_tree ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!trans->reloc_reserved) {\n\t\trsv = trans->block_rsv;\n\t\ttrans->block_rsv = rc->block_rsv;\n\t\tclear_rsv = 1;\n\t}\n\treloc_root = create_reloc_root(trans, root, root->root_key.objectid);\n\tif (clear_rsv)\n\t\ttrans->block_rsv = rsv;\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\troot->reloc_root = reloc_root;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_reloc_root",
          "args": [
            "reloc_root"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "__add_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1275-1302",
          "snippet": "static int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_reloc_root",
          "args": [
            "trans",
            "root",
            "root->root_key.objectid"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "create_reloc_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "1366-1435",
          "snippet": "static struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_init_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\tstruct btrfs_block_rsv *rsv;\n\tint clear_rsv = 0;\n\tint ret;\n\n\tif (root->reloc_root) {\n\t\treloc_root = root->reloc_root;\n\t\treloc_root->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (!rc || !rc->create_reloc_tree ||\n\t    root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\treturn 0;\n\n\tif (!trans->reloc_reserved) {\n\t\trsv = trans->block_rsv;\n\t\ttrans->block_rsv = rc->block_rsv;\n\t\tclear_rsv = 1;\n\t}\n\treloc_root = create_reloc_root(trans, root, root->root_key.objectid);\n\tif (clear_rsv)\n\t\ttrans->block_rsv = rsv;\n\n\tret = __add_reloc_root(reloc_root);\n\tBUG_ON(ret < 0);\n\troot->reloc_root = reloc_root;\n\treturn 0;\n}"
  },
  {
    "function_name": "create_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1366-1435",
    "snippet": "static struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(reloc_root)"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reloc_root"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root",
          "args": [
            "root->fs_info->tree_root",
            "&root_key"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "root_item"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_root",
          "args": [
            "trans",
            "root->fs_info->tree_root",
            "&root_key",
            "root_item"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "212-220",
          "snippet": "int btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct btrfs_key *key, struct btrfs_root_item *item)\n{\n\t/*\n\t * Make sure generation v1 and v2 match. See update_root for details.\n\t */\n\tbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\n\treturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "eb"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_otransid",
          "args": [
            "root_item",
            "trans->transid"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_rtransid",
          "args": [
            "root_item",
            "last_snap"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_item->drop_progress",
            "0",
            "sizeof(struct btrfs_disk_key)"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_refs",
          "args": [
            "root_item",
            "0"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_generation",
          "args": [
            "root_item",
            "trans->transid"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_level",
          "args": [
            "root_item",
            "btrfs_header_level(eb)"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_bytenr",
          "args": [
            "root_item",
            "eb->start"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "root_item",
            "&root->root_item",
            "sizeof(*root_item)"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_copy_root",
          "args": [
            "trans",
            "root",
            "root->node",
            "&eb",
            "BTRFS_TREE_RELOC_OBJECTID"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_copy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "238-290",
          "snippet": "int btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nint btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_last_snapshot",
          "args": [
            "&root->root_item",
            "trans->transid - 1"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&root->root_item"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root_item"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*root_item)",
            "GFP_NOFS"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *create_reloc_root(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root, u64 objectid)\n{\n\tstruct btrfs_root *reloc_root;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_root_item *root_item;\n\tstruct btrfs_key root_key;\n\tu64 last_snap = 0;\n\tint ret;\n\n\troot_item = kmalloc(sizeof(*root_item), GFP_NOFS);\n\tBUG_ON(!root_item);\n\n\troot_key.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = objectid;\n\n\tif (root->root_key.objectid == objectid) {\n\t\t/* called by btrfs_init_reloc_root */\n\t\tret = btrfs_copy_root(trans, root, root->commit_root, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\n\t\tlast_snap = btrfs_root_last_snapshot(&root->root_item);\n\t\tbtrfs_set_root_last_snapshot(&root->root_item,\n\t\t\t\t\t     trans->transid - 1);\n\t} else {\n\t\t/*\n\t\t * called by btrfs_reloc_post_snapshot_hook.\n\t\t * the source tree is a reloc tree, all tree blocks\n\t\t * modified after it was created have RELOC flag\n\t\t * set in their headers. so it's OK to not update\n\t\t * the 'last_snapshot'.\n\t\t */\n\t\tret = btrfs_copy_root(trans, root, root->node, &eb,\n\t\t\t\t      BTRFS_TREE_RELOC_OBJECTID);\n\t\tBUG_ON(ret);\n\t}\n\n\tmemcpy(root_item, &root->root_item, sizeof(*root_item));\n\tbtrfs_set_root_bytenr(root_item, eb->start);\n\tbtrfs_set_root_level(root_item, btrfs_header_level(eb));\n\tbtrfs_set_root_generation(root_item, trans->transid);\n\n\tif (root->root_key.objectid == objectid) {\n\t\tbtrfs_set_root_refs(root_item, 0);\n\t\tmemset(&root_item->drop_progress, 0,\n\t\t       sizeof(struct btrfs_disk_key));\n\t\troot_item->drop_level = 0;\n\t\t/*\n\t\t * abuse rtransid, it is safe because it is impossible to\n\t\t * receive data into a relocation tree.\n\t\t */\n\t\tbtrfs_set_root_rtransid(root_item, last_snap);\n\t\tbtrfs_set_root_otransid(root_item, trans->transid);\n\t}\n\n\tbtrfs_tree_unlock(eb);\n\tfree_extent_buffer(eb);\n\n\tret = btrfs_insert_root(trans, root->fs_info->tree_root,\n\t\t\t\t&root_key, root_item);\n\tBUG_ON(ret);\n\tkfree(root_item);\n\n\treloc_root = btrfs_read_fs_root(root->fs_info->tree_root, &root_key);\n\tBUG_ON(IS_ERR(reloc_root));\n\treloc_root->last_trans = trans->transid;\n\treturn reloc_root;\n}"
  },
  {
    "function_name": "__update_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1337-1364",
    "snippet": "static int __update_reloc_root(struct btrfs_root *root, u64 new_bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn 0;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\tnode->bytenr = new_bytenr;\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, node->bytenr);\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backref_tree_panic",
          "args": [
            "rb_node",
            "-EEXIST",
            "node->bytenr"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "backref_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "331-341",
          "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&rc->reloc_root_tree.rb_root",
            "node->bytenr",
            "&node->rb_node"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(struct btrfs_root *)node->data != root"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&node->rb_node",
            "&rc->reloc_root_tree.rb_root"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structmapping_node",
            "rb_node"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "&rc->reloc_root_tree.rb_root",
            "root->node->start"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __update_reloc_root(struct btrfs_root *root, u64 new_bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn 0;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\tnode->bytenr = new_bytenr;\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, node->bytenr);\n\treturn 0;\n}"
  },
  {
    "function_name": "__del_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1308-1331",
    "snippet": "static void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&root->root_list"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(struct btrfs_root *)node->data != root"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&node->rb_node",
            "&rc->reloc_root_tree.rb_root"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structmapping_node",
            "rb_node"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "&rc->reloc_root_tree.rb_root",
            "root->node->start"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void __del_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node = NULL;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root,\n\t\t\t      root->node->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\trb_erase(&node->rb_node, &rc->reloc_root_tree.rb_root);\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\n\tif (!node)\n\t\treturn;\n\tBUG_ON((struct btrfs_root *)node->data != root);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&root->root_list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\tkfree(node);\n}"
  },
  {
    "function_name": "__add_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1275-1302",
    "snippet": "static int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&root->root_list",
            "&rc->reloc_roots"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_panic",
          "args": [
            "root->fs_info",
            "-EEXIST",
            "\"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\"",
            "node->bytenr"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&rc->reloc_root_tree.rb_root",
            "node->bytenr",
            "&node->rb_node"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*node)",
            "GFP_NOFS"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int __must_check __add_reloc_root(struct btrfs_root *root)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct reloc_control *rc = root->fs_info->reloc_ctl;\n\n\tnode = kmalloc(sizeof(*node), GFP_NOFS);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tnode->bytenr = root->node->start;\n\tnode->data = root;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_insert(&rc->reloc_root_tree.rb_root,\n\t\t\t      node->bytenr, &node->rb_node);\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\tif (rb_node) {\n\t\tbtrfs_panic(root->fs_info, -EEXIST, \"Duplicate root found \"\n\t\t\t    \"for start=%llu while inserting into relocation \"\n\t\t\t    \"tree\", node->bytenr);\n\t\tkfree(node);\n\t\treturn -EEXIST;\n\t}\n\n\tlist_add_tail(&root->root_list, &rc->reloc_roots);\n\treturn 0;\n}"
  },
  {
    "function_name": "clone_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "1186-1270",
    "snippet": "static int clone_backref_node(struct btrfs_trans_handle *trans,\n\t\t\t      struct reloc_control *rc,\n\t\t\t      struct btrfs_root *src,\n\t\t\t      struct btrfs_root *dest)\n{\n\tstruct btrfs_root *reloc_root = src->reloc_root;\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node = NULL;\n\tstruct backref_node *new_node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *new_edge;\n\tstruct rb_node *rb_node;\n\n\tif (cache->last_trans > 0)\n\t\tupdate_backref_cache(trans, cache);\n\n\trb_node = tree_search(&cache->rb_root, src->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct backref_node, rb_node);\n\t\tif (node->detached)\n\t\t\tnode = NULL;\n\t\telse\n\t\t\tBUG_ON(node->new_bytenr != reloc_root->node->start);\n\t}\n\n\tif (!node) {\n\t\trb_node = tree_search(&cache->rb_root,\n\t\t\t\t      reloc_root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(node->detached);\n\t\t}\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\tnew_node = alloc_backref_node(cache);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->bytenr = dest->node->start;\n\tnew_node->level = node->level;\n\tnew_node->lowest = node->lowest;\n\tnew_node->checked = 1;\n\tnew_node->root = dest;\n\n\tif (!node->lowest) {\n\t\tlist_for_each_entry(edge, &node->lower, list[UPPER]) {\n\t\t\tnew_edge = alloc_backref_edge(cache);\n\t\t\tif (!new_edge)\n\t\t\t\tgoto fail;\n\n\t\t\tnew_edge->node[UPPER] = new_node;\n\t\t\tnew_edge->node[LOWER] = edge->node[LOWER];\n\t\t\tlist_add_tail(&new_edge->list[UPPER],\n\t\t\t\t      &new_node->lower);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&new_node->lower, &cache->leaves);\n\t}\n\n\trb_node = tree_insert(&cache->rb_root, new_node->bytenr,\n\t\t\t      &new_node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, new_node->bytenr);\n\n\tif (!new_node->lowest) {\n\t\tlist_for_each_entry(new_edge, &new_node->lower, list[UPPER]) {\n\t\t\tlist_add_tail(&new_edge->list[LOWER],\n\t\t\t\t      &new_edge->node[LOWER]->upper);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\twhile (!list_empty(&new_node->lower)) {\n\t\tnew_edge = list_entry(new_node->lower.next,\n\t\t\t\t      struct backref_edge, list[UPPER]);\n\t\tlist_del(&new_edge->list[UPPER]);\n\t\tfree_backref_edge(cache, new_edge);\n\t}\n\tfree_backref_node(cache, new_node);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_backref_node",
          "args": [
            "cache",
            "new_node"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "free_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "261-268",
          "snippet": "static void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_backref_edge",
          "args": [
            "cache",
            "new_edge"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "free_backref_edge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "280-287",
          "snippet": "static void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&new_edge->list[UPPER]"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "new_node->lower.next",
            "structbackref_edge",
            "list[UPPER]"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&new_node->lower"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_edge->list[LOWER]",
            "&new_edge->node[LOWER]->upper"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "new_edge",
            "&new_node->lower",
            "list[UPPER]"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backref_tree_panic",
          "args": [
            "rb_node",
            "-EEXIST",
            "new_node->bytenr"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "backref_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "331-341",
          "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&cache->rb_root",
            "new_node->bytenr",
            "&new_node->rb_node"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_node->lower",
            "&cache->leaves"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_edge->list[UPPER]",
            "&new_node->lower"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_backref_edge",
          "args": [
            "cache"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_backref_edge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "270-278",
          "snippet": "static struct backref_edge *alloc_backref_edge(struct backref_cache *cache)\n{\n\tstruct backref_edge *edge;\n\n\tedge = kzalloc(sizeof(*edge), GFP_NOFS);\n\tif (edge)\n\t\tcache->nr_edges++;\n\treturn edge;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_edge *alloc_backref_edge(struct backref_cache *cache)\n{\n\tstruct backref_edge *edge;\n\n\tedge = kzalloc(sizeof(*edge), GFP_NOFS);\n\tif (edge)\n\t\tcache->nr_edges++;\n\treturn edge;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "edge",
            "&node->lower",
            "list[UPPER]"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_backref_node",
          "args": [
            "cache"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "246-259",
          "snippet": "static struct backref_node *alloc_backref_node(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_NOFS);\n\tif (node) {\n\t\tINIT_LIST_HEAD(&node->list);\n\t\tINIT_LIST_HEAD(&node->upper);\n\t\tINIT_LIST_HEAD(&node->lower);\n\t\tRB_CLEAR_NODE(&node->rb_node);\n\t\tcache->nr_nodes++;\n\t}\n\treturn node;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *alloc_backref_node(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_NOFS);\n\tif (node) {\n\t\tINIT_LIST_HEAD(&node->list);\n\t\tINIT_LIST_HEAD(&node->upper);\n\t\tINIT_LIST_HEAD(&node->lower);\n\t\tRB_CLEAR_NODE(&node->rb_node);\n\t\tcache->nr_nodes++;\n\t}\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->detached"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structbackref_node",
            "rb_node"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "&cache->rb_root",
            "reloc_root->commit_root->start"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->new_bytenr != reloc_root->node->start"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structbackref_node",
            "rb_node"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_backref_cache",
          "args": [
            "trans",
            "cache"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "update_backref_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "476-524",
          "snippet": "static int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int clone_backref_node(struct btrfs_trans_handle *trans,\n\t\t\t      struct reloc_control *rc,\n\t\t\t      struct btrfs_root *src,\n\t\t\t      struct btrfs_root *dest)\n{\n\tstruct btrfs_root *reloc_root = src->reloc_root;\n\tstruct backref_cache *cache = &rc->backref_cache;\n\tstruct backref_node *node = NULL;\n\tstruct backref_node *new_node;\n\tstruct backref_edge *edge;\n\tstruct backref_edge *new_edge;\n\tstruct rb_node *rb_node;\n\n\tif (cache->last_trans > 0)\n\t\tupdate_backref_cache(trans, cache);\n\n\trb_node = tree_search(&cache->rb_root, src->commit_root->start);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct backref_node, rb_node);\n\t\tif (node->detached)\n\t\t\tnode = NULL;\n\t\telse\n\t\t\tBUG_ON(node->new_bytenr != reloc_root->node->start);\n\t}\n\n\tif (!node) {\n\t\trb_node = tree_search(&cache->rb_root,\n\t\t\t\t      reloc_root->commit_root->start);\n\t\tif (rb_node) {\n\t\t\tnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\trb_node);\n\t\t\tBUG_ON(node->detached);\n\t\t}\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\tnew_node = alloc_backref_node(cache);\n\tif (!new_node)\n\t\treturn -ENOMEM;\n\n\tnew_node->bytenr = dest->node->start;\n\tnew_node->level = node->level;\n\tnew_node->lowest = node->lowest;\n\tnew_node->checked = 1;\n\tnew_node->root = dest;\n\n\tif (!node->lowest) {\n\t\tlist_for_each_entry(edge, &node->lower, list[UPPER]) {\n\t\t\tnew_edge = alloc_backref_edge(cache);\n\t\t\tif (!new_edge)\n\t\t\t\tgoto fail;\n\n\t\t\tnew_edge->node[UPPER] = new_node;\n\t\t\tnew_edge->node[LOWER] = edge->node[LOWER];\n\t\t\tlist_add_tail(&new_edge->list[UPPER],\n\t\t\t\t      &new_node->lower);\n\t\t}\n\t} else {\n\t\tlist_add_tail(&new_node->lower, &cache->leaves);\n\t}\n\n\trb_node = tree_insert(&cache->rb_root, new_node->bytenr,\n\t\t\t      &new_node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, new_node->bytenr);\n\n\tif (!new_node->lowest) {\n\t\tlist_for_each_entry(new_edge, &new_node->lower, list[UPPER]) {\n\t\t\tlist_add_tail(&new_edge->list[LOWER],\n\t\t\t\t      &new_edge->node[LOWER]->upper);\n\t\t}\n\t}\n\treturn 0;\nfail:\n\twhile (!list_empty(&new_node->lower)) {\n\t\tnew_edge = list_entry(new_node->lower.next,\n\t\t\t\t      struct backref_edge, list[UPPER]);\n\t\tlist_del(&new_edge->list[UPPER]);\n\t\tfree_backref_edge(cache, new_edge);\n\t}\n\tfree_backref_node(cache, new_node);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "find_inline_backref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "621-662",
    "snippet": "static noinline_for_stack\nint find_inline_backref(struct extent_buffer *leaf, int slot,\n\t\t\tunsigned long *ptr, unsigned long *end)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_tree_block_info *bi;\n\tu32 item_size;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\titem_size = btrfs_item_size_nr(leaf, slot);\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (item_size < sizeof(*ei)) {\n\t\tWARN_ON(item_size != sizeof(struct btrfs_extent_item_v0));\n\t\treturn 1;\n\t}\n#endif\n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tWARN_ON(!(btrfs_extent_flags(leaf, ei) &\n\t\t  BTRFS_EXTENT_FLAG_TREE_BLOCK));\n\n\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t    item_size <= sizeof(*ei) + sizeof(*bi)) {\n\t\tWARN_ON(item_size < sizeof(*ei) + sizeof(*bi));\n\t\treturn 1;\n\t}\n\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t    item_size <= sizeof(*ei)) {\n\t\tWARN_ON(item_size < sizeof(*ei));\n\t\treturn 1;\n\t}\n\n\tif (key.type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tbi = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*ptr = (unsigned long)(bi + 1);\n\t} else {\n\t\t*ptr = (unsigned long)(ei + 1);\n\t}\n\t*end = (unsigned long)ei + item_size;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "item_size < sizeof(*ei)"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "item_size < sizeof(*ei) + sizeof(*bi)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(btrfs_extent_flags(leaf, ei) &\n\t\t  BTRFS_EXTENT_FLAG_TREE_BLOCK)"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "leaf",
            "ei"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_extent_item"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "item_size != sizeof(struct btrfs_extent_item_v0)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic noinline_for_stack\nint find_inline_backref(struct extent_buffer *leaf, int slot,\n\t\t\tunsigned long *ptr, unsigned long *end)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_tree_block_info *bi;\n\tu32 item_size;\n\n\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\titem_size = btrfs_item_size_nr(leaf, slot);\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (item_size < sizeof(*ei)) {\n\t\tWARN_ON(item_size != sizeof(struct btrfs_extent_item_v0));\n\t\treturn 1;\n\t}\n#endif\n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tWARN_ON(!(btrfs_extent_flags(leaf, ei) &\n\t\t  BTRFS_EXTENT_FLAG_TREE_BLOCK));\n\n\tif (key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t    item_size <= sizeof(*ei) + sizeof(*bi)) {\n\t\tWARN_ON(item_size < sizeof(*ei) + sizeof(*bi));\n\t\treturn 1;\n\t}\n\tif (key.type == BTRFS_METADATA_ITEM_KEY &&\n\t    item_size <= sizeof(*ei)) {\n\t\tWARN_ON(item_size < sizeof(*ei));\n\t\treturn 1;\n\t}\n\n\tif (key.type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tbi = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*ptr = (unsigned long)(bi + 1);\n\t} else {\n\t\t*ptr = (unsigned long)(ei + 1);\n\t}\n\t*end = (unsigned long)ei + item_size;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_tree_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "600-618",
    "snippet": "btrfs_root *find_tree_root(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *leaf,\n\t\t\t\t  struct btrfs_extent_ref_v0 *ref0)\n{\n\tstruct btrfs_root *root;\n\tu64 root_objectid = btrfs_ref_root_v0(leaf, ref0);\n\tu64 generation = btrfs_ref_generation_v0(leaf, ref0);\n\n\tBUG_ON(root_objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\troot = read_fs_root(rc->extent_root->fs_info, root_objectid);\n\tBUG_ON(IS_ERR(root));\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    generation != btrfs_root_generation(&root->root_item))\n\t\treturn NULL;\n\n\treturn root;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_root_generation",
          "args": [
            "&root->root_item"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ERR(root)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_fs_root",
          "args": [
            "rc->extent_root->fs_info",
            "root_objectid"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "read_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "583-596",
          "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root_objectid == BTRFS_TREE_RELOC_OBJECTID"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ref_generation_v0",
          "args": [
            "leaf",
            "ref0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ref_root_v0",
          "args": [
            "leaf",
            "ref0"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nbtrfs_root *find_tree_root(struct reloc_control *rc,\n\t\t\t\t  struct extent_buffer *leaf,\n\t\t\t\t  struct btrfs_extent_ref_v0 *ref0)\n{\n\tstruct btrfs_root *root;\n\tu64 root_objectid = btrfs_ref_root_v0(leaf, ref0);\n\tu64 generation = btrfs_ref_generation_v0(leaf, ref0);\n\n\tBUG_ON(root_objectid == BTRFS_TREE_RELOC_OBJECTID);\n\n\troot = read_fs_root(rc->extent_root->fs_info, root_objectid);\n\tBUG_ON(IS_ERR(root));\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    generation != btrfs_root_generation(&root->root_item))\n\t\treturn NULL;\n\n\treturn root;\n}"
  },
  {
    "function_name": "read_fs_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "583-596",
    "snippet": "static struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_get_fs_root",
          "args": [
            "fs_info",
            "&key",
            "false"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_fs_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1626-1700",
          "snippet": "struct btrfs_root *btrfs_get_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_key *location,\n\t\t\t\t     bool check_ref)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (location->objectid == BTRFS_ROOT_TREE_OBJECTID)\n\t\treturn fs_info->tree_root;\n\tif (location->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\treturn fs_info->extent_root;\n\tif (location->objectid == BTRFS_CHUNK_TREE_OBJECTID)\n\t\treturn fs_info->chunk_root;\n\tif (location->objectid == BTRFS_DEV_TREE_OBJECTID)\n\t\treturn fs_info->dev_root;\n\tif (location->objectid == BTRFS_CSUM_TREE_OBJECTID)\n\t\treturn fs_info->csum_root;\n\tif (location->objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn fs_info->quota_root ? fs_info->quota_root :\n\t\t\t\t\t     ERR_PTR(-ENOENT);\n\tif (location->objectid == BTRFS_UUID_TREE_OBJECTID)\n\t\treturn fs_info->uuid_root ? fs_info->uuid_root :\n\t\t\t\t\t    ERR_PTR(-ENOENT);\nagain:\n\troot = btrfs_lookup_fs_root(fs_info, location->objectid);\n\tif (root) {\n\t\tif (check_ref && btrfs_root_refs(&root->root_item) == 0)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn root;\n\t}\n\n\troot = btrfs_read_fs_root(fs_info->tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (check_ref && btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_init_fs_root(root);\n\tif (ret)\n\t\tgoto fail;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = location->objectid;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tbtrfs_free_path(path);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\tret = btrfs_insert_fs_root(fs_info, root);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\tfree_fs_root(root);\n\t\t\tgoto again;\n\t\t}\n\t\tgoto fail;\n\t}\n\treturn root;\nfail:\n\tfree_fs_root(root);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_get_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_key *location,\n\t\t\t\t     bool check_ref)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret;\n\n\tif (location->objectid == BTRFS_ROOT_TREE_OBJECTID)\n\t\treturn fs_info->tree_root;\n\tif (location->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\treturn fs_info->extent_root;\n\tif (location->objectid == BTRFS_CHUNK_TREE_OBJECTID)\n\t\treturn fs_info->chunk_root;\n\tif (location->objectid == BTRFS_DEV_TREE_OBJECTID)\n\t\treturn fs_info->dev_root;\n\tif (location->objectid == BTRFS_CSUM_TREE_OBJECTID)\n\t\treturn fs_info->csum_root;\n\tif (location->objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn fs_info->quota_root ? fs_info->quota_root :\n\t\t\t\t\t     ERR_PTR(-ENOENT);\n\tif (location->objectid == BTRFS_UUID_TREE_OBJECTID)\n\t\treturn fs_info->uuid_root ? fs_info->uuid_root :\n\t\t\t\t\t    ERR_PTR(-ENOENT);\nagain:\n\troot = btrfs_lookup_fs_root(fs_info, location->objectid);\n\tif (root) {\n\t\tif (check_ref && btrfs_root_refs(&root->root_item) == 0)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn root;\n\t}\n\n\troot = btrfs_read_fs_root(fs_info->tree_root, location);\n\tif (IS_ERR(root))\n\t\treturn root;\n\n\tif (check_ref && btrfs_root_refs(&root->root_item) == 0) {\n\t\tret = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tret = btrfs_init_fs_root(root);\n\tif (ret)\n\t\tgoto fail;\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tkey.objectid = BTRFS_ORPHAN_OBJECTID;\n\tkey.type = BTRFS_ORPHAN_ITEM_KEY;\n\tkey.offset = location->objectid;\n\n\tret = btrfs_search_slot(NULL, fs_info->tree_root, &key, path, 0, 0);\n\tbtrfs_free_path(path);\n\tif (ret < 0)\n\t\tgoto fail;\n\tif (ret == 0)\n\t\tset_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &root->state);\n\n\tret = btrfs_insert_fs_root(fs_info, root);\n\tif (ret) {\n\t\tif (ret == -EEXIST) {\n\t\t\tfree_fs_root(root);\n\t\t\tgoto again;\n\t\t}\n\t\tgoto fail;\n\t}\n\treturn root;\nfail:\n\tfree_fs_root(root);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cowonly_root",
          "args": [
            "root_objectid"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "is_cowonly_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "569-581",
          "snippet": "static int is_cowonly_root(u64 root_objectid)\n{\n\tif (root_objectid == BTRFS_ROOT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_EXTENT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_CHUNK_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_DEV_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_TREE_LOG_OBJECTID ||\n\t    root_objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_UUID_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int is_cowonly_root(u64 root_objectid)\n{\n\tif (root_objectid == BTRFS_ROOT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_EXTENT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_CHUNK_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_DEV_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_TREE_LOG_OBJECTID ||\n\t    root_objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_UUID_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *read_fs_root(struct btrfs_fs_info *fs_info,\n\t\t\t\t\tu64 root_objectid)\n{\n\tstruct btrfs_key key;\n\n\tkey.objectid = root_objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tif (is_cowonly_root(root_objectid))\n\t\tkey.offset = 0;\n\telse\n\t\tkey.offset = (u64)-1;\n\n\treturn btrfs_get_fs_root(fs_info, &key, false);\n}"
  },
  {
    "function_name": "is_cowonly_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "569-581",
    "snippet": "static int is_cowonly_root(u64 root_objectid)\n{\n\tif (root_objectid == BTRFS_ROOT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_EXTENT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_CHUNK_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_DEV_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_TREE_LOG_OBJECTID ||\n\t    root_objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_UUID_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int is_cowonly_root(u64 root_objectid)\n{\n\tif (root_objectid == BTRFS_ROOT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_EXTENT_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_CHUNK_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_DEV_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_TREE_LOG_OBJECTID ||\n\t    root_objectid == BTRFS_CSUM_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_UUID_TREE_OBJECTID ||\n\t    root_objectid == BTRFS_QUOTA_TREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_reloc_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "552-567",
    "snippet": "static struct btrfs_root *find_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t  u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct btrfs_root *root = NULL;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root, bytenr);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\troot = (struct btrfs_root *)node->data;\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\treturn root;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structmapping_node",
            "rb_node"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_search",
          "args": [
            "&rc->reloc_root_tree.rb_root",
            "bytenr"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tree_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "313-329",
          "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rc->reloc_root_tree.lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct btrfs_root *find_reloc_root(struct reloc_control *rc,\n\t\t\t\t\t  u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\tstruct mapping_node *node;\n\tstruct btrfs_root *root = NULL;\n\n\tspin_lock(&rc->reloc_root_tree.lock);\n\trb_node = tree_search(&rc->reloc_root_tree.rb_root, bytenr);\n\tif (rb_node) {\n\t\tnode = rb_entry(rb_node, struct mapping_node, rb_node);\n\t\troot = (struct btrfs_root *)node->data;\n\t}\n\tspin_unlock(&rc->reloc_root_tree.lock);\n\treturn root;\n}"
  },
  {
    "function_name": "should_ignore_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "527-548",
    "snippet": "static int should_ignore_root(struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\treloc_root = root->reloc_root;\n\tif (!reloc_root)\n\t\treturn 0;\n\n\tif (btrfs_root_last_snapshot(&reloc_root->root_item) ==\n\t    root->fs_info->running_transaction->transid - 1)\n\t\treturn 0;\n\t/*\n\t * if there is reloc tree and it was created in previous\n\t * transaction backref lookup can find the reloc tree,\n\t * so backref node for the fs tree root is useless for\n\t * relocation.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&reloc_root->root_item"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int should_ignore_root(struct btrfs_root *root)\n{\n\tstruct btrfs_root *reloc_root;\n\n\tif (!test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\treturn 0;\n\n\treloc_root = root->reloc_root;\n\tif (!reloc_root)\n\t\treturn 0;\n\n\tif (btrfs_root_last_snapshot(&reloc_root->root_item) ==\n\t    root->fs_info->running_transaction->transid - 1)\n\t\treturn 0;\n\t/*\n\t * if there is reloc tree and it was created in previous\n\t * transaction backref lookup can find the reloc tree,\n\t * so backref node for the fs tree root is useless for\n\t * relocation.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "update_backref_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "476-524",
    "snippet": "static int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_backref_node",
          "args": [
            "cache",
            "node",
            "node->new_bytenr"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "update_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "462-471",
          "snippet": "static void update_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node, u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\trb_erase(&node->rb_node, &cache->rb_root);\n\tnode->bytenr = bytenr;\n\trb_node = tree_insert(&cache->rb_root, node->bytenr, &node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void update_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node, u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\trb_erase(&node->rb_node, &cache->rb_root);\n\tnode->bytenr = bytenr;\n\trb_node = tree_insert(&cache->rb_root, node->bytenr, &node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!node->pending"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "node",
            "&cache->pending[level]",
            "list"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->pending"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&node->list"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->changed.next",
            "structbackref_node",
            "list"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->changed"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_backref_node",
          "args": [
            "cache",
            "node"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "remove_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "424-460",
          "snippet": "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->detached.next",
            "structbackref_node",
            "list"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic int update_backref_cache(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint level = 0;\n\n\tif (cache->last_trans == 0) {\n\t\tcache->last_trans = trans->transid;\n\t\treturn 0;\n\t}\n\n\tif (cache->last_trans == trans->transid)\n\t\treturn 0;\n\n\t/*\n\t * detached nodes are used to avoid unnecessary backref\n\t * lookup. transaction commit changes the extent tree.\n\t * so the detached nodes are no longer useful.\n\t */\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->changed)) {\n\t\tnode = list_entry(cache->changed.next,\n\t\t\t\t  struct backref_node, list);\n\t\tlist_del_init(&node->list);\n\t\tBUG_ON(node->pending);\n\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t}\n\n\t/*\n\t * some nodes can be left in the pending list if there were\n\t * errors during processing the pending nodes.\n\t */\n\tfor (level = 0; level < BTRFS_MAX_LEVEL; level++) {\n\t\tlist_for_each_entry(node, &cache->pending[level], list) {\n\t\t\tBUG_ON(!node->pending);\n\t\t\tif (node->bytenr == node->new_bytenr)\n\t\t\t\tcontinue;\n\t\t\tupdate_backref_node(cache, node, node->new_bytenr);\n\t\t}\n\t}\n\n\tcache->last_trans = 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "update_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "462-471",
    "snippet": "static void update_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node, u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\trb_erase(&node->rb_node, &cache->rb_root);\n\tnode->bytenr = bytenr;\n\trb_node = tree_insert(&cache->rb_root, node->bytenr, &node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, bytenr);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backref_tree_panic",
          "args": [
            "rb_node",
            "-EEXIST",
            "bytenr"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "backref_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "331-341",
          "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_insert",
          "args": [
            "&cache->rb_root",
            "node->bytenr",
            "&node->rb_node"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "289-311",
          "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&node->rb_node",
            "&cache->rb_root"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void update_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node, u64 bytenr)\n{\n\tstruct rb_node *rb_node;\n\trb_erase(&node->rb_node, &cache->rb_root);\n\tnode->bytenr = bytenr;\n\trb_node = tree_insert(&cache->rb_root, node->bytenr, &node->rb_node);\n\tif (rb_node)\n\t\tbackref_tree_panic(rb_node, -EEXIST, bytenr);\n}"
  },
  {
    "function_name": "remove_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "424-460",
    "snippet": "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_backref_node",
          "args": [
            "cache",
            "node"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "drop_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "408-419",
          "snippet": "static void drop_backref_node(struct backref_cache *tree,\n\t\t\t      struct backref_node *node)\n{\n\tBUG_ON(!list_empty(&node->upper));\n\n\tdrop_node_buffer(node);\n\tlist_del(&node->list);\n\tlist_del(&node->lower);\n\tif (!RB_EMPTY_NODE(&node->rb_node))\n\t\trb_erase(&node->rb_node, &tree->rb_root);\n\tfree_backref_node(tree, node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_backref_node(struct backref_cache *tree,\n\t\t\t      struct backref_node *node)\n{\n\tBUG_ON(!list_empty(&node->upper));\n\n\tdrop_node_buffer(node);\n\tlist_del(&node->list);\n\tlist_del(&node->lower);\n\tif (!RB_EMPTY_NODE(&node->rb_node))\n\t\trb_erase(&node->rb_node, &tree->rb_root);\n\tfree_backref_node(tree, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&upper->lower",
            "&cache->leaves"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&upper->lower"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&node->upper)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&upper->rb_node"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_backref_edge",
          "args": [
            "cache",
            "edge"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "free_backref_edge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "280-287",
          "snippet": "static void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&edge->list[UPPER]"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "node->upper.next",
            "structbackref_edge",
            "list[LOWER]"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!node->lowest && !node->detached"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}"
  },
  {
    "function_name": "drop_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "408-419",
    "snippet": "static void drop_backref_node(struct backref_cache *tree,\n\t\t\t      struct backref_node *node)\n{\n\tBUG_ON(!list_empty(&node->upper));\n\n\tdrop_node_buffer(node);\n\tlist_del(&node->list);\n\tlist_del(&node->lower);\n\tif (!RB_EMPTY_NODE(&node->rb_node))\n\t\trb_erase(&node->rb_node, &tree->rb_root);\n\tfree_backref_node(tree, node);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_backref_node",
          "args": [
            "tree",
            "node"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "free_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "261-268",
          "snippet": "static void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&node->rb_node",
            "&tree->rb_root"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&node->rb_node"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&node->lower"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_node_buffer",
          "args": [
            "node"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "drop_node_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "399-406",
          "snippet": "static void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&node->upper)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->upper"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_backref_node(struct backref_cache *tree,\n\t\t\t      struct backref_node *node)\n{\n\tBUG_ON(!list_empty(&node->upper));\n\n\tdrop_node_buffer(node);\n\tlist_del(&node->list);\n\tlist_del(&node->lower);\n\tif (!RB_EMPTY_NODE(&node->rb_node))\n\t\trb_erase(&node->rb_node, &tree->rb_root);\n\tfree_backref_node(tree, node);\n}"
  },
  {
    "function_name": "drop_node_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "399-406",
    "snippet": "static void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "node->eb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_node_buffer",
          "args": [
            "node"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_node_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "391-397",
          "snippet": "static void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void drop_node_buffer(struct backref_node *node)\n{\n\tif (node->eb) {\n\t\tunlock_node_buffer(node);\n\t\tfree_extent_buffer(node->eb);\n\t\tnode->eb = NULL;\n\t}\n}"
  },
  {
    "function_name": "unlock_node_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "391-397",
    "snippet": "static void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "node->eb"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void unlock_node_buffer(struct backref_node *node)\n{\n\tif (node->locked) {\n\t\tbtrfs_tree_unlock(node->eb);\n\t\tnode->locked = 0;\n\t}\n}"
  },
  {
    "function_name": "walk_down_backref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "367-389",
    "snippet": "static struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "edge->list[LOWER].next",
            "structbackref_edge",
            "list[LOWER]"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&edge->list[LOWER]",
            "&lower->upper"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_down_backref(struct backref_edge *edges[],\n\t\t\t\t\t      int *index)\n{\n\tstruct backref_edge *edge;\n\tstruct backref_node *lower;\n\tint idx = *index;\n\n\twhile (idx > 0) {\n\t\tedge = edges[idx - 1];\n\t\tlower = edge->node[LOWER];\n\t\tif (list_is_last(&edge->list[LOWER], &lower->upper)) {\n\t\t\tidx--;\n\t\t\tcontinue;\n\t\t}\n\t\tedge = list_entry(edge->list[LOWER].next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx - 1] = edge;\n\t\t*index = idx;\n\t\treturn edge->node[UPPER];\n\t}\n\t*index = 0;\n\treturn NULL;\n}"
  },
  {
    "function_name": "walk_up_backref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "346-362",
    "snippet": "static struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UPPER\t1",
      "#define LOWER\t0"
    ],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "node->detached"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "node->upper.next",
            "structbackref_edge",
            "list[LOWER]"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&node->upper"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *walk_up_backref(struct backref_node *node,\n\t\t\t\t\t    struct backref_edge *edges[],\n\t\t\t\t\t    int *index)\n{\n\tstruct backref_edge *edge;\n\tint idx = *index;\n\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next,\n\t\t\t\t  struct backref_edge, list[LOWER]);\n\t\tedges[idx++] = edge;\n\t\tnode = edge->node[UPPER];\n\t}\n\tBUG_ON(node->detached);\n\t*index = idx;\n\treturn node;\n}"
  },
  {
    "function_name": "backref_tree_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "331-341",
    "snippet": "static void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_panic",
          "args": [
            "fs_info",
            "errno",
            "\"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\"",
            "bytenr"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structbackref_node",
            "rb_node"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_tree_panic(struct rb_node *rb_node, int errno, u64 bytenr)\n{\n\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct backref_node *bnode = rb_entry(rb_node, struct backref_node,\n\t\t\t\t\t      rb_node);\n\tif (bnode->root)\n\t\tfs_info = bnode->root->fs_info;\n\tbtrfs_panic(fs_info, errno, \"Inconsistency in backref cache \"\n\t\t    \"found at offset %llu\", bytenr);\n}"
  },
  {
    "function_name": "tree_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "313-329",
    "snippet": "static struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structtree_entry",
            "rb_node"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_search(struct rb_root *root, u64 bytenr)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct tree_entry *entry;\n\n\twhile (n) {\n\t\tentry = rb_entry(n, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tn = n->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn n;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "289-311",
    "snippet": "static struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structtree_entry",
            "rb_node"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct rb_node *tree_insert(struct rb_root *root, u64 bytenr,\n\t\t\t\t   struct rb_node *node)\n{\n\tstruct rb_node **p = &root->rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_entry *entry;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tentry = rb_entry(parent, struct tree_entry, rb_node);\n\n\t\tif (bytenr < entry->bytenr)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (bytenr > entry->bytenr)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn parent;\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n\treturn NULL;\n}"
  },
  {
    "function_name": "free_backref_edge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "280-287",
    "snippet": "static void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "edge"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_edge(struct backref_cache *cache,\n\t\t\t      struct backref_edge *edge)\n{\n\tif (edge) {\n\t\tcache->nr_edges--;\n\t\tkfree(edge);\n\t}\n}"
  },
  {
    "function_name": "alloc_backref_edge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "270-278",
    "snippet": "static struct backref_edge *alloc_backref_edge(struct backref_cache *cache)\n{\n\tstruct backref_edge *edge;\n\n\tedge = kzalloc(sizeof(*edge), GFP_NOFS);\n\tif (edge)\n\t\tcache->nr_edges++;\n\treturn edge;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*edge)",
            "GFP_NOFS"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_edge *alloc_backref_edge(struct backref_cache *cache)\n{\n\tstruct backref_edge *edge;\n\n\tedge = kzalloc(sizeof(*edge), GFP_NOFS);\n\tif (edge)\n\t\tcache->nr_edges++;\n\treturn edge;\n}"
  },
  {
    "function_name": "free_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "261-268",
    "snippet": "static void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void free_backref_node(struct backref_cache *cache,\n\t\t\t      struct backref_node *node)\n{\n\tif (node) {\n\t\tcache->nr_nodes--;\n\t\tkfree(node);\n\t}\n}"
  },
  {
    "function_name": "alloc_backref_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "246-259",
    "snippet": "static struct backref_node *alloc_backref_node(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_NOFS);\n\tif (node) {\n\t\tINIT_LIST_HEAD(&node->list);\n\t\tINIT_LIST_HEAD(&node->upper);\n\t\tINIT_LIST_HEAD(&node->lower);\n\t\tRB_CLEAR_NODE(&node->rb_node);\n\t\tcache->nr_nodes++;\n\t}\n\treturn node;\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&node->rb_node"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->lower"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->upper"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&node->list"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*node)",
            "GFP_NOFS"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic struct backref_node *alloc_backref_node(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\n\tnode = kzalloc(sizeof(*node), GFP_NOFS);\n\tif (node) {\n\t\tINIT_LIST_HEAD(&node->list);\n\t\tINIT_LIST_HEAD(&node->upper);\n\t\tINIT_LIST_HEAD(&node->lower);\n\t\tRB_CLEAR_NODE(&node->rb_node);\n\t\tcache->nr_nodes++;\n\t}\n\treturn node;\n}"
  },
  {
    "function_name": "backref_cache_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "218-244",
    "snippet": "static void backref_cache_cleanup(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint i;\n\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->leaves)) {\n\t\tnode = list_entry(cache->leaves.next,\n\t\t\t\t  struct backref_node, lower);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\tcache->last_trans = 0;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tBUG_ON(!list_empty(&cache->pending[i]));\n\tBUG_ON(!list_empty(&cache->changed));\n\tBUG_ON(!list_empty(&cache->detached));\n\tBUG_ON(!RB_EMPTY_ROOT(&cache->rb_root));\n\tBUG_ON(cache->nr_nodes);\n\tBUG_ON(cache->nr_edges);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
      "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cache->nr_edges"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cache->nr_nodes"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_ROOT(&cache->rb_root)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&cache->rb_root"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cache->detached)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cache->detached"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cache->changed)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cache->pending[i])"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_backref_node",
          "args": [
            "cache",
            "node"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "remove_backref_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "424-460",
          "snippet": "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPPER\t1",
            "#define LOWER\t0"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPPER\t1\n#define LOWER\t0\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node)\n{\n\tstruct backref_node *upper;\n\tstruct backref_edge *edge;\n\n\tif (!node)\n\t\treturn;\n\n\tBUG_ON(!node->lowest && !node->detached);\n\twhile (!list_empty(&node->upper)) {\n\t\tedge = list_entry(node->upper.next, struct backref_edge,\n\t\t\t\t  list[LOWER]);\n\t\tupper = edge->node[UPPER];\n\t\tlist_del(&edge->list[LOWER]);\n\t\tlist_del(&edge->list[UPPER]);\n\t\tfree_backref_edge(cache, edge);\n\n\t\tif (RB_EMPTY_NODE(&upper->rb_node)) {\n\t\t\tBUG_ON(!list_empty(&node->upper));\n\t\t\tdrop_backref_node(cache, node);\n\t\t\tnode = upper;\n\t\t\tnode->lowest = 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * add the node to leaf node list if no other\n\t\t * child block cached.\n\t\t */\n\t\tif (list_empty(&upper->lower)) {\n\t\t\tlist_add_tail(&upper->lower, &cache->leaves);\n\t\t\tupper->lowest = 1;\n\t\t}\n\t}\n\n\tdrop_backref_node(cache, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->leaves.next",
            "structbackref_node",
            "lower"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "cache->detached.next",
            "structbackref_node",
            "list"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_cache_cleanup(struct backref_cache *cache)\n{\n\tstruct backref_node *node;\n\tint i;\n\n\twhile (!list_empty(&cache->detached)) {\n\t\tnode = list_entry(cache->detached.next,\n\t\t\t\t  struct backref_node, list);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\twhile (!list_empty(&cache->leaves)) {\n\t\tnode = list_entry(cache->leaves.next,\n\t\t\t\t  struct backref_node, lower);\n\t\tremove_backref_node(cache, node);\n\t}\n\n\tcache->last_trans = 0;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tBUG_ON(!list_empty(&cache->pending[i]));\n\tBUG_ON(!list_empty(&cache->changed));\n\tBUG_ON(!list_empty(&cache->detached));\n\tBUG_ON(!RB_EMPTY_ROOT(&cache->rb_root));\n\tBUG_ON(cache->nr_nodes);\n\tBUG_ON(cache->nr_edges);\n}"
  },
  {
    "function_name": "backref_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "207-216",
    "snippet": "static void backref_cache_init(struct backref_cache *cache)\n{\n\tint i;\n\tcache->rb_root = RB_ROOT;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tINIT_LIST_HEAD(&cache->pending[i]);\n\tINIT_LIST_HEAD(&cache->changed);\n\tINIT_LIST_HEAD(&cache->detached);\n\tINIT_LIST_HEAD(&cache->leaves);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->leaves"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->detached"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->changed"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cache->pending[i]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void backref_cache_init(struct backref_cache *cache)\n{\n\tint i;\n\tcache->rb_root = RB_ROOT;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++)\n\t\tINIT_LIST_HEAD(&cache->pending[i]);\n\tINIT_LIST_HEAD(&cache->changed);\n\tINIT_LIST_HEAD(&cache->detached);\n\tINIT_LIST_HEAD(&cache->leaves);\n}"
  },
  {
    "function_name": "mapping_tree_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
    "lines": "201-205",
    "snippet": "static void mapping_tree_init(struct mapping_tree *tree)\n{\n\ttree->rb_root = RB_ROOT;\n\tspin_lock_init(&tree->lock);\n}",
    "includes": [
      "#include \"inode-map.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"async-thread.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"locking.h\"",
      "#include \"volumes.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline_for_stack\nstruct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&tree->lock"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nstatic void mapping_tree_init(struct mapping_tree *tree)\n{\n\ttree->rb_root = RB_ROOT;\n\tspin_lock_init(&tree->lock);\n}"
  }
]