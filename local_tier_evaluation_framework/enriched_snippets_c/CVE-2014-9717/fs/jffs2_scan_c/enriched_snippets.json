[
  {
    "function_name": "ffs2_rotate_lists(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "1138-1176",
    "snippet": "oid jffs2_rotate_lists(struct jffs2_sb_info *c)\n{\n\tuint32_t x;\n\tuint32_t rotateby;\n\n\tx = count_list(&c->clean_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->clean_list), rotateby);\n\t}\n\n\tx = count_list(&c->very_dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->very_dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->erasable_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->erasable_list), rotateby);\n\t}\n\n\tif (c->nr_erasing_blocks) {\n\t\trotateby = pseudo_random % c->nr_erasing_blocks;\n\t\trotate_list((&c->erase_pending_list), rotateby);\n\t}\n\n\tif (c->nr_free_blocks) {\n\t\trotateby = pseudo_random % c->nr_free_blocks;\n\t\trotate_list((&c->free_list), rotateby);\n\t}\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic uint32_t pseudo_random;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "otate_list(",
          "args": [
            "&c->free_list),",
            "otateby)"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "otate_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "1127-1136",
          "snippet": "tatic void rotate_list(struct list_head *head, uint32_t count)\n{\n\tstruct list_head *n = head->next;\n\n\tlist_del(head);\n\twhile(count--) {\n\t\tn = n->next;\n\t}\n\tlist_add(head, n);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void rotate_list(struct list_head *head, uint32_t count)\n{\n\tstruct list_head *n = head->next;\n\n\tlist_del(head);\n\twhile(count--) {\n\t\tn = n->next;\n\t}\n\tlist_add(head, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ount_list(",
          "args": [
            "c->erasable_list)"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ount_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "1114-1123",
          "snippet": "tatic int count_list(struct list_head *l)\n{\n\tuint32_t count = 0;\n\tstruct list_head *tmp;\n\n\tlist_for_each(tmp, l) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int count_list(struct list_head *l)\n{\n\tuint32_t count = 0;\n\tstruct list_head *tmp;\n\n\tlist_for_each(tmp, l) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\n\noid jffs2_rotate_lists(struct jffs2_sb_info *c)\n{\n\tuint32_t x;\n\tuint32_t rotateby;\n\n\tx = count_list(&c->clean_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->clean_list), rotateby);\n\t}\n\n\tx = count_list(&c->very_dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->very_dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->dirty_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->dirty_list), rotateby);\n\t}\n\n\tx = count_list(&c->erasable_list);\n\tif (x) {\n\t\trotateby = pseudo_random % x;\n\t\trotate_list((&c->erasable_list), rotateby);\n\t}\n\n\tif (c->nr_erasing_blocks) {\n\t\trotateby = pseudo_random % c->nr_erasing_blocks;\n\t\trotate_list((&c->erase_pending_list), rotateby);\n\t}\n\n\tif (c->nr_free_blocks) {\n\t\trotateby = pseudo_random % c->nr_free_blocks;\n\t\trotate_list((&c->free_list), rotateby);\n\t}\n}"
  },
  {
    "function_name": "otate_list(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "1127-1136",
    "snippet": "tatic void rotate_list(struct list_head *head, uint32_t count)\n{\n\tstruct list_head *n = head->next;\n\n\tlist_del(head);\n\twhile(count--) {\n\t\tn = n->next;\n\t}\n\tlist_add(head, n);\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "ead,",
            ")"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del(",
          "args": [
            "ead)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic void rotate_list(struct list_head *head, uint32_t count)\n{\n\tstruct list_head *n = head->next;\n\n\tlist_del(head);\n\twhile(count--) {\n\t\tn = n->next;\n\t}\n\tlist_add(head, n);\n}"
  },
  {
    "function_name": "ount_list(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "1114-1123",
    "snippet": "tatic int count_list(struct list_head *l)\n{\n\tuint32_t count = 0;\n\tstruct list_head *tmp;\n\n\tlist_for_each(tmp, l) {\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_for_each(",
          "args": [
            "mp,",
            ")"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int count_list(struct list_head *l)\n{\n\tuint32_t count = 0;\n\tstruct list_head *tmp;\n\n\tlist_for_each(tmp, l) {\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "ffs2_scan_dirent_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "1039-1112",
    "snippet": "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t checkedlen;\n\tuint32_t crc;\n\tint err;\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We don't get here unless the node is still valid, so we don't have to\n\t   mask in the ACCURATE bit any more. */\n\tcrc = crc32(0, rd, sizeof(*rd)-8);\n\n\tif (crc != je32_to_cpu(rd->node_crc)) {\n\t\tpr_notice(\"%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->node_crc), crc);\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tpseudo_random += je32_to_cpu(rd->version);\n\n\t/* Should never happen. Did. (OLPC trac #4184)*/\n\tcheckedlen = strnlen(rd->name, rd->nsize);\n\tif (checkedlen < rd->nsize) {\n\t\tpr_err(\"Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",\n\t\t       ofs, checkedlen);\n\t}\n\tfd = jffs2_alloc_full_dirent(checkedlen+1);\n\tif (!fd) {\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&fd->name, rd->name, checkedlen);\n\tfd->name[checkedlen] = 0;\n\n\tcrc = crc32(0, fd->name, rd->nsize);\n\tif (crc != je32_to_cpu(rd->name_crc)) {\n\t\tpr_notice(\"%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->name_crc), crc);\n\t\tjffs2_dbg(1, \"Name for which CRC failed is (now) '%s', ino #%d\\n\",\n\t\t\t  fd->name, je32_to_cpu(rd->ino));\n\t\tjffs2_free_full_dirent(fd);\n\t\t/* FIXME: Why do we believe totlen? */\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));\n\tif (!ic) {\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),\n\t\t\t\t      PAD(je32_to_cpu(rd->totlen)), ic);\n\n\tfd->next = NULL;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(fd->name, checkedlen);\n\tfd->type = rd->type;\n\tjffs2_add_fd_to_list(c, fd, &ic->scan_dents);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_dirent_mem(s, rd, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic uint32_t pseudo_random;",
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_sum_add_dirent_mem(",
          "args": [
            ",",
            "d,",
            "fs - jeb->offset)"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_dirent_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "133-155",
          "snippet": "nt jffs2_sum_add_dirent_mem(struct jffs2_summary *s, struct jffs2_raw_dirent *rd,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_dirent_mem *temp =\n\t\tkmalloc(sizeof(struct jffs2_sum_dirent_mem) + rd->nsize, GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rd->nodetype;\n\ttemp->totlen = rd->totlen;\n\ttemp->offset = cpu_to_je32(ofs);\t/* relative from the beginning of the jeb */\n\ttemp->pino = rd->pino;\n\ttemp->version = rd->version;\n\ttemp->ino = rd->ino;\n\ttemp->nsize = rd->nsize;\n\ttemp->type = rd->type;\n\ttemp->next = NULL;\n\n\tmemcpy(temp->name, rd->name, rd->nsize);\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_dirent_mem(struct jffs2_summary *s, struct jffs2_raw_dirent *rd,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_dirent_mem *temp =\n\t\tkmalloc(sizeof(struct jffs2_sum_dirent_mem) + rd->nsize, GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rd->nodetype;\n\ttemp->totlen = rd->totlen;\n\ttemp->offset = cpu_to_je32(ofs);\t/* relative from the beginning of the jeb */\n\ttemp->pino = rd->pino;\n\ttemp->version = rd->version;\n\ttemp->ino = rd->ino;\n\ttemp->nsize = rd->nsize;\n\ttemp->type = rd->type;\n\ttemp->next = NULL;\n\n\tmemcpy(temp->name, rd->name, rd->nsize);\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_add_fd_to_list(",
          "args": [
            ",",
            "d,",
            "ic->scan_dents)"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_add_fd_to_list(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "26-57",
          "snippet": "oid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\n{\n\tstruct jffs2_full_dirent **prev = list;\n\n\tdbg_dentlist(\"add dirent \\\"%s\\\", ino #%u\\n\", new->name, new->ino);\n\n\twhile ((*prev) && (*prev)->nhash <= new->nhash) {\n\t\tif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\n\t\t\t/* Duplicate. Free one */\n\t\t\tif (new->version < (*prev)->version) {\n\t\t\t\tdbg_dentlist(\"Eep! Marking new dirent node obsolete, old is \\\"%s\\\", ino #%u\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tjffs2_mark_node_obsolete(c, new->raw);\n\t\t\t\tjffs2_free_full_dirent(new);\n\t\t\t} else {\n\t\t\t\tdbg_dentlist(\"marking old dirent \\\"%s\\\", ino #%u obsolete\\n\",\n\t\t\t\t\t(*prev)->name, (*prev)->ino);\n\t\t\t\tnew->next = (*prev)->next;\n\t\t\t\t/* It may have been a 'placeholder' deletion dirent, \n\t\t\t\t   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */\n\t\t\t\tif ((*prev)->raw)\n\t\t\t\t\tjffs2_mark_node_obsolete(c, ((*prev)->raw));\n\t\t\t\tjffs2_free_full_dirent(*prev);\n\t\t\t\t*prev = new;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprev = &((*prev)->next);\n\t}\n\tnew->next = *prev;\n\t*prev = new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ull_name_hash(",
          "args": [
            "d->name,",
            "heckedlen)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->ino)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs | dirent_node_state(rd),",
            "AD(je32_to_cpu(rd->totlen)),",
            "c)"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(rd->totlen))"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->totlen)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irent_node_state(",
          "args": [
            "d)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_free_full_dirent(",
          "args": [
            "d)"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_free_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "130-134",
          "snippet": "oid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_free_full_dirent(struct jffs2_full_dirent *x)\n{\n\tdbg_memalloc(\"%p\\n\", x);\n\tkfree(x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_scan_make_ino_cache(",
          "args": [
            ",",
            "e32_to_cpu(rd->pino))"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_make_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "959-983",
          "snippet": "truct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntruct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->pino)"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "AD(je32_to_cpu(rd->totlen)))"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(rd->totlen))"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->totlen)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Name for which CRC failed is (now) '%s', ino #%d\\n\",",
            "d->name,",
            "e32_to_cpu(rd->ino))"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->ino)"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "_func__,",
            "fs,",
            "e32_to_cpu(rd->name_crc),",
            "rc)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->name_crc)"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->name_crc)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d->name,",
            "d->nsize)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "fd->name,",
            "d->name,",
            "heckedlen)"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_full_dirent(",
          "args": [
            "heckedlen+1)"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_alloc_full_dirent(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "122-128",
          "snippet": "truct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)\n{\n\tstruct jffs2_full_dirent *ret;\n\tret = kmalloc(sizeof(struct jffs2_full_dirent) + namesize, GFP_KERNEL);\n\tdbg_memalloc(\"%p\\n\", ret);\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_full_dirent *jffs2_alloc_full_dirent(int namesize)\n{\n\tstruct jffs2_full_dirent *ret;\n\tret = kmalloc(sizeof(struct jffs2_full_dirent) + namesize, GFP_KERNEL);\n\tdbg_memalloc(\"%p\\n\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r_err(",
          "args": [
            "Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",",
            "fs,",
            "heckedlen)"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trnlen(",
          "args": [
            "d->name,",
            "d->nsize)"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->version)"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(rd->totlen))"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->totlen)"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "_func__,",
            "fs,",
            "e32_to_cpu(rd->node_crc),",
            "rc)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->node_crc)"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "d->node_crc)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "d,",
            "izeof(*rd)-8)"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Node at 0x%08x\\n\",",
            "_func__,",
            "fs)"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t checkedlen;\n\tuint32_t crc;\n\tint err;\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We don't get here unless the node is still valid, so we don't have to\n\t   mask in the ACCURATE bit any more. */\n\tcrc = crc32(0, rd, sizeof(*rd)-8);\n\n\tif (crc != je32_to_cpu(rd->node_crc)) {\n\t\tpr_notice(\"%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->node_crc), crc);\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tpseudo_random += je32_to_cpu(rd->version);\n\n\t/* Should never happen. Did. (OLPC trac #4184)*/\n\tcheckedlen = strnlen(rd->name, rd->nsize);\n\tif (checkedlen < rd->nsize) {\n\t\tpr_err(\"Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",\n\t\t       ofs, checkedlen);\n\t}\n\tfd = jffs2_alloc_full_dirent(checkedlen+1);\n\tif (!fd) {\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&fd->name, rd->name, checkedlen);\n\tfd->name[checkedlen] = 0;\n\n\tcrc = crc32(0, fd->name, rd->nsize);\n\tif (crc != je32_to_cpu(rd->name_crc)) {\n\t\tpr_notice(\"%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->name_crc), crc);\n\t\tjffs2_dbg(1, \"Name for which CRC failed is (now) '%s', ino #%d\\n\",\n\t\t\t  fd->name, je32_to_cpu(rd->ino));\n\t\tjffs2_free_full_dirent(fd);\n\t\t/* FIXME: Why do we believe totlen? */\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));\n\tif (!ic) {\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),\n\t\t\t\t      PAD(je32_to_cpu(rd->totlen)), ic);\n\n\tfd->next = NULL;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(fd->name, checkedlen);\n\tfd->type = rd->type;\n\tjffs2_add_fd_to_list(c, fd, &ic->scan_dents);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_dirent_mem(s, rd, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_scan_inode_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "985-1037",
    "snippet": "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t crc, ino = je32_to_cpu(ri->ino);\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We do very little here now. Just check the ino# to which we should attribute\n\t   this node; we can do all the CRC checking etc. later. There's a tradeoff here --\n\t   we used to scan the flash once only, reading everything we want from it into\n\t   memory, then building all our in-core data structures and freeing the extra\n\t   information. Now we allow the first part of the mount to complete a lot quicker,\n\t   but we have to go _back_ to the flash in order to finish the CRC checking, etc.\n\t   Which means that the _full_ amount of time to get to proper write mode with GC\n\t   operational may actually be _longer_ than before. Sucks to be me. */\n\n\t/* Check the node CRC in any case. */\n\tcrc = crc32(0, ri, sizeof(*ri)-8);\n\tif (crc != je32_to_cpu(ri->node_crc)) {\n\t\tpr_notice(\"%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(ri->node_crc), crc);\n\t\t/*\n\t\t * We believe totlen because the CRC on the node\n\t\t * _header_ was OK, just the node itself failed.\n\t\t */\n\t\treturn jffs2_scan_dirty_space(c, jeb,\n\t\t\t\t\t      PAD(je32_to_cpu(ri->totlen)));\n\t}\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (!ic) {\n\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\tif (!ic)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Wheee. It worked */\n\tjffs2_link_node_ref(c, jeb, ofs | REF_UNCHECKED, PAD(je32_to_cpu(ri->totlen)), ic);\n\n\tjffs2_dbg(1, \"Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",\n\t\t  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),\n\t\t  je32_to_cpu(ri->offset),\n\t\t  je32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize));\n\n\tpseudo_random += je32_to_cpu(ri->version);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_inode_mem(s, ri, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic uint32_t pseudo_random;",
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_sum_add_inode_mem(",
          "args": [
            ",",
            "i,",
            "fs - jeb->offset)"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_inode_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "115-131",
          "snippet": "nt jffs2_sum_add_inode_mem(struct jffs2_summary *s, struct jffs2_raw_inode *ri,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_inode_mem *temp = kmalloc(sizeof(struct jffs2_sum_inode_mem), GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = ri->nodetype;\n\ttemp->inode = ri->ino;\n\ttemp->version = ri->version;\n\ttemp->offset = cpu_to_je32(ofs); /* relative offset from the beginning of the jeb */\n\ttemp->totlen = ri->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_inode_mem(struct jffs2_summary *s, struct jffs2_raw_inode *ri,\n\t\t\t\tuint32_t ofs)\n{\n\tstruct jffs2_sum_inode_mem *temp = kmalloc(sizeof(struct jffs2_sum_inode_mem), GFP_KERNEL);\n\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = ri->nodetype;\n\ttemp->inode = ri->ino;\n\ttemp->version = ri->version;\n\ttemp->offset = cpu_to_je32(ofs); /* relative offset from the beginning of the jeb */\n\ttemp->totlen = ri->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->version)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",",
            "e32_to_cpu(ri->ino),",
            "e32_to_cpu(ri->version),",
            "e32_to_cpu(ri->offset),",
            "e32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize))"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->dsize)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->offset)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->offset)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->version)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->ino)"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs | REF_UNCHECKED,",
            "AD(je32_to_cpu(ri->totlen)),",
            "c)"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(ri->totlen))"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->totlen)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_make_ino_cache(",
          "args": [
            ",",
            "no)"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_make_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "959-983",
          "snippet": "truct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntruct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_get_ino_cache(",
          "args": [
            ",",
            "no)"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_get_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "421-434",
          "snippet": "truct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "AD(je32_to_cpu(ri->totlen)))"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(ri->totlen))"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->totlen)"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "_func__,",
            "fs,",
            "e32_to_cpu(ri->node_crc),",
            "rc)"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->node_crc)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->node_crc)"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "i,",
            "izeof(*ri)-8)"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Node at 0x%08x\\n\",",
            "_func__,",
            "fs)"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "i->ino)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t crc, ino = je32_to_cpu(ri->ino);\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We do very little here now. Just check the ino# to which we should attribute\n\t   this node; we can do all the CRC checking etc. later. There's a tradeoff here --\n\t   we used to scan the flash once only, reading everything we want from it into\n\t   memory, then building all our in-core data structures and freeing the extra\n\t   information. Now we allow the first part of the mount to complete a lot quicker,\n\t   but we have to go _back_ to the flash in order to finish the CRC checking, etc.\n\t   Which means that the _full_ amount of time to get to proper write mode with GC\n\t   operational may actually be _longer_ than before. Sucks to be me. */\n\n\t/* Check the node CRC in any case. */\n\tcrc = crc32(0, ri, sizeof(*ri)-8);\n\tif (crc != je32_to_cpu(ri->node_crc)) {\n\t\tpr_notice(\"%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(ri->node_crc), crc);\n\t\t/*\n\t\t * We believe totlen because the CRC on the node\n\t\t * _header_ was OK, just the node itself failed.\n\t\t */\n\t\treturn jffs2_scan_dirty_space(c, jeb,\n\t\t\t\t\t      PAD(je32_to_cpu(ri->totlen)));\n\t}\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (!ic) {\n\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\tif (!ic)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Wheee. It worked */\n\tjffs2_link_node_ref(c, jeb, ofs | REF_UNCHECKED, PAD(je32_to_cpu(ri->totlen)), ic);\n\n\tjffs2_dbg(1, \"Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",\n\t\t  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),\n\t\t  je32_to_cpu(ri->offset),\n\t\t  je32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize));\n\n\tpseudo_random += je32_to_cpu(ri->version);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_inode_mem(s, ri, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_scan_make_ino_cache(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "959-983",
    "snippet": "truct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_add_ino_cache(",
          "args": [
            ",",
            "c)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "c,",
            ",",
            "izeof(*ic))"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "%s(): allocation of inode cache failed\\n\",",
            "_func__)"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_inode_cache(",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_get_ino_cache(",
          "args": [
            ",",
            "no)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_get_ino_cache(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "421-434",
          "snippet": "truct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ret;\n\n\tret = c->inocache_list[ino % c->inocache_hashsize];\n\twhile (ret && ret->ino < ino) {\n\t\tret = ret->next;\n\t}\n\n\tif (ret && ret->ino != ino)\n\t\tret = NULL;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntruct jffs2_inode_cache *jffs2_scan_make_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\n{\n\tstruct jffs2_inode_cache *ic;\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (ic)\n\t\treturn ic;\n\n\tif (ino > c->highest_ino)\n\t\tc->highest_ino = ino;\n\n\tic = jffs2_alloc_inode_cache();\n\tif (!ic) {\n\t\tpr_notice(\"%s(): allocation of inode cache failed\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tmemset(ic, 0, sizeof(*ic));\n\n\tic->ino = ino;\n\tic->nodes = (void *)ic;\n\tjffs2_add_ino_cache(c, ic);\n\tif (ino == 1)\n\t\tic->pino_nlink = 1;\n\treturn ic;\n}"
  },
  {
    "function_name": "ffs2_scan_eraseblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "442-957",
    "snippet": "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s) {\n\tstruct jffs2_unknown_node *node;\n\tstruct jffs2_unknown_node crcnode;\n\tuint32_t ofs, prevofs, max_ofs;\n\tuint32_t hdr_crc, buf_ofs, buf_len;\n\tint err;\n\tint noise = 0;\n\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tint cleanmarkerfound = 0;\n#endif\n\n\tofs = jeb->offset;\n\tprevofs = jeb->offset - 1;\n\n\tjffs2_dbg(1, \"%s(): Scanning block at 0x%x\\n\", __func__, ofs);\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tint ret;\n\n\t\tif (mtd_block_isbad(c->mtd, jeb->offset))\n\t\t\treturn BLK_STATE_BADBLOCK;\n\n\t\tret = jffs2_check_nand_cleanmarker(c, jeb);\n\t\tjffs2_dbg(2, \"jffs_check_nand_cleanmarker returned %d\\n\", ret);\n\n\t\t/* Even if it's not found, we still scan to see\n\t\t   if the block is empty. We use this information\n\t\t   to decide whether to erase it or not. */\n\t\tswitch (ret) {\n\t\tcase 0:\t\tcleanmarkerfound = 1; break;\n\t\tcase 1: \tbreak;\n\t\tdefault: \treturn ret;\n\t\t}\n\t}\n#endif\n\n\tif (jffs2_sum_active()) {\n\t\tstruct jffs2_sum_marker *sm;\n\t\tvoid *sumptr = NULL;\n\t\tuint32_t sumlen;\n\t      \n\t\tif (!buf_size) {\n\t\t\t/* XIP case. Just look, point at the summary if it's there */\n\t\t\tsm = (void *)buf + c->sector_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumptr = buf + je32_to_cpu(sm->offset);\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t}\n\t\t} else {\n\t\t\t/* If NAND flash, read a whole page of it. Else just the end */\n\t\t\tif (c->wbuf_pagesize)\n\t\t\t\tbuf_len = c->wbuf_pagesize;\n\t\t\telse\n\t\t\t\tbuf_len = sizeof(*sm);\n\n\t\t\t/* Read as much as we want into the _end_ of the preallocated buffer */\n\t\t\terr = jffs2_fill_scan_buf(c, buf + buf_size - buf_len, \n\t\t\t\t\t\t  jeb->offset + c->sector_size - buf_len,\n\t\t\t\t\t\t  buf_len);\t\t\t\t\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsm = (void *)buf + buf_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t\tsumptr = buf + buf_size - sumlen;\n\n\t\t\t\t/* sm->offset maybe wrong but MAGIC maybe right */\n\t\t\t\tif (sumlen > c->sector_size)\n\t\t\t\t\tgoto full_scan;\n\n\t\t\t\t/* Now, make sure the summary itself is available */\n\t\t\t\tif (sumlen > buf_size) {\n\t\t\t\t\t/* Need to kmalloc for this. */\n\t\t\t\t\tsumptr = kmalloc(sumlen, GFP_KERNEL);\n\t\t\t\t\tif (!sumptr)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tmemcpy(sumptr + sumlen - buf_len, buf + buf_size - buf_len, buf_len);\n\t\t\t\t}\n\t\t\t\tif (buf_len < sumlen) {\n\t\t\t\t\t/* Need to read more so that the entire summary node is present */\n\t\t\t\t\terr = jffs2_fill_scan_buf(c, sumptr, \n\t\t\t\t\t\t\t\t  jeb->offset + c->sector_size - sumlen,\n\t\t\t\t\t\t\t\t  sumlen - buf_len);\t\t\t\t\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (sumptr) {\n\t\t\terr = jffs2_sum_scan_sumnode(c, jeb, sumptr, sumlen, &pseudo_random);\n\n\t\t\tif (buf_size && sumlen > buf_size)\n\t\t\t\tkfree(sumptr);\n\t\t\t/* If it returns with a real error, bail. \n\t\t\t   If it returns positive, that's a block classification\n\t\t\t   (i.e. BLK_STATE_xxx) so return that too.\n\t\t\t   If it returns zero, fall through to full scan. */\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\nfull_scan:\n\tbuf_ofs = jeb->offset;\n\n\tif (!buf_size) {\n\t\t/* This is the XIP case -- we're reading _directly_ from the flash chip */\n\t\tbuf_len = c->sector_size;\n\t} else {\n\t\tbuf_len = EMPTY_SCAN_SIZE(c->sector_size);\n\t\terr = jffs2_fill_scan_buf(c, buf, buf_ofs, buf_len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* We temporarily use 'ofs' as a pointer into the buffer/jeb */\n\tofs = 0;\n\tmax_ofs = EMPTY_SCAN_SIZE(c->sector_size);\n\t/* Scan only EMPTY_SCAN_SIZE of 0xFF before declaring it's empty */\n\twhile(ofs < max_ofs && *(uint32_t *)(&buf[ofs]) == 0xFFFFFFFF)\n\t\tofs += 4;\n\n\tif (ofs == max_ofs) {\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\t/* scan oob, take care of cleanmarker */\n\t\t\tint ret = jffs2_check_oob_empty(c, jeb, cleanmarkerfound);\n\t\t\tjffs2_dbg(2, \"jffs2_check_oob_empty returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\treturn cleanmarkerfound ? BLK_STATE_CLEANMARKER : BLK_STATE_ALLFF;\n\t\t\tcase 1: \treturn BLK_STATE_ALLDIRTY;\n\t\t\tdefault: \treturn ret;\n\t\t\t}\n\t\t}\n#endif\n\t\tjffs2_dbg(1, \"Block at 0x%08x is empty (erased)\\n\",\n\t\t\t  jeb->offset);\n\t\tif (c->cleanmarker_size == 0)\n\t\t\treturn BLK_STATE_CLEANMARKER;\t/* don't bother with re-erase */\n\t\telse\n\t\t\treturn BLK_STATE_ALLFF;\t/* OK to erase if all blocks are like this */\n\t}\n\tif (ofs) {\n\t\tjffs2_dbg(1, \"Free space at %08x ends at %08x\\n\", jeb->offset,\n\t\t\t  jeb->offset + ofs);\n\t\tif ((err = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\t\treturn err;\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs)))\n\t\t\treturn err;\n\t}\n\n\t/* Now ofs is a complete physical flash offset as it always was... */\n\tofs += jeb->offset;\n\n\tnoise = 10;\n\n\tdbg_summary(\"no summary found in jeb 0x%08x. Apply original scan.\\n\",jeb->offset);\n\nscan_more:\n\twhile(ofs < jeb->offset + c->sector_size) {\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t/* Make sure there are node refs available for use */\n\t\terr = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcond_resched();\n\n\t\tif (ofs & 3) {\n\t\t\tpr_warn(\"Eep. ofs 0x%08x not word-aligned!\\n\", ofs);\n\t\t\tofs = PAD(ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ofs == prevofs) {\n\t\t\tpr_warn(\"ofs 0x%08x has already been seen. Skipping\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tprevofs = ofs;\n\n\t\tif (jeb->offset + c->sector_size < ofs + sizeof(*node)) {\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes left to end of block. (%x+%x<%x+%zx) Not reading\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  jeb->offset, c->sector_size, ofs,\n\t\t\t\t  sizeof(*node));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, (jeb->offset + c->sector_size)-ofs)))\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_ofs + buf_len < ofs + sizeof(*node)) {\n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (node header) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t}\n\n\t\tnode = (struct jffs2_unknown_node *)&buf[ofs-buf_ofs];\n\n\t\tif (*(uint32_t *)(&buf[ofs-buf_ofs]) == 0xffffffff) {\n\t\t\tuint32_t inbuf_ofs;\n\t\t\tuint32_t empty_start, scan_end;\n\n\t\t\tempty_start = ofs;\n\t\t\tofs += 4;\n\t\t\tscan_end = min_t(uint32_t, EMPTY_SCAN_SIZE(c->sector_size)/8, buf_len);\n\n\t\t\tjffs2_dbg(1, \"Found empty flash at 0x%08x\\n\", ofs);\n\t\tmore_empty:\n\t\t\tinbuf_ofs = ofs - buf_ofs;\n\t\t\twhile (inbuf_ofs < scan_end) {\n\t\t\t\tif (unlikely(*(uint32_t *)(&buf[inbuf_ofs]) != 0xffffffff)) {\n\t\t\t\t\tpr_warn(\"Empty flash at 0x%08x ends at 0x%08x\\n\",\n\t\t\t\t\t\tempty_start, ofs);\n\t\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs-empty_start)))\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tgoto scan_more;\n\t\t\t\t}\n\n\t\t\t\tinbuf_ofs+=4;\n\t\t\t\tofs += 4;\n\t\t\t}\n\t\t\t/* Ran off end. */\n\t\t\tjffs2_dbg(1, \"Empty flash to end of buffer at 0x%08x\\n\",\n\t\t\t\t  ofs);\n\n\t\t\t/* If we're only checking the beginning of a block with a cleanmarker,\n\t\t\t   bail now */\n\t\t\tif (buf_ofs == jeb->offset && jeb->used_size == PAD(c->cleanmarker_size) &&\n\t\t\t    c->cleanmarker_size && !jeb->dirty_size && !ref_next(jeb->first_node)) {\n\t\t\t\tjffs2_dbg(1, \"%d bytes at start of block seems clean... assuming all clean\\n\",\n\t\t\t\t\t  EMPTY_SCAN_SIZE(c->sector_size));\n\t\t\t\treturn BLK_STATE_CLEANMARKER;\n\t\t\t}\n\t\t\tif (!buf_size && (scan_end != buf_len)) {/* XIP/point case */\n\t\t\t\tscan_end = buf_len;\n\t\t\t\tgoto more_empty;\n\t\t\t}\n\t\t\t\n\t\t\t/* See how much more there is to read in this eraseblock... */\n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tif (!buf_len) {\n\t\t\t\t/* No more to read. Break out of main loop without marking\n\t\t\t\t   this range of empty space as dirty (because it's not) */\n\t\t\t\tjffs2_dbg(1, \"Empty flash at %08x runs to end of block. Treating as free_space\\n\",\n\t\t\t\t\t  empty_start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* point never reaches here */\n\t\t\tscan_end = buf_len;\n\t\t\tjffs2_dbg(1, \"Reading another 0x%x at 0x%08x\\n\",\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t\tgoto more_empty;\n\t\t}\n\n\t\tif (ofs == jeb->offset && je16_to_cpu(node->magic) == KSAMTIB_CIGAM_2SFFJ) {\n\t\t\tpr_warn(\"Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_DIRTY_BITMASK) {\n\t\t\tjffs2_dbg(1, \"Dirty bitmask at 0x%08x\\n\", ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_OLD_MAGIC_BITMASK) {\n\t\t\tpr_warn(\"Old JFFS2 bitmask found at 0x%08x\\n\", ofs);\n\t\t\tpr_warn(\"You cannot use older JFFS2 filesystems with newer kernels\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t/* OK. We're out of possibilities. Whinge and move on */\n\t\t\tnoisy_printk(&noise, \"%s(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     JFFS2_MAGIC_BITMASK, ofs,\n\t\t\t\t     je16_to_cpu(node->magic));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We seem to have a node of sorts. Check the CRC */\n\t\tcrcnode.magic = node->magic;\n\t\tcrcnode.nodetype = cpu_to_je16( je16_to_cpu(node->nodetype) | JFFS2_NODE_ACCURATE);\n\t\tcrcnode.totlen = node->totlen;\n\t\thdr_crc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\t\tif (hdr_crc != je32_to_cpu(node->hdr_crc)) {\n\t\t\tnoisy_printk(&noise, \"%s(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     ofs, je16_to_cpu(node->magic),\n\t\t\t\t     je16_to_cpu(node->nodetype),\n\t\t\t\t     je32_to_cpu(node->totlen),\n\t\t\t\t     je32_to_cpu(node->hdr_crc),\n\t\t\t\t     hdr_crc);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ofs + je32_to_cpu(node->totlen) > jeb->offset + c->sector_size) {\n\t\t\t/* Eep. Node goes over the end of the erase block. */\n\t\t\tpr_warn(\"Node at 0x%08x with length 0x%08x would run over the end of the erase block\\n\",\n\t\t\t\tofs, je32_to_cpu(node->totlen));\n\t\t\tpr_warn(\"Perhaps the file system was created with the wrong erase size?\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(je16_to_cpu(node->nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\t\t/* Wheee. This is an obsoleted node */\n\t\t\tjffs2_dbg(2, \"Node at 0x%08x is obsolete. Skipping\\n\",\n\t\t\t\t  ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(je16_to_cpu(node->nodetype)) {\n\t\tcase JFFS2_NODETYPE_INODE:\n\t\t\tif (buf_ofs + buf_len < ofs + sizeof(struct jffs2_raw_inode)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  sizeof(struct jffs2_raw_inode),\n\t\t\t\t\t  buf_len, ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_inode_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_dirent_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase JFFS2_NODETYPE_XATTR:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xattr node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xattr_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\t\tcase JFFS2_NODETYPE_XREF:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xref node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xref_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n#endif\t/* CONFIG_JFFS2_FS_XATTR */\n\n\t\tcase JFFS2_NODETYPE_CLEANMARKER:\n\t\t\tjffs2_dbg(1, \"CLEANMARKER node found at 0x%08x\\n\", ofs);\n\t\t\tif (je32_to_cpu(node->totlen) != c->cleanmarker_size) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\t\t  ofs, je32_to_cpu(node->totlen),\n\t\t\t\t\t  c->cleanmarker_size);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else if (jeb->first_node) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\\n\",\n\t\t\t\t\t  ofs, jeb->offset);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else {\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\t\t\t\tofs += PAD(c->cleanmarker_size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_PADDING:\n\t\t\tif (jffs2_sum_active())\n\t\t\t\tjffs2_sum_add_padding_mem(s, je32_to_cpu(node->totlen));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tswitch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {\n\t\t\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\t\t\tpr_notice(\"Read-only compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tc->flags |= JFFS2_SB_FLAG_RO;\n\t\t\t\tif (!(jffs2_is_readonly(c)))\n\t\t\t\t\treturn -EROFS;\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_INCOMPAT:\n\t\t\t\tpr_notice(\"Incompatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_COPY: {\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(node->totlen)), NULL);\n\n\t\t\t\t/* We can't summarise nodes we don't grok */\n\t\t\t\tjffs2_sum_disable_collecting(s);\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\tif (PAD(s->sum_size + JFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size) {\n\t\t\tdbg_summary(\"There is not enough space for \"\n\t\t\t\t\"summary information, disabling for this jeb!\\n\");\n\t\t\tjffs2_sum_disable_collecting(s);\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x, wasted 0x%08x\\n\",\n\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t  jeb->unchecked_size, jeb->used_size, jeb->wasted_size);\n\t\n\t/* mark_node_obsolete can add to wasted !! */\n\tif (jeb->wasted_size) {\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic uint32_t pseudo_random;",
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_scan_classify_jeb(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_classify_jeb(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "307-324",
          "snippet": "nt jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tif ((jeb->used_size + jeb->unchecked_size) == PAD(c->cleanmarker_size) && !jeb->dirty_size\n\t    && (!jeb->first_node || !ref_next(jeb->first_node)) )\n\t\treturn BLK_STATE_CLEANMARKER;\n\n\t/* move blocks with max 4 byte dirty space to cleanlist */\n\telse if (!ISDIRTY(c->sector_size - (jeb->used_size + jeb->unchecked_size))) {\n\t\tc->dirty_size -= jeb->dirty_size;\n\t\tc->wasted_size += jeb->dirty_size;\n\t\tjeb->wasted_size += jeb->dirty_size;\n\t\tjeb->dirty_size = 0;\n\t\treturn BLK_STATE_CLEAN;\n\t} else if (jeb->used_size || jeb->unchecked_size)\n\t\treturn BLK_STATE_PARTDIRTY;\n\telse\n\t\treturn BLK_STATE_ALLDIRTY;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tif ((jeb->used_size + jeb->unchecked_size) == PAD(c->cleanmarker_size) && !jeb->dirty_size\n\t    && (!jeb->first_node || !ref_next(jeb->first_node)) )\n\t\treturn BLK_STATE_CLEANMARKER;\n\n\t/* move blocks with max 4 byte dirty space to cleanlist */\n\telse if (!ISDIRTY(c->sector_size - (jeb->used_size + jeb->unchecked_size))) {\n\t\tc->dirty_size -= jeb->dirty_size;\n\t\tc->wasted_size += jeb->dirty_size;\n\t\tjeb->wasted_size += jeb->dirty_size;\n\t\tjeb->dirty_size = 0;\n\t\treturn BLK_STATE_CLEAN;\n\t} else if (jeb->used_size || jeb->unchecked_size)\n\t\treturn BLK_STATE_PARTDIRTY;\n\telse\n\t\treturn BLK_STATE_ALLDIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x, wasted 0x%08x\\n\",",
            "eb->offset,",
            "eb->free_size,",
            "eb->dirty_size,",
            "eb->unchecked_size,",
            "eb->used_size,",
            "eb->wasted_size)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_disable_collecting(",
          "args": [
            ")"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_disable_collecting(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "217-222",
          "snippet": "oid jffs2_sum_disable_collecting(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = JFFS2_SUMMARY_NOSUM_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_sum_disable_collecting(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = JFFS2_SUMMARY_NOSUM_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bg_summary(",
          "args": [
            "There is not enough space for \"\n\t\t\t\t\"summary information, disabling for this jeb!\\n\")"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "->sum_size + JFFS2_SUMMARY_FRAME_SIZE)"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs | REF_PRISTINE,",
            "AD(je32_to_cpu(node->totlen)),",
            "ULL)"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",",
            "e16_to_cpu(node->nodetype),",
            "fs)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "AD(je32_to_cpu(node->totlen)))"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",",
            "e16_to_cpu(node->nodetype),",
            "fs)"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Incompatible feature node (0x%04x) found at offset 0x%08x\\n\",",
            "e16_to_cpu(node->nodetype),",
            "fs)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_is_readonly(",
          "args": [
            ")"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Read-only compatible feature node (0x%04x) found at offset 0x%08x\\n\",",
            "e16_to_cpu(node->nodetype),",
            "fs)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_add_padding_mem(",
          "args": [
            ",",
            "e32_to_cpu(node->totlen))"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_padding_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "108-113",
          "snippet": "nt jffs2_sum_add_padding_mem(struct jffs2_summary *s, uint32_t size)\n{\n\tdbg_summary(\"called with %u\\n\", size);\n\ts->sum_padded += size;\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_padding_mem(struct jffs2_summary *s, uint32_t size)\n{\n\tdbg_summary(\"called with %u\\n\", size);\n\ts->sum_padded += size;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "->cleanmarker_size)"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_unknown_node))"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_unknown_node))"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\\n\",",
            "fs,",
            "eb->offset)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_unknown_node))"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_unknown_node))"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\\n\",",
            "fs,",
            "e32_to_cpu(node->totlen),",
            "->cleanmarker_size)"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "CLEANMARKER node found at 0x%08x\\n\",",
            "fs)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_xref_node(",
          "args": [
            ",",
            "eb,",
            "void *)node,",
            "fs,",
            ")"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_xref_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "383-437",
          "snippet": "tatic int jffs2_scan_xref_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_xref *rr, uint32_t ofs,\n\t\t\t\tstruct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_ref *ref;\n\tuint32_t crc;\n\tint err;\n\n\tcrc = crc32(0, rr, sizeof(*rr) - 4);\n\tif (crc != je32_to_cpu(rr->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rr->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tif (PAD(sizeof(struct jffs2_raw_xref)) != je32_to_cpu(rr->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%zd\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->totlen),\n\t\t\t      PAD(sizeof(struct jffs2_raw_xref)));\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rr->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\t/* BEFORE jffs2_build_xattr_subsystem() called, \n\t * and AFTER xattr_ref is marked as a dead xref,\n\t * ref->xid is used to store 32bit xid, xd is not used\n\t * ref->ino is used to store 32bit inode-number, ic is not used\n\t * Thoes variables are declared as union, thus using those\n\t * are exclusive. In a similar way, ref->next is temporarily\n\t * used to chain all xattr_ref object. It's re-chained to\n\t * jffs2_inode_cache in jffs2_build_xattr_subsystem() correctly.\n\t */\n\tref->ino = je32_to_cpu(rr->ino);\n\tref->xid = je32_to_cpu(rr->xid);\n\tref->xseqno = je32_to_cpu(rr->xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\tref->next = c->xref_temp;\n\tc->xref_temp = ref;\n\n\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rr->totlen)), (void *)ref);\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xref_mem(s, rr, ofs - jeb->offset);\n\tdbg_xattr(\"scan xref at %#08x (xid=%u, ino=%u)\\n\",\n\t\t  ofs, ref->xid, ref->ino);\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_xref_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_xref *rr, uint32_t ofs,\n\t\t\t\tstruct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_ref *ref;\n\tuint32_t crc;\n\tint err;\n\n\tcrc = crc32(0, rr, sizeof(*rr) - 4);\n\tif (crc != je32_to_cpu(rr->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rr->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tif (PAD(sizeof(struct jffs2_raw_xref)) != je32_to_cpu(rr->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%zd\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->totlen),\n\t\t\t      PAD(sizeof(struct jffs2_raw_xref)));\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rr->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\t/* BEFORE jffs2_build_xattr_subsystem() called, \n\t * and AFTER xattr_ref is marked as a dead xref,\n\t * ref->xid is used to store 32bit xid, xd is not used\n\t * ref->ino is used to store 32bit inode-number, ic is not used\n\t * Thoes variables are declared as union, thus using those\n\t * are exclusive. In a similar way, ref->next is temporarily\n\t * used to chain all xattr_ref object. It's re-chained to\n\t * jffs2_inode_cache in jffs2_build_xattr_subsystem() correctly.\n\t */\n\tref->ino = je32_to_cpu(rr->ino);\n\tref->xid = je32_to_cpu(rr->xid);\n\tref->xseqno = je32_to_cpu(rr->xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\tref->next = c->xref_temp;\n\tc->xref_temp = ref;\n\n\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rr->totlen)), (void *)ref);\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xref_mem(s, rr, ofs - jeb->offset);\n\tdbg_xattr(\"scan xref at %#08x (xid=%u, ino=%u)\\n\",\n\t\t  ofs, ref->xid, ref->ino);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_fill_scan_buf(",
          "args": [
            ",",
            "uf,",
            "fs,",
            "uf_len)"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_fill_scan_buf(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "287-305",
          "snippet": "tatic int jffs2_fill_scan_buf(struct jffs2_sb_info *c, void *buf,\n\t\t\t       uint32_t ofs, uint32_t len)\n{\n\tint ret;\n\tsize_t retlen;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret) {\n\t\tjffs2_dbg(1, \"mtd->read(0x%x bytes from 0x%x) returned %d\\n\",\n\t\t\t  len, ofs, ret);\n\t\treturn ret;\n\t}\n\tif (retlen < len) {\n\t\tjffs2_dbg(1, \"Read at 0x%x gave only 0x%zx bytes\\n\",\n\t\t\t  ofs, retlen);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_fill_scan_buf(struct jffs2_sb_info *c, void *buf,\n\t\t\t       uint32_t ofs, uint32_t len)\n{\n\tint ret;\n\tsize_t retlen;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret) {\n\t\tjffs2_dbg(1, \"mtd->read(0x%x bytes from 0x%x) returned %d\\n\",\n\t\t\t  len, ofs, ret);\n\t\treturn ret;\n\t}\n\tif (retlen < len) {\n\t\tjffs2_dbg(1, \"Read at 0x%x gave only 0x%zx bytes\\n\",\n\t\t\t  ofs, retlen);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %d bytes (xref node) left to end of buf. Reading 0x%x at 0x%08x\\n\",",
            "e32_to_cpu(node->totlen),",
            "uf_len,",
            "fs)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_xattr_node(",
          "args": [
            ",",
            "eb,",
            "void *)node,",
            "fs,",
            ")"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_xattr_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "327-381",
          "snippet": "tatic int jffs2_scan_xattr_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_xattr *rx, uint32_t ofs,\n\t\t\t\t struct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t xid, version, totlen, crc;\n\tint err;\n\n\tcrc = crc32(0, rx, sizeof(struct jffs2_raw_xattr) - 4);\n\tif (crc != je32_to_cpu(rx->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txid = je32_to_cpu(rx->xid);\n\tversion = je32_to_cpu(rx->version);\n\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len));\n\tif (totlen != je32_to_cpu(rx->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%u\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->totlen), totlen);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txd = jffs2_setup_xattr_datum(c, xid, version);\n\tif (IS_ERR(xd))\n\t\treturn PTR_ERR(xd);\n\n\tif (xd->version > version) {\n\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t= jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, NULL);\n\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\txd->node->next_in_ino = raw;\n\t} else {\n\t\txd->version = version;\n\t\txd->xprefix = rx->xprefix;\n\t\txd->name_len = rx->name_len;\n\t\txd->value_len = je16_to_cpu(rx->value_len);\n\t\txd->data_crc = je32_to_cpu(rx->data_crc);\n\n\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, (void *)xd);\n\t}\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xattr_mem(s, rx, ofs - jeb->offset);\n\tdbg_xattr(\"scanning xdatum at %#08x (xid=%u, version=%u)\\n\",\n\t\t  ofs, xd->xid, xd->version);\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_xattr_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_xattr *rx, uint32_t ofs,\n\t\t\t\t struct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t xid, version, totlen, crc;\n\tint err;\n\n\tcrc = crc32(0, rx, sizeof(struct jffs2_raw_xattr) - 4);\n\tif (crc != je32_to_cpu(rx->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txid = je32_to_cpu(rx->xid);\n\tversion = je32_to_cpu(rx->version);\n\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len));\n\tif (totlen != je32_to_cpu(rx->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%u\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->totlen), totlen);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txd = jffs2_setup_xattr_datum(c, xid, version);\n\tif (IS_ERR(xd))\n\t\treturn PTR_ERR(xd);\n\n\tif (xd->version > version) {\n\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t= jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, NULL);\n\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\txd->node->next_in_ino = raw;\n\t} else {\n\t\txd->version = version;\n\t\txd->xprefix = rx->xprefix;\n\t\txd->name_len = rx->name_len;\n\t\txd->value_len = je16_to_cpu(rx->value_len);\n\t\txd->data_crc = je32_to_cpu(rx->data_crc);\n\n\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, (void *)xd);\n\t}\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xattr_mem(s, rx, ofs - jeb->offset);\n\tdbg_xattr(\"scanning xdatum at %#08x (xid=%u, version=%u)\\n\",\n\t\t  ofs, xd->xid, xd->version);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %d bytes (xattr node) left to end of buf. Reading 0x%x at 0x%08x\\n\",",
            "e32_to_cpu(node->totlen),",
            "uf_len,",
            "fs)"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirent_node(",
          "args": [
            ",",
            "eb,",
            "void *)node,",
            "fs,",
            ")"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirent_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "1039-1112",
          "snippet": "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t checkedlen;\n\tuint32_t crc;\n\tint err;\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We don't get here unless the node is still valid, so we don't have to\n\t   mask in the ACCURATE bit any more. */\n\tcrc = crc32(0, rd, sizeof(*rd)-8);\n\n\tif (crc != je32_to_cpu(rd->node_crc)) {\n\t\tpr_notice(\"%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->node_crc), crc);\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tpseudo_random += je32_to_cpu(rd->version);\n\n\t/* Should never happen. Did. (OLPC trac #4184)*/\n\tcheckedlen = strnlen(rd->name, rd->nsize);\n\tif (checkedlen < rd->nsize) {\n\t\tpr_err(\"Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",\n\t\t       ofs, checkedlen);\n\t}\n\tfd = jffs2_alloc_full_dirent(checkedlen+1);\n\tif (!fd) {\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&fd->name, rd->name, checkedlen);\n\tfd->name[checkedlen] = 0;\n\n\tcrc = crc32(0, fd->name, rd->nsize);\n\tif (crc != je32_to_cpu(rd->name_crc)) {\n\t\tpr_notice(\"%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->name_crc), crc);\n\t\tjffs2_dbg(1, \"Name for which CRC failed is (now) '%s', ino #%d\\n\",\n\t\t\t  fd->name, je32_to_cpu(rd->ino));\n\t\tjffs2_free_full_dirent(fd);\n\t\t/* FIXME: Why do we believe totlen? */\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));\n\tif (!ic) {\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),\n\t\t\t\t      PAD(je32_to_cpu(rd->totlen)), ic);\n\n\tfd->next = NULL;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(fd->name, checkedlen);\n\tfd->type = rd->type;\n\tjffs2_add_fd_to_list(c, fd, &ic->scan_dents);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_dirent_mem(s, rd, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic uint32_t pseudo_random;",
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_full_dirent *fd;\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t checkedlen;\n\tuint32_t crc;\n\tint err;\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We don't get here unless the node is still valid, so we don't have to\n\t   mask in the ACCURATE bit any more. */\n\tcrc = crc32(0, rd, sizeof(*rd)-8);\n\n\tif (crc != je32_to_cpu(rd->node_crc)) {\n\t\tpr_notice(\"%s(): Node CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->node_crc), crc);\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tpseudo_random += je32_to_cpu(rd->version);\n\n\t/* Should never happen. Did. (OLPC trac #4184)*/\n\tcheckedlen = strnlen(rd->name, rd->nsize);\n\tif (checkedlen < rd->nsize) {\n\t\tpr_err(\"Dirent at %08x has zeroes in name. Truncating to %d chars\\n\",\n\t\t       ofs, checkedlen);\n\t}\n\tfd = jffs2_alloc_full_dirent(checkedlen+1);\n\tif (!fd) {\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(&fd->name, rd->name, checkedlen);\n\tfd->name[checkedlen] = 0;\n\n\tcrc = crc32(0, fd->name, rd->nsize);\n\tif (crc != je32_to_cpu(rd->name_crc)) {\n\t\tpr_notice(\"%s(): Name CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(rd->name_crc), crc);\n\t\tjffs2_dbg(1, \"Name for which CRC failed is (now) '%s', ino #%d\\n\",\n\t\t\t  fd->name, je32_to_cpu(rd->ino));\n\t\tjffs2_free_full_dirent(fd);\n\t\t/* FIXME: Why do we believe totlen? */\n\t\t/* We believe totlen because the CRC on the node _header_ was OK, just the name failed. */\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\tic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));\n\tif (!ic) {\n\t\tjffs2_free_full_dirent(fd);\n\t\treturn -ENOMEM;\n\t}\n\n\tfd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),\n\t\t\t\t      PAD(je32_to_cpu(rd->totlen)), ic);\n\n\tfd->next = NULL;\n\tfd->version = je32_to_cpu(rd->version);\n\tfd->ino = je32_to_cpu(rd->ino);\n\tfd->nhash = full_name_hash(fd->name, checkedlen);\n\tfd->type = rd->type;\n\tjffs2_add_fd_to_list(c, fd, &ic->scan_dents);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_dirent_mem(s, rd, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x\\n\",",
            "e32_to_cpu(node->totlen),",
            "uf_len,",
            "fs)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_inode_node(",
          "args": [
            ",",
            "eb,",
            "void *)node,",
            "fs,",
            ")"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_inode_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "985-1037",
          "snippet": "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t crc, ino = je32_to_cpu(ri->ino);\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We do very little here now. Just check the ino# to which we should attribute\n\t   this node; we can do all the CRC checking etc. later. There's a tradeoff here --\n\t   we used to scan the flash once only, reading everything we want from it into\n\t   memory, then building all our in-core data structures and freeing the extra\n\t   information. Now we allow the first part of the mount to complete a lot quicker,\n\t   but we have to go _back_ to the flash in order to finish the CRC checking, etc.\n\t   Which means that the _full_ amount of time to get to proper write mode with GC\n\t   operational may actually be _longer_ than before. Sucks to be me. */\n\n\t/* Check the node CRC in any case. */\n\tcrc = crc32(0, ri, sizeof(*ri)-8);\n\tif (crc != je32_to_cpu(ri->node_crc)) {\n\t\tpr_notice(\"%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(ri->node_crc), crc);\n\t\t/*\n\t\t * We believe totlen because the CRC on the node\n\t\t * _header_ was OK, just the node itself failed.\n\t\t */\n\t\treturn jffs2_scan_dirty_space(c, jeb,\n\t\t\t\t\t      PAD(je32_to_cpu(ri->totlen)));\n\t}\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (!ic) {\n\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\tif (!ic)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Wheee. It worked */\n\tjffs2_link_node_ref(c, jeb, ofs | REF_UNCHECKED, PAD(je32_to_cpu(ri->totlen)), ic);\n\n\tjffs2_dbg(1, \"Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",\n\t\t  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),\n\t\t  je32_to_cpu(ri->offset),\n\t\t  je32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize));\n\n\tpseudo_random += je32_to_cpu(ri->version);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_inode_mem(s, ri, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic uint32_t pseudo_random;",
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)\n{\n\tstruct jffs2_inode_cache *ic;\n\tuint32_t crc, ino = je32_to_cpu(ri->ino);\n\n\tjffs2_dbg(1, \"%s(): Node at 0x%08x\\n\", __func__, ofs);\n\n\t/* We do very little here now. Just check the ino# to which we should attribute\n\t   this node; we can do all the CRC checking etc. later. There's a tradeoff here --\n\t   we used to scan the flash once only, reading everything we want from it into\n\t   memory, then building all our in-core data structures and freeing the extra\n\t   information. Now we allow the first part of the mount to complete a lot quicker,\n\t   but we have to go _back_ to the flash in order to finish the CRC checking, etc.\n\t   Which means that the _full_ amount of time to get to proper write mode with GC\n\t   operational may actually be _longer_ than before. Sucks to be me. */\n\n\t/* Check the node CRC in any case. */\n\tcrc = crc32(0, ri, sizeof(*ri)-8);\n\tif (crc != je32_to_cpu(ri->node_crc)) {\n\t\tpr_notice(\"%s(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t  __func__, ofs, je32_to_cpu(ri->node_crc), crc);\n\t\t/*\n\t\t * We believe totlen because the CRC on the node\n\t\t * _header_ was OK, just the node itself failed.\n\t\t */\n\t\treturn jffs2_scan_dirty_space(c, jeb,\n\t\t\t\t\t      PAD(je32_to_cpu(ri->totlen)));\n\t}\n\n\tic = jffs2_get_ino_cache(c, ino);\n\tif (!ic) {\n\t\tic = jffs2_scan_make_ino_cache(c, ino);\n\t\tif (!ic)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* Wheee. It worked */\n\tjffs2_link_node_ref(c, jeb, ofs | REF_UNCHECKED, PAD(je32_to_cpu(ri->totlen)), ic);\n\n\tjffs2_dbg(1, \"Node is ino #%u, version %d. Range 0x%x-0x%x\\n\",\n\t\t  je32_to_cpu(ri->ino), je32_to_cpu(ri->version),\n\t\t  je32_to_cpu(ri->offset),\n\t\t  je32_to_cpu(ri->offset)+je32_to_cpu(ri->dsize));\n\n\tpseudo_random += je32_to_cpu(ri->version);\n\n\tif (jffs2_sum_active()) {\n\t\tjffs2_sum_add_inode_mem(s, ri, ofs - jeb->offset);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %zd bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\\n\",",
            "izeof(struct jffs2_raw_inode),",
            "uf_len,",
            "fs)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(node->totlen))"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Node at 0x%08x is obsolete. Skipping\\n\",",
            "fs)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Perhaps the file system was created with the wrong erase size?\\n\")"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Node at 0x%08x with length 0x%08x would run over the end of the erase block\\n\",",
            "fs,",
            "e32_to_cpu(node->totlen))"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oisy_printk(",
          "args": [
            "noise,",
            "%s(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\\n\",",
            "_func__,",
            "fs,",
            "e16_to_cpu(node->magic),",
            "e16_to_cpu(node->nodetype),",
            "e32_to_cpu(node->totlen),",
            "e32_to_cpu(node->hdr_crc),",
            "dr_crc)"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->hdr_crc)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->totlen)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "ode->hdr_crc)"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "crcnode,",
            "izeof(crcnode)-4)"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pu_to_je16(",
          "args": [
            "e16_to_cpu(node->nodetype) | JFFS2_NODE_ACCURATE)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->nodetype)"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oisy_printk(",
          "args": [
            "noise,",
            "%s(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\\n\",",
            "_func__,",
            "FFS2_MAGIC_BITMASK,",
            "fs,",
            "e16_to_cpu(node->magic))"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "You cannot use older JFFS2 filesystems with newer kernels\\n\")"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Old JFFS2 bitmask found at 0x%08x\\n\",",
            "fs)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Dirty bitmask at 0x%08x\\n\",",
            "fs)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\\n\",",
            "fs)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "ode->magic)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Reading another 0x%x at 0x%08x\\n\",",
            "uf_len,",
            "fs)"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Empty flash at %08x runs to end of block. Treating as free_space\\n\",",
            "mpty_start)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%d bytes at start of block seems clean... assuming all clean\\n\",",
            "MPTY_SCAN_SIZE(c->sector_size))"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MPTY_SCAN_SIZE(",
          "args": [
            "->sector_size)"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "MPTY_SCAN_SIZE(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "62-67",
          "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ef_next(",
          "args": [
            "eb->first_node)"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ef_next(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "101-117",
          "snippet": "tatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "->cleanmarker_size)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Empty flash to end of buffer at 0x%08x\\n\",",
            "fs)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Empty flash at 0x%08x ends at 0x%08x\\n\",",
            "mpty_start,",
            "fs)"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlikely(",
          "args": [
            "(uint32_t *)(&buf[inbuf_ofs]) != 0xffffffff)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Found empty flash at 0x%08x\\n\",",
            "fs)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "MPTY_SCAN_SIZE(c->sector_size)/8,",
            "uf_len)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %zd bytes (node header) left to end of buf. Reading 0x%x at 0x%08x\\n\",",
            "izeof(struct jffs2_unknown_node),",
            "uf_len,",
            "fs)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_t(",
          "args": [
            "int32_t,",
            "uf_size,",
            "eb->offset + c->sector_size - ofs)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Fewer than %zd bytes left to end of block. (%x+%x<%x+%zx) Not reading\\n\",",
            "izeof(struct jffs2_unknown_node),",
            "eb->offset,",
            "->sector_size,",
            "fs,",
            "izeof(*node))"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "ofs 0x%08x has already been seen. Skipping\\n\",",
            "fs)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "fs)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "Eep. ofs 0x%08x not word-aligned!\\n\",",
            "fs)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ond_resched(",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "eb,",
            ")"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "309-384",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "bg_summary(",
          "args": [
            "no summary found in jeb 0x%08x. Apply original scan.\\n\",",
            "eb->offset)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Free space at %08x ends at %08x\\n\",",
            "eb->offset,",
            "eb->offset + ofs)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Block at 0x%08x is empty (erased)\\n\",",
            "eb->offset)"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs2_check_oob_empty returned %d\\n\",",
            "et)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_check_oob_empty(",
          "args": [
            ",",
            "eb,",
            "leanmarkerfound)"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_cleanmarker_oob(",
          "args": [
            ")"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "umptr)"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_scan_sumnode(",
          "args": [
            ",",
            "eb,",
            "umptr,",
            "umlen,",
            "pseudo_random)"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_scan_sumnode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "572-670",
          "snippet": "nt jffs2_sum_scan_sumnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   struct jffs2_raw_summary *summary, uint32_t sumsize,\n\t\t\t   uint32_t *pseudo_random)\n{\n\tstruct jffs2_unknown_node crcnode;\n\tint ret, ofs;\n\tuint32_t crc;\n\n\tofs = c->sector_size - sumsize;\n\n\tdbg_summary(\"summary found for 0x%08x at 0x%08x (0x%x bytes)\\n\",\n\t\t    jeb->offset, jeb->offset + ofs, sumsize);\n\n\t/* OK, now check for node validity and CRC */\n\tcrcnode.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tcrcnode.nodetype = cpu_to_je16(JFFS2_NODETYPE_SUMMARY);\n\tcrcnode.totlen = summary->totlen;\n\tcrc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\tif (je32_to_cpu(summary->hdr_crc) != crc) {\n\t\tdbg_summary(\"Summary node header is corrupt (bad CRC or \"\n\t\t\t\t\"no summary at all)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif (je32_to_cpu(summary->totlen) != sumsize) {\n\t\tdbg_summary(\"Summary node is corrupt (wrong erasesize?)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary, sizeof(struct jffs2_raw_summary)-8);\n\n\tif (je32_to_cpu(summary->node_crc) != crc) {\n\t\tdbg_summary(\"Summary node is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary->sum, sumsize - sizeof(struct jffs2_raw_summary));\n\n\tif (je32_to_cpu(summary->sum_crc) != crc) {\n\t\tdbg_summary(\"Summary node data is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif ( je32_to_cpu(summary->cln_mkr) ) {\n\n\t\tdbg_summary(\"Summary : CLEANMARKER node \\n\");\n\n\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (je32_to_cpu(summary->cln_mkr) != c->cleanmarker_size) {\n\t\t\tdbg_summary(\"CLEANMARKER node has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\tje32_to_cpu(summary->cln_mkr), c->cleanmarker_size);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else if (jeb->first_node) {\n\t\t\tdbg_summary(\"CLEANMARKER node not first node in block \"\n\t\t\t\t\t\"(0x%08x)\\n\", jeb->offset);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL,\n\t\t\t\t\t    je32_to_cpu(summary->cln_mkr), NULL);\n\t\t}\n\t}\n\n\tret = jffs2_sum_process_sum_data(c, jeb, summary, pseudo_random);\n\t/* -ENOTRECOVERABLE isn't a fatal error -- it means we should do a full\n\t   scan of this eraseblock. So return zero */\n\tif (ret == -ENOTRECOVERABLE)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\t\t/* real error */\n\n\t/* for PARANOIA_CHECK */\n\tret = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tsum_link_node_ref(c, jeb, ofs | REF_NORMAL, sumsize, NULL);\n\n\tif (unlikely(jeb->free_size)) {\n\t\tJFFS2_WARNING(\"Free size 0x%x bytes in eraseblock @0x%08x with summary?\\n\",\n\t\t\t      jeb->free_size, jeb->offset);\n\t\tjeb->wasted_size += jeb->free_size;\n\t\tc->wasted_size += jeb->free_size;\n\t\tc->free_size -= jeb->free_size;\n\t\tjeb->free_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n\ncrc_err:\n\tJFFS2_WARNING(\"Summary node crc error, skipping summary information.\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_scan_sumnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   struct jffs2_raw_summary *summary, uint32_t sumsize,\n\t\t\t   uint32_t *pseudo_random)\n{\n\tstruct jffs2_unknown_node crcnode;\n\tint ret, ofs;\n\tuint32_t crc;\n\n\tofs = c->sector_size - sumsize;\n\n\tdbg_summary(\"summary found for 0x%08x at 0x%08x (0x%x bytes)\\n\",\n\t\t    jeb->offset, jeb->offset + ofs, sumsize);\n\n\t/* OK, now check for node validity and CRC */\n\tcrcnode.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tcrcnode.nodetype = cpu_to_je16(JFFS2_NODETYPE_SUMMARY);\n\tcrcnode.totlen = summary->totlen;\n\tcrc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\tif (je32_to_cpu(summary->hdr_crc) != crc) {\n\t\tdbg_summary(\"Summary node header is corrupt (bad CRC or \"\n\t\t\t\t\"no summary at all)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif (je32_to_cpu(summary->totlen) != sumsize) {\n\t\tdbg_summary(\"Summary node is corrupt (wrong erasesize?)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary, sizeof(struct jffs2_raw_summary)-8);\n\n\tif (je32_to_cpu(summary->node_crc) != crc) {\n\t\tdbg_summary(\"Summary node is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tcrc = crc32(0, summary->sum, sumsize - sizeof(struct jffs2_raw_summary));\n\n\tif (je32_to_cpu(summary->sum_crc) != crc) {\n\t\tdbg_summary(\"Summary node data is corrupt (bad CRC)\\n\");\n\t\tgoto crc_err;\n\t}\n\n\tif ( je32_to_cpu(summary->cln_mkr) ) {\n\n\t\tdbg_summary(\"Summary : CLEANMARKER node \\n\");\n\n\t\tret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (je32_to_cpu(summary->cln_mkr) != c->cleanmarker_size) {\n\t\t\tdbg_summary(\"CLEANMARKER node has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\tje32_to_cpu(summary->cln_mkr), c->cleanmarker_size);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else if (jeb->first_node) {\n\t\t\tdbg_summary(\"CLEANMARKER node not first node in block \"\n\t\t\t\t\t\"(0x%08x)\\n\", jeb->offset);\n\t\t\tif ((ret = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(summary->cln_mkr)))))\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL,\n\t\t\t\t\t    je32_to_cpu(summary->cln_mkr), NULL);\n\t\t}\n\t}\n\n\tret = jffs2_sum_process_sum_data(c, jeb, summary, pseudo_random);\n\t/* -ENOTRECOVERABLE isn't a fatal error -- it means we should do a full\n\t   scan of this eraseblock. So return zero */\n\tif (ret == -ENOTRECOVERABLE)\n\t\treturn 0;\n\tif (ret)\n\t\treturn ret;\t\t/* real error */\n\n\t/* for PARANOIA_CHECK */\n\tret = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tsum_link_node_ref(c, jeb, ofs | REF_NORMAL, sumsize, NULL);\n\n\tif (unlikely(jeb->free_size)) {\n\t\tJFFS2_WARNING(\"Free size 0x%x bytes in eraseblock @0x%08x with summary?\\n\",\n\t\t\t      jeb->free_size, jeb->offset);\n\t\tjeb->wasted_size += jeb->free_size;\n\t\tc->wasted_size += jeb->free_size;\n\t\tc->free_size -= jeb->free_size;\n\t\tjeb->free_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n\ncrc_err:\n\tJFFS2_WARNING(\"Summary node crc error, skipping summary information.\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emcpy(",
          "args": [
            "umptr + sumlen - buf_len,",
            "uf + buf_size - buf_len,",
            "uf_len)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "umlen,",
            "FP_KERNEL)"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "m->offset)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "m->magic)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "m->offset)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "m->offset)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "m->magic)"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "jffs_check_nand_cleanmarker returned %d\\n\",",
            "et)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_check_nand_cleanmarker(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_block_isbad(",
          "args": [
            "->mtd,",
            "eb->offset)"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_cleanmarker_oob(",
          "args": [
            ")"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Scanning block at 0x%x\\n\",",
            "_func__,",
            "fs)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic uint32_t pseudo_random;\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s) {\n\tstruct jffs2_unknown_node *node;\n\tstruct jffs2_unknown_node crcnode;\n\tuint32_t ofs, prevofs, max_ofs;\n\tuint32_t hdr_crc, buf_ofs, buf_len;\n\tint err;\n\tint noise = 0;\n\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tint cleanmarkerfound = 0;\n#endif\n\n\tofs = jeb->offset;\n\tprevofs = jeb->offset - 1;\n\n\tjffs2_dbg(1, \"%s(): Scanning block at 0x%x\\n\", __func__, ofs);\n\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (jffs2_cleanmarker_oob(c)) {\n\t\tint ret;\n\n\t\tif (mtd_block_isbad(c->mtd, jeb->offset))\n\t\t\treturn BLK_STATE_BADBLOCK;\n\n\t\tret = jffs2_check_nand_cleanmarker(c, jeb);\n\t\tjffs2_dbg(2, \"jffs_check_nand_cleanmarker returned %d\\n\", ret);\n\n\t\t/* Even if it's not found, we still scan to see\n\t\t   if the block is empty. We use this information\n\t\t   to decide whether to erase it or not. */\n\t\tswitch (ret) {\n\t\tcase 0:\t\tcleanmarkerfound = 1; break;\n\t\tcase 1: \tbreak;\n\t\tdefault: \treturn ret;\n\t\t}\n\t}\n#endif\n\n\tif (jffs2_sum_active()) {\n\t\tstruct jffs2_sum_marker *sm;\n\t\tvoid *sumptr = NULL;\n\t\tuint32_t sumlen;\n\t      \n\t\tif (!buf_size) {\n\t\t\t/* XIP case. Just look, point at the summary if it's there */\n\t\t\tsm = (void *)buf + c->sector_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumptr = buf + je32_to_cpu(sm->offset);\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t}\n\t\t} else {\n\t\t\t/* If NAND flash, read a whole page of it. Else just the end */\n\t\t\tif (c->wbuf_pagesize)\n\t\t\t\tbuf_len = c->wbuf_pagesize;\n\t\t\telse\n\t\t\t\tbuf_len = sizeof(*sm);\n\n\t\t\t/* Read as much as we want into the _end_ of the preallocated buffer */\n\t\t\terr = jffs2_fill_scan_buf(c, buf + buf_size - buf_len, \n\t\t\t\t\t\t  jeb->offset + c->sector_size - buf_len,\n\t\t\t\t\t\t  buf_len);\t\t\t\t\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tsm = (void *)buf + buf_size - sizeof(*sm);\n\t\t\tif (je32_to_cpu(sm->magic) == JFFS2_SUM_MAGIC) {\n\t\t\t\tsumlen = c->sector_size - je32_to_cpu(sm->offset);\n\t\t\t\tsumptr = buf + buf_size - sumlen;\n\n\t\t\t\t/* sm->offset maybe wrong but MAGIC maybe right */\n\t\t\t\tif (sumlen > c->sector_size)\n\t\t\t\t\tgoto full_scan;\n\n\t\t\t\t/* Now, make sure the summary itself is available */\n\t\t\t\tif (sumlen > buf_size) {\n\t\t\t\t\t/* Need to kmalloc for this. */\n\t\t\t\t\tsumptr = kmalloc(sumlen, GFP_KERNEL);\n\t\t\t\t\tif (!sumptr)\n\t\t\t\t\t\treturn -ENOMEM;\n\t\t\t\t\tmemcpy(sumptr + sumlen - buf_len, buf + buf_size - buf_len, buf_len);\n\t\t\t\t}\n\t\t\t\tif (buf_len < sumlen) {\n\t\t\t\t\t/* Need to read more so that the entire summary node is present */\n\t\t\t\t\terr = jffs2_fill_scan_buf(c, sumptr, \n\t\t\t\t\t\t\t\t  jeb->offset + c->sector_size - sumlen,\n\t\t\t\t\t\t\t\t  sumlen - buf_len);\t\t\t\t\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (sumptr) {\n\t\t\terr = jffs2_sum_scan_sumnode(c, jeb, sumptr, sumlen, &pseudo_random);\n\n\t\t\tif (buf_size && sumlen > buf_size)\n\t\t\t\tkfree(sumptr);\n\t\t\t/* If it returns with a real error, bail. \n\t\t\t   If it returns positive, that's a block classification\n\t\t\t   (i.e. BLK_STATE_xxx) so return that too.\n\t\t\t   If it returns zero, fall through to full scan. */\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\nfull_scan:\n\tbuf_ofs = jeb->offset;\n\n\tif (!buf_size) {\n\t\t/* This is the XIP case -- we're reading _directly_ from the flash chip */\n\t\tbuf_len = c->sector_size;\n\t} else {\n\t\tbuf_len = EMPTY_SCAN_SIZE(c->sector_size);\n\t\terr = jffs2_fill_scan_buf(c, buf, buf_ofs, buf_len);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* We temporarily use 'ofs' as a pointer into the buffer/jeb */\n\tofs = 0;\n\tmax_ofs = EMPTY_SCAN_SIZE(c->sector_size);\n\t/* Scan only EMPTY_SCAN_SIZE of 0xFF before declaring it's empty */\n\twhile(ofs < max_ofs && *(uint32_t *)(&buf[ofs]) == 0xFFFFFFFF)\n\t\tofs += 4;\n\n\tif (ofs == max_ofs) {\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\t/* scan oob, take care of cleanmarker */\n\t\t\tint ret = jffs2_check_oob_empty(c, jeb, cleanmarkerfound);\n\t\t\tjffs2_dbg(2, \"jffs2_check_oob_empty returned %d\\n\",\n\t\t\t\t  ret);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\t\treturn cleanmarkerfound ? BLK_STATE_CLEANMARKER : BLK_STATE_ALLFF;\n\t\t\tcase 1: \treturn BLK_STATE_ALLDIRTY;\n\t\t\tdefault: \treturn ret;\n\t\t\t}\n\t\t}\n#endif\n\t\tjffs2_dbg(1, \"Block at 0x%08x is empty (erased)\\n\",\n\t\t\t  jeb->offset);\n\t\tif (c->cleanmarker_size == 0)\n\t\t\treturn BLK_STATE_CLEANMARKER;\t/* don't bother with re-erase */\n\t\telse\n\t\t\treturn BLK_STATE_ALLFF;\t/* OK to erase if all blocks are like this */\n\t}\n\tif (ofs) {\n\t\tjffs2_dbg(1, \"Free space at %08x ends at %08x\\n\", jeb->offset,\n\t\t\t  jeb->offset + ofs);\n\t\tif ((err = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\t\treturn err;\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs)))\n\t\t\treturn err;\n\t}\n\n\t/* Now ofs is a complete physical flash offset as it always was... */\n\tofs += jeb->offset;\n\n\tnoise = 10;\n\n\tdbg_summary(\"no summary found in jeb 0x%08x. Apply original scan.\\n\",jeb->offset);\n\nscan_more:\n\twhile(ofs < jeb->offset + c->sector_size) {\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t/* Make sure there are node refs available for use */\n\t\terr = jffs2_prealloc_raw_node_refs(c, jeb, 2);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcond_resched();\n\n\t\tif (ofs & 3) {\n\t\t\tpr_warn(\"Eep. ofs 0x%08x not word-aligned!\\n\", ofs);\n\t\t\tofs = PAD(ofs);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ofs == prevofs) {\n\t\t\tpr_warn(\"ofs 0x%08x has already been seen. Skipping\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tprevofs = ofs;\n\n\t\tif (jeb->offset + c->sector_size < ofs + sizeof(*node)) {\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes left to end of block. (%x+%x<%x+%zx) Not reading\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  jeb->offset, c->sector_size, ofs,\n\t\t\t\t  sizeof(*node));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, (jeb->offset + c->sector_size)-ofs)))\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf_ofs + buf_len < ofs + sizeof(*node)) {\n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (node header) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t  sizeof(struct jffs2_unknown_node),\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t}\n\n\t\tnode = (struct jffs2_unknown_node *)&buf[ofs-buf_ofs];\n\n\t\tif (*(uint32_t *)(&buf[ofs-buf_ofs]) == 0xffffffff) {\n\t\t\tuint32_t inbuf_ofs;\n\t\t\tuint32_t empty_start, scan_end;\n\n\t\t\tempty_start = ofs;\n\t\t\tofs += 4;\n\t\t\tscan_end = min_t(uint32_t, EMPTY_SCAN_SIZE(c->sector_size)/8, buf_len);\n\n\t\t\tjffs2_dbg(1, \"Found empty flash at 0x%08x\\n\", ofs);\n\t\tmore_empty:\n\t\t\tinbuf_ofs = ofs - buf_ofs;\n\t\t\twhile (inbuf_ofs < scan_end) {\n\t\t\t\tif (unlikely(*(uint32_t *)(&buf[inbuf_ofs]) != 0xffffffff)) {\n\t\t\t\t\tpr_warn(\"Empty flash at 0x%08x ends at 0x%08x\\n\",\n\t\t\t\t\t\tempty_start, ofs);\n\t\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, ofs-empty_start)))\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tgoto scan_more;\n\t\t\t\t}\n\n\t\t\t\tinbuf_ofs+=4;\n\t\t\t\tofs += 4;\n\t\t\t}\n\t\t\t/* Ran off end. */\n\t\t\tjffs2_dbg(1, \"Empty flash to end of buffer at 0x%08x\\n\",\n\t\t\t\t  ofs);\n\n\t\t\t/* If we're only checking the beginning of a block with a cleanmarker,\n\t\t\t   bail now */\n\t\t\tif (buf_ofs == jeb->offset && jeb->used_size == PAD(c->cleanmarker_size) &&\n\t\t\t    c->cleanmarker_size && !jeb->dirty_size && !ref_next(jeb->first_node)) {\n\t\t\t\tjffs2_dbg(1, \"%d bytes at start of block seems clean... assuming all clean\\n\",\n\t\t\t\t\t  EMPTY_SCAN_SIZE(c->sector_size));\n\t\t\t\treturn BLK_STATE_CLEANMARKER;\n\t\t\t}\n\t\t\tif (!buf_size && (scan_end != buf_len)) {/* XIP/point case */\n\t\t\t\tscan_end = buf_len;\n\t\t\t\tgoto more_empty;\n\t\t\t}\n\t\t\t\n\t\t\t/* See how much more there is to read in this eraseblock... */\n\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\tif (!buf_len) {\n\t\t\t\t/* No more to read. Break out of main loop without marking\n\t\t\t\t   this range of empty space as dirty (because it's not) */\n\t\t\t\tjffs2_dbg(1, \"Empty flash at %08x runs to end of block. Treating as free_space\\n\",\n\t\t\t\t\t  empty_start);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* point never reaches here */\n\t\t\tscan_end = buf_len;\n\t\t\tjffs2_dbg(1, \"Reading another 0x%x at 0x%08x\\n\",\n\t\t\t\t  buf_len, ofs);\n\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbuf_ofs = ofs;\n\t\t\tgoto more_empty;\n\t\t}\n\n\t\tif (ofs == jeb->offset && je16_to_cpu(node->magic) == KSAMTIB_CIGAM_2SFFJ) {\n\t\t\tpr_warn(\"Magic bitmask is backwards at offset 0x%08x. Wrong endian filesystem?\\n\",\n\t\t\t\tofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_DIRTY_BITMASK) {\n\t\t\tjffs2_dbg(1, \"Dirty bitmask at 0x%08x\\n\", ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) == JFFS2_OLD_MAGIC_BITMASK) {\n\t\t\tpr_warn(\"Old JFFS2 bitmask found at 0x%08x\\n\", ofs);\n\t\t\tpr_warn(\"You cannot use older JFFS2 filesystems with newer kernels\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\tif (je16_to_cpu(node->magic) != JFFS2_MAGIC_BITMASK) {\n\t\t\t/* OK. We're out of possibilities. Whinge and move on */\n\t\t\tnoisy_printk(&noise, \"%s(): Magic bitmask 0x%04x not found at 0x%08x: 0x%04x instead\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     JFFS2_MAGIC_BITMASK, ofs,\n\t\t\t\t     je16_to_cpu(node->magic));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\t\t/* We seem to have a node of sorts. Check the CRC */\n\t\tcrcnode.magic = node->magic;\n\t\tcrcnode.nodetype = cpu_to_je16( je16_to_cpu(node->nodetype) | JFFS2_NODE_ACCURATE);\n\t\tcrcnode.totlen = node->totlen;\n\t\thdr_crc = crc32(0, &crcnode, sizeof(crcnode)-4);\n\n\t\tif (hdr_crc != je32_to_cpu(node->hdr_crc)) {\n\t\t\tnoisy_printk(&noise, \"%s(): Node at 0x%08x {0x%04x, 0x%04x, 0x%08x) has invalid CRC 0x%08x (calculated 0x%08x)\\n\",\n\t\t\t\t     __func__,\n\t\t\t\t     ofs, je16_to_cpu(node->magic),\n\t\t\t\t     je16_to_cpu(node->nodetype),\n\t\t\t\t     je32_to_cpu(node->totlen),\n\t\t\t\t     je32_to_cpu(node->hdr_crc),\n\t\t\t\t     hdr_crc);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ofs + je32_to_cpu(node->totlen) > jeb->offset + c->sector_size) {\n\t\t\t/* Eep. Node goes over the end of the erase block. */\n\t\t\tpr_warn(\"Node at 0x%08x with length 0x%08x would run over the end of the erase block\\n\",\n\t\t\t\tofs, je32_to_cpu(node->totlen));\n\t\t\tpr_warn(\"Perhaps the file system was created with the wrong erase size?\\n\");\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, 4)))\n\t\t\t\treturn err;\n\t\t\tofs += 4;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(je16_to_cpu(node->nodetype) & JFFS2_NODE_ACCURATE)) {\n\t\t\t/* Wheee. This is an obsoleted node */\n\t\t\tjffs2_dbg(2, \"Node at 0x%08x is obsolete. Skipping\\n\",\n\t\t\t\t  ofs);\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch(je16_to_cpu(node->nodetype)) {\n\t\tcase JFFS2_NODETYPE_INODE:\n\t\t\tif (buf_ofs + buf_len < ofs + sizeof(struct jffs2_raw_inode)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %zd bytes (inode node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  sizeof(struct jffs2_raw_inode),\n\t\t\t\t\t  buf_len, ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_inode_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_DIRENT:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (dirent node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_dirent_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err) return err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase JFFS2_NODETYPE_XATTR:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xattr node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xattr_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\t\tcase JFFS2_NODETYPE_XREF:\n\t\t\tif (buf_ofs + buf_len < ofs + je32_to_cpu(node->totlen)) {\n\t\t\t\tbuf_len = min_t(uint32_t, buf_size, jeb->offset + c->sector_size - ofs);\n\t\t\t\tjffs2_dbg(1, \"Fewer than %d bytes (xref node) left to end of buf. Reading 0x%x at 0x%08x\\n\",\n\t\t\t\t\t  je32_to_cpu(node->totlen), buf_len,\n\t\t\t\t\t  ofs);\n\t\t\t\terr = jffs2_fill_scan_buf(c, buf, ofs, buf_len);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tbuf_ofs = ofs;\n\t\t\t\tnode = (void *)buf;\n\t\t\t}\n\t\t\terr = jffs2_scan_xref_node(c, jeb, (void *)node, ofs, s);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n#endif\t/* CONFIG_JFFS2_FS_XATTR */\n\n\t\tcase JFFS2_NODETYPE_CLEANMARKER:\n\t\t\tjffs2_dbg(1, \"CLEANMARKER node found at 0x%08x\\n\", ofs);\n\t\t\tif (je32_to_cpu(node->totlen) != c->cleanmarker_size) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x has totlen 0x%x != normal 0x%x\\n\",\n\t\t\t\t\t  ofs, je32_to_cpu(node->totlen),\n\t\t\t\t\t  c->cleanmarker_size);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else if (jeb->first_node) {\n\t\t\t\tpr_notice(\"CLEANMARKER node found at 0x%08x, not first node in block (0x%08x)\\n\",\n\t\t\t\t\t  ofs, jeb->offset);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(sizeof(struct jffs2_unknown_node)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(sizeof(struct jffs2_unknown_node));\n\t\t\t} else {\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\t\t\t\tofs += PAD(c->cleanmarker_size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase JFFS2_NODETYPE_PADDING:\n\t\t\tif (jffs2_sum_active())\n\t\t\t\tjffs2_sum_add_padding_mem(s, je32_to_cpu(node->totlen));\n\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\treturn err;\n\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tswitch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {\n\t\t\tcase JFFS2_FEATURE_ROCOMPAT:\n\t\t\t\tpr_notice(\"Read-only compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tc->flags |= JFFS2_SB_FLAG_RO;\n\t\t\t\tif (!(jffs2_is_readonly(c)))\n\t\t\t\t\treturn -EROFS;\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_INCOMPAT:\n\t\t\t\tpr_notice(\"Incompatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\treturn -EINVAL;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_DELETE:\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\t\t\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))\n\t\t\t\t\treturn err;\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\n\t\t\tcase JFFS2_FEATURE_RWCOMPAT_COPY: {\n\t\t\t\tjffs2_dbg(1, \"Unknown but compatible feature node (0x%04x) found at offset 0x%08x\\n\",\n\t\t\t\t\t  je16_to_cpu(node->nodetype), ofs);\n\n\t\t\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(node->totlen)), NULL);\n\n\t\t\t\t/* We can't summarise nodes we don't grok */\n\t\t\t\tjffs2_sum_disable_collecting(s);\n\t\t\t\tofs += PAD(je32_to_cpu(node->totlen));\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\tif (PAD(s->sum_size + JFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size) {\n\t\t\tdbg_summary(\"There is not enough space for \"\n\t\t\t\t\"summary information, disabling for this jeb!\\n\");\n\t\t\tjffs2_sum_disable_collecting(s);\n\t\t}\n\t}\n\n\tjffs2_dbg(1, \"Block at 0x%08x: free 0x%08x, dirty 0x%08x, unchecked 0x%08x, used 0x%08x, wasted 0x%08x\\n\",\n\t\t  jeb->offset, jeb->free_size, jeb->dirty_size,\n\t\t  jeb->unchecked_size, jeb->used_size, jeb->wasted_size);\n\t\n\t/* mark_node_obsolete can add to wasted !! */\n\tif (jeb->wasted_size) {\n\t\tjeb->dirty_size += jeb->wasted_size;\n\t\tc->dirty_size += jeb->wasted_size;\n\t\tc->wasted_size -= jeb->wasted_size;\n\t\tjeb->wasted_size = 0;\n\t}\n\n\treturn jffs2_scan_classify_jeb(c, jeb);\n}"
  },
  {
    "function_name": "ffs2_scan_xref_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "383-437",
    "snippet": "tatic int jffs2_scan_xref_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_xref *rr, uint32_t ofs,\n\t\t\t\tstruct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_ref *ref;\n\tuint32_t crc;\n\tint err;\n\n\tcrc = crc32(0, rr, sizeof(*rr) - 4);\n\tif (crc != je32_to_cpu(rr->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rr->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tif (PAD(sizeof(struct jffs2_raw_xref)) != je32_to_cpu(rr->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%zd\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->totlen),\n\t\t\t      PAD(sizeof(struct jffs2_raw_xref)));\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rr->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\t/* BEFORE jffs2_build_xattr_subsystem() called, \n\t * and AFTER xattr_ref is marked as a dead xref,\n\t * ref->xid is used to store 32bit xid, xd is not used\n\t * ref->ino is used to store 32bit inode-number, ic is not used\n\t * Thoes variables are declared as union, thus using those\n\t * are exclusive. In a similar way, ref->next is temporarily\n\t * used to chain all xattr_ref object. It's re-chained to\n\t * jffs2_inode_cache in jffs2_build_xattr_subsystem() correctly.\n\t */\n\tref->ino = je32_to_cpu(rr->ino);\n\tref->xid = je32_to_cpu(rr->xid);\n\tref->xseqno = je32_to_cpu(rr->xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\tref->next = c->xref_temp;\n\tc->xref_temp = ref;\n\n\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rr->totlen)), (void *)ref);\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xref_mem(s, rr, ofs - jeb->offset);\n\tdbg_xattr(\"scan xref at %#08x (xid=%u, ino=%u)\\n\",\n\t\t  ofs, ref->xid, ref->ino);\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "scan xref at %#08x (xid=%u, ino=%u)\\n\",",
            "fs,",
            "ef->xid,",
            "ef->ino)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_add_xref_mem(",
          "args": [
            ",",
            "r,",
            "fs - jeb->offset)"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_xref_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "176-189",
          "snippet": "nt jffs2_sum_add_xref_mem(struct jffs2_summary *s, struct jffs2_raw_xref *rr, uint32_t ofs)\n{\n\tstruct jffs2_sum_xref_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xref_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rr->nodetype;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_xref_mem(struct jffs2_summary *s, struct jffs2_raw_xref *rr, uint32_t ofs)\n{\n\tstruct jffs2_sum_xref_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xref_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rr->nodetype;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs | REF_PRISTINE,",
            "AD(je32_to_cpu(rr->totlen)),",
            "void *)ref)"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(rr->totlen))"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->totlen)"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->xseqno)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->xid)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->ino)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_alloc_xattr_ref(",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "e32_to_cpu(rr->totlen))"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->totlen)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "node length mismatch at %#08x, read=%u, calc=%zd\\n\",",
            "fs,",
            "e32_to_cpu(rr->totlen),",
            "AD(sizeof(struct jffs2_raw_xref)))"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xref))"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->totlen)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->totlen)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xref))"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "e32_to_cpu(rr->totlen))"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->totlen)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",",
            "fs,",
            "e32_to_cpu(rr->node_crc),",
            "rc)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->node_crc)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "r->node_crc)"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "r,",
            "izeof(*rr) - 4)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_xref_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\tstruct jffs2_raw_xref *rr, uint32_t ofs,\n\t\t\t\tstruct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_ref *ref;\n\tuint32_t crc;\n\tint err;\n\n\tcrc = crc32(0, rr, sizeof(*rr) - 4);\n\tif (crc != je32_to_cpu(rr->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rr->totlen)))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tif (PAD(sizeof(struct jffs2_raw_xref)) != je32_to_cpu(rr->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%zd\\n\",\n\t\t\t      ofs, je32_to_cpu(rr->totlen),\n\t\t\t      PAD(sizeof(struct jffs2_raw_xref)));\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rr->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\tref = jffs2_alloc_xattr_ref();\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\t/* BEFORE jffs2_build_xattr_subsystem() called, \n\t * and AFTER xattr_ref is marked as a dead xref,\n\t * ref->xid is used to store 32bit xid, xd is not used\n\t * ref->ino is used to store 32bit inode-number, ic is not used\n\t * Thoes variables are declared as union, thus using those\n\t * are exclusive. In a similar way, ref->next is temporarily\n\t * used to chain all xattr_ref object. It's re-chained to\n\t * jffs2_inode_cache in jffs2_build_xattr_subsystem() correctly.\n\t */\n\tref->ino = je32_to_cpu(rr->ino);\n\tref->xid = je32_to_cpu(rr->xid);\n\tref->xseqno = je32_to_cpu(rr->xseqno);\n\tif (ref->xseqno > c->highest_xseqno)\n\t\tc->highest_xseqno = (ref->xseqno & ~XREF_DELETE_MARKER);\n\tref->next = c->xref_temp;\n\tc->xref_temp = ref;\n\n\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rr->totlen)), (void *)ref);\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xref_mem(s, rr, ofs - jeb->offset);\n\tdbg_xattr(\"scan xref at %#08x (xid=%u, ino=%u)\\n\",\n\t\t  ofs, ref->xid, ref->ino);\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_scan_xattr_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "327-381",
    "snippet": "tatic int jffs2_scan_xattr_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_xattr *rx, uint32_t ofs,\n\t\t\t\t struct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t xid, version, totlen, crc;\n\tint err;\n\n\tcrc = crc32(0, rx, sizeof(struct jffs2_raw_xattr) - 4);\n\tif (crc != je32_to_cpu(rx->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txid = je32_to_cpu(rx->xid);\n\tversion = je32_to_cpu(rx->version);\n\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len));\n\tif (totlen != je32_to_cpu(rx->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%u\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->totlen), totlen);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txd = jffs2_setup_xattr_datum(c, xid, version);\n\tif (IS_ERR(xd))\n\t\treturn PTR_ERR(xd);\n\n\tif (xd->version > version) {\n\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t= jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, NULL);\n\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\txd->node->next_in_ino = raw;\n\t} else {\n\t\txd->version = version;\n\t\txd->xprefix = rx->xprefix;\n\t\txd->name_len = rx->name_len;\n\t\txd->value_len = je16_to_cpu(rx->value_len);\n\t\txd->data_crc = je32_to_cpu(rx->data_crc);\n\n\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, (void *)xd);\n\t}\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xattr_mem(s, rx, ofs - jeb->offset);\n\tdbg_xattr(\"scanning xdatum at %#08x (xid=%u, version=%u)\\n\",\n\t\t  ofs, xd->xid, xd->version);\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bg_xattr(",
          "args": [
            "scanning xdatum at %#08x (xid=%u, version=%u)\\n\",",
            "fs,",
            "d->xid,",
            "d->version)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_add_xattr_mem(",
          "args": [
            ",",
            "x,",
            "fs - jeb->offset)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_add_xattr_mem(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "158-174",
          "snippet": "nt jffs2_sum_add_xattr_mem(struct jffs2_summary *s, struct jffs2_raw_xattr *rx, uint32_t ofs)\n{\n\tstruct jffs2_sum_xattr_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xattr_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rx->nodetype;\n\ttemp->xid = rx->xid;\n\ttemp->version = rx->version;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->totlen = rx->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_sum_add_xattr_mem(struct jffs2_summary *s, struct jffs2_raw_xattr *rx, uint32_t ofs)\n{\n\tstruct jffs2_sum_xattr_mem *temp;\n\n\ttemp = kmalloc(sizeof(struct jffs2_sum_xattr_mem), GFP_KERNEL);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->nodetype = rx->nodetype;\n\ttemp->xid = rx->xid;\n\ttemp->version = rx->version;\n\ttemp->offset = cpu_to_je32(ofs);\n\ttemp->totlen = rx->totlen;\n\ttemp->next = NULL;\n\n\treturn jffs2_sum_add_mem(s, (union jffs2_sum_mem *)temp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_link_node_ref(",
          "args": [
            ",",
            "eb,",
            "fs | REF_PRISTINE,",
            "otlen,",
            "void *)xd)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_link_node_ref(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "585-659",
          "snippet": "truct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\n\t\t\t\t\t       struct jffs2_eraseblock *jeb,\n\t\t\t\t\t       uint32_t ofs, uint32_t len,\n\t\t\t\t\t       struct jffs2_inode_cache *ic)\n{\n\tstruct jffs2_raw_node_ref *ref;\n\n\tBUG_ON(!jeb->allocated_refs);\n\tjeb->allocated_refs--;\n\n\tref = jeb->last_node;\n\n\tdbg_noderef(\"Last node at %p is (%08x,%p)\\n\", ref, ref->flash_offset,\n\t\t    ref->next_in_ino);\n\n\twhile (ref->flash_offset != REF_EMPTY_NODE) {\n\t\tif (ref->flash_offset == REF_LINK_NODE)\n\t\t\tref = ref->next_in_ino;\n\t\telse\n\t\t\tref++;\n\t}\n\n\tdbg_noderef(\"New ref is %p (%08x becomes %08x,%p) len 0x%x\\n\", ref, \n\t\t    ref->flash_offset, ofs, ref->next_in_ino, len);\n\n\tref->flash_offset = ofs;\n\n\tif (!jeb->first_node) {\n\t\tjeb->first_node = ref;\n\t\tBUG_ON(ref_offset(ref) != jeb->offset);\n\t} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\n\t\tuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\n\n\t\tJFFS2_ERROR(\"Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\\n\",\n\t\t\t    ref, ref_offset(ref), ref_offset(ref)+len,\n\t\t\t    ref_offset(jeb->last_node), \n\t\t\t    ref_offset(jeb->last_node)+last_len);\n\t\tBUG();\n\t}\n\tjeb->last_node = ref;\n\n\tif (ic) {\n\t\tref->next_in_ino = ic->nodes;\n\t\tic->nodes = ref;\n\t} else {\n\t\tref->next_in_ino = NULL;\n\t}\n\n\tswitch(ref_flags(ref)) {\n\tcase REF_UNCHECKED:\n\t\tc->unchecked_size += len;\n\t\tjeb->unchecked_size += len;\n\t\tbreak;\n\n\tcase REF_NORMAL:\n\tcase REF_PRISTINE:\n\t\tc->used_size += len;\n\t\tjeb->used_size += len;\n\t\tbreak;\n\n\tcase REF_OBSOLETE:\n\t\tc->dirty_size += len;\n\t\tjeb->dirty_size += len;\n\t\tbreak;\n\t}\n\tc->free_size -= len;\n\tjeb->free_size -= len;\n\n#ifdef TEST_TOTLEN\n\t/* Set (and test) __totlen field... for now */\n\tref->__totlen = len;\n\tref_totlen(c, jeb, ref);\n#endif\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->data_crc)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x->value_len)"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "d)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "d)"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_setup_xattr_datum(",
          "args": [
            ",",
            "id,",
            "ersion)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_setup_xattr_datum(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/xattr.c",
          "lines": "889-906",
          "snippet": "truct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t  uint32_t xid, uint32_t version)\n{\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = jffs2_find_xattr_datum(c, xid);\n\tif (!xd) {\n\t\txd = jffs2_alloc_xattr_datum();\n\t\tif (!xd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\txd->xid = xid;\n\t\txd->version = version;\n\t\tif (xd->xid > c->highest_xid)\n\t\t\tc->highest_xid = xd->xid;\n\t\tlist_add_tail(&xd->xindex, &c->xattrindex[xid % XATTRINDEX_HASHSIZE]);\n\t}\n\treturn xd;\n}",
          "includes": [
            "include \"nodelist.h\"\n/",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/posix_acl_xattr.h>\n#",
            "include <linux/xattr.h>\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/highmem.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/time.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\n/\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/posix_acl_xattr.h>\n#\ninclude <linux/xattr.h>\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/highmem.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/time.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\ntruct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,\n\t\t\t\t\t\t  uint32_t xid, uint32_t version)\n{\n\tstruct jffs2_xattr_datum *xd;\n\n\txd = jffs2_find_xattr_datum(c, xid);\n\tif (!xd) {\n\t\txd = jffs2_alloc_xattr_datum();\n\t\tif (!xd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\txd->xid = xid;\n\t\txd->version = version;\n\t\tif (xd->xid > c->highest_xid)\n\t\t\tc->highest_xid = xd->xid;\n\t\tlist_add_tail(&xd->xindex, &c->xattrindex[xid % XATTRINDEX_HASHSIZE]);\n\t}\n\treturn xd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "e32_to_cpu(rx->totlen))"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->totlen)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "node length mismatch at %#08x, read=%u, calc=%u\\n\",",
            "fs,",
            "e32_to_cpu(rx->totlen),",
            "otlen)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->totlen)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->totlen)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "izeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len))"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e16_to_cpu(",
          "args": [
            "x->value_len)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->version)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->xid)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->totlen)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",",
            "fs,",
            "e32_to_cpu(rx->node_crc),",
            "rc)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->node_crc)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e32_to_cpu(",
          "args": [
            "x->node_crc)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc32(",
          "args": [
            ",",
            "x,",
            "izeof(struct jffs2_raw_xattr) - 4)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int jffs2_scan_xattr_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_xattr *rx, uint32_t ofs,\n\t\t\t\t struct jffs2_summary *s)\n{\n\tstruct jffs2_xattr_datum *xd;\n\tuint32_t xid, version, totlen, crc;\n\tint err;\n\n\tcrc = crc32(0, rx, sizeof(struct jffs2_raw_xattr) - 4);\n\tif (crc != je32_to_cpu(rx->node_crc)) {\n\t\tJFFS2_WARNING(\"node CRC failed at %#08x, read=%#08x, calc=%#08x\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->node_crc), crc);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txid = je32_to_cpu(rx->xid);\n\tversion = je32_to_cpu(rx->version);\n\n\ttotlen = PAD(sizeof(struct jffs2_raw_xattr)\n\t\t\t+ rx->name_len + 1 + je16_to_cpu(rx->value_len));\n\tif (totlen != je32_to_cpu(rx->totlen)) {\n\t\tJFFS2_WARNING(\"node length mismatch at %#08x, read=%u, calc=%u\\n\",\n\t\t\t      ofs, je32_to_cpu(rx->totlen), totlen);\n\t\tif ((err = jffs2_scan_dirty_space(c, jeb, je32_to_cpu(rx->totlen))))\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\txd = jffs2_setup_xattr_datum(c, xid, version);\n\tif (IS_ERR(xd))\n\t\treturn PTR_ERR(xd);\n\n\tif (xd->version > version) {\n\t\tstruct jffs2_raw_node_ref *raw\n\t\t\t= jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, NULL);\n\t\traw->next_in_ino = xd->node->next_in_ino;\n\t\txd->node->next_in_ino = raw;\n\t} else {\n\t\txd->version = version;\n\t\txd->xprefix = rx->xprefix;\n\t\txd->name_len = rx->name_len;\n\t\txd->value_len = je16_to_cpu(rx->value_len);\n\t\txd->data_crc = je32_to_cpu(rx->data_crc);\n\n\t\tjffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, totlen, (void *)xd);\n\t}\n\n\tif (jffs2_sum_active())\n\t\tjffs2_sum_add_xattr_mem(s, rx, ofs - jeb->offset);\n\tdbg_xattr(\"scanning xdatum at %#08x (xid=%u, version=%u)\\n\",\n\t\t  ofs, xd->xid, xd->version);\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_scan_classify_jeb(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "307-324",
    "snippet": "nt jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tif ((jeb->used_size + jeb->unchecked_size) == PAD(c->cleanmarker_size) && !jeb->dirty_size\n\t    && (!jeb->first_node || !ref_next(jeb->first_node)) )\n\t\treturn BLK_STATE_CLEANMARKER;\n\n\t/* move blocks with max 4 byte dirty space to cleanlist */\n\telse if (!ISDIRTY(c->sector_size - (jeb->used_size + jeb->unchecked_size))) {\n\t\tc->dirty_size -= jeb->dirty_size;\n\t\tc->wasted_size += jeb->dirty_size;\n\t\tjeb->wasted_size += jeb->dirty_size;\n\t\tjeb->dirty_size = 0;\n\t\treturn BLK_STATE_CLEAN;\n\t} else if (jeb->used_size || jeb->unchecked_size)\n\t\treturn BLK_STATE_PARTDIRTY;\n\telse\n\t\treturn BLK_STATE_ALLDIRTY;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SDIRTY(",
          "args": [
            "->sector_size - (jeb->used_size + jeb->unchecked_size))"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef_next(",
          "args": [
            "eb->first_node)"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ef_next(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "101-117",
          "snippet": "tatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline struct jffs2_raw_node_ref *ref_next(struct jffs2_raw_node_ref *ref)\n{\n\tref++;\n\n\t/* Link to another block of refs */\n\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\tref = ref->next_in_ino;\n\t\tif (!ref)\n\t\t\treturn ref;\n\t}\n\n\t/* End of chain */\n\tif (ref->flash_offset == REF_EMPTY_NODE)\n\t\treturn NULL;\n\n\treturn ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AD(",
          "args": [
            "->cleanmarker_size)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_classify_jeb(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tif ((jeb->used_size + jeb->unchecked_size) == PAD(c->cleanmarker_size) && !jeb->dirty_size\n\t    && (!jeb->first_node || !ref_next(jeb->first_node)) )\n\t\treturn BLK_STATE_CLEANMARKER;\n\n\t/* move blocks with max 4 byte dirty space to cleanlist */\n\telse if (!ISDIRTY(c->sector_size - (jeb->used_size + jeb->unchecked_size))) {\n\t\tc->dirty_size -= jeb->dirty_size;\n\t\tc->wasted_size += jeb->dirty_size;\n\t\tjeb->wasted_size += jeb->dirty_size;\n\t\tjeb->dirty_size = 0;\n\t\treturn BLK_STATE_CLEAN;\n\t} else if (jeb->used_size || jeb->unchecked_size)\n\t\treturn BLK_STATE_PARTDIRTY;\n\telse\n\t\treturn BLK_STATE_ALLDIRTY;\n}"
  },
  {
    "function_name": "ffs2_fill_scan_buf(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "287-305",
    "snippet": "tatic int jffs2_fill_scan_buf(struct jffs2_sb_info *c, void *buf,\n\t\t\t       uint32_t ofs, uint32_t len)\n{\n\tint ret;\n\tsize_t retlen;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret) {\n\t\tjffs2_dbg(1, \"mtd->read(0x%x bytes from 0x%x) returned %d\\n\",\n\t\t\t  len, ofs, ret);\n\t\treturn ret;\n\t}\n\tif (retlen < len) {\n\t\tjffs2_dbg(1, \"Read at 0x%x gave only 0x%zx bytes\\n\",\n\t\t\t  ofs, retlen);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Read at 0x%x gave only 0x%zx bytes\\n\",",
            "fs,",
            "etlen)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "mtd->read(0x%x bytes from 0x%x) returned %d\\n\",",
            "en,",
            "fs,",
            "et)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_flash_read(",
          "args": [
            ",",
            "fs,",
            "en,",
            "retlen,",
            "uf)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_fill_scan_buf(struct jffs2_sb_info *c, void *buf,\n\t\t\t       uint32_t ofs, uint32_t len)\n{\n\tint ret;\n\tsize_t retlen;\n\n\tret = jffs2_flash_read(c, ofs, len, &retlen, buf);\n\tif (ret) {\n\t\tjffs2_dbg(1, \"mtd->read(0x%x bytes from 0x%x) returned %d\\n\",\n\t\t\t  len, ofs, ret);\n\t\treturn ret;\n\t}\n\tif (retlen < len) {\n\t\tjffs2_dbg(1, \"Read at 0x%x gave only 0x%zx bytes\\n\",\n\t\t\t  ofs, retlen);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ffs2_scan_medium(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "91-285",
    "snippet": "nt jffs2_scan_medium(struct jffs2_sb_info *c)\n{\n\tint i, ret;\n\tuint32_t empty_blocks = 0, bad_blocks = 0;\n\tunsigned char *flashbuf = NULL;\n\tuint32_t buf_size = 0;\n\tstruct jffs2_summary *s = NULL; /* summary info collected by the scan process */\n#ifndef __ECOS\n\tsize_t pointlen, try_size;\n\n\tret = mtd_point(c->mtd, 0, c->mtd->size, &pointlen,\n\t\t\t(void **)&flashbuf, NULL);\n\tif (!ret && pointlen < c->mtd->size) {\n\t\t/* Don't muck about if it won't let us point to the whole flash */\n\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t  pointlen);\n\t\tmtd_unpoint(c->mtd, 0, pointlen);\n\t\tflashbuf = NULL;\n\t}\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n#endif\n\tif (!flashbuf) {\n\t\t/* For NAND it's quicker to read a whole eraseblock at a time,\n\t\t   apparently */\n\t\tif (jffs2_cleanmarker_oob(c))\n\t\t\ttry_size = c->sector_size;\n\t\telse\n\t\t\ttry_size = PAGE_SIZE;\n\n\t\tjffs2_dbg(1, \"Trying to allocate readbuf of %zu \"\n\t\t\t  \"bytes\\n\", try_size);\n\n\t\tflashbuf = mtd_kmalloc_up_to(c->mtd, &try_size);\n\t\tif (!flashbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tjffs2_dbg(1, \"Allocated readbuf of %zu bytes\\n\",\n\t\t\t  try_size);\n\n\t\tbuf_size = (uint32_t)try_size;\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\ts = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tJFFS2_WARNING(\"Can't allocate memory for summary\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tstruct jffs2_eraseblock *jeb = &c->blocks[i];\n\n\t\tcond_resched();\n\n\t\t/* reset summary info for next eraseblock scan */\n\t\tjffs2_sum_reset_collected(s);\n\n\t\tret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),\n\t\t\t\t\t\tbuf_size, s);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t/* Now decide which list to put it on */\n\t\tswitch(ret) {\n\t\tcase BLK_STATE_ALLFF:\n\t\t\t/*\n\t\t\t * Empty block.   Since we can't be sure it\n\t\t\t * was entirely erased, we just queue it for erase\n\t\t\t * again.  It will be marked as such when the erase\n\t\t\t * is complete.  Meanwhile we still count it as empty\n\t\t\t * for later checks.\n\t\t\t */\n\t\t\tempty_blocks++;\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEANMARKER:\n\t\t\t/* Only a CLEANMARKER node is valid */\n\t\t\tif (!jeb->dirty_size) {\n\t\t\t\t/* It's actually free */\n\t\t\t\tlist_add(&jeb->list, &c->free_list);\n\t\t\t\tc->nr_free_blocks++;\n\t\t\t} else {\n\t\t\t\t/* Dirt */\n\t\t\t\tjffs2_dbg(1, \"Adding all-dirty block at 0x%08x to erase_pending_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEAN:\n\t\t\t/* Full (or almost full) of clean data. Clean list */\n\t\t\tlist_add(&jeb->list, &c->clean_list);\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_PARTDIRTY:\n\t\t\t/* Some data, but not full. Dirty list. */\n\t\t\t/* We want to remember the block with most free space\n\t\t\tand stick it in the 'nextblock' position to start writing to it. */\n\t\t\tif (jeb->free_size > min_free(c) &&\n\t\t\t\t\t(!c->nextblock || c->nextblock->free_size < jeb->free_size)) {\n\t\t\t\t/* Better candidate for the next writes to go to */\n\t\t\t\tif (c->nextblock) {\n\t\t\t\t\tret = file_dirty(c, c->nextblock);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t/* deleting summary information of the old nextblock */\n\t\t\t\t\tjffs2_sum_reset_collected(c->summary);\n\t\t\t\t}\n\t\t\t\t/* update collected summary information for the current nextblock */\n\t\t\t\tjffs2_sum_move_collected(c, s);\n\t\t\t\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t\t\t\t  __func__, jeb->offset);\n\t\t\t\tc->nextblock = jeb;\n\t\t\t} else {\n\t\t\t\tret = file_dirty(c, jeb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_ALLDIRTY:\n\t\t\t/* Nothing valid - not even a clean marker. Needs erasing. */\n\t\t\t/* For now we just put it on the erasing list. We'll start the erases later */\n\t\t\tjffs2_dbg(1, \"Erase block at 0x%08x is not formatted. It will be erased\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_BADBLOCK:\n\t\t\tjffs2_dbg(1, \"Block at 0x%08x is bad\\n\", jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->bad_list);\n\t\t\tc->bad_size += c->sector_size;\n\t\t\tc->free_size -= c->sector_size;\n\t\t\tbad_blocks++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"%s(): unknown block state\\n\", __func__);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* Nextblock dirty is always seen as wasted, because we cannot recycle it now */\n\tif (c->nextblock && (c->nextblock->dirty_size)) {\n\t\tc->nextblock->wasted_size += c->nextblock->dirty_size;\n\t\tc->wasted_size += c->nextblock->dirty_size;\n\t\tc->dirty_size -= c->nextblock->dirty_size;\n\t\tc->nextblock->dirty_size = 0;\n\t}\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && c->wbuf_pagesize && c->nextblock && (c->nextblock->free_size % c->wbuf_pagesize)) {\n\t\t/* If we're going to start writing into a block which already\n\t\t   contains data, and the end of the data isn't page-aligned,\n\t\t   skip a little and align it. */\n\n\t\tuint32_t skip = c->nextblock->free_size % c->wbuf_pagesize;\n\n\t\tjffs2_dbg(1, \"%s(): Skipping %d bytes in nextblock to ensure page alignment\\n\",\n\t\t\t  __func__, skip);\n\t\tjffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\t\tjffs2_scan_dirty_space(c, c->nextblock, skip);\n\t}\n#endif\n\tif (c->nr_erasing_blocks) {\n\t\tif ( !c->used_size && ((c->nr_free_blocks+empty_blocks+bad_blocks)!= c->nr_blocks || bad_blocks == c->nr_blocks) ) {\n\t\t\tpr_notice(\"Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\\n\");\n\t\t\tpr_notice(\"empty_blocks %d, bad_blocks %d, c->nr_blocks %d\\n\",\n\t\t\t\t  empty_blocks, bad_blocks, c->nr_blocks);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjffs2_garbage_collect_trigger(c);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tret = 0;\n out:\n\tif (buf_size)\n\t\tkfree(flashbuf);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, 0, c->mtd->size);\n#endif\n\tkfree(s);\n\treturn ret;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            ")"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_unlock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_garbage_collect_trigger(",
          "args": [
            ")"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pin_lock(",
          "args": [
            "c->erase_completion_lock)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "empty_blocks %d, bad_blocks %d, c->nr_blocks %d\\n\",",
            "mpty_blocks,",
            "ad_blocks,",
            "->nr_blocks)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_notice(",
          "args": [
            "Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\\n\")"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "->nextblock,",
            "kip)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "->nextblock,",
            ")"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): Skipping %d bytes in nextblock to ensure page alignment\\n\",",
            "_func__,",
            "kip)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_can_mark_obsolete(",
          "args": [
            ")"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UG(",
          "args": [],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_warn(",
          "args": [
            "%s(): unknown block state\\n\",",
            "_func__)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->bad_list)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Block at 0x%08x is bad\\n\",",
            "eb->offset)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->erase_pending_list)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Erase block at 0x%08x is not formatted. It will be erased\\n\",",
            "eb->offset)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ile_dirty(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ile_dirty(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "69-89",
          "snippet": "tatic int file_dirty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\n\tif ((ret = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\treturn ret;\n\tif ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))\n\t\treturn ret;\n\t/* Turned wasted size into dirty, since we apparently \n\t   think it's recoverable now. */\n\tjeb->dirty_size += jeb->wasted_size;\n\tc->dirty_size += jeb->wasted_size;\n\tc->wasted_size -= jeb->wasted_size;\n\tjeb->wasted_size = 0;\n\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\tlist_add(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tlist_add(&jeb->list, &c->dirty_list);\n\t}\n\treturn 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
            "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
            "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int file_dirty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\n\tif ((ret = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\treturn ret;\n\tif ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))\n\t\treturn ret;\n\t/* Turned wasted size into dirty, since we apparently \n\t   think it's recoverable now. */\n\tjeb->dirty_size += jeb->wasted_size;\n\tc->dirty_size += jeb->wasted_size;\n\tc->wasted_size -= jeb->wasted_size;\n\tjeb->wasted_size = 0;\n\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\tlist_add(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tlist_add(&jeb->list, &c->dirty_list);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "%s(): new nextblock = 0x%08x\\n\",",
            "_func__,",
            "eb->offset)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_move_collected(",
          "args": [
            ",",
            ")"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_move_collected(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "231-244",
          "snippet": "oid jffs2_sum_move_collected(struct jffs2_sb_info *c, struct jffs2_summary *s)\n{\n\tdbg_summary(\"oldsize=0x%x oldnum=%u => newsize=0x%x newnum=%u\\n\",\n\t\t\t\tc->summary->sum_size, c->summary->sum_num,\n\t\t\t\ts->sum_size, s->sum_num);\n\n\tc->summary->sum_size = s->sum_size;\n\tc->summary->sum_num = s->sum_num;\n\tc->summary->sum_padded = s->sum_padded;\n\tc->summary->sum_list_head = s->sum_list_head;\n\tc->summary->sum_list_tail = s->sum_list_tail;\n\n\ts->sum_list_head = s->sum_list_tail = NULL;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_sum_move_collected(struct jffs2_sb_info *c, struct jffs2_summary *s)\n{\n\tdbg_summary(\"oldsize=0x%x oldnum=%u => newsize=0x%x newnum=%u\\n\",\n\t\t\t\tc->summary->sum_size, c->summary->sum_num,\n\t\t\t\ts->sum_size, s->sum_num);\n\n\tc->summary->sum_size = s->sum_size;\n\tc->summary->sum_num = s->sum_num;\n\tc->summary->sum_padded = s->sum_padded;\n\tc->summary->sum_list_head = s->sum_list_head;\n\tc->summary->sum_list_tail = s->sum_list_tail;\n\n\ts->sum_list_head = s->sum_list_tail = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_sum_reset_collected(",
          "args": [
            "->summary)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_sum_reset_collected(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/summary.c",
          "lines": "210-215",
          "snippet": "oid jffs2_sum_reset_collected(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = 0;\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"nodelist.h\"\n#",
            "include <linux/vmalloc.h>\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"nodelist.h\"\n#\ninclude <linux/vmalloc.h>\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\noid jffs2_sum_reset_collected(struct jffs2_summary *s)\n{\n\tdbg_summary(\"called\\n\");\n\tjffs2_sum_clean_collected(s);\n\ts->sum_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->clean_list)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->erase_pending_list)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Adding all-dirty block at 0x%08x to erase_pending_list\\n\",",
            "eb->offset)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->free_list)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->erase_pending_list)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg_acct_paranoia_check_nolock(",
          "args": [
            ",",
            "eb)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_dbg_acct_paranoia_check_nolock(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/debug.c",
          "lines": "309-384",
          "snippet": "id\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#",
          "includes": [
            "nclude \"debug.h\"\n\n#",
            "nclude \"nodelist.h\"\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/jffs2.h>\n#i",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/types.h>\n#i",
            "nclude <linux/kernel.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"debug.h\"\n\n#\nnclude \"nodelist.h\"\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/jffs2.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/types.h>\n#i\nnclude <linux/kernel.h>\n#i\n\nid\n__jffs2_dbg_acct_paranoia_check_nolock(struct jffs2_sb_info *c,\n\t\t\t\t       struct jffs2_eraseblock *jeb)\n{\n\tuint32_t my_used_size = 0;\n\tuint32_t my_unchecked_size = 0;\n\tuint32_t my_dirty_size = 0;\n\tstruct jffs2_raw_node_ref *ref2 = jeb->first_node;\n\n\twhile (ref2) {\n\t\tuint32_t totlen = ref_totlen(c, jeb, ref2);\n\n\t\tif (ref_offset(ref2) < jeb->offset ||\n\t\t\t\tref_offset(ref2) > jeb->offset + c->sector_size) {\n\t\t\tJFFS2_ERROR(\"node_ref %#08x shouldn't be in block at %#08x.\\n\",\n\t\t\t\tref_offset(ref2), jeb->offset);\n\t\t\tgoto error;\n\n\t\t}\n\t\tif (ref_flags(ref2) == REF_UNCHECKED)\n\t\t\tmy_unchecked_size += totlen;\n\t\telse if (!ref_obsolete(ref2))\n\t\t\tmy_used_size += totlen;\n\t\telse\n\t\t\tmy_dirty_size += totlen;\n\n\t\tif ((!ref_next(ref2)) != (ref2 == jeb->last_node)) {\n\t\t\tJFFS2_ERROR(\"node_ref for node at %#08x (mem %p) has next at %#08x (mem %p), last_node is at %#08x (mem %p).\\n\",\n\t\t\t\t    ref_offset(ref2), ref2, ref_offset(ref_next(ref2)), ref_next(ref2),\n\t\t\t\t    ref_offset(jeb->last_node), jeb->last_node);\n\t\t\tgoto error;\n\t\t}\n\t\tref2 = ref_next(ref2);\n\t}\n\n\tif (my_used_size != jeb->used_size) {\n\t\tJFFS2_ERROR(\"Calculated used size %#08x != stored used size %#08x.\\n\",\n\t\t\tmy_used_size, jeb->used_size);\n\t\tgoto error;\n\t}\n\n\tif (my_unchecked_size != jeb->unchecked_size) {\n\t\tJFFS2_ERROR(\"Calculated unchecked size %#08x != stored unchecked size %#08x.\\n\",\n\t\t\tmy_unchecked_size, jeb->unchecked_size);\n\t\tgoto error;\n\t}\n\n#if 0\n\t/* This should work when we implement ref->__totlen elemination */\n\tif (my_dirty_size != jeb->dirty_size + jeb->wasted_size) {\n\t\tJFFS2_ERROR(\"Calculated dirty+wasted size %#08x != stored dirty + wasted size %#08x\\n\",\n\t\t\tmy_dirty_size, jeb->dirty_size + jeb->wasted_size);\n\t\tgoto error;\n\t}\n\n\tif (jeb->free_size == 0\n\t\t&& my_used_size + my_unchecked_size + my_dirty_size != c->sector_size) {\n\t\tJFFS2_ERROR(\"The sum of all nodes in block (%#x) != size of block (%#x)\\n\",\n\t\t\tmy_used_size + my_unchecked_size + my_dirty_size,\n\t\t\tc->sector_size);\n\t\tgoto error;\n\t}\n#endif\n\n\tif (!(c->flags & (JFFS2_SB_FLAG_BUILDING|JFFS2_SB_FLAG_SCANNING)))\n\t\t__jffs2_dbg_superblock_counts(c);\n\n\treturn;\n\nerror:\n\t__jffs2_dbg_dump_node_refs_nolock(c, jeb);\n\t__jffs2_dbg_dump_jeb_nolock(jeb);\n\t__jffs2_dbg_dump_block_lists_nolock(c);\n\tBUG();\n\n}\n#"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_scan_eraseblock(",
          "args": [
            ",",
            "eb,",
            "uf_size?flashbuf:(flashbuf+jeb->offset),",
            "uf_size,",
            ")"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ond_resched(",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FFS2_WARNING(",
          "args": [
            "Can't allocate memory for summary\\n\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc(",
          "args": [
            "izeof(struct jffs2_summary),",
            "FP_KERNEL)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_sum_active(",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Allocated readbuf of %zu bytes\\n\",",
            "ry_size)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_kmalloc_up_to(",
          "args": [
            "->mtd,",
            "try_size)"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "Trying to allocate readbuf of %zu \"\n\t\t\t  \"bytes\\n\",",
            "ry_size)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_cleanmarker_oob(",
          "args": [
            ")"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "MTD point failed %d\\n\",",
            "et)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_unpoint(",
          "args": [
            "->mtd,",
            ",",
            "ointlen)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_dbg(",
          "args": [
            ",",
            "MTD point returned len too short: 0x%zx\\n\",",
            "ointlen)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "td_point(",
          "args": [
            "->mtd,",
            ",",
            "->mtd->size,",
            "pointlen,",
            "void **)&flashbuf,",
            "ULL)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\nnt jffs2_scan_medium(struct jffs2_sb_info *c)\n{\n\tint i, ret;\n\tuint32_t empty_blocks = 0, bad_blocks = 0;\n\tunsigned char *flashbuf = NULL;\n\tuint32_t buf_size = 0;\n\tstruct jffs2_summary *s = NULL; /* summary info collected by the scan process */\n#ifndef __ECOS\n\tsize_t pointlen, try_size;\n\n\tret = mtd_point(c->mtd, 0, c->mtd->size, &pointlen,\n\t\t\t(void **)&flashbuf, NULL);\n\tif (!ret && pointlen < c->mtd->size) {\n\t\t/* Don't muck about if it won't let us point to the whole flash */\n\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t  pointlen);\n\t\tmtd_unpoint(c->mtd, 0, pointlen);\n\t\tflashbuf = NULL;\n\t}\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n#endif\n\tif (!flashbuf) {\n\t\t/* For NAND it's quicker to read a whole eraseblock at a time,\n\t\t   apparently */\n\t\tif (jffs2_cleanmarker_oob(c))\n\t\t\ttry_size = c->sector_size;\n\t\telse\n\t\t\ttry_size = PAGE_SIZE;\n\n\t\tjffs2_dbg(1, \"Trying to allocate readbuf of %zu \"\n\t\t\t  \"bytes\\n\", try_size);\n\n\t\tflashbuf = mtd_kmalloc_up_to(c->mtd, &try_size);\n\t\tif (!flashbuf)\n\t\t\treturn -ENOMEM;\n\n\t\tjffs2_dbg(1, \"Allocated readbuf of %zu bytes\\n\",\n\t\t\t  try_size);\n\n\t\tbuf_size = (uint32_t)try_size;\n\t}\n\n\tif (jffs2_sum_active()) {\n\t\ts = kzalloc(sizeof(struct jffs2_summary), GFP_KERNEL);\n\t\tif (!s) {\n\t\t\tJFFS2_WARNING(\"Can't allocate memory for summary\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i=0; i<c->nr_blocks; i++) {\n\t\tstruct jffs2_eraseblock *jeb = &c->blocks[i];\n\n\t\tcond_resched();\n\n\t\t/* reset summary info for next eraseblock scan */\n\t\tjffs2_sum_reset_collected(s);\n\n\t\tret = jffs2_scan_eraseblock(c, jeb, buf_size?flashbuf:(flashbuf+jeb->offset),\n\t\t\t\t\t\tbuf_size, s);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\t\t/* Now decide which list to put it on */\n\t\tswitch(ret) {\n\t\tcase BLK_STATE_ALLFF:\n\t\t\t/*\n\t\t\t * Empty block.   Since we can't be sure it\n\t\t\t * was entirely erased, we just queue it for erase\n\t\t\t * again.  It will be marked as such when the erase\n\t\t\t * is complete.  Meanwhile we still count it as empty\n\t\t\t * for later checks.\n\t\t\t */\n\t\t\tempty_blocks++;\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEANMARKER:\n\t\t\t/* Only a CLEANMARKER node is valid */\n\t\t\tif (!jeb->dirty_size) {\n\t\t\t\t/* It's actually free */\n\t\t\t\tlist_add(&jeb->list, &c->free_list);\n\t\t\t\tc->nr_free_blocks++;\n\t\t\t} else {\n\t\t\t\t/* Dirt */\n\t\t\t\tjffs2_dbg(1, \"Adding all-dirty block at 0x%08x to erase_pending_list\\n\",\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\t\tc->nr_erasing_blocks++;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_CLEAN:\n\t\t\t/* Full (or almost full) of clean data. Clean list */\n\t\t\tlist_add(&jeb->list, &c->clean_list);\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_PARTDIRTY:\n\t\t\t/* Some data, but not full. Dirty list. */\n\t\t\t/* We want to remember the block with most free space\n\t\t\tand stick it in the 'nextblock' position to start writing to it. */\n\t\t\tif (jeb->free_size > min_free(c) &&\n\t\t\t\t\t(!c->nextblock || c->nextblock->free_size < jeb->free_size)) {\n\t\t\t\t/* Better candidate for the next writes to go to */\n\t\t\t\tif (c->nextblock) {\n\t\t\t\t\tret = file_dirty(c, c->nextblock);\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t/* deleting summary information of the old nextblock */\n\t\t\t\t\tjffs2_sum_reset_collected(c->summary);\n\t\t\t\t}\n\t\t\t\t/* update collected summary information for the current nextblock */\n\t\t\t\tjffs2_sum_move_collected(c, s);\n\t\t\t\tjffs2_dbg(1, \"%s(): new nextblock = 0x%08x\\n\",\n\t\t\t\t\t  __func__, jeb->offset);\n\t\t\t\tc->nextblock = jeb;\n\t\t\t} else {\n\t\t\t\tret = file_dirty(c, jeb);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_ALLDIRTY:\n\t\t\t/* Nothing valid - not even a clean marker. Needs erasing. */\n\t\t\t/* For now we just put it on the erasing list. We'll start the erases later */\n\t\t\tjffs2_dbg(1, \"Erase block at 0x%08x is not formatted. It will be erased\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->erase_pending_list);\n\t\t\tc->nr_erasing_blocks++;\n\t\t\tbreak;\n\n\t\tcase BLK_STATE_BADBLOCK:\n\t\t\tjffs2_dbg(1, \"Block at 0x%08x is bad\\n\", jeb->offset);\n\t\t\tlist_add(&jeb->list, &c->bad_list);\n\t\t\tc->bad_size += c->sector_size;\n\t\t\tc->free_size -= c->sector_size;\n\t\t\tbad_blocks++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"%s(): unknown block state\\n\", __func__);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t/* Nextblock dirty is always seen as wasted, because we cannot recycle it now */\n\tif (c->nextblock && (c->nextblock->dirty_size)) {\n\t\tc->nextblock->wasted_size += c->nextblock->dirty_size;\n\t\tc->wasted_size += c->nextblock->dirty_size;\n\t\tc->dirty_size -= c->nextblock->dirty_size;\n\t\tc->nextblock->dirty_size = 0;\n\t}\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && c->wbuf_pagesize && c->nextblock && (c->nextblock->free_size % c->wbuf_pagesize)) {\n\t\t/* If we're going to start writing into a block which already\n\t\t   contains data, and the end of the data isn't page-aligned,\n\t\t   skip a little and align it. */\n\n\t\tuint32_t skip = c->nextblock->free_size % c->wbuf_pagesize;\n\n\t\tjffs2_dbg(1, \"%s(): Skipping %d bytes in nextblock to ensure page alignment\\n\",\n\t\t\t  __func__, skip);\n\t\tjffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\n\t\tjffs2_scan_dirty_space(c, c->nextblock, skip);\n\t}\n#endif\n\tif (c->nr_erasing_blocks) {\n\t\tif ( !c->used_size && ((c->nr_free_blocks+empty_blocks+bad_blocks)!= c->nr_blocks || bad_blocks == c->nr_blocks) ) {\n\t\t\tpr_notice(\"Cowardly refusing to erase blocks on filesystem with no valid JFFS2 nodes\\n\");\n\t\t\tpr_notice(\"empty_blocks %d, bad_blocks %d, c->nr_blocks %d\\n\",\n\t\t\t\t  empty_blocks, bad_blocks, c->nr_blocks);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tjffs2_garbage_collect_trigger(c);\n\t\tspin_unlock(&c->erase_completion_lock);\n\t}\n\tret = 0;\n out:\n\tif (buf_size)\n\t\tkfree(flashbuf);\n#ifndef __ECOS\n\telse\n\t\tmtd_unpoint(c->mtd, 0, c->mtd->size);\n#endif\n\tkfree(s);\n\treturn ret;\n}"
  },
  {
    "function_name": "ile_dirty(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "69-89",
    "snippet": "tatic int file_dirty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\n\tif ((ret = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\treturn ret;\n\tif ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))\n\t\treturn ret;\n\t/* Turned wasted size into dirty, since we apparently \n\t   think it's recoverable now. */\n\tjeb->dirty_size += jeb->wasted_size;\n\tc->dirty_size += jeb->wasted_size;\n\tc->wasted_size -= jeb->wasted_size;\n\tjeb->wasted_size = 0;\n\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\tlist_add(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tlist_add(&jeb->list, &c->dirty_list);\n\t}\n\treturn 0;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);",
      "tatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);",
      "tatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->dirty_list)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "jeb->list,",
            "c->very_dirty_list)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERYDIRTY(",
          "args": [
            ",",
            "eb->dirty_size)"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs2_scan_dirty_space(",
          "args": [
            ",",
            "eb,",
            "eb->free_size)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_scan_dirty_space(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.c",
          "lines": "662-689",
          "snippet": "nt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/pagemap.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/rbtree.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/fs.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/pagemap.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/rbtree.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/fs.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t   uint32_t size)\n{\n\tif (!size)\n\t\treturn 0;\n\tif (unlikely(size > jeb->free_size)) {\n\t\tpr_crit(\"Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\\n\",\n\t\t\tsize, jeb->free_size, jeb->wasted_size);\n\t\tBUG();\n\t}\n\t/* REF_EMPTY_NODE is !obsolete, so that works OK */\n\tif (jeb->last_node && ref_obsolete(jeb->last_node)) {\n#ifdef TEST_TOTLEN\n\t\tjeb->last_node->__totlen += size;\n#endif\n\t\tc->dirty_size += size;\n\t\tc->free_size -= size;\n\t\tjeb->dirty_size += size;\n\t\tjeb->free_size -= size;\n\t} else {\n\t\tuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\n\t\tofs |= REF_OBSOLETE;\n\n\t\tjffs2_link_node_ref(c, jeb, ofs, size, NULL);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs2_prealloc_raw_node_refs(",
          "args": [
            ",",
            "eb,",
            ")"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_prealloc_raw_node_refs(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/malloc.c",
          "lines": "210-249",
          "snippet": "nt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}",
          "includes": [
            "include \"nodelist.h\"",
            "include <linux/jffs2.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"nodelist.h\"\ninclude <linux/jffs2.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/kernel.h>\n#\n\nnt jffs2_prealloc_raw_node_refs(struct jffs2_sb_info *c,\n\t\t\t\t struct jffs2_eraseblock *jeb, int nr)\n{\n\tstruct jffs2_raw_node_ref **p, *ref;\n\tint i = nr;\n\n\tdbg_memalloc(\"%d\\n\", nr);\n\n\tp = &jeb->last_node;\n\tref = *p;\n\n\tdbg_memalloc(\"Reserving %d refs for block @0x%08x\\n\", nr, jeb->offset);\n\n\t/* If jeb->last_node is really a valid node then skip over it */\n\tif (ref && ref->flash_offset != REF_EMPTY_NODE)\n\t\tref++;\n\n\twhile (i) {\n\t\tif (!ref) {\n\t\t\tdbg_memalloc(\"Allocating new refblock linked from %p\\n\", p);\n\t\t\tref = *p = jffs2_alloc_refblock();\n\t\t\tif (!ref)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tp = &ref->next_in_ino;\n\t\t\tref = *p;\n\t\t\tcontinue;\n\t\t}\n\t\ti--;\n\t\tref++;\n\t}\n\tjeb->allocated_refs = nr;\n\n\tdbg_memalloc(\"Reserved %d refs for block @0x%08x, last_node is %p (%08x,%p)\\n\",\n\t\t  nr, jeb->offset, jeb->last_node, jeb->last_node->flash_offset,\n\t\t  jeb->last_node->next_in_ino);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t  unsigned char *buf, uint32_t buf_size, struct jffs2_summary *s);\ntatic int jffs2_scan_inode_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s);\ntatic int jffs2_scan_dirent_node(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t struct jffs2_raw_dirent *rd, uint32_t ofs, struct jffs2_summary *s);\n\ntatic int file_dirty(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\n\tif ((ret = jffs2_prealloc_raw_node_refs(c, jeb, 1)))\n\t\treturn ret;\n\tif ((ret = jffs2_scan_dirty_space(c, jeb, jeb->free_size)))\n\t\treturn ret;\n\t/* Turned wasted size into dirty, since we apparently \n\t   think it's recoverable now. */\n\tjeb->dirty_size += jeb->wasted_size;\n\tc->dirty_size += jeb->wasted_size;\n\tc->wasted_size -= jeb->wasted_size;\n\tjeb->wasted_size = 0;\n\tif (VERYDIRTY(c, jeb->dirty_size)) {\n\t\tlist_add(&jeb->list, &c->very_dirty_list);\n\t} else {\n\t\tlist_add(&jeb->list, &c->dirty_list);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "MPTY_SCAN_SIZE(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "62-67",
    "snippet": "tatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline uint32_t EMPTY_SCAN_SIZE(uint32_t sector_size) {\n\tif (sector_size < DEFAULT_EMPTY_SCAN_SIZE)\n\t\treturn sector_size;\n\telse\n\t\treturn DEFAULT_EMPTY_SCAN_SIZE;\n}"
  },
  {
    "function_name": "in_free(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
    "lines": "51-60",
    "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
    "includes": [
      "include \"debug.h\"",
      "include \"summary.h\"\n#",
      "include \"nodelist.h\"\n#",
      "include <linux/compiler.h>\n#",
      "include <linux/crc32.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/mtd/mtd.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/kernel.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffs2_can_mark_obsolete(",
          "args": [
            ")"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
  }
]