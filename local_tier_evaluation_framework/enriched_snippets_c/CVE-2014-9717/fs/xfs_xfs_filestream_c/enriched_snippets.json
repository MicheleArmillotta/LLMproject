[
  {
    "function_name": "xfs_filestream_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "426-431",
    "snippet": "void\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mru_cache_destroy",
          "args": [
            "mp->m_filestream"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "410-421",
          "snippet": "void\nxfs_mru_cache_destroy(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\txfs_mru_cache_flush(mru);\n\n\tkmem_free(mru->lists);\n\tkmem_free(mru);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_destroy(\n\tstruct xfs_mru_cache\t*mru)\n{\n\tif (!mru || !mru->lists)\n\t\treturn;\n\n\txfs_mru_cache_flush(mru);\n\n\tkmem_free(mru->lists);\n\tkmem_free(mru);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_filestream_unmount(\n\txfs_mount_t\t*mp)\n{\n\txfs_mru_cache_destroy(mp->m_filestream);\n}"
  },
  {
    "function_name": "xfs_filestream_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "411-424",
    "snippet": "int\nxfs_filestream_mount(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * The filestream timer tunable is currently fixed within the range of\n\t * one second to four minutes, with five seconds being the default.  The\n\t * group count is somewhat arbitrary, but it'd be nice to adhere to the\n\t * timer tunable to within about 10 percent.  This requires at least 10\n\t * groups.\n\t */\n\treturn xfs_mru_cache_create(&mp->m_filestream, xfs_fstrm_centisecs * 10,\n\t\t\t\t    10, xfs_fstrm_free_func);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mru_cache_create",
          "args": [
            "&mp->m_filestream",
            "xfs_fstrm_centisecs * 10",
            "10",
            "xfs_fstrm_free_func"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "326-382",
          "snippet": "int\nxfs_mru_cache_create(\n\tstruct xfs_mru_cache\t**mrup,\n\tunsigned int\t\tlifetime_ms,\n\tunsigned int\t\tgrp_count,\n\txfs_mru_cache_free_func_t free_func)\n{\n\tstruct xfs_mru_cache\t*mru = NULL;\n\tint\t\t\terr = 0, grp;\n\tunsigned int\t\tgrp_time;\n\n\tif (mrup)\n\t\t*mrup = NULL;\n\n\tif (!mrup || !grp_count || !lifetime_ms || !free_func)\n\t\treturn -EINVAL;\n\n\tif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\n\t\treturn -EINVAL;\n\n\tif (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))\n\t\treturn -ENOMEM;\n\n\t/* An extra list is needed to avoid reaping up to a grp_time early. */\n\tmru->grp_count = grp_count + 1;\n\tmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);\n\n\tif (!mru->lists) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor (grp = 0; grp < mru->grp_count; grp++)\n\t\tINIT_LIST_HEAD(mru->lists + grp);\n\n\t/*\n\t * We use GFP_KERNEL radix tree preload and do inserts under a\n\t * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.\n\t */\n\tINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&mru->reap_list);\n\tspin_lock_init(&mru->lock);\n\tINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\n\n\tmru->grp_time  = grp_time;\n\tmru->free_func = free_func;\n\n\t*mrup = mru;\n\nexit:\n\tif (err && mru && mru->lists)\n\t\tkmem_free(mru->lists);\n\tif (err && mru)\n\t\tkmem_free(mru);\n\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nint\nxfs_mru_cache_create(\n\tstruct xfs_mru_cache\t**mrup,\n\tunsigned int\t\tlifetime_ms,\n\tunsigned int\t\tgrp_count,\n\txfs_mru_cache_free_func_t free_func)\n{\n\tstruct xfs_mru_cache\t*mru = NULL;\n\tint\t\t\terr = 0, grp;\n\tunsigned int\t\tgrp_time;\n\n\tif (mrup)\n\t\t*mrup = NULL;\n\n\tif (!mrup || !grp_count || !lifetime_ms || !free_func)\n\t\treturn -EINVAL;\n\n\tif (!(grp_time = msecs_to_jiffies(lifetime_ms) / grp_count))\n\t\treturn -EINVAL;\n\n\tif (!(mru = kmem_zalloc(sizeof(*mru), KM_SLEEP)))\n\t\treturn -ENOMEM;\n\n\t/* An extra list is needed to avoid reaping up to a grp_time early. */\n\tmru->grp_count = grp_count + 1;\n\tmru->lists = kmem_zalloc(mru->grp_count * sizeof(*mru->lists), KM_SLEEP);\n\n\tif (!mru->lists) {\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tfor (grp = 0; grp < mru->grp_count; grp++)\n\t\tINIT_LIST_HEAD(mru->lists + grp);\n\n\t/*\n\t * We use GFP_KERNEL radix tree preload and do inserts under a\n\t * spinlock so GFP_ATOMIC is appropriate for the radix tree itself.\n\t */\n\tINIT_RADIX_TREE(&mru->store, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&mru->reap_list);\n\tspin_lock_init(&mru->lock);\n\tINIT_DELAYED_WORK(&mru->work, _xfs_mru_cache_reap);\n\n\tmru->grp_time  = grp_time;\n\tmru->free_func = free_func;\n\n\t*mrup = mru;\n\nexit:\n\tif (err && mru && mru->lists)\n\t\tkmem_free(mru->lists);\n\tif (err && mru)\n\t\tkmem_free(mru);\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_filestream_mount(\n\txfs_mount_t\t*mp)\n{\n\t/*\n\t * The filestream timer tunable is currently fixed within the range of\n\t * one second to four minutes, with five seconds being the default.  The\n\t * group count is somewhat arbitrary, but it'd be nice to adhere to the\n\t * timer tunable to within about 10 percent.  This requires at least 10\n\t * groups.\n\t */\n\treturn xfs_mru_cache_create(&mp->m_filestream, xfs_fstrm_centisecs * 10,\n\t\t\t\t    10, xfs_fstrm_free_func);\n}"
  },
  {
    "function_name": "xfs_filestream_deassociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "404-409",
    "snippet": "void\nxfs_filestream_deassociate(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_mru_cache_delete(ip->i_mount->m_filestream, ip->i_ino);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mru_cache_delete",
          "args": [
            "ip->i_mount->m_filestream",
            "ip->i_ino"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "486-496",
          "snippet": "void\nxfs_mru_cache_delete(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\telem = xfs_mru_cache_remove(mru, key);\n\tif (elem)\n\t\tmru->free_func(elem);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_delete(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\telem = xfs_mru_cache_remove(mru, key);\n\tif (elem)\n\t\tmru->free_func(elem);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_filestream_deassociate(\n\tstruct xfs_inode\t*ip)\n{\n\txfs_mru_cache_delete(ip->i_mount->m_filestream, ip->i_ino);\n}"
  },
  {
    "function_name": "xfs_filestream_new_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "361-402",
    "snippet": "int\nxfs_filestream_new_ag(\n\tstruct xfs_bmalloca\t*ap,\n\txfs_agnumber_t\t\t*agp)\n{\n\tstruct xfs_inode\t*ip = ap->ip, *pip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_extlen_t\t\tminlen = ap->length;\n\txfs_agnumber_t\t\tstartag = 0;\n\tint\t\t\tflags, err = 0;\n\tstruct xfs_mru_cache_elem *mru;\n\n\t*agp = NULLAGNUMBER;\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto exit;\n\n\tmru = xfs_mru_cache_remove(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tstruct xfs_fstrm_item *item =\n\t\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\t\tstartag = (item->ag + 1) % mp->m_sb.sb_agcount;\n\t}\n\n\tflags = (ap->userdata ? XFS_PICK_USERDATA : 0) |\n\t        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);\n\n\terr = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);\n\n\t/*\n\t * Only free the item here so we skip over the old AG earlier.\n\t */\n\tif (mru)\n\t\txfs_fstrm_free_func(mru);\n\n\tIRELE(pip);\nexit:\n\tif (*agp == NULLAGNUMBER)\n\t\t*agp = 0;\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "pip"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_fstrm_free_func",
          "args": [
            "mru"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_fstrm_free_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "121-133",
          "snippet": "static void\nxfs_fstrm_free_func(\n\tstruct xfs_mru_cache_elem *mru)\n{\n\tstruct xfs_fstrm_item\t*item =\n\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\n\txfs_filestream_put_ag(item->ip->i_mount, item->ag);\n\n\ttrace_xfs_filestream_free(item->ip, item->ag);\n\n\tkmem_free(item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_fstrm_free_func(\n\tstruct xfs_mru_cache_elem *mru)\n{\n\tstruct xfs_fstrm_item\t*item =\n\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\n\txfs_filestream_put_ag(item->ip->i_mount, item->ag);\n\n\ttrace_xfs_filestream_free(item->ip, item->ag);\n\n\tkmem_free(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_pick_ag",
          "args": [
            "pip",
            "startag",
            "agp",
            "flags",
            "minlen"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_pick_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "139-280",
          "snippet": "static int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mru",
            "structxfs_fstrm_item",
            "mru"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_remove",
          "args": [
            "mp->m_filestream",
            "pip->i_ino"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "462-480",
          "snippet": "struct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstruct xfs_mru_cache_elem *\nxfs_mru_cache_remove(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_delete(&mru->store, key);\n\tif (elem)\n\t\tlist_del(&elem->list_node);\n\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_get_parent",
          "args": [
            "ip"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "282-304",
          "snippet": "static struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_filestream_new_ag(\n\tstruct xfs_bmalloca\t*ap,\n\txfs_agnumber_t\t\t*agp)\n{\n\tstruct xfs_inode\t*ip = ap->ip, *pip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_extlen_t\t\tminlen = ap->length;\n\txfs_agnumber_t\t\tstartag = 0;\n\tint\t\t\tflags, err = 0;\n\tstruct xfs_mru_cache_elem *mru;\n\n\t*agp = NULLAGNUMBER;\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto exit;\n\n\tmru = xfs_mru_cache_remove(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tstruct xfs_fstrm_item *item =\n\t\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\t\tstartag = (item->ag + 1) % mp->m_sb.sb_agcount;\n\t}\n\n\tflags = (ap->userdata ? XFS_PICK_USERDATA : 0) |\n\t        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);\n\n\terr = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);\n\n\t/*\n\t * Only free the item here so we skip over the old AG earlier.\n\t */\n\tif (mru)\n\t\txfs_fstrm_free_func(mru);\n\n\tIRELE(pip);\nexit:\n\tif (*agp == NULLAGNUMBER)\n\t\t*agp = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_filestream_lookup_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "312-353",
    "snippet": "xfs_agnumber_t\nxfs_filestream_lookup_ag(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_inode\t*pip = NULL;\n\txfs_agnumber_t\t\tstartag, ag = NULLAGNUMBER;\n\tstruct xfs_mru_cache_elem *mru;\n\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto out;\n\n\tmru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tag = container_of(mru, struct xfs_fstrm_item, mru)->ag;\n\t\txfs_mru_cache_done(mp->m_filestream);\n\n\t\ttrace_xfs_filestream_lookup(ip, ag);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Set the starting AG using the rotor for inode32, otherwise\n\t * use the directory inode's AG.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES) {\n\t\txfs_agnumber_t\t rotorstep = xfs_rotorstep;\n\t\tstartag = (mp->m_agfrotor / rotorstep) % mp->m_sb.sb_agcount;\n\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t                 (mp->m_sb.sb_agcount * rotorstep);\n\t} else\n\t\tstartag = XFS_INO_TO_AGNO(mp, pip->i_ino);\n\n\tif (xfs_filestream_pick_ag(pip, startag, &ag, 0, 0))\n\t\tag = NULLAGNUMBER;\nout:\n\tIRELE(pip);\n\treturn ag;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "pip"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_filestream_pick_ag",
          "args": [
            "pip",
            "startag",
            "&ag",
            "0",
            "0"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_pick_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "139-280",
          "snippet": "static int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_AGNO",
          "args": [
            "mp",
            "pip->i_ino"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_filestream_lookup",
          "args": [
            "ip",
            "ag"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_done",
          "args": [
            "mp->m_filestream"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "546-552",
          "snippet": "void\nxfs_mru_cache_done(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock)\n{\n\tspin_unlock(&mru->lock);\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_mru_cache_done(\n\tstruct xfs_mru_cache\t*mru)\n\t\t__releases(mru->lock)\n{\n\tspin_unlock(&mru->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mru",
            "structxfs_fstrm_item",
            "mru"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_lookup",
          "args": [
            "mp->m_filestream",
            "pip->i_ino"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "518-539",
          "snippet": "struct xfs_mru_cache_elem *\nxfs_mru_cache_lookup(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_lookup(&mru->store, key);\n\tif (elem) {\n\t\tlist_del(&elem->list_node);\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\t\t__release(mru_lock); /* help sparse not be stupid */\n\t} else\n\t\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nstruct xfs_mru_cache_elem *\nxfs_mru_cache_lookup(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey)\n{\n\tstruct xfs_mru_cache_elem *elem;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn NULL;\n\n\tspin_lock(&mru->lock);\n\telem = radix_tree_lookup(&mru->store, key);\n\tif (elem) {\n\t\tlist_del(&elem->list_node);\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\t\t__release(mru_lock); /* help sparse not be stupid */\n\t} else\n\t\tspin_unlock(&mru->lock);\n\n\treturn elem;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_get_parent",
          "args": [
            "ip"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "282-304",
          "snippet": "static struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISREG(ip->i_d.di_mode)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nxfs_agnumber_t\nxfs_filestream_lookup_ag(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_inode\t*pip = NULL;\n\txfs_agnumber_t\t\tstartag, ag = NULLAGNUMBER;\n\tstruct xfs_mru_cache_elem *mru;\n\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto out;\n\n\tmru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tag = container_of(mru, struct xfs_fstrm_item, mru)->ag;\n\t\txfs_mru_cache_done(mp->m_filestream);\n\n\t\ttrace_xfs_filestream_lookup(ip, ag);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Set the starting AG using the rotor for inode32, otherwise\n\t * use the directory inode's AG.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES) {\n\t\txfs_agnumber_t\t rotorstep = xfs_rotorstep;\n\t\tstartag = (mp->m_agfrotor / rotorstep) % mp->m_sb.sb_agcount;\n\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t                 (mp->m_sb.sb_agcount * rotorstep);\n\t} else\n\t\tstartag = XFS_INO_TO_AGNO(mp, pip->i_ino);\n\n\tif (xfs_filestream_pick_ag(pip, startag, &ag, 0, 0))\n\t\tag = NULLAGNUMBER;\nout:\n\tIRELE(pip);\n\treturn ag;\n}"
  },
  {
    "function_name": "xfs_filestream_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "282-304",
    "snippet": "static struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_I",
          "args": [
            "dir"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "parent->d_inode"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ip"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "78-81",
          "snippet": "static inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline struct inode *VFS_I(struct xfs_inode *ip)\n{\n\treturn &ip->i_vnode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic struct xfs_inode *\nxfs_filestream_get_parent(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct inode\t\t*inode = VFS_I(ip), *dir = NULL;\n\tstruct dentry\t\t*dentry, *parent;\n\n\tdentry = d_find_alias(inode);\n\tif (!dentry)\n\t\tgoto out;\n\n\tparent = dget_parent(dentry);\n\tif (!parent)\n\t\tgoto out_dput;\n\n\tdir = igrab(parent->d_inode);\n\tdput(parent);\n\nout_dput:\n\tdput(dentry);\nout:\n\treturn dir ? XFS_I(dir) : NULL;\n}"
  },
  {
    "function_name": "xfs_filestream_pick_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "139-280",
    "snippet": "static int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_filestream_put_ag",
          "args": [
            "mp",
            "*agp"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_put_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "109-119",
          "snippet": "static void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "item"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mru_cache_insert",
          "args": [
            "mp->m_filestream",
            "ip->i_ino",
            "&item->mru"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mru_cache_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mru_cache.c",
          "lines": "428-454",
          "snippet": "int\nxfs_mru_cache_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tint\t\t\terror;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn -EINVAL;\n\n\tif (radix_tree_preload(GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&elem->list_node);\n\telem->key = key;\n\n\tspin_lock(&mru->lock);\n\terror = radix_tree_insert(&mru->store, key, elem);\n\tradix_tree_preload_end();\n\tif (!error)\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\tspin_unlock(&mru->lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mru_cache.h\"\n#include \"xfs.h\"\n\nint\nxfs_mru_cache_insert(\n\tstruct xfs_mru_cache\t*mru,\n\tunsigned long\t\tkey,\n\tstruct xfs_mru_cache_elem *elem)\n{\n\tint\t\t\terror;\n\n\tASSERT(mru && mru->lists);\n\tif (!mru || !mru->lists)\n\t\treturn -EINVAL;\n\n\tif (radix_tree_preload(GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&elem->list_node);\n\telem->key = key;\n\n\tspin_lock(&mru->lock);\n\terror = radix_tree_insert(&mru->store, key, elem);\n\tradix_tree_preload_end();\n\tif (!error)\n\t\t_xfs_mru_cache_list_insert(mru, elem);\n\tspin_unlock(&mru->lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_alloc",
          "args": [
            "sizeof(*item)",
            "KM_MAYFAIL"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "45-62",
          "snippet": "void *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_alloc(size_t size, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmalloc(size, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_filestream_pick",
          "args": [
            "ip",
            "*agp",
            "free",
            "nscan"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_filestream_pick",
          "args": [
            "ip",
            "*agp",
            "free",
            "nscan"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_filestream_get_ag",
          "args": [
            "mp",
            "max_ag"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_get_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "95-107",
          "snippet": "static int\nxfs_filestream_get_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_inc_return(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_filestream_get_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_inc_return(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_longest_free_extent",
          "args": [
            "mp",
            "pag"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_longest_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1819-1833",
          "snippet": "xfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nxfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_pagf_init",
          "args": [
            "mp",
            "NULL",
            "ag",
            "trylock"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_pagf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2115-2130",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "ag"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_filestream_scan",
          "args": [
            "ip",
            "ag"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "S_ISDIR(ip->i_d.di_mode)"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_filestream_pick_ag(\n\tstruct xfs_inode\t*ip,\n\txfs_agnumber_t\t\tstartag,\n\txfs_agnumber_t\t\t*agp,\n\tint\t\t\tflags,\n\txfs_extlen_t\t\tminlen)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_fstrm_item\t*item;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest, free = 0, minfree, maxfree = 0;\n\txfs_agnumber_t\t\tag, max_ag = NULLAGNUMBER;\n\tint\t\t\terr, trylock, nscan;\n\n\tASSERT(S_ISDIR(ip->i_d.di_mode));\n\n\t/* 2% of an AG's blocks must be free for it to be chosen. */\n\tminfree = mp->m_sb.sb_agblocks / 50;\n\n\tag = startag;\n\t*agp = NULLAGNUMBER;\n\n\t/* For the first pass, don't sleep trying to init the per-AG. */\n\ttrylock = XFS_ALLOC_FLAG_TRYLOCK;\n\n\tfor (nscan = 0; 1; nscan++) {\n\t\ttrace_xfs_filestream_scan(ip, ag);\n\n\t\tpag = xfs_perag_get(mp, ag);\n\n\t\tif (!pag->pagf_init) {\n\t\t\terr = xfs_alloc_pagf_init(mp, NULL, ag, trylock);\n\t\t\tif (err && !trylock) {\n\t\t\t\txfs_perag_put(pag);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t/* Might fail sometimes during the 1st pass with trylock set. */\n\t\tif (!pag->pagf_init)\n\t\t\tgoto next_ag;\n\n\t\t/* Keep track of the AG with the most free blocks. */\n\t\tif (pag->pagf_freeblks > maxfree) {\n\t\t\tmaxfree = pag->pagf_freeblks;\n\t\t\tmax_ag = ag;\n\t\t}\n\n\t\t/*\n\t\t * The AG reference count does two things: it enforces mutual\n\t\t * exclusion when examining the suitability of an AG in this\n\t\t * loop, and it guards against two filestreams being established\n\t\t * in the same AG as each other.\n\t\t */\n\t\tif (xfs_filestream_get_ag(mp, ag) > 1) {\n\t\t\txfs_filestream_put_ag(mp, ag);\n\t\t\tgoto next_ag;\n\t\t}\n\n\t\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\t\tif (((minlen && longest >= minlen) ||\n\t\t     (!minlen && pag->pagf_freeblks >= minfree)) &&\n\t\t    (!pag->pagf_metadata || !(flags & XFS_PICK_USERDATA) ||\n\t\t     (flags & XFS_PICK_LOWSPACE))) {\n\n\t\t\t/* Break out, retaining the reference on the AG. */\n\t\t\tfree = pag->pagf_freeblks;\n\t\t\txfs_perag_put(pag);\n\t\t\t*agp = ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Drop the reference on this AG, it's not usable. */\n\t\txfs_filestream_put_ag(mp, ag);\nnext_ag:\n\t\txfs_perag_put(pag);\n\t\t/* Move to the next AG, wrapping to AG 0 if necessary. */\n\t\tif (++ag >= mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\n\t\t/* If a full pass of the AGs hasn't been done yet, continue. */\n\t\tif (ag != startag)\n\t\t\tcontinue;\n\n\t\t/* Allow sleeping in xfs_alloc_pagf_init() on the 2nd pass. */\n\t\tif (trylock != 0) {\n\t\t\ttrylock = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Finally, if lowspace wasn't set, set it for the 3rd pass. */\n\t\tif (!(flags & XFS_PICK_LOWSPACE)) {\n\t\t\tflags |= XFS_PICK_LOWSPACE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Take the AG with the most free space, regardless of whether\n\t\t * it's already in use by another filestream.\n\t\t */\n\t\tif (max_ag != NULLAGNUMBER) {\n\t\t\txfs_filestream_get_ag(mp, max_ag);\n\t\t\tfree = maxfree;\n\t\t\t*agp = max_ag;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* take AG 0 if none matched */\n\t\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\t\t*agp = 0;\n\t\treturn 0;\n\t}\n\n\ttrace_xfs_filestream_pick(ip, *agp, free, nscan);\n\n\tif (*agp == NULLAGNUMBER)\n\t\treturn 0;\n\n\terr = -ENOMEM;\n\titem = kmem_alloc(sizeof(*item), KM_MAYFAIL);\n\tif (!item)\n\t\tgoto out_put_ag;\n\n\titem->ag = *agp;\n\titem->ip = ip;\n\n\terr = xfs_mru_cache_insert(mp->m_filestream, ip->i_ino, &item->mru);\n\tif (err) {\n\t\tif (err == -EEXIST)\n\t\t\terr = 0;\n\t\tgoto out_free_item;\n\t}\n\n\treturn 0;\n\nout_free_item:\n\tkmem_free(item);\nout_put_ag:\n\txfs_filestream_put_ag(mp, *agp);\n\treturn err;\n}"
  },
  {
    "function_name": "xfs_fstrm_free_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "121-133",
    "snippet": "static void\nxfs_fstrm_free_func(\n\tstruct xfs_mru_cache_elem *mru)\n{\n\tstruct xfs_fstrm_item\t*item =\n\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\n\txfs_filestream_put_ag(item->ip->i_mount, item->ag);\n\n\ttrace_xfs_filestream_free(item->ip, item->ag);\n\n\tkmem_free(item);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "item"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_filestream_free",
          "args": [
            "item->ip",
            "item->ag"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_filestream_put_ag",
          "args": [
            "item->ip->i_mount",
            "item->ag"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_put_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "109-119",
          "snippet": "static void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "mru",
            "structxfs_fstrm_item",
            "mru"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_fstrm_free_func(\n\tstruct xfs_mru_cache_elem *mru)\n{\n\tstruct xfs_fstrm_item\t*item =\n\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\n\txfs_filestream_put_ag(item->ip->i_mount, item->ag);\n\n\ttrace_xfs_filestream_free(item->ip, item->ag);\n\n\tkmem_free(item);\n}"
  },
  {
    "function_name": "xfs_filestream_put_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "109-119",
    "snippet": "static void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&pag->pagf_fstrms"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_filestream_put_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\n\tpag = xfs_perag_get(mp, agno);\n\tatomic_dec(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n}"
  },
  {
    "function_name": "xfs_filestream_get_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "95-107",
    "snippet": "static int\nxfs_filestream_get_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_inc_return(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&pag->pagf_fstrms"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_filestream_get_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_inc_return(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}"
  },
  {
    "function_name": "xfs_filestream_peek_ag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
    "lines": "81-93",
    "snippet": "int\nxfs_filestream_peek_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_read(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}",
    "includes": [
      "#include \"xfs_trace.h\"",
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_mru_cache.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pag->pagf_fstrms"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "agno"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_filestream_peek_ag(\n\txfs_mount_t\t*mp,\n\txfs_agnumber_t\tagno)\n{\n\tstruct xfs_perag *pag;\n\tint\t\tret;\n\n\tpag = xfs_perag_get(mp, agno);\n\tret = atomic_read(&pag->pagf_fstrms);\n\txfs_perag_put(pag);\n\treturn ret;\n}"
  }
]