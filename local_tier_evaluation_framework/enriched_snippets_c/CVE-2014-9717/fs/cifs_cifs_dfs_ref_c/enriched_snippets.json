[
  {
    "function_name": "cifs_dfs_d_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "357-375",
    "snippet": "struct vfsmount *cifs_dfs_d_automount(struct path *path)\n{\n\tstruct vfsmount *newmnt;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\n\tnewmnt = cifs_dfs_do_automount(path->dentry);\n\tif (IS_ERR(newmnt)) {\n\t\tcifs_dbg(FYI, \"leaving %s [automount failed]\\n\" , __func__);\n\t\treturn newmnt;\n\t}\n\n\tmntget(newmnt); /* prevent immediate expiration */\n\tmnt_set_expiry(newmnt, &cifs_dfs_automount_list);\n\tschedule_delayed_work(&cifs_dfs_automount_task,\n\t\t\t      cifs_dfs_mountpoint_expiry_timeout);\n\tcifs_dbg(FYI, \"leaving %s [ok]\\n\" , __func__);\n\treturn newmnt;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(cifs_dfs_automount_list);",
      "static int cifs_dfs_mountpoint_expiry_timeout = 500 * HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"leaving %s [ok]\\n\"",
            "__func__"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&cifs_dfs_automount_task",
            "cifs_dfs_mountpoint_expiry_timeout"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_set_expiry",
          "args": [
            "newmnt",
            "&cifs_dfs_automount_list"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2391-2398",
          "snippet": "void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)\n{\n\tnamespace_lock();\n\n\tlist_add_tail(&real_mount(mnt)->mnt_expire, expiry_list);\n\n\tnamespace_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mntget",
          "args": [
            "newmnt"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "mntget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1130-1135",
          "snippet": "struct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *mntget(struct vfsmount *mnt)\n{\n\tif (mnt)\n\t\tmnt_add_count(real_mount(mnt), 1);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"leaving %s [automount failed]\\n\"",
            "__func__"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newmnt"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dfs_do_automount",
          "args": [
            "path->dentry"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dfs_do_automount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "277-352",
          "snippet": "static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)\n{\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_ses *ses;\n\tchar *full_path;\n\tunsigned int xid;\n\tint i;\n\tint rc;\n\tstruct vfsmount *mnt;\n\tstruct tcon_link *tlink;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\tBUG_ON(IS_ROOT(mntpt));\n\n\t/*\n\t * The MSDFS spec states that paths in DFS referral requests and\n\t * responses must be prefixed by a single '\\' character instead of\n\t * the double backslashes usually used in the UNC. This function\n\t * gives us the latter, so we must adjust the result.\n\t */\n\tmnt = ERR_PTR(-ENOMEM);\n\tfull_path = build_path_from_dentry(mntpt);\n\tif (full_path == NULL)\n\t\tgoto cdda_exit;\n\n\tcifs_sb = CIFS_SB(mntpt->d_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tmnt = ERR_CAST(tlink);\n\t\tgoto free_full_path;\n\t}\n\tses = tlink_tcon(tlink)->ses;\n\n\txid = get_xid();\n\trc = get_dfs_path(xid, ses, full_path + 1, cifs_sb->local_nls,\n\t\t&num_referrals, &referrals,\n\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tmnt = ERR_PTR(-ENOENT);\n\tfor (i = 0; i < num_referrals; i++) {\n\t\tint len;\n\t\tdump_referral(referrals + i);\n\t\t/* connect to a node */\n\t\tlen = strlen(referrals[i].node_name);\n\t\tif (len < 2) {\n\t\t\tcifs_dbg(VFS, \"%s: Net Address path too short: %s\\n\",\n\t\t\t\t __func__, referrals[i].node_name);\n\t\t\tmnt = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tmnt = cifs_dfs_do_refmount(cifs_sb,\n\t\t\t\tfull_path, referrals + i);\n\t\tcifs_dbg(FYI, \"%s: cifs_dfs_do_refmount:%s , mnt:%p\\n\",\n\t\t\t __func__, referrals[i].node_name, mnt);\n\t\tif (!IS_ERR(mnt))\n\t\t\tgoto success;\n\t}\n\n\t/* no valid submounts were found; return error from get_dfs_path() by\n\t * preference */\n\tif (rc != 0)\n\t\tmnt = ERR_PTR(rc);\n\nsuccess:\n\tfree_dfs_info_array(referrals, num_referrals);\nfree_full_path:\n\tkfree(full_path);\ncdda_exit:\n\tcifs_dbg(FYI, \"leaving %s\\n\" , __func__);\n\treturn mnt;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)\n{\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_ses *ses;\n\tchar *full_path;\n\tunsigned int xid;\n\tint i;\n\tint rc;\n\tstruct vfsmount *mnt;\n\tstruct tcon_link *tlink;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\tBUG_ON(IS_ROOT(mntpt));\n\n\t/*\n\t * The MSDFS spec states that paths in DFS referral requests and\n\t * responses must be prefixed by a single '\\' character instead of\n\t * the double backslashes usually used in the UNC. This function\n\t * gives us the latter, so we must adjust the result.\n\t */\n\tmnt = ERR_PTR(-ENOMEM);\n\tfull_path = build_path_from_dentry(mntpt);\n\tif (full_path == NULL)\n\t\tgoto cdda_exit;\n\n\tcifs_sb = CIFS_SB(mntpt->d_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tmnt = ERR_CAST(tlink);\n\t\tgoto free_full_path;\n\t}\n\tses = tlink_tcon(tlink)->ses;\n\n\txid = get_xid();\n\trc = get_dfs_path(xid, ses, full_path + 1, cifs_sb->local_nls,\n\t\t&num_referrals, &referrals,\n\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tmnt = ERR_PTR(-ENOENT);\n\tfor (i = 0; i < num_referrals; i++) {\n\t\tint len;\n\t\tdump_referral(referrals + i);\n\t\t/* connect to a node */\n\t\tlen = strlen(referrals[i].node_name);\n\t\tif (len < 2) {\n\t\t\tcifs_dbg(VFS, \"%s: Net Address path too short: %s\\n\",\n\t\t\t\t __func__, referrals[i].node_name);\n\t\t\tmnt = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tmnt = cifs_dfs_do_refmount(cifs_sb,\n\t\t\t\tfull_path, referrals + i);\n\t\tcifs_dbg(FYI, \"%s: cifs_dfs_do_refmount:%s , mnt:%p\\n\",\n\t\t\t __func__, referrals[i].node_name, mnt);\n\t\tif (!IS_ERR(mnt))\n\t\t\tgoto success;\n\t}\n\n\t/* no valid submounts were found; return error from get_dfs_path() by\n\t * preference */\n\tif (rc != 0)\n\t\tmnt = ERR_PTR(rc);\n\nsuccess:\n\tfree_dfs_info_array(referrals, num_referrals);\nfree_full_path:\n\tkfree(full_path);\ncdda_exit:\n\tcifs_dbg(FYI, \"leaving %s\\n\" , __func__);\n\treturn mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic LIST_HEAD(cifs_dfs_automount_list);\nstatic int cifs_dfs_mountpoint_expiry_timeout = 500 * HZ;\n\nstruct vfsmount *cifs_dfs_d_automount(struct path *path)\n{\n\tstruct vfsmount *newmnt;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\n\tnewmnt = cifs_dfs_do_automount(path->dentry);\n\tif (IS_ERR(newmnt)) {\n\t\tcifs_dbg(FYI, \"leaving %s [automount failed]\\n\" , __func__);\n\t\treturn newmnt;\n\t}\n\n\tmntget(newmnt); /* prevent immediate expiration */\n\tmnt_set_expiry(newmnt, &cifs_dfs_automount_list);\n\tschedule_delayed_work(&cifs_dfs_automount_task,\n\t\t\t      cifs_dfs_mountpoint_expiry_timeout);\n\tcifs_dbg(FYI, \"leaving %s [ok]\\n\" , __func__);\n\treturn newmnt;\n}"
  },
  {
    "function_name": "cifs_dfs_do_automount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "277-352",
    "snippet": "static struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)\n{\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_ses *ses;\n\tchar *full_path;\n\tunsigned int xid;\n\tint i;\n\tint rc;\n\tstruct vfsmount *mnt;\n\tstruct tcon_link *tlink;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\tBUG_ON(IS_ROOT(mntpt));\n\n\t/*\n\t * The MSDFS spec states that paths in DFS referral requests and\n\t * responses must be prefixed by a single '\\' character instead of\n\t * the double backslashes usually used in the UNC. This function\n\t * gives us the latter, so we must adjust the result.\n\t */\n\tmnt = ERR_PTR(-ENOMEM);\n\tfull_path = build_path_from_dentry(mntpt);\n\tif (full_path == NULL)\n\t\tgoto cdda_exit;\n\n\tcifs_sb = CIFS_SB(mntpt->d_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tmnt = ERR_CAST(tlink);\n\t\tgoto free_full_path;\n\t}\n\tses = tlink_tcon(tlink)->ses;\n\n\txid = get_xid();\n\trc = get_dfs_path(xid, ses, full_path + 1, cifs_sb->local_nls,\n\t\t&num_referrals, &referrals,\n\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tmnt = ERR_PTR(-ENOENT);\n\tfor (i = 0; i < num_referrals; i++) {\n\t\tint len;\n\t\tdump_referral(referrals + i);\n\t\t/* connect to a node */\n\t\tlen = strlen(referrals[i].node_name);\n\t\tif (len < 2) {\n\t\t\tcifs_dbg(VFS, \"%s: Net Address path too short: %s\\n\",\n\t\t\t\t __func__, referrals[i].node_name);\n\t\t\tmnt = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tmnt = cifs_dfs_do_refmount(cifs_sb,\n\t\t\t\tfull_path, referrals + i);\n\t\tcifs_dbg(FYI, \"%s: cifs_dfs_do_refmount:%s , mnt:%p\\n\",\n\t\t\t __func__, referrals[i].node_name, mnt);\n\t\tif (!IS_ERR(mnt))\n\t\t\tgoto success;\n\t}\n\n\t/* no valid submounts were found; return error from get_dfs_path() by\n\t * preference */\n\tif (rc != 0)\n\t\tmnt = ERR_PTR(rc);\n\nsuccess:\n\tfree_dfs_info_array(referrals, num_referrals);\nfree_full_path:\n\tkfree(full_path);\ncdda_exit:\n\tcifs_dbg(FYI, \"leaving %s\\n\" , __func__);\n\treturn mnt;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"leaving %s\\n\"",
            "__func__"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "full_path"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_dfs_info_array",
          "args": [
            "referrals",
            "num_referrals"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "free_dfs_info_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1387-1398",
          "snippet": "static inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void free_dfs_info_array(struct dfs_info3_param *param,\n\t\t\t\t       int number_of_items)\n{\n\tint i;\n\tif ((number_of_items == 0) || (param == NULL))\n\t\treturn;\n\tfor (i = 0; i < number_of_items; i++) {\n\t\tkfree(param[i].path_name);\n\t\tkfree(param[i].node_name);\n\t}\n\tkfree(param);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: cifs_dfs_do_refmount:%s , mnt:%p\\n\"",
            "__func__",
            "referrals[i].node_name",
            "mnt"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dfs_do_refmount",
          "args": [
            "cifs_sb",
            "full_path",
            "referrals + i"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_dfs_do_refmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "243-262",
          "snippet": "static struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,\n\t\tconst char *fullpath, const struct dfs_info3_param *ref)\n{\n\tstruct vfsmount *mnt;\n\tchar *mountdata;\n\tchar *devname = NULL;\n\n\t/* strip first '\\' from fullpath */\n\tmountdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\tfullpath + 1, ref, &devname);\n\n\tif (IS_ERR(mountdata))\n\t\treturn (struct vfsmount *)mountdata;\n\n\tmnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);\n\tkfree(mountdata);\n\tkfree(devname);\n\treturn mnt;\n\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,\n\t\tconst char *fullpath, const struct dfs_info3_param *ref)\n{\n\tstruct vfsmount *mnt;\n\tchar *mountdata;\n\tchar *devname = NULL;\n\n\t/* strip first '\\' from fullpath */\n\tmountdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\tfullpath + 1, ref, &devname);\n\n\tif (IS_ERR(mountdata))\n\t\treturn (struct vfsmount *)mountdata;\n\n\tmnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);\n\tkfree(mountdata);\n\tkfree(devname);\n\treturn mnt;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "VFS",
            "\"%s: Net Address path too short: %s\\n\"",
            "__func__",
            "referrals[i].node_name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "referrals[i].node_name"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_referral",
          "args": [
            "referrals + i"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "dump_referral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "264-272",
          "snippet": "static void dump_referral(const struct dfs_info3_param *ref)\n{\n\tcifs_dbg(FYI, \"DFS: ref path: %s\\n\", ref->path_name);\n\tcifs_dbg(FYI, \"DFS: node path: %s\\n\", ref->node_name);\n\tcifs_dbg(FYI, \"DFS: fl: %hd, srv_type: %hd\\n\",\n\t\t ref->flags, ref->server_type);\n\tcifs_dbg(FYI, \"DFS: ref_flags: %hd, path_consumed: %hd\\n\",\n\t\t ref->ref_flag, ref->path_consumed);\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic void dump_referral(const struct dfs_info3_param *ref)\n{\n\tcifs_dbg(FYI, \"DFS: ref path: %s\\n\", ref->path_name);\n\tcifs_dbg(FYI, \"DFS: node path: %s\\n\", ref->node_name);\n\tcifs_dbg(FYI, \"DFS: fl: %hd, srv_type: %hd\\n\",\n\t\t ref->flags, ref->server_type);\n\tcifs_dbg(FYI, \"DFS: ref_flags: %hd, path_consumed: %hd\\n\",\n\t\t ref->ref_flag, ref->path_consumed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_put_tlink",
          "args": [
            "tlink"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_put_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2666-2682",
          "snippet": "void\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nvoid\ncifs_put_tlink(struct tcon_link *tlink)\n{\n\tif (!tlink || IS_ERR(tlink))\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&tlink->tl_count) ||\n\t    test_bit(TCON_LINK_IN_TREE, &tlink->tl_flags)) {\n\t\ttlink->tl_time = jiffies;\n\t\treturn;\n\t}\n\n\tif (!IS_ERR(tlink_tcon(tlink)))\n\t\tcifs_put_tcon(tlink_tcon(tlink));\n\tkfree(tlink);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_xid",
          "args": [
            "xid"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "_free_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "63-71",
          "snippet": "void\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nvoid\n_free_xid(unsigned int xid)\n{\n\tspin_lock(&GlobalMid_Lock);\n\t/* if (GlobalTotalActiveXid == 0)\n\t\tBUG(); */\n\tGlobalTotalActiveXid--;\n\tspin_unlock(&GlobalMid_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dfs_path",
          "args": [
            "xid",
            "ses",
            "full_path + 1",
            "cifs_sb->local_nls",
            "&num_referrals",
            "&referrals",
            "cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_dfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "2768-2807",
          "snippet": "int\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ip_connect(struct TCP_Server_Info *server);",
            "static int generic_ip_connect(struct TCP_Server_Info *server);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\nstatic int ip_connect(struct TCP_Server_Info *server);\nstatic int generic_ip_connect(struct TCP_Server_Info *server);\n\nint\nget_dfs_path(const unsigned int xid, struct cifs_ses *ses, const char *old_path,\n\t     const struct nls_table *nls_codepage, unsigned int *num_referrals,\n\t     struct dfs_info3_param **referrals, int remap)\n{\n\tchar *temp_unc;\n\tint rc = 0;\n\n\tif (!ses->server->ops->tree_connect || !ses->server->ops->get_dfs_refer)\n\t\treturn -ENOSYS;\n\n\t*num_referrals = 0;\n\t*referrals = NULL;\n\n\tif (ses->ipc_tid == 0) {\n\t\ttemp_unc = kmalloc(2 /* for slashes */ +\n\t\t\tstrnlen(ses->serverName, SERVER_NAME_LEN_WITH_NULL * 2)\n\t\t\t\t+ 1 + 4 /* slash IPC$ */ + 2, GFP_KERNEL);\n\t\tif (temp_unc == NULL)\n\t\t\treturn -ENOMEM;\n\t\ttemp_unc[0] = '\\\\';\n\t\ttemp_unc[1] = '\\\\';\n\t\tstrcpy(temp_unc + 2, ses->serverName);\n\t\tstrcpy(temp_unc + 2 + strlen(ses->serverName), \"\\\\IPC$\");\n\t\trc = ses->server->ops->tree_connect(xid, ses, temp_unc, NULL,\n\t\t\t\t\t\t    nls_codepage);\n\t\tcifs_dbg(FYI, \"Tcon rc = %d ipc_tid = %d\\n\", rc, ses->ipc_tid);\n\t\tkfree(temp_unc);\n\t}\n\tif (rc == 0)\n\t\trc = ses->server->ops->get_dfs_refer(xid, ses, old_path,\n\t\t\t\t\t\t     referrals, num_referrals,\n\t\t\t\t\t\t     nls_codepage, remap);\n\t/*\n\t * BB - map targetUNCs to dfs_info3 structures, here or in\n\t * ses->server->ops->get_dfs_refer.\n\t */\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_xid",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "_get_xid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/misc.c",
          "lines": "45-61",
          "snippet": "unsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}",
          "includes": [
            "#include \"smb2pdu.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"nterr.h\"",
            "#include \"smberr.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/mempool.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smb2pdu.h\"\n#include \"cifs_unicode.h\"\n#include \"nterr.h\"\n#include \"smberr.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/mempool.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n\nunsigned int\n_get_xid(void)\n{\n\tunsigned int xid;\n\n\tspin_lock(&GlobalMid_Lock);\n\tGlobalTotalActiveXid++;\n\n\t/* keep high water mark for number of simultaneous ops in filesystem */\n\tif (GlobalTotalActiveXid > GlobalMaxActiveXid)\n\t\tGlobalMaxActiveXid = GlobalTotalActiveXid;\n\tif (GlobalTotalActiveXid > 65000)\n\t\tcifs_dbg(FYI, \"warning: more than 65000 requests active\\n\");\n\txid = GlobalCurrentXid++;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn xid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tlink_tcon",
          "args": [
            "tlink"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "tlink_tcon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "931-935",
          "snippet": "static inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_tcon *\ntlink_tcon(struct tcon_link *tlink)\n{\n\treturn tlink->tl_tcon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tlink"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tlink"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_sb_tlink",
          "args": [
            "cifs_sb"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_sb_tlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/connect.c",
          "lines": "4011-4082",
          "snippet": "struct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}",
          "includes": [
            "#include \"fscache.h\"",
            "#include \"rfc1002pdu.h\"",
            "#include \"nterr.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <linux/parser.h>",
            "#include <net/ipv6.h>",
            "#include <keys/user-type.h>",
            "#include <linux/module.h>",
            "#include <linux/inet.h>",
            "#include <asm/processor.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/freezer.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/delay.h>",
            "#include <linux/mempool.h>",
            "#include <linux/utsname.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/net.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define TLINK_ERROR_EXPIRE\t(1 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fscache.h\"\n#include \"rfc1002pdu.h\"\n#include \"nterr.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <linux/parser.h>\n#include <net/ipv6.h>\n#include <keys/user-type.h>\n#include <linux/module.h>\n#include <linux/inet.h>\n#include <asm/processor.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/freezer.h>\n#include <linux/pagevec.h>\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/mempool.h>\n#include <linux/utsname.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/fs.h>\n\n#define TLINK_ERROR_EXPIRE\t(1 * HZ)\n\nstruct tcon_link *\ncifs_sb_tlink(struct cifs_sb_info *cifs_sb)\n{\n\tint ret;\n\tkuid_t fsuid = current_fsuid();\n\tstruct tcon_link *tlink, *newtlink;\n\n\tif (!(cifs_sb->mnt_cifs_flags & CIFS_MOUNT_MULTIUSER))\n\t\treturn cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n\n\tspin_lock(&cifs_sb->tlink_tree_lock);\n\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\tif (tlink)\n\t\tcifs_get_tlink(tlink);\n\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\n\tif (tlink == NULL) {\n\t\tnewtlink = kzalloc(sizeof(*tlink), GFP_KERNEL);\n\t\tif (newtlink == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tnewtlink->tl_uid = fsuid;\n\t\tnewtlink->tl_tcon = ERR_PTR(-EACCES);\n\t\tset_bit(TCON_LINK_PENDING, &newtlink->tl_flags);\n\t\tset_bit(TCON_LINK_IN_TREE, &newtlink->tl_flags);\n\t\tcifs_get_tlink(newtlink);\n\n\t\tspin_lock(&cifs_sb->tlink_tree_lock);\n\t\t/* was one inserted after previous search? */\n\t\ttlink = tlink_rb_search(&cifs_sb->tlink_tree, fsuid);\n\t\tif (tlink) {\n\t\t\tcifs_get_tlink(tlink);\n\t\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t\t\tkfree(newtlink);\n\t\t\tgoto wait_for_construction;\n\t\t}\n\t\ttlink = newtlink;\n\t\ttlink_rb_insert(&cifs_sb->tlink_tree, tlink);\n\t\tspin_unlock(&cifs_sb->tlink_tree_lock);\n\t} else {\nwait_for_construction:\n\t\tret = wait_on_bit(&tlink->tl_flags, TCON_LINK_PENDING,\n\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (ret) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-ERESTARTSYS);\n\t\t}\n\n\t\t/* if it's good, return it */\n\t\tif (!IS_ERR(tlink->tl_tcon))\n\t\t\treturn tlink;\n\n\t\t/* return error if we tried this already recently */\n\t\tif (time_before(jiffies, tlink->tl_time + TLINK_ERROR_EXPIRE)) {\n\t\t\tcifs_put_tlink(tlink);\n\t\t\treturn ERR_PTR(-EACCES);\n\t\t}\n\n\t\tif (test_and_set_bit(TCON_LINK_PENDING, &tlink->tl_flags))\n\t\t\tgoto wait_for_construction;\n\t}\n\n\ttlink->tl_tcon = cifs_construct_tcon(cifs_sb, fsuid);\n\tclear_bit(TCON_LINK_PENDING, &tlink->tl_flags);\n\twake_up_bit(&tlink->tl_flags, TCON_LINK_PENDING);\n\n\tif (IS_ERR(tlink->tl_tcon)) {\n\t\tcifs_put_tlink(tlink);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn tlink;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CIFS_SB",
          "args": [
            "mntpt->d_inode->i_sb"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "CIFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1165-1169",
          "snippet": "static inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline struct cifs_sb_info *\nCIFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "build_path_from_dentry",
          "args": [
            "mntpt"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "build_path_from_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dir.c",
          "lines": "81-167",
          "snippet": "char *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifsfs.h\"",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifs_fs_sb.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include \"cifsfs.h\"\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nchar *\nbuild_path_from_dentry(struct dentry *direntry)\n{\n\tstruct dentry *temp;\n\tint namelen;\n\tint dfsplen;\n\tchar *full_path;\n\tchar dirsep;\n\tstruct cifs_sb_info *cifs_sb = CIFS_SB(direntry->d_sb);\n\tstruct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);\n\tunsigned seq;\n\n\tdirsep = CIFS_DIR_SEP(cifs_sb);\n\tif (tcon->Flags & SMB_SHARE_IS_IN_DFS)\n\t\tdfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);\n\telse\n\t\tdfsplen = 0;\ncifs_bp_rename_retry:\n\tnamelen = dfsplen;\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tnamelen += (1 + temp->d_name.len);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tfull_path = kmalloc(namelen+1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn full_path;\n\tfull_path[namelen] = 0;\t/* trailing null */\n\trcu_read_lock();\n\tfor (temp = direntry; !IS_ROOT(temp);) {\n\t\tspin_lock(&temp->d_lock);\n\t\tnamelen -= 1 + temp->d_name.len;\n\t\tif (namelen < 0) {\n\t\t\tspin_unlock(&temp->d_lock);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tfull_path[namelen] = dirsep;\n\t\t\tstrncpy(full_path + namelen + 1, temp->d_name.name,\n\t\t\t\ttemp->d_name.len);\n\t\t\tcifs_dbg(FYI, \"name: %s\\n\", full_path + namelen);\n\t\t}\n\t\tspin_unlock(&temp->d_lock);\n\t\ttemp = temp->d_parent;\n\t\tif (temp == NULL) {\n\t\t\tcifs_dbg(VFS, \"corrupt dentry\\n\");\n\t\t\trcu_read_unlock();\n\t\t\tkfree(full_path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (namelen != dfsplen || read_seqretry(&rename_lock, seq)) {\n\t\tcifs_dbg(FYI, \"did not end path lookup where expected. namelen=%ddfsplen=%d\\n\",\n\t\t\t namelen, dfsplen);\n\t\t/* presumably this is only possible if racing with a rename\n\t\tof one of the parent directories  (we can not lock the dentries\n\t\tabove us to prevent this, but retrying should be harmless) */\n\t\tkfree(full_path);\n\t\tgoto cifs_bp_rename_retry;\n\t}\n\t/* DIR_SEP already set for byte  0 / vs \\ but not for\n\t   subsequent slashes in prepath which currently must\n\t   be entered the right way - not sure if there is an alternative\n\t   since the '\\' is a valid posix character so we can not switch\n\t   those safely to '/' if any are found in the middle of the prepath */\n\t/* BB test paths to Windows with '/' in the midst of prepath */\n\n\tif (dfsplen) {\n\t\tstrncpy(full_path, tcon->treeName, dfsplen);\n\t\tif (cifs_sb->mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < dfsplen; i++) {\n\t\t\t\tif (full_path[i] == '\\\\')\n\t\t\t\t\tfull_path[i] = '/';\n\t\t\t}\n\t\t}\n\t}\n\treturn full_path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "IS_ROOT(mntpt)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "mntpt"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"in %s\\n\"",
            "__func__"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)\n{\n\tstruct dfs_info3_param *referrals = NULL;\n\tunsigned int num_referrals = 0;\n\tstruct cifs_sb_info *cifs_sb;\n\tstruct cifs_ses *ses;\n\tchar *full_path;\n\tunsigned int xid;\n\tint i;\n\tint rc;\n\tstruct vfsmount *mnt;\n\tstruct tcon_link *tlink;\n\n\tcifs_dbg(FYI, \"in %s\\n\", __func__);\n\tBUG_ON(IS_ROOT(mntpt));\n\n\t/*\n\t * The MSDFS spec states that paths in DFS referral requests and\n\t * responses must be prefixed by a single '\\' character instead of\n\t * the double backslashes usually used in the UNC. This function\n\t * gives us the latter, so we must adjust the result.\n\t */\n\tmnt = ERR_PTR(-ENOMEM);\n\tfull_path = build_path_from_dentry(mntpt);\n\tif (full_path == NULL)\n\t\tgoto cdda_exit;\n\n\tcifs_sb = CIFS_SB(mntpt->d_inode->i_sb);\n\ttlink = cifs_sb_tlink(cifs_sb);\n\tif (IS_ERR(tlink)) {\n\t\tmnt = ERR_CAST(tlink);\n\t\tgoto free_full_path;\n\t}\n\tses = tlink_tcon(tlink)->ses;\n\n\txid = get_xid();\n\trc = get_dfs_path(xid, ses, full_path + 1, cifs_sb->local_nls,\n\t\t&num_referrals, &referrals,\n\t\tcifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\n\tfree_xid(xid);\n\n\tcifs_put_tlink(tlink);\n\n\tmnt = ERR_PTR(-ENOENT);\n\tfor (i = 0; i < num_referrals; i++) {\n\t\tint len;\n\t\tdump_referral(referrals + i);\n\t\t/* connect to a node */\n\t\tlen = strlen(referrals[i].node_name);\n\t\tif (len < 2) {\n\t\t\tcifs_dbg(VFS, \"%s: Net Address path too short: %s\\n\",\n\t\t\t\t __func__, referrals[i].node_name);\n\t\t\tmnt = ERR_PTR(-EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tmnt = cifs_dfs_do_refmount(cifs_sb,\n\t\t\t\tfull_path, referrals + i);\n\t\tcifs_dbg(FYI, \"%s: cifs_dfs_do_refmount:%s , mnt:%p\\n\",\n\t\t\t __func__, referrals[i].node_name, mnt);\n\t\tif (!IS_ERR(mnt))\n\t\t\tgoto success;\n\t}\n\n\t/* no valid submounts were found; return error from get_dfs_path() by\n\t * preference */\n\tif (rc != 0)\n\t\tmnt = ERR_PTR(rc);\n\nsuccess:\n\tfree_dfs_info_array(referrals, num_referrals);\nfree_full_path:\n\tkfree(full_path);\ncdda_exit:\n\tcifs_dbg(FYI, \"leaving %s\\n\" , __func__);\n\treturn mnt;\n}"
  },
  {
    "function_name": "dump_referral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "264-272",
    "snippet": "static void dump_referral(const struct dfs_info3_param *ref)\n{\n\tcifs_dbg(FYI, \"DFS: ref path: %s\\n\", ref->path_name);\n\tcifs_dbg(FYI, \"DFS: node path: %s\\n\", ref->node_name);\n\tcifs_dbg(FYI, \"DFS: fl: %hd, srv_type: %hd\\n\",\n\t\t ref->flags, ref->server_type);\n\tcifs_dbg(FYI, \"DFS: ref_flags: %hd, path_consumed: %hd\\n\",\n\t\t ref->ref_flag, ref->path_consumed);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"DFS: ref_flags: %hd, path_consumed: %hd\\n\"",
            "ref->ref_flag",
            "ref->path_consumed"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"DFS: fl: %hd, srv_type: %hd\\n\"",
            "ref->flags",
            "ref->server_type"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"DFS: node path: %s\\n\"",
            "ref->node_name"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"DFS: ref path: %s\\n\"",
            "ref->path_name"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic void dump_referral(const struct dfs_info3_param *ref)\n{\n\tcifs_dbg(FYI, \"DFS: ref path: %s\\n\", ref->path_name);\n\tcifs_dbg(FYI, \"DFS: node path: %s\\n\", ref->node_name);\n\tcifs_dbg(FYI, \"DFS: fl: %hd, srv_type: %hd\\n\",\n\t\t ref->flags, ref->server_type);\n\tcifs_dbg(FYI, \"DFS: ref_flags: %hd, path_consumed: %hd\\n\",\n\t\t ref->ref_flag, ref->path_consumed);\n}"
  },
  {
    "function_name": "cifs_dfs_do_refmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "243-262",
    "snippet": "static struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,\n\t\tconst char *fullpath, const struct dfs_info3_param *ref)\n{\n\tstruct vfsmount *mnt;\n\tchar *mountdata;\n\tchar *devname = NULL;\n\n\t/* strip first '\\' from fullpath */\n\tmountdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\tfullpath + 1, ref, &devname);\n\n\tif (IS_ERR(mountdata))\n\t\treturn (struct vfsmount *)mountdata;\n\n\tmnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);\n\tkfree(mountdata);\n\tkfree(devname);\n\treturn mnt;\n\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devname"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mountdata"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "&cifs_fs_type",
            "0",
            "devname",
            "mountdata"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mountdata"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_compose_mount_options",
          "args": [
            "cifs_sb->mountdata",
            "fullpath + 1",
            "ref",
            "&devname"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_compose_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "136-235",
          "snippet": "char *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nchar *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,\n\t\tconst char *fullpath, const struct dfs_info3_param *ref)\n{\n\tstruct vfsmount *mnt;\n\tchar *mountdata;\n\tchar *devname = NULL;\n\n\t/* strip first '\\' from fullpath */\n\tmountdata = cifs_compose_mount_options(cifs_sb->mountdata,\n\t\t\tfullpath + 1, ref, &devname);\n\n\tif (IS_ERR(mountdata))\n\t\treturn (struct vfsmount *)mountdata;\n\n\tmnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);\n\tkfree(mountdata);\n\tkfree(devname);\n\treturn mnt;\n\n}"
  },
  {
    "function_name": "cifs_compose_mount_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "136-235",
    "snippet": "char *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*devname"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mountdata"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "srvIP"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "mountdata",
            "srvIP"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "mountdata",
            "\"ip=\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "mountdata",
            "&sep",
            "1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mountdata"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "mountdata",
            "sb_mountdata + off"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "mountdata",
            "sb_mountdata + off",
            "noff"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "sb_mountdata + off",
            "\"prefixpath=\"",
            "11"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "sb_mountdata + off",
            "\"ip=\"",
            "3"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "sb_mountdata + off",
            "\"unc=\"",
            "4"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "sb_mountdata + off",
            "sep"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "mountdata",
            "sb_mountdata",
            "5"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "sb_mountdata",
            "\"sep=\"",
            "4"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "md_len + 1",
            "GFP_KERNEL"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_dbg",
          "args": [
            "FYI",
            "\"%s: Failed to resolve server part of %s to IP: %d\\n\"",
            "__func__",
            "*devname",
            "rc"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dns_resolve_server_name_to_ip",
          "args": [
            "*devname",
            "&srvIP"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "dns_resolve_server_name_to_ip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/dns_resolve.c",
          "lines": "45-99",
          "snippet": "int\ndns_resolve_server_name_to_ip(const char *unc, char **ip_addr)\n{\n\tstruct sockaddr_storage ss;\n\tconst char *hostname, *sep;\n\tchar *name;\n\tint len, rc;\n\n\tif (!ip_addr || !unc)\n\t\treturn -EINVAL;\n\n\tlen = strlen(unc);\n\tif (len < 3) {\n\t\tcifs_dbg(FYI, \"%s: unc is too short: %s\\n\", __func__, unc);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Discount leading slashes for cifs */\n\tlen -= 2;\n\thostname = unc + 2;\n\n\t/* Search for server name delimiter */\n\tsep = memchr(hostname, '/', len);\n\tif (sep)\n\t\tlen = sep - hostname;\n\telse\n\t\tcifs_dbg(FYI, \"%s: probably server name is whole unc: %s\\n\",\n\t\t\t __func__, unc);\n\n\t/* Try to interpret hostname as an IPv4 or IPv6 address */\n\trc = cifs_convert_address((struct sockaddr *)&ss, hostname, len);\n\tif (rc > 0)\n\t\tgoto name_is_IP_address;\n\n\t/* Perform the upcall */\n\trc = dns_query(NULL, hostname, len, NULL, ip_addr, NULL);\n\tif (rc < 0)\n\t\tcifs_dbg(FYI, \"%s: unable to resolve: %*.*s\\n\",\n\t\t\t __func__, len, len, hostname);\n\telse\n\t\tcifs_dbg(FYI, \"%s: resolved: %*.*s to %s\\n\",\n\t\t\t __func__, len, len, hostname, *ip_addr);\n\treturn rc;\n\nname_is_IP_address:\n\tname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tmemcpy(name, hostname, len);\n\tname[len] = 0;\n\tcifs_dbg(FYI, \"%s: unc is IP, skipping dns upcall: %s\\n\",\n\t\t __func__, name);\n\t*ip_addr = name;\n\treturn 0;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"dns_resolve.h\"",
            "#include <linux/dns_resolver.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"dns_resolve.h\"\n#include <linux/dns_resolver.h>\n#include <linux/slab.h>\n\nint\ndns_resolve_server_name_to_ip(const char *unc, char **ip_addr)\n{\n\tstruct sockaddr_storage ss;\n\tconst char *hostname, *sep;\n\tchar *name;\n\tint len, rc;\n\n\tif (!ip_addr || !unc)\n\t\treturn -EINVAL;\n\n\tlen = strlen(unc);\n\tif (len < 3) {\n\t\tcifs_dbg(FYI, \"%s: unc is too short: %s\\n\", __func__, unc);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Discount leading slashes for cifs */\n\tlen -= 2;\n\thostname = unc + 2;\n\n\t/* Search for server name delimiter */\n\tsep = memchr(hostname, '/', len);\n\tif (sep)\n\t\tlen = sep - hostname;\n\telse\n\t\tcifs_dbg(FYI, \"%s: probably server name is whole unc: %s\\n\",\n\t\t\t __func__, unc);\n\n\t/* Try to interpret hostname as an IPv4 or IPv6 address */\n\trc = cifs_convert_address((struct sockaddr *)&ss, hostname, len);\n\tif (rc > 0)\n\t\tgoto name_is_IP_address;\n\n\t/* Perform the upcall */\n\trc = dns_query(NULL, hostname, len, NULL, ip_addr, NULL);\n\tif (rc < 0)\n\t\tcifs_dbg(FYI, \"%s: unable to resolve: %*.*s\\n\",\n\t\t\t __func__, len, len, hostname);\n\telse\n\t\tcifs_dbg(FYI, \"%s: resolved: %*.*s to %s\\n\",\n\t\t\t __func__, len, len, hostname, *ip_addr);\n\treturn rc;\n\nname_is_IP_address:\n\tname = kmalloc(len + 1, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tmemcpy(name, hostname, len);\n\tname[len] = 0;\n\tcifs_dbg(FYI, \"%s: unc is IP, skipping dns upcall: %s\\n\",\n\t\t __func__, name);\n\t*ip_addr = name;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*devname"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*devname"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cifs_build_devname",
          "args": [
            "ref->node_name",
            "prepath"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_build_devname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
          "lines": "63-120",
          "snippet": "static char *\ncifs_build_devname(char *nodename, const char *prepath)\n{\n\tsize_t pplen;\n\tsize_t unclen;\n\tchar *dev;\n\tchar *pos;\n\n\t/* skip over any preceding delimiters */\n\tnodename += strspn(nodename, \"\\\\\");\n\tif (!*nodename)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* get length of UNC and set pos to last char */\n\tunclen = strlen(nodename);\n\tpos = nodename + unclen - 1;\n\n\t/* trim off any trailing delimiters */\n\twhile (*pos == '\\\\') {\n\t\t--pos;\n\t\t--unclen;\n\t}\n\n\t/* allocate a buffer:\n\t * +2 for preceding \"//\"\n\t * +1 for delimiter between UNC and prepath\n\t * +1 for trailing NULL\n\t */\n\tpplen = prepath ? strlen(prepath) : 0;\n\tdev = kmalloc(2 + unclen + 1 + pplen + 1, GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpos = dev;\n\t/* add the initial \"//\" */\n\t*pos = '/';\n\t++pos;\n\t*pos = '/';\n\t++pos;\n\n\t/* copy in the UNC portion from referral */\n\tmemcpy(pos, nodename, unclen);\n\tpos += unclen;\n\n\t/* copy the prefixpath remainder (if there is one) */\n\tif (pplen) {\n\t\t*pos = '/';\n\t\t++pos;\n\t\tmemcpy(pos, prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t/* NULL terminator */\n\t*pos = '\\0';\n\n\tconvert_delimiter(dev, '/');\n\treturn dev;\n}",
          "includes": [
            "#include \"cifs_debug.h\"",
            "#include \"dns_resolve.h\"",
            "#include \"cifsfs.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/vfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *\ncifs_build_devname(char *nodename, const char *prepath)\n{\n\tsize_t pplen;\n\tsize_t unclen;\n\tchar *dev;\n\tchar *pos;\n\n\t/* skip over any preceding delimiters */\n\tnodename += strspn(nodename, \"\\\\\");\n\tif (!*nodename)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* get length of UNC and set pos to last char */\n\tunclen = strlen(nodename);\n\tpos = nodename + unclen - 1;\n\n\t/* trim off any trailing delimiters */\n\twhile (*pos == '\\\\') {\n\t\t--pos;\n\t\t--unclen;\n\t}\n\n\t/* allocate a buffer:\n\t * +2 for preceding \"//\"\n\t * +1 for delimiter between UNC and prepath\n\t * +1 for trailing NULL\n\t */\n\tpplen = prepath ? strlen(prepath) : 0;\n\tdev = kmalloc(2 + unclen + 1 + pplen + 1, GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpos = dev;\n\t/* add the initial \"//\" */\n\t*pos = '/';\n\t++pos;\n\t*pos = '/';\n\t++pos;\n\n\t/* copy in the UNC portion from referral */\n\tmemcpy(pos, nodename, unclen);\n\tpos += unclen;\n\n\t/* copy the prefixpath remainder (if there is one) */\n\tif (pplen) {\n\t\t*pos = '/';\n\t\t++pos;\n\t\tmemcpy(pos, prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t/* NULL terminator */\n\t*pos = '\\0';\n\n\tconvert_delimiter(dev, '/');\n\treturn dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nchar *cifs_compose_mount_options(const char *sb_mountdata,\n\t\t\t\t   const char *fullpath,\n\t\t\t\t   const struct dfs_info3_param *ref,\n\t\t\t\t   char **devname)\n{\n\tint rc;\n\tchar *mountdata = NULL;\n\tconst char *prepath = NULL;\n\tint md_len;\n\tchar *tkn_e;\n\tchar *srvIP = NULL;\n\tchar sep = ',';\n\tint off, noff;\n\n\tif (sb_mountdata == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(fullpath) - ref->path_consumed)\n\t\tprepath = fullpath + ref->path_consumed;\n\n\t*devname = cifs_build_devname(ref->node_name, prepath);\n\tif (IS_ERR(*devname)) {\n\t\trc = PTR_ERR(*devname);\n\t\t*devname = NULL;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\trc = dns_resolve_server_name_to_ip(*devname, &srvIP);\n\tif (rc < 0) {\n\t\tcifs_dbg(FYI, \"%s: Failed to resolve server part of %s to IP: %d\\n\",\n\t\t\t __func__, *devname, rc);\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/*\n\t * In most cases, we'll be building a shorter string than the original,\n\t * but we do have to assume that the address in the ip= option may be\n\t * much longer than the original. Add the max length of an address\n\t * string to the length of the original string to allow for worst case.\n\t */\n\tmd_len = strlen(sb_mountdata) + INET6_ADDRSTRLEN;\n\tmountdata = kzalloc(md_len + 1, GFP_KERNEL);\n\tif (mountdata == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto compose_mount_options_err;\n\t}\n\n\t/* copy all options except of unc,ip,prefixpath */\n\toff = 0;\n\tif (strncmp(sb_mountdata, \"sep=\", 4) == 0) {\n\t\t\tsep = sb_mountdata[4];\n\t\t\tstrncpy(mountdata, sb_mountdata, 5);\n\t\t\toff += 5;\n\t}\n\n\tdo {\n\t\ttkn_e = strchr(sb_mountdata + off, sep);\n\t\tif (tkn_e == NULL)\n\t\t\tnoff = strlen(sb_mountdata + off);\n\t\telse\n\t\t\tnoff = tkn_e - (sb_mountdata + off) + 1;\n\n\t\tif (strncasecmp(sb_mountdata + off, \"unc=\", 4) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"ip=\", 3) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncasecmp(sb_mountdata + off, \"prefixpath=\", 11) == 0) {\n\t\t\toff += noff;\n\t\t\tcontinue;\n\t\t}\n\t\tstrncat(mountdata, sb_mountdata + off, noff);\n\t\toff += noff;\n\t} while (tkn_e);\n\tstrcat(mountdata, sb_mountdata + off);\n\tmountdata[md_len] = '\\0';\n\n\t/* copy new IP and ref share name */\n\tif (mountdata[strlen(mountdata) - 1] != sep)\n\t\tstrncat(mountdata, &sep, 1);\n\tstrcat(mountdata, \"ip=\");\n\tstrcat(mountdata, srvIP);\n\n\t/*cifs_dbg(FYI, \"%s: parent mountdata: %s\\n\", __func__, sb_mountdata);*/\n\t/*cifs_dbg(FYI, \"%s: submount mountdata: %s\\n\", __func__, mountdata );*/\n\ncompose_mount_options_out:\n\tkfree(srvIP);\n\treturn mountdata;\n\ncompose_mount_options_err:\n\tkfree(mountdata);\n\tmountdata = ERR_PTR(rc);\n\tkfree(*devname);\n\t*devname = NULL;\n\tgoto compose_mount_options_out;\n}"
  },
  {
    "function_name": "cifs_build_devname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "63-120",
    "snippet": "static char *\ncifs_build_devname(char *nodename, const char *prepath)\n{\n\tsize_t pplen;\n\tsize_t unclen;\n\tchar *dev;\n\tchar *pos;\n\n\t/* skip over any preceding delimiters */\n\tnodename += strspn(nodename, \"\\\\\");\n\tif (!*nodename)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* get length of UNC and set pos to last char */\n\tunclen = strlen(nodename);\n\tpos = nodename + unclen - 1;\n\n\t/* trim off any trailing delimiters */\n\twhile (*pos == '\\\\') {\n\t\t--pos;\n\t\t--unclen;\n\t}\n\n\t/* allocate a buffer:\n\t * +2 for preceding \"//\"\n\t * +1 for delimiter between UNC and prepath\n\t * +1 for trailing NULL\n\t */\n\tpplen = prepath ? strlen(prepath) : 0;\n\tdev = kmalloc(2 + unclen + 1 + pplen + 1, GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpos = dev;\n\t/* add the initial \"//\" */\n\t*pos = '/';\n\t++pos;\n\t*pos = '/';\n\t++pos;\n\n\t/* copy in the UNC portion from referral */\n\tmemcpy(pos, nodename, unclen);\n\tpos += unclen;\n\n\t/* copy the prefixpath remainder (if there is one) */\n\tif (pplen) {\n\t\t*pos = '/';\n\t\t++pos;\n\t\tmemcpy(pos, prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t/* NULL terminator */\n\t*pos = '\\0';\n\n\tconvert_delimiter(dev, '/');\n\treturn dev;\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "convert_delimiter",
          "args": [
            "dev",
            "'/'"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "convert_delimiter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifsglob.h",
          "lines": "1185-1198",
          "snippet": "static inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2pdu.h\"",
            "#include <uapi/linux/cifs/cifs_mount.h>",
            "#include <linux/scatterlist.h>",
            "#include <crypto/internal/hash.h>",
            "#include \"cifsacl.h\"",
            "#include \"cifs_fs_sb.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/mempool.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2pdu.h\"\n#include <uapi/linux/cifs/cifs_mount.h>\n#include <linux/scatterlist.h>\n#include <crypto/internal/hash.h>\n#include \"cifsacl.h\"\n#include \"cifs_fs_sb.h\"\n#include <linux/workqueue.h>\n#include <linux/mempool.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n\nstatic inline void\nconvert_delimiter(char *path, char delim)\n{\n\tchar old_delim, *pos;\n\n\tif (delim == '/')\n\t\told_delim = '\\\\';\n\telse\n\t\told_delim = '/';\n\n\tpos = path;\n\twhile ((pos = strchr(pos, old_delim)))\n\t\t*pos = delim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "prepath",
            "pplen"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pos",
            "nodename",
            "unclen"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2 + unclen + 1 + pplen + 1",
            "GFP_KERNEL"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prepath"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "nodename",
            "\"\\\\\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic char *\ncifs_build_devname(char *nodename, const char *prepath)\n{\n\tsize_t pplen;\n\tsize_t unclen;\n\tchar *dev;\n\tchar *pos;\n\n\t/* skip over any preceding delimiters */\n\tnodename += strspn(nodename, \"\\\\\");\n\tif (!*nodename)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* get length of UNC and set pos to last char */\n\tunclen = strlen(nodename);\n\tpos = nodename + unclen - 1;\n\n\t/* trim off any trailing delimiters */\n\twhile (*pos == '\\\\') {\n\t\t--pos;\n\t\t--unclen;\n\t}\n\n\t/* allocate a buffer:\n\t * +2 for preceding \"//\"\n\t * +1 for delimiter between UNC and prepath\n\t * +1 for trailing NULL\n\t */\n\tpplen = prepath ? strlen(prepath) : 0;\n\tdev = kmalloc(2 + unclen + 1 + pplen + 1, GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpos = dev;\n\t/* add the initial \"//\" */\n\t*pos = '/';\n\t++pos;\n\t*pos = '/';\n\t++pos;\n\n\t/* copy in the UNC portion from referral */\n\tmemcpy(pos, nodename, unclen);\n\tpos += unclen;\n\n\t/* copy the prefixpath remainder (if there is one) */\n\tif (pplen) {\n\t\t*pos = '/';\n\t\t++pos;\n\t\tmemcpy(pos, prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t/* NULL terminator */\n\t*pos = '\\0';\n\n\tconvert_delimiter(dev, '/');\n\treturn dev;\n}"
  },
  {
    "function_name": "cifs_dfs_release_automount_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "45-49",
    "snippet": "void cifs_dfs_release_automount_timer(void)\n{\n\tBUG_ON(!list_empty(&cifs_dfs_automount_list));\n\tcancel_delayed_work_sync(&cifs_dfs_automount_task);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(cifs_dfs_automount_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&cifs_dfs_automount_task"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&cifs_dfs_automount_list)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cifs_dfs_automount_list"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic LIST_HEAD(cifs_dfs_automount_list);\n\nvoid cifs_dfs_release_automount_timer(void)\n{\n\tBUG_ON(!list_empty(&cifs_dfs_automount_list));\n\tcancel_delayed_work_sync(&cifs_dfs_automount_task);\n}"
  },
  {
    "function_name": "cifs_dfs_expire_automounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_dfs_ref.c",
    "lines": "35-43",
    "snippet": "static void cifs_dfs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &cifs_dfs_automount_list;\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list))\n\t\tschedule_delayed_work(&cifs_dfs_automount_task,\n\t\t\t\t      cifs_dfs_mountpoint_expiry_timeout);\n}",
    "includes": [
      "#include \"cifs_debug.h\"",
      "#include \"dns_resolve.h\"",
      "#include \"cifsfs.h\"",
      "#include \"cifsproto.h\"",
      "#include \"cifsglob.h\"",
      "#include <linux/inet.h>",
      "#include <linux/fs.h>",
      "#include <linux/vfs.h>",
      "#include <linux/slab.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/dcache.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(cifs_dfs_automount_list);",
      "static void cifs_dfs_expire_automounts(struct work_struct *work);",
      "static DECLARE_DELAYED_WORK(cifs_dfs_automount_task,\n\t\t\t    cifs_dfs_expire_automounts);",
      "static int cifs_dfs_mountpoint_expiry_timeout = 500 * HZ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&cifs_dfs_automount_task",
            "cifs_dfs_mountpoint_expiry_timeout"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mounts_for_expiry",
          "args": [
            "list"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mounts_for_expiry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2406-2436",
          "snippet": "void mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mark_mounts_for_expiry(struct list_head *mounts)\n{\n\tstruct mount *mnt, *next;\n\tLIST_HEAD(graveyard);\n\n\tif (list_empty(mounts))\n\t\treturn;\n\n\tnamespace_lock();\n\tlock_mount_hash();\n\n\t/* extract from the expiration list every vfsmount that matches the\n\t * following criteria:\n\t * - only referenced by its parent vfsmount\n\t * - still marked for expiry (marked on the last call here; marks are\n\t *   cleared by mntput())\n\t */\n\tlist_for_each_entry_safe(mnt, next, mounts, mnt_expire) {\n\t\tif (!xchg(&mnt->mnt_expiry_mark, 1) ||\n\t\t\tpropagate_mount_busy(mnt, 1))\n\t\t\tcontinue;\n\t\tlist_move(&mnt->mnt_expire, &graveyard);\n\t}\n\twhile (!list_empty(&graveyard)) {\n\t\tmnt = list_first_entry(&graveyard, struct mount, mnt_expire);\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tumount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tnamespace_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cifs_debug.h\"\n#include \"dns_resolve.h\"\n#include \"cifsfs.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/vfs.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/dcache.h>\n\nstatic LIST_HEAD(cifs_dfs_automount_list);\nstatic void cifs_dfs_expire_automounts(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(cifs_dfs_automount_task,\n\t\t\t    cifs_dfs_expire_automounts);\nstatic int cifs_dfs_mountpoint_expiry_timeout = 500 * HZ;\n\nstatic void cifs_dfs_expire_automounts(struct work_struct *work)\n{\n\tstruct list_head *list = &cifs_dfs_automount_list;\n\n\tmark_mounts_for_expiry(list);\n\tif (!list_empty(list))\n\t\tschedule_delayed_work(&cifs_dfs_automount_task,\n\t\t\t\t      cifs_dfs_mountpoint_expiry_timeout);\n}"
  }
]