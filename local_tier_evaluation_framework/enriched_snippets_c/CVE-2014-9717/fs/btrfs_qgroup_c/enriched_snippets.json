[
  {
    "function_name": "btrfs_qgroup_rescan_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2820-2826",
    "snippet": "void\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->qgroup_rescan_workers",
            "&fs_info->qgroup_rescan_work"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\n{\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t &fs_info->qgroup_rescan_work);\n}"
  },
  {
    "function_name": "btrfs_qgroup_wait_for_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2798-2814",
    "snippet": "int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_completion_interruptible",
          "args": [
            "&fs_info->qgroup_rescan_completion"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\n{\n\tint running;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\trunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (running)\n\t\tret = wait_for_completion_interruptible(\n\t\t\t\t\t&fs_info->qgroup_rescan_completion);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_qgroup_rescan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2758-2796",
    "snippet": "int\nbtrfs_qgroup_rescan(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\tstruct btrfs_trans_handle *trans;\n\n\tret = qgroup_rescan_init(fs_info, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * We have set the rescan_progress to 0, which means no more\n\t * delayed refs will be accounted by btrfs_qgroup_account_ref.\n\t * However, btrfs_qgroup_account_ref may be right after its call\n\t * to btrfs_find_all_roots, in which case it would still do the\n\t * accounting.\n\t * To solve this, we're committing the transaction, which will\n\t * ensure we run all delayed refs and only after that, we are\n\t * going to clear all tracking information for a clean start.\n\t */\n\n\ttrans = btrfs_join_transaction(fs_info->fs_root);\n\tif (IS_ERR(trans)) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, fs_info->fs_root);\n\tif (ret) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t\treturn ret;\n\t}\n\n\tqgroup_rescan_zero_tracking(fs_info);\n\n\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t &fs_info->qgroup_rescan_work);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->qgroup_rescan_workers",
            "&fs_info->qgroup_rescan_work"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_zero_tracking",
          "args": [
            "fs_info"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_zero_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2740-2756",
          "snippet": "static void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "fs_info->fs_root"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "fs_info->fs_root"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_init",
          "args": [
            "fs_info",
            "0",
            "1"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2685-2738",
          "snippet": "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);",
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint\nbtrfs_qgroup_rescan(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\tstruct btrfs_trans_handle *trans;\n\n\tret = qgroup_rescan_init(fs_info, 0, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * We have set the rescan_progress to 0, which means no more\n\t * delayed refs will be accounted by btrfs_qgroup_account_ref.\n\t * However, btrfs_qgroup_account_ref may be right after its call\n\t * to btrfs_find_all_roots, in which case it would still do the\n\t * accounting.\n\t * To solve this, we're committing the transaction, which will\n\t * ensure we run all delayed refs and only after that, we are\n\t * going to clear all tracking information for a clean start.\n\t */\n\n\ttrans = btrfs_join_transaction(fs_info->fs_root);\n\tif (IS_ERR(trans)) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t\treturn PTR_ERR(trans);\n\t}\n\tret = btrfs_commit_transaction(trans, fs_info->fs_root);\n\tif (ret) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t\treturn ret;\n\t}\n\n\tqgroup_rescan_zero_tracking(fs_info);\n\n\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t &fs_info->qgroup_rescan_work);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_rescan_zero_tracking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2740-2756",
    "snippet": "static void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup",
            "node"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&fs_info->qgroup_tree"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
  },
  {
    "function_name": "qgroup_rescan_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2685-2738",
    "snippet": "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);",
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"qgroup_rescan_init failed with %d\"",
            "ret"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&fs_info->qgroup_rescan_work",
            "btrfs_qgroup_rescan_helper",
            "btrfs_qgroup_rescan_worker",
            "NULL",
            "NULL"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fs_info->qgroup_rescan_work",
            "0",
            "sizeof(fs_info->qgroup_rescan_work)"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&fs_info->qgroup_rescan_completion"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fs_info->qgroup_rescan_progress",
            "0",
            "sizeof(fs_info->qgroup_rescan_progress)"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_qgroup_rescan_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2612-2679",
    "snippet": "static void btrfs_qgroup_rescan_worker(struct btrfs_work *work)\n{\n\tstruct btrfs_fs_info *fs_info = container_of(work, struct btrfs_fs_info,\n\t\t\t\t\t\t     qgroup_rescan_work);\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *tmp = NULL, *qgroups = NULL;\n\tstruct extent_buffer *scratch_leaf = NULL;\n\tint err = -ENOMEM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\tgoto out;\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\tgoto out;\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\tgoto out;\n\tscratch_leaf = kmalloc(sizeof(*scratch_leaf), GFP_NOFS);\n\tif (!scratch_leaf)\n\t\tgoto out;\n\n\terr = 0;\n\twhile (!err) {\n\t\ttrans = btrfs_start_transaction(fs_info->fs_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fs_info->quota_enabled) {\n\t\t\terr = -EINTR;\n\t\t} else {\n\t\t\terr = qgroup_rescan_leaf(fs_info, path, trans,\n\t\t\t\t\t\t qgroups, tmp, scratch_leaf);\n\t\t}\n\t\tif (err > 0)\n\t\t\tbtrfs_commit_transaction(trans, fs_info->fs_root);\n\t\telse\n\t\t\tbtrfs_end_transaction(trans, fs_info->fs_root);\n\t}\n\nout:\n\tkfree(scratch_leaf);\n\tulist_free(qgroups);\n\tulist_free(tmp);\n\tbtrfs_free_path(path);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\n\tif (err == 2 &&\n\t    fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t} else if (err < 0) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (err >= 0) {\n\t\tbtrfs_info(fs_info, \"qgroup scan completed%s\",\n\t\t\terr == 2 ? \" (inconsistency flag cleared)\" : \"\");\n\t} else {\n\t\tbtrfs_err(fs_info, \"qgroup scan failed with %d\", err);\n\t}\n\n\tcomplete_all(&fs_info->qgroup_rescan_completion);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete_all",
          "args": [
            "&fs_info->qgroup_rescan_completion"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"qgroup scan failed with %d\"",
            "err"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"qgroup scan completed%s\"",
            "err == 2 ? \" (inconsistency flag cleared)\" : \"\""
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "tmp"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scratch_leaf"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "fs_info->fs_root"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "fs_info->fs_root"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_leaf",
          "args": [
            "fs_info",
            "path",
            "trans",
            "qgroups",
            "tmp",
            "scratch_leaf"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2518-2610",
          "snippet": "static int\nqgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t   struct btrfs_trans_handle *trans, struct ulist *qgroups,\n\t\t   struct ulist *tmp, struct extent_buffer *scratch_leaf)\n{\n\tstruct btrfs_key found;\n\tstruct ulist *roots = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tu64 num_bytes;\n\tu64 seq;\n\tint new_roots;\n\tint slot;\n\tint ret;\n\n\tpath->leave_spinning = 1;\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tret = btrfs_search_slot_for_read(fs_info->extent_root,\n\t\t\t\t\t &fs_info->qgroup_rescan_progress,\n\t\t\t\t\t path, 1, 0);\n\n\tpr_debug(\"current progress key (%llu %u %llu), search_slot ret %d\\n\",\n\t\t fs_info->qgroup_rescan_progress.objectid,\n\t\t fs_info->qgroup_rescan_progress.type,\n\t\t fs_info->qgroup_rescan_progress.offset, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * The rescan is about to end, we will not be scanning any\n\t\t * further blocks. We cannot unset the RESCAN flag here, because\n\t\t * we want to commit the transaction if everything went well.\n\t\t * To make the live accounting work in this phase, we set our\n\t\t * scan progress pointer such that every real extent objectid\n\t\t * will be smaller.\n\t\t */\n\t\tfs_info->qgroup_rescan_progress.objectid = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\treturn ret;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found,\n\t\t\t      btrfs_header_nritems(path->nodes[0]) - 1);\n\tfs_info->qgroup_rescan_progress.objectid = found.objectid + 1;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\tmemcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));\n\tslot = path->slots[0];\n\tbtrfs_release_path(path);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tfor (; slot < btrfs_header_nritems(scratch_leaf); ++slot) {\n\t\tbtrfs_item_key_to_cpu(scratch_leaf, &found, slot);\n\t\tif (found.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    found.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\tcontinue;\n\t\tif (found.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\tnum_bytes = fs_info->extent_root->nodesize;\n\t\telse\n\t\t\tnum_bytes = found.offset;\n\n\t\tulist_reinit(qgroups);\n\t\tret = btrfs_find_all_roots(NULL, fs_info, found.objectid, 0,\n\t\t\t\t\t   &roots);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t\tseq = fs_info->qgroup_seq;\n\t\tfs_info->qgroup_seq += roots->nnodes + 1; /* max refcnt */\n\n\t\tnew_roots = 0;\n\t\tret = qgroup_calc_old_refcnt(fs_info, 0, tmp, roots, qgroups,\n\t\t\t\t\t     seq, &new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qgroup_adjust_counters(fs_info, 0, num_bytes, qgroups,\n\t\t\t\t\t     seq, 0, new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tulist_free(roots);\n\t}\nout:\n\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t   struct btrfs_trans_handle *trans, struct ulist *qgroups,\n\t\t   struct ulist *tmp, struct extent_buffer *scratch_leaf)\n{\n\tstruct btrfs_key found;\n\tstruct ulist *roots = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tu64 num_bytes;\n\tu64 seq;\n\tint new_roots;\n\tint slot;\n\tint ret;\n\n\tpath->leave_spinning = 1;\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tret = btrfs_search_slot_for_read(fs_info->extent_root,\n\t\t\t\t\t &fs_info->qgroup_rescan_progress,\n\t\t\t\t\t path, 1, 0);\n\n\tpr_debug(\"current progress key (%llu %u %llu), search_slot ret %d\\n\",\n\t\t fs_info->qgroup_rescan_progress.objectid,\n\t\t fs_info->qgroup_rescan_progress.type,\n\t\t fs_info->qgroup_rescan_progress.offset, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * The rescan is about to end, we will not be scanning any\n\t\t * further blocks. We cannot unset the RESCAN flag here, because\n\t\t * we want to commit the transaction if everything went well.\n\t\t * To make the live accounting work in this phase, we set our\n\t\t * scan progress pointer such that every real extent objectid\n\t\t * will be smaller.\n\t\t */\n\t\tfs_info->qgroup_rescan_progress.objectid = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\treturn ret;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found,\n\t\t\t      btrfs_header_nritems(path->nodes[0]) - 1);\n\tfs_info->qgroup_rescan_progress.objectid = found.objectid + 1;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\tmemcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));\n\tslot = path->slots[0];\n\tbtrfs_release_path(path);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tfor (; slot < btrfs_header_nritems(scratch_leaf); ++slot) {\n\t\tbtrfs_item_key_to_cpu(scratch_leaf, &found, slot);\n\t\tif (found.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    found.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\tcontinue;\n\t\tif (found.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\tnum_bytes = fs_info->extent_root->nodesize;\n\t\telse\n\t\t\tnum_bytes = found.offset;\n\n\t\tulist_reinit(qgroups);\n\t\tret = btrfs_find_all_roots(NULL, fs_info, found.objectid, 0,\n\t\t\t\t\t   &roots);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t\tseq = fs_info->qgroup_seq;\n\t\tfs_info->qgroup_seq += roots->nnodes + 1; /* max refcnt */\n\n\t\tnew_roots = 0;\n\t\tret = qgroup_calc_old_refcnt(fs_info, 0, tmp, roots, qgroups,\n\t\t\t\t\t     seq, &new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qgroup_adjust_counters(fs_info, 0, num_bytes, qgroups,\n\t\t\t\t\t     seq, 0, new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tulist_free(roots);\n\t}\nout:\n\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "fs_info->fs_root",
            "0"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*scratch_leaf)",
            "GFP_NOFS"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 2628
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbtrfs_fs_info",
            "qgroup_rescan_work"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void btrfs_qgroup_rescan_worker(struct btrfs_work *work)\n{\n\tstruct btrfs_fs_info *fs_info = container_of(work, struct btrfs_fs_info,\n\t\t\t\t\t\t     qgroup_rescan_work);\n\tstruct btrfs_path *path;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *tmp = NULL, *qgroups = NULL;\n\tstruct extent_buffer *scratch_leaf = NULL;\n\tint err = -ENOMEM;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\tgoto out;\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\tgoto out;\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\tgoto out;\n\tscratch_leaf = kmalloc(sizeof(*scratch_leaf), GFP_NOFS);\n\tif (!scratch_leaf)\n\t\tgoto out;\n\n\terr = 0;\n\twhile (!err) {\n\t\ttrans = btrfs_start_transaction(fs_info->fs_root, 0);\n\t\tif (IS_ERR(trans)) {\n\t\t\terr = PTR_ERR(trans);\n\t\t\tbreak;\n\t\t}\n\t\tif (!fs_info->quota_enabled) {\n\t\t\terr = -EINTR;\n\t\t} else {\n\t\t\terr = qgroup_rescan_leaf(fs_info, path, trans,\n\t\t\t\t\t\t qgroups, tmp, scratch_leaf);\n\t\t}\n\t\tif (err > 0)\n\t\t\tbtrfs_commit_transaction(trans, fs_info->fs_root);\n\t\telse\n\t\t\tbtrfs_end_transaction(trans, fs_info->fs_root);\n\t}\n\nout:\n\tkfree(scratch_leaf);\n\tulist_free(qgroups);\n\tulist_free(tmp);\n\tbtrfs_free_path(path);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\n\tif (err == 2 &&\n\t    fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT) {\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t} else if (err < 0) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tif (err >= 0) {\n\t\tbtrfs_info(fs_info, \"qgroup scan completed%s\",\n\t\t\terr == 2 ? \" (inconsistency flag cleared)\" : \"\");\n\t} else {\n\t\tbtrfs_err(fs_info, \"qgroup scan failed with %d\", err);\n\t}\n\n\tcomplete_all(&fs_info->qgroup_rescan_completion);\n}"
  },
  {
    "function_name": "qgroup_rescan_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2518-2610",
    "snippet": "static int\nqgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t   struct btrfs_trans_handle *trans, struct ulist *qgroups,\n\t\t   struct ulist *tmp, struct extent_buffer *scratch_leaf)\n{\n\tstruct btrfs_key found;\n\tstruct ulist *roots = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tu64 num_bytes;\n\tu64 seq;\n\tint new_roots;\n\tint slot;\n\tint ret;\n\n\tpath->leave_spinning = 1;\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tret = btrfs_search_slot_for_read(fs_info->extent_root,\n\t\t\t\t\t &fs_info->qgroup_rescan_progress,\n\t\t\t\t\t path, 1, 0);\n\n\tpr_debug(\"current progress key (%llu %u %llu), search_slot ret %d\\n\",\n\t\t fs_info->qgroup_rescan_progress.objectid,\n\t\t fs_info->qgroup_rescan_progress.type,\n\t\t fs_info->qgroup_rescan_progress.offset, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * The rescan is about to end, we will not be scanning any\n\t\t * further blocks. We cannot unset the RESCAN flag here, because\n\t\t * we want to commit the transaction if everything went well.\n\t\t * To make the live accounting work in this phase, we set our\n\t\t * scan progress pointer such that every real extent objectid\n\t\t * will be smaller.\n\t\t */\n\t\tfs_info->qgroup_rescan_progress.objectid = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\treturn ret;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found,\n\t\t\t      btrfs_header_nritems(path->nodes[0]) - 1);\n\tfs_info->qgroup_rescan_progress.objectid = found.objectid + 1;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\tmemcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));\n\tslot = path->slots[0];\n\tbtrfs_release_path(path);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tfor (; slot < btrfs_header_nritems(scratch_leaf); ++slot) {\n\t\tbtrfs_item_key_to_cpu(scratch_leaf, &found, slot);\n\t\tif (found.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    found.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\tcontinue;\n\t\tif (found.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\tnum_bytes = fs_info->extent_root->nodesize;\n\t\telse\n\t\t\tnum_bytes = found.offset;\n\n\t\tulist_reinit(qgroups);\n\t\tret = btrfs_find_all_roots(NULL, fs_info, found.objectid, 0,\n\t\t\t\t\t   &roots);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t\tseq = fs_info->qgroup_seq;\n\t\tfs_info->qgroup_seq += roots->nnodes + 1; /* max refcnt */\n\n\t\tnew_roots = 0;\n\t\tret = qgroup_calc_old_refcnt(fs_info, 0, tmp, roots, qgroups,\n\t\t\t\t\t     seq, &new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qgroup_adjust_counters(fs_info, 0, num_bytes, qgroups,\n\t\t\t\t\t     seq, 0, new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tulist_free(roots);\n\t}\nout:\n\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "roots"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_adjust_counters",
          "args": [
            "fs_info",
            "0",
            "num_bytes",
            "qgroups",
            "seq",
            "0",
            "new_roots",
            "1"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_adjust_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1694-1766",
          "snippet": "static int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_calc_old_refcnt",
          "args": [
            "fs_info",
            "0",
            "tmp",
            "roots",
            "qgroups",
            "seq",
            "&new_roots",
            "1"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_calc_old_refcnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1458-1540",
          "snippet": "static int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_roots",
          "args": [
            "NULL",
            "fs_info",
            "found.objectid",
            "0",
            "&roots"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1187-1199",
          "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "qgroups"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "scratch_leaf",
            "&found",
            "slot"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "scratch_leaf"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "scratch_leaf",
            "path->nodes[0]",
            "sizeof(*scratch_leaf)"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"current progress key (%llu %u %llu), search_slot ret %d\\n\"",
            "fs_info->qgroup_rescan_progress.objectid",
            "fs_info->qgroup_rescan_progress.type",
            "fs_info->qgroup_rescan_progress.offset",
            "ret"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "fs_info->extent_root",
            "&fs_info->qgroup_rescan_progress",
            "path",
            "1",
            "0"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t   struct btrfs_trans_handle *trans, struct ulist *qgroups,\n\t\t   struct ulist *tmp, struct extent_buffer *scratch_leaf)\n{\n\tstruct btrfs_key found;\n\tstruct ulist *roots = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tu64 num_bytes;\n\tu64 seq;\n\tint new_roots;\n\tint slot;\n\tint ret;\n\n\tpath->leave_spinning = 1;\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tret = btrfs_search_slot_for_read(fs_info->extent_root,\n\t\t\t\t\t &fs_info->qgroup_rescan_progress,\n\t\t\t\t\t path, 1, 0);\n\n\tpr_debug(\"current progress key (%llu %u %llu), search_slot ret %d\\n\",\n\t\t fs_info->qgroup_rescan_progress.objectid,\n\t\t fs_info->qgroup_rescan_progress.type,\n\t\t fs_info->qgroup_rescan_progress.offset, ret);\n\n\tif (ret) {\n\t\t/*\n\t\t * The rescan is about to end, we will not be scanning any\n\t\t * further blocks. We cannot unset the RESCAN flag here, because\n\t\t * we want to commit the transaction if everything went well.\n\t\t * To make the live accounting work in this phase, we set our\n\t\t * scan progress pointer such that every real extent objectid\n\t\t * will be smaller.\n\t\t */\n\t\tfs_info->qgroup_rescan_progress.objectid = (u64)-1;\n\t\tbtrfs_release_path(path);\n\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\treturn ret;\n\t}\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &found,\n\t\t\t      btrfs_header_nritems(path->nodes[0]) - 1);\n\tfs_info->qgroup_rescan_progress.objectid = found.objectid + 1;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\tmemcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));\n\tslot = path->slots[0];\n\tbtrfs_release_path(path);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tfor (; slot < btrfs_header_nritems(scratch_leaf); ++slot) {\n\t\tbtrfs_item_key_to_cpu(scratch_leaf, &found, slot);\n\t\tif (found.type != BTRFS_EXTENT_ITEM_KEY &&\n\t\t    found.type != BTRFS_METADATA_ITEM_KEY)\n\t\t\tcontinue;\n\t\tif (found.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\tnum_bytes = fs_info->extent_root->nodesize;\n\t\telse\n\t\t\tnum_bytes = found.offset;\n\n\t\tulist_reinit(qgroups);\n\t\tret = btrfs_find_all_roots(NULL, fs_info, found.objectid, 0,\n\t\t\t\t\t   &roots);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t\tseq = fs_info->qgroup_seq;\n\t\tfs_info->qgroup_seq += roots->nnodes + 1; /* max refcnt */\n\n\t\tnew_roots = 0;\n\t\tret = qgroup_calc_old_refcnt(fs_info, 0, tmp, roots, qgroups,\n\t\t\t\t\t     seq, &new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qgroup_adjust_counters(fs_info, 0, num_bytes, qgroups,\n\t\t\t\t\t     seq, 0, new_roots, 1);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tulist_free(roots);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tulist_free(roots);\n\t}\nout:\n\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "assert_qgroups_uptodate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2501-2512",
    "snippet": "void assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "trans->root->fs_info",
            "\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\"",
            "trans",
            "list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\"",
            "(u32)(trans->delayed_ref_elem.seq >> 32)",
            "(u32)trans->delayed_ref_elem.seq"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "trans->delayed_ref_elem.seq >> 32"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->qgroup_ref_list"
          ],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\n{\n\tif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\n\t\treturn;\n\tbtrfs_err(trans->root->fs_info,\n\t\t\"qgroups not uptodate in trans handle %p:  list is%s empty, \"\n\t\t\"seq is %#x.%x\",\n\t\ttrans, list_empty(&trans->qgroup_ref_list) ? \"\" : \" not\",\n\t\t(u32)(trans->delayed_ref_elem.seq >> 32),\n\t\t(u32)trans->delayed_ref_elem.seq);\n\tBUG();\n}"
  },
  {
    "function_name": "btrfs_qgroup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2448-2499",
    "snippet": "void btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "fs_info->qgroup_ulist",
            "glist->group->qgroupid",
            "(uintptr_t)glist->group",
            "GFP_ATOMIC"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "fs_info->qgroup_ulist",
            "&uiter"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "fs_info->qgroup_ulist"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "ref_root"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\n\tif (!is_fstree(ref_root))\n\t\treturn;\n\n\tif (num_bytes == 0)\n\t\treturn;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved -= num_bytes;\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
  },
  {
    "function_name": "btrfs_qgroup_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2367-2446",
    "snippet": "int btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "fs_info->qgroup_ulist",
            "&uiter"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "fs_info->qgroup_ulist",
            "glist->group->qgroupid",
            "(uintptr_t)glist->group",
            "GFP_ATOMIC"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "fs_info->qgroup_ulist"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "ref_root"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tu64 ref_root = root->root_key.objectid;\n\tint ret = 0;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\n\tif (!is_fstree(ref_root))\n\t\treturn 0;\n\n\tif (num_bytes == 0)\n\t\treturn 0;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root)\n\t\tgoto out;\n\n\tqgroup = find_qgroup_rb(fs_info, ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\n\t/*\n\t * in a first step, we check all affected qgroups if any limits would\n\t * be exceeded\n\t */\n\tulist_reinit(fs_info->qgroup_ulist);\n\tret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\n\t\t\t(uintptr_t)qgroup, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\n\t\t    qg->reserved + (s64)qg->rfer + num_bytes >\n\t\t    qg->max_rfer) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\n\t\t    qg->reserved + (s64)qg->excl + num_bytes >\n\t\t    qg->max_excl) {\n\t\t\tret = -EDQUOT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(fs_info->qgroup_ulist,\n\t\t\t\t\tglist->group->qgroupid,\n\t\t\t\t\t(uintptr_t)glist->group, GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\t/*\n\t * no limits exceeded, now record the reservation into all qgroups\n\t */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\n\t\tstruct btrfs_qgroup *qg;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\n\t\tqg->reserved += num_bytes;\n\t}\n\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_qgroup_inherit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2190-2359",
    "snippet": "int btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "i_qgroups[1]"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_relation_rb",
          "args": [
            "quota_root->fs_info",
            "objectid",
            "*i_qgroups"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "add_relation_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "201-223",
          "snippet": "static int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_dirty",
          "args": [
            "fs_info",
            "srcgroup"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "997-1002",
          "snippet": "static void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dstgroup"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dstgroup"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_qgroup_rb",
          "args": [
            "fs_info",
            "objectid"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "130-162",
          "snippet": "static struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_relation_item",
          "args": [
            "trans",
            "quota_root",
            "*i_qgroups",
            "objectid"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_relation_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "477-499",
          "snippet": "static int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "srcroot"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "srcroot"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&srckey"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_qgroup_limit_item",
          "args": [
            "trans",
            "quota_root",
            "objectid",
            "inherit->lim.flags",
            "inherit->lim.max_rfer",
            "inherit->lim.max_excl",
            "inherit->lim.rsv_rfer",
            "inherit->lim.rsv_excl"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "update_qgroup_limit_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "646-687",
          "snippet": "static int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_item",
          "args": [
            "trans",
            "quota_root",
            "objectid"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "532-598",
          "snippet": "static int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\n\t\t\t struct btrfs_qgroup_inherit *inherit)\n{\n\tint ret = 0;\n\tint i;\n\tu64 *i_qgroups;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_qgroup *srcgroup;\n\tstruct btrfs_qgroup *dstgroup;\n\tu32 level_size = 0;\n\tu64 nums;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_enabled)\n\t\tgoto out;\n\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\n\t\t       2 * inherit->num_excl_copies;\n\t\tfor (i = 0; i < nums; ++i) {\n\t\t\tsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\n\t\t\tif (!srcgroup) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\t/*\n\t * create a tracking group for the subvol itself\n\t */\n\tret = add_qgroup_item(trans, quota_root, objectid);\n\tif (ret)\n\t\tgoto out;\n\n\tif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\n\t\tret = update_qgroup_limit_item(trans, quota_root, objectid,\n\t\t\t\t\t       inherit->lim.flags,\n\t\t\t\t\t       inherit->lim.max_rfer,\n\t\t\t\t\t       inherit->lim.max_excl,\n\t\t\t\t\t       inherit->lim.rsv_rfer,\n\t\t\t\t\t       inherit->lim.rsv_excl);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (srcid) {\n\t\tstruct btrfs_root *srcroot;\n\t\tstruct btrfs_key srckey;\n\n\t\tsrckey.objectid = srcid;\n\t\tsrckey.type = BTRFS_ROOT_ITEM_KEY;\n\t\tsrckey.offset = (u64)-1;\n\t\tsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\n\t\tif (IS_ERR(srcroot)) {\n\t\t\tret = PTR_ERR(srcroot);\n\t\t\tgoto out;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tlevel_size = srcroot->nodesize;\n\t\trcu_read_unlock();\n\t}\n\n\t/*\n\t * add qgroup to all inherited groups\n\t */\n\tif (inherit) {\n\t\ti_qgroups = (u64 *)(inherit + 1);\n\t\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       objectid, *i_qgroups);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tret = add_qgroup_relation_item(trans, quota_root,\n\t\t\t\t\t\t       *i_qgroups, objectid);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\t++i_qgroups;\n\t\t}\n\t}\n\n\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tdstgroup = add_qgroup_rb(fs_info, objectid);\n\tif (IS_ERR(dstgroup)) {\n\t\tret = PTR_ERR(dstgroup);\n\t\tgoto unlock;\n\t}\n\n\tif (srcid) {\n\t\tsrcgroup = find_qgroup_rb(fs_info, srcid);\n\t\tif (!srcgroup)\n\t\t\tgoto unlock;\n\n\t\t/*\n\t\t * We call inherit after we clone the root in order to make sure\n\t\t * our counts don't go crazy, so at this point the only\n\t\t * difference between the two roots should be the root node.\n\t\t */\n\t\tdstgroup->rfer = srcgroup->rfer;\n\t\tdstgroup->rfer_cmpr = srcgroup->rfer_cmpr;\n\t\tdstgroup->excl = level_size;\n\t\tdstgroup->excl_cmpr = level_size;\n\t\tsrcgroup->excl = level_size;\n\t\tsrcgroup->excl_cmpr = level_size;\n\t\tqgroup_dirty(fs_info, dstgroup);\n\t\tqgroup_dirty(fs_info, srcgroup);\n\t}\n\n\tif (!inherit)\n\t\tgoto unlock;\n\n\ti_qgroups = (u64 *)(inherit + 1);\n\tfor (i = 0; i < inherit->num_qgroups; ++i) {\n\t\tret = add_relation_rb(quota_root->fs_info, objectid,\n\t\t\t\t      *i_qgroups);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t\t++i_qgroups;\n\t}\n\n\tfor (i = 0; i <  inherit->num_ref_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->rfer = src->rfer - level_size;\n\t\tdst->rfer_cmpr = src->rfer_cmpr - level_size;\n\t\ti_qgroups += 2;\n\t}\n\tfor (i = 0; i <  inherit->num_excl_copies; ++i) {\n\t\tstruct btrfs_qgroup *src;\n\t\tstruct btrfs_qgroup *dst;\n\n\t\tsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\n\t\tdst = find_qgroup_rb(fs_info, i_qgroups[1]);\n\n\t\tif (!src || !dst) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tdst->excl = src->excl + level_size;\n\t\tdst->excl_cmpr = src->excl_cmpr + level_size;\n\t\ti_qgroups += 2;\n\t}\n\nunlock:\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_run_qgroups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2133-2184",
    "snippet": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tint ret = 0;\n\tint start_rescan_worker = 0;\n\n\tif (!quota_root)\n\t\tgoto out;\n\n\tif (!fs_info->quota_enabled && fs_info->pending_quota_state)\n\t\tstart_rescan_worker = 1;\n\n\tfs_info->quota_enabled = fs_info->pending_quota_state;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, quota_root, qgroup);\n\t\tif (ret)\n\t\t\tfs_info->qgroup_flags |=\n\t\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (fs_info->quota_enabled)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tret = update_qgroup_status_item(trans, fs_info, quota_root);\n\tif (ret)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\n\tif (!ret && start_rescan_worker) {\n\t\tret = qgroup_rescan_init(fs_info, 0, 1);\n\t\tif (!ret) {\n\t\t\tqgroup_rescan_zero_tracking(fs_info);\n\t\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t\t &fs_info->qgroup_rescan_work);\n\t\t}\n\t\tret = 0;\n\t}\n\nout:\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->qgroup_rescan_workers",
            "&fs_info->qgroup_rescan_work"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_zero_tracking",
          "args": [
            "fs_info"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_zero_tracking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2740-2756",
          "snippet": "static void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\t/* clear all current qgroup tracking information */\n\tfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tqgroup->rfer = 0;\n\t\tqgroup->rfer_cmpr = 0;\n\t\tqgroup->excl = 0;\n\t\tqgroup->excl_cmpr = 0;\n\t}\n\tspin_unlock(&fs_info->qgroup_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_init",
          "args": [
            "fs_info",
            "0",
            "1"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2685-2738",
          "snippet": "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);",
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_qgroup_status_item",
          "args": [
            "trans",
            "fs_info",
            "quota_root"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "update_qgroup_status_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "734-773",
          "snippet": "static int update_qgroup_status_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr(l, slot, struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_flags(l, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_generation(l, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_rescan(l, ptr,\n\t\t\t\tfs_info->qgroup_rescan_progress.objectid);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int update_qgroup_status_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr(l, slot, struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_flags(l, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_generation(l, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_rescan(l, ptr,\n\t\t\t\tfs_info->qgroup_rescan_progress.objectid);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_qgroup_info_item",
          "args": [
            "trans",
            "quota_root",
            "qgroup"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "update_qgroup_info_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "689-732",
          "snippet": "static int update_qgroup_info_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tint ret;\n\tint slot;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroup->qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_info = btrfs_item_ptr(l, slot, struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(l, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(l, qgroup_info, qgroup->rfer);\n\tbtrfs_set_qgroup_info_rfer_cmpr(l, qgroup_info, qgroup->rfer_cmpr);\n\tbtrfs_set_qgroup_info_excl(l, qgroup_info, qgroup->excl);\n\tbtrfs_set_qgroup_info_excl_cmpr(l, qgroup_info, qgroup->excl_cmpr);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_qgroup_info_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tint ret;\n\tint slot;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroup->qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_info = btrfs_item_ptr(l, slot, struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(l, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(l, qgroup_info, qgroup->rfer);\n\tbtrfs_set_qgroup_info_rfer_cmpr(l, qgroup_info, qgroup->rfer_cmpr);\n\tbtrfs_set_qgroup_info_excl(l, qgroup_info, qgroup->excl);\n\tbtrfs_set_qgroup_info_excl_cmpr(l, qgroup_info, qgroup->excl_cmpr);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&qgroup->dirty"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&fs_info->dirty_qgroups",
            "structbtrfs_qgroup",
            "dirty"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fs_info->dirty_qgroups"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_run_qgroups(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tint ret = 0;\n\tint start_rescan_worker = 0;\n\n\tif (!quota_root)\n\t\tgoto out;\n\n\tif (!fs_info->quota_enabled && fs_info->pending_quota_state)\n\t\tstart_rescan_worker = 1;\n\n\tfs_info->quota_enabled = fs_info->pending_quota_state;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, quota_root, qgroup);\n\t\tif (ret)\n\t\t\tfs_info->qgroup_flags |=\n\t\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (fs_info->quota_enabled)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tret = update_qgroup_status_item(trans, fs_info, quota_root);\n\tif (ret)\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\n\tif (!ret && start_rescan_worker) {\n\t\tret = qgroup_rescan_init(fs_info, 0, 1);\n\t\tif (!ret) {\n\t\t\tqgroup_rescan_zero_tracking(fs_info);\n\t\t\tbtrfs_queue_work(fs_info->qgroup_rescan_workers,\n\t\t\t\t\t &fs_info->qgroup_rescan_work);\n\t\t}\n\t\tret = 0;\n\t}\n\nout:\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_delayed_qgroup_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2109-2128",
    "snippet": "int btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oper"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&oper->elem"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&oper->n",
            "&fs_info->qgroup_op_tree"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_account",
          "args": [
            "trans",
            "fs_info",
            "oper"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_qgroup_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2063-2103",
          "snippet": "static int btrfs_qgroup_account(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup_operation *oper)\n{\n\tint ret = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tBUG_ON(!fs_info->quota_root);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tif (fs_info->qgroup_rescan_progress.objectid <= oper->bytenr) {\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tASSERT(is_fstree(oper->ref_root));\n\n\ttrace_btrfs_qgroup_account(oper);\n\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tret = qgroup_excl_accounting(fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_ADD_SHARED:\n\tcase BTRFS_QGROUP_OPER_SUB_SHARED:\n\t\tret = qgroup_shared_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_SUBTREE:\n\t\tret = qgroup_subtree_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_qgroup_account(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup_operation *oper)\n{\n\tint ret = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tBUG_ON(!fs_info->quota_root);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tif (fs_info->qgroup_rescan_progress.objectid <= oper->bytenr) {\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tASSERT(is_fstree(oper->ref_root));\n\n\ttrace_btrfs_qgroup_account(oper);\n\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tret = qgroup_excl_accounting(fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_ADD_SHARED:\n\tcase BTRFS_QGROUP_OPER_SUB_SHARED:\n\t\tret = qgroup_shared_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_SUBTREE:\n\t\tret = qgroup_subtree_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oper->list"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&trans->qgroup_ref_list",
            "structbtrfs_qgroup_operation",
            "list"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->qgroup_ref_list"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_delayed_qgroup_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret = 0;\n\n\twhile (!list_empty(&trans->qgroup_ref_list)) {\n\t\toper = list_first_entry(&trans->qgroup_ref_list,\n\t\t\t\t\tstruct btrfs_qgroup_operation, list);\n\t\tlist_del_init(&oper->list);\n\t\tif (!ret || !trans->aborted)\n\t\t\tret = btrfs_qgroup_account(trans, fs_info, oper);\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\trb_erase(&oper->n, &fs_info->qgroup_op_tree);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\t\tkfree(oper);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_qgroup_account",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "2063-2103",
    "snippet": "static int btrfs_qgroup_account(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup_operation *oper)\n{\n\tint ret = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tBUG_ON(!fs_info->quota_root);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tif (fs_info->qgroup_rescan_progress.objectid <= oper->bytenr) {\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tASSERT(is_fstree(oper->ref_root));\n\n\ttrace_btrfs_qgroup_account(oper);\n\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tret = qgroup_excl_accounting(fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_ADD_SHARED:\n\tcase BTRFS_QGROUP_OPER_SUB_SHARED:\n\t\tret = qgroup_shared_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_SUBTREE:\n\t\tret = qgroup_subtree_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgroup_subtree_accounting",
          "args": [
            "trans",
            "fs_info",
            "oper"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_subtree_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1957-2055",
          "snippet": "static int qgroup_subtree_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist *parents;\n\tint ret = 0;\n\tint err;\n\tstruct btrfs_qgroup *qg;\n\tu64 root_obj = 0;\n\tstruct seq_list elem = {};\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   elem.seq, &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (roots->nnodes != 1)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&uiter);\n\tunode = ulist_next(roots, &uiter); /* Only want 1 so no need to loop */\n\t/*\n\t * If we find our ref root then that means all refs\n\t * this extent has to the root have not yet been\n\t * deleted. In that case, we do nothing and let the\n\t * last ref for this bytenr drive our update.\n\t *\n\t * This can happen for example if an extent is\n\t * referenced multiple times in a snapshot (clone,\n\t * etc). If we are in the middle of snapshot removal,\n\t * queued updates for such an extent will find the\n\t * root if we have not yet finished removing the\n\t * snapshot.\n\t */\n\tif (unode->val == oper->ref_root)\n\t\tgoto out;\n\n\troot_obj = unode->val;\n\tBUG_ON(!root_obj);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqg = find_qgroup_rb(fs_info, root_obj);\n\tif (!qg)\n\t\tgoto out_unlock;\n\n\tqg->excl += oper->num_bytes;\n\tqg->excl_cmpr += oper->num_bytes;\n\tqgroup_dirty(fs_info, qg);\n\n\t/*\n\t * Adjust counts for parent groups. First we find all\n\t * parents, then in the 2nd loop we do the adjustment\n\t * while adding parents of the parents to our ulist.\n\t */\n\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tret = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(parents, &uiter))) {\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tqg->excl += oper->num_bytes;\n\t\tqg->excl_cmpr += oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qg);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tret = err;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock(&fs_info->qgroup_lock);\n\nout:\n\tulist_free(roots);\n\tulist_free(parents);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_subtree_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist *parents;\n\tint ret = 0;\n\tint err;\n\tstruct btrfs_qgroup *qg;\n\tu64 root_obj = 0;\n\tstruct seq_list elem = {};\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   elem.seq, &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (roots->nnodes != 1)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&uiter);\n\tunode = ulist_next(roots, &uiter); /* Only want 1 so no need to loop */\n\t/*\n\t * If we find our ref root then that means all refs\n\t * this extent has to the root have not yet been\n\t * deleted. In that case, we do nothing and let the\n\t * last ref for this bytenr drive our update.\n\t *\n\t * This can happen for example if an extent is\n\t * referenced multiple times in a snapshot (clone,\n\t * etc). If we are in the middle of snapshot removal,\n\t * queued updates for such an extent will find the\n\t * root if we have not yet finished removing the\n\t * snapshot.\n\t */\n\tif (unode->val == oper->ref_root)\n\t\tgoto out;\n\n\troot_obj = unode->val;\n\tBUG_ON(!root_obj);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqg = find_qgroup_rb(fs_info, root_obj);\n\tif (!qg)\n\t\tgoto out_unlock;\n\n\tqg->excl += oper->num_bytes;\n\tqg->excl_cmpr += oper->num_bytes;\n\tqgroup_dirty(fs_info, qg);\n\n\t/*\n\t * Adjust counts for parent groups. First we find all\n\t * parents, then in the 2nd loop we do the adjustment\n\t * while adding parents of the parents to our ulist.\n\t */\n\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tret = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(parents, &uiter))) {\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tqg->excl += oper->num_bytes;\n\t\tqg->excl_cmpr += oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qg);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tret = err;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock(&fs_info->qgroup_lock);\n\nout:\n\tulist_free(roots);\n\tulist_free(parents);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_shared_accounting",
          "args": [
            "trans",
            "fs_info",
            "oper"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_shared_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1841-1950",
          "snippet": "static int qgroup_shared_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist *qgroups, *tmp;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct seq_list elem = {};\n\tu64 seq;\n\tint old_roots = 0;\n\tint new_roots = 0;\n\tint ret = 0;\n\n\tif (oper->elem.seq) {\n\t\tret = check_existing_refs(trans, fs_info, oper);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\treturn -ENOMEM;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp) {\n\t\tulist_free(qgroups);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr, elem.seq,\n\t\t\t\t   &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0) {\n\t\tulist_free(qgroups);\n\t\tulist_free(tmp);\n\t\treturn ret;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tseq = fs_info->qgroup_seq;\n\n\t/*\n\t * So roots is the list of all the roots currently pointing at the\n\t * bytenr, including the ref we are adding if we are adding, or not if\n\t * we are removing a ref.  So we pass in the ref_root to skip that root\n\t * in our calculations.  We set old_refnct and new_refcnt cause who the\n\t * hell knows what everything looked like before, and it doesn't matter\n\t * except...\n\t */\n\tret = qgroup_calc_old_refcnt(fs_info, oper->ref_root, tmp, roots, qgroups,\n\t\t\t\t     seq, &old_roots, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now adjust the refcounts of the qgroups that care about this\n\t * reference, either the old_count in the case of removal or new_count\n\t * in the case of an addition.\n\t */\n\tret = qgroup_calc_new_refcnt(fs_info, oper, qgroup, tmp, qgroups,\n\t\t\t\t     seq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * ...in the case of removals.  If we had a removal before we got around\n\t * to processing this operation then we need to find that guy and count\n\t * his references as if they really existed so we don't end up screwing\n\t * up the exclusive counts.  Then whenever we go to process the delete\n\t * everything will be grand and we can account for whatever exclusive\n\t * changes need to be made there.  We also have to pass in old_roots so\n\t * we have an accurate count of the roots as it pertains to this\n\t * operations view of the world.\n\t */\n\tret = qgroup_account_deleted_refs(fs_info, oper, tmp, qgroups, seq,\n\t\t\t\t\t  &old_roots);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We are adding our root, need to adjust up the number of roots,\n\t * otherwise old_roots is the number of roots we want.\n\t */\n\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\tnew_roots = old_roots + 1;\n\t} else {\n\t\tnew_roots = old_roots;\n\t\told_roots++;\n\t}\n\tfs_info->qgroup_seq += old_roots + 1;\n\n\n\t/*\n\t * And now the magic happens, bless Arne for having a pretty elegant\n\t * solution for this.\n\t */\n\tqgroup_adjust_counters(fs_info, oper->ref_root, oper->num_bytes,\n\t\t\t       qgroups, seq, old_roots, new_roots, 0);\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(qgroups);\n\tulist_free(roots);\n\tulist_free(tmp);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_shared_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist *qgroups, *tmp;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct seq_list elem = {};\n\tu64 seq;\n\tint old_roots = 0;\n\tint new_roots = 0;\n\tint ret = 0;\n\n\tif (oper->elem.seq) {\n\t\tret = check_existing_refs(trans, fs_info, oper);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\treturn -ENOMEM;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp) {\n\t\tulist_free(qgroups);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr, elem.seq,\n\t\t\t\t   &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0) {\n\t\tulist_free(qgroups);\n\t\tulist_free(tmp);\n\t\treturn ret;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tseq = fs_info->qgroup_seq;\n\n\t/*\n\t * So roots is the list of all the roots currently pointing at the\n\t * bytenr, including the ref we are adding if we are adding, or not if\n\t * we are removing a ref.  So we pass in the ref_root to skip that root\n\t * in our calculations.  We set old_refnct and new_refcnt cause who the\n\t * hell knows what everything looked like before, and it doesn't matter\n\t * except...\n\t */\n\tret = qgroup_calc_old_refcnt(fs_info, oper->ref_root, tmp, roots, qgroups,\n\t\t\t\t     seq, &old_roots, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now adjust the refcounts of the qgroups that care about this\n\t * reference, either the old_count in the case of removal or new_count\n\t * in the case of an addition.\n\t */\n\tret = qgroup_calc_new_refcnt(fs_info, oper, qgroup, tmp, qgroups,\n\t\t\t\t     seq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * ...in the case of removals.  If we had a removal before we got around\n\t * to processing this operation then we need to find that guy and count\n\t * his references as if they really existed so we don't end up screwing\n\t * up the exclusive counts.  Then whenever we go to process the delete\n\t * everything will be grand and we can account for whatever exclusive\n\t * changes need to be made there.  We also have to pass in old_roots so\n\t * we have an accurate count of the roots as it pertains to this\n\t * operations view of the world.\n\t */\n\tret = qgroup_account_deleted_refs(fs_info, oper, tmp, qgroups, seq,\n\t\t\t\t\t  &old_roots);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We are adding our root, need to adjust up the number of roots,\n\t * otherwise old_roots is the number of roots we want.\n\t */\n\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\tnew_roots = old_roots + 1;\n\t} else {\n\t\tnew_roots = old_roots;\n\t\told_roots++;\n\t}\n\tfs_info->qgroup_seq += old_roots + 1;\n\n\n\t/*\n\t * And now the magic happens, bless Arne for having a pretty elegant\n\t * solution for this.\n\t */\n\tqgroup_adjust_counters(fs_info, oper->ref_root, oper->num_bytes,\n\t\t\t       qgroups, seq, old_roots, new_roots, 0);\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(qgroups);\n\tulist_free(roots);\n\tulist_free(tmp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_excl_accounting",
          "args": [
            "fs_info",
            "oper"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_excl_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1380-1452",
          "snippet": "static int qgroup_excl_accounting(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper)\n{\n\tstruct btrfs_qgroup *qgroup;\n\tstruct ulist *tmp;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint sign = 0;\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\t\tsign = 1;\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tsign = -1;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\tqgroup->rfer += sign * oper->num_bytes;\n\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\n\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\tqgroup->excl += sign * oper->num_bytes;\n\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\n\tqgroup_dirty(fs_info, qgroup);\n\n\t/* Get all of the parent groups that contain this qgroup */\n\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Iterate all of the parents and adjust their reference counts */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tqgroup = u64_to_ptr(unode->aux);\n\t\tqgroup->rfer += sign * oper->num_bytes;\n\t\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\t\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\t\tqgroup->excl += sign * oper->num_bytes;\n\t\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qgroup);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(tmp);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_excl_accounting(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper)\n{\n\tstruct btrfs_qgroup *qgroup;\n\tstruct ulist *tmp;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint sign = 0;\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\t\tsign = 1;\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tsign = -1;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\tqgroup->rfer += sign * oper->num_bytes;\n\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\n\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\tqgroup->excl += sign * oper->num_bytes;\n\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\n\tqgroup_dirty(fs_info, qgroup);\n\n\t/* Get all of the parent groups that contain this qgroup */\n\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Iterate all of the parents and adjust their reference counts */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tqgroup = u64_to_ptr(unode->aux);\n\t\tqgroup->rfer += sign * oper->num_bytes;\n\t\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\t\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\t\tqgroup->excl += sign * oper->num_bytes;\n\t\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qgroup);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(tmp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_qgroup_account",
          "args": [
            "oper"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "is_fstree(oper->ref_root)"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "oper->ref_root"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_rescan_lock"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!fs_info->quota_root"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_qgroup_account(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_qgroup_operation *oper)\n{\n\tint ret = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tBUG_ON(!fs_info->quota_root);\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\n\t\tif (fs_info->qgroup_rescan_progress.objectid <= oper->bytenr) {\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tASSERT(is_fstree(oper->ref_root));\n\n\ttrace_btrfs_qgroup_account(oper);\n\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tret = qgroup_excl_accounting(fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_ADD_SHARED:\n\tcase BTRFS_QGROUP_OPER_SUB_SHARED:\n\t\tret = qgroup_shared_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_SUBTREE:\n\t\tret = qgroup_subtree_accounting(trans, fs_info, oper);\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "qgroup_subtree_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1957-2055",
    "snippet": "static int qgroup_subtree_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist *parents;\n\tint ret = 0;\n\tint err;\n\tstruct btrfs_qgroup *qg;\n\tu64 root_obj = 0;\n\tstruct seq_list elem = {};\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   elem.seq, &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (roots->nnodes != 1)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&uiter);\n\tunode = ulist_next(roots, &uiter); /* Only want 1 so no need to loop */\n\t/*\n\t * If we find our ref root then that means all refs\n\t * this extent has to the root have not yet been\n\t * deleted. In that case, we do nothing and let the\n\t * last ref for this bytenr drive our update.\n\t *\n\t * This can happen for example if an extent is\n\t * referenced multiple times in a snapshot (clone,\n\t * etc). If we are in the middle of snapshot removal,\n\t * queued updates for such an extent will find the\n\t * root if we have not yet finished removing the\n\t * snapshot.\n\t */\n\tif (unode->val == oper->ref_root)\n\t\tgoto out;\n\n\troot_obj = unode->val;\n\tBUG_ON(!root_obj);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqg = find_qgroup_rb(fs_info, root_obj);\n\tif (!qg)\n\t\tgoto out_unlock;\n\n\tqg->excl += oper->num_bytes;\n\tqg->excl_cmpr += oper->num_bytes;\n\tqgroup_dirty(fs_info, qg);\n\n\t/*\n\t * Adjust counts for parent groups. First we find all\n\t * parents, then in the 2nd loop we do the adjustment\n\t * while adding parents of the parents to our ulist.\n\t */\n\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tret = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(parents, &uiter))) {\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tqg->excl += oper->num_bytes;\n\t\tqg->excl_cmpr += oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qg);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tret = err;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock(&fs_info->qgroup_lock);\n\nout:\n\tulist_free(roots);\n\tulist_free(parents);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "parents"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "parents",
            "glist->group->qgroupid",
            "ptr_to_u64(glist->group)",
            "GFP_ATOMIC"
          ],
          "line": 2039
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgroup_dirty",
          "args": [
            "fs_info",
            "qg"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "997-1002",
          "snippet": "static void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "parents",
            "&uiter"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "root_obj"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!root_obj"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_roots",
          "args": [
            "trans",
            "fs_info",
            "oper->bytenr",
            "elem.seq",
            "&roots"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1187-1199",
          "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_subtree_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist *parents;\n\tint ret = 0;\n\tint err;\n\tstruct btrfs_qgroup *qg;\n\tu64 root_obj = 0;\n\tstruct seq_list elem = {};\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   elem.seq, &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (roots->nnodes != 1)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&uiter);\n\tunode = ulist_next(roots, &uiter); /* Only want 1 so no need to loop */\n\t/*\n\t * If we find our ref root then that means all refs\n\t * this extent has to the root have not yet been\n\t * deleted. In that case, we do nothing and let the\n\t * last ref for this bytenr drive our update.\n\t *\n\t * This can happen for example if an extent is\n\t * referenced multiple times in a snapshot (clone,\n\t * etc). If we are in the middle of snapshot removal,\n\t * queued updates for such an extent will find the\n\t * root if we have not yet finished removing the\n\t * snapshot.\n\t */\n\tif (unode->val == oper->ref_root)\n\t\tgoto out;\n\n\troot_obj = unode->val;\n\tBUG_ON(!root_obj);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqg = find_qgroup_rb(fs_info, root_obj);\n\tif (!qg)\n\t\tgoto out_unlock;\n\n\tqg->excl += oper->num_bytes;\n\tqg->excl_cmpr += oper->num_bytes;\n\tqgroup_dirty(fs_info, qg);\n\n\t/*\n\t * Adjust counts for parent groups. First we find all\n\t * parents, then in the 2nd loop we do the adjustment\n\t * while adding parents of the parents to our ulist.\n\t */\n\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tret = err;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(parents, &uiter))) {\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tqg->excl += oper->num_bytes;\n\t\tqg->excl_cmpr += oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qg);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\terr = ulist_add(parents, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tret = err;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock(&fs_info->qgroup_lock);\n\nout:\n\tulist_free(roots);\n\tulist_free(parents);\n\treturn ret;\n}"
  },
  {
    "function_name": "qgroup_shared_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1841-1950",
    "snippet": "static int qgroup_shared_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist *qgroups, *tmp;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct seq_list elem = {};\n\tu64 seq;\n\tint old_roots = 0;\n\tint new_roots = 0;\n\tint ret = 0;\n\n\tif (oper->elem.seq) {\n\t\tret = check_existing_refs(trans, fs_info, oper);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\treturn -ENOMEM;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp) {\n\t\tulist_free(qgroups);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr, elem.seq,\n\t\t\t\t   &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0) {\n\t\tulist_free(qgroups);\n\t\tulist_free(tmp);\n\t\treturn ret;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tseq = fs_info->qgroup_seq;\n\n\t/*\n\t * So roots is the list of all the roots currently pointing at the\n\t * bytenr, including the ref we are adding if we are adding, or not if\n\t * we are removing a ref.  So we pass in the ref_root to skip that root\n\t * in our calculations.  We set old_refnct and new_refcnt cause who the\n\t * hell knows what everything looked like before, and it doesn't matter\n\t * except...\n\t */\n\tret = qgroup_calc_old_refcnt(fs_info, oper->ref_root, tmp, roots, qgroups,\n\t\t\t\t     seq, &old_roots, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now adjust the refcounts of the qgroups that care about this\n\t * reference, either the old_count in the case of removal or new_count\n\t * in the case of an addition.\n\t */\n\tret = qgroup_calc_new_refcnt(fs_info, oper, qgroup, tmp, qgroups,\n\t\t\t\t     seq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * ...in the case of removals.  If we had a removal before we got around\n\t * to processing this operation then we need to find that guy and count\n\t * his references as if they really existed so we don't end up screwing\n\t * up the exclusive counts.  Then whenever we go to process the delete\n\t * everything will be grand and we can account for whatever exclusive\n\t * changes need to be made there.  We also have to pass in old_roots so\n\t * we have an accurate count of the roots as it pertains to this\n\t * operations view of the world.\n\t */\n\tret = qgroup_account_deleted_refs(fs_info, oper, tmp, qgroups, seq,\n\t\t\t\t\t  &old_roots);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We are adding our root, need to adjust up the number of roots,\n\t * otherwise old_roots is the number of roots we want.\n\t */\n\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\tnew_roots = old_roots + 1;\n\t} else {\n\t\tnew_roots = old_roots;\n\t\told_roots++;\n\t}\n\tfs_info->qgroup_seq += old_roots + 1;\n\n\n\t/*\n\t * And now the magic happens, bless Arne for having a pretty elegant\n\t * solution for this.\n\t */\n\tqgroup_adjust_counters(fs_info, oper->ref_root, oper->num_bytes,\n\t\t\t       qgroups, seq, old_roots, new_roots, 0);\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(qgroups);\n\tulist_free(roots);\n\tulist_free(tmp);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "tmp"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_adjust_counters",
          "args": [
            "fs_info",
            "oper->ref_root",
            "oper->num_bytes",
            "qgroups",
            "seq",
            "old_roots",
            "new_roots",
            "0"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_adjust_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1694-1766",
          "snippet": "static int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_account_deleted_refs",
          "args": [
            "fs_info",
            "oper",
            "tmp",
            "qgroups",
            "seq",
            "&old_roots"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_account_deleted_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1546-1638",
          "snippet": "static int qgroup_account_deleted_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct btrfs_qgroup_operation *oper,\n\t\t\t\t       struct ulist *tmp,\n\t\t\t\t       struct ulist *qgroups, u64 seq,\n\t\t\t\t       int *old_roots)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tstruct btrfs_qgroup_operation *tmp_oper;\n\tstruct rb_node *n;\n\tint ret;\n\n\tulist_reinit(tmp);\n\n\t/*\n\t * We only walk forward in the tree since we're only interested in\n\t * removals that happened _after_  our operation.\n\t */\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = rb_next(&oper->n);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\tif (!n)\n\t\treturn 0;\n\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\twhile (tmp_oper->bytenr == oper->bytenr) {\n\t\t/*\n\t\t * If it's not a removal we don't care, additions work out\n\t\t * properly with our refcnt tracking.\n\t\t */\n\t\tif (tmp_oper->type != BTRFS_QGROUP_OPER_SUB_SHARED &&\n\t\t    tmp_oper->type != BTRFS_QGROUP_OPER_SUB_EXCL)\n\t\t\tgoto next;\n\t\tqg = find_qgroup_rb(fs_info, tmp_oper->ref_root);\n\t\tif (!qg)\n\t\t\tgoto next;\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t/*\n\t\t\t * We only want to increase old_roots if this qgroup is\n\t\t\t * not already in the list of qgroups.  If it is already\n\t\t\t * there then that means it must have been re-added or\n\t\t\t * the delete will be discarded because we had an\n\t\t\t * existing ref that we haven't looked up yet.  In this\n\t\t\t * case we don't want to increase old_roots.  So if ret\n\t\t\t * == 1 then we know that this is the first time we've\n\t\t\t * seen this qgroup and we can bump the old_roots.\n\t\t\t */\n\t\t\t(*old_roots)++;\n\t\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\nnext:\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\tn = rb_next(&tmp_oper->n);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tif (!n)\n\t\t\tbreak;\n\t\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t}\n\n\t/* Ok now process the qgroups we found */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (qg->old_refcnt < seq)\n\t\t\tqg->old_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->old_refcnt++;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tqg->new_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->new_refcnt++;\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_account_deleted_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct btrfs_qgroup_operation *oper,\n\t\t\t\t       struct ulist *tmp,\n\t\t\t\t       struct ulist *qgroups, u64 seq,\n\t\t\t\t       int *old_roots)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tstruct btrfs_qgroup_operation *tmp_oper;\n\tstruct rb_node *n;\n\tint ret;\n\n\tulist_reinit(tmp);\n\n\t/*\n\t * We only walk forward in the tree since we're only interested in\n\t * removals that happened _after_  our operation.\n\t */\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = rb_next(&oper->n);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\tif (!n)\n\t\treturn 0;\n\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\twhile (tmp_oper->bytenr == oper->bytenr) {\n\t\t/*\n\t\t * If it's not a removal we don't care, additions work out\n\t\t * properly with our refcnt tracking.\n\t\t */\n\t\tif (tmp_oper->type != BTRFS_QGROUP_OPER_SUB_SHARED &&\n\t\t    tmp_oper->type != BTRFS_QGROUP_OPER_SUB_EXCL)\n\t\t\tgoto next;\n\t\tqg = find_qgroup_rb(fs_info, tmp_oper->ref_root);\n\t\tif (!qg)\n\t\t\tgoto next;\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t/*\n\t\t\t * We only want to increase old_roots if this qgroup is\n\t\t\t * not already in the list of qgroups.  If it is already\n\t\t\t * there then that means it must have been re-added or\n\t\t\t * the delete will be discarded because we had an\n\t\t\t * existing ref that we haven't looked up yet.  In this\n\t\t\t * case we don't want to increase old_roots.  So if ret\n\t\t\t * == 1 then we know that this is the first time we've\n\t\t\t * seen this qgroup and we can bump the old_roots.\n\t\t\t */\n\t\t\t(*old_roots)++;\n\t\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\nnext:\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\tn = rb_next(&tmp_oper->n);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tif (!n)\n\t\t\tbreak;\n\t\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t}\n\n\t/* Ok now process the qgroups we found */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (qg->old_refcnt < seq)\n\t\t\tqg->old_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->old_refcnt++;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tqg->new_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->new_refcnt++;\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_calc_new_refcnt",
          "args": [
            "fs_info",
            "oper",
            "qgroup",
            "tmp",
            "qgroups",
            "seq"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_calc_new_refcnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1641-1689",
          "snippet": "static int qgroup_calc_new_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper,\n\t\t\t\t  struct btrfs_qgroup *qgroup,\n\t\t\t\t  struct ulist *tmp, struct ulist *qgroups,\n\t\t\t\t  u64 seq)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tulist_reinit(tmp);\n\tret = ulist_add(qgroups, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ulist_add(tmp, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t} else {\n\t\t\tif (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\t\t}\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_calc_new_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper,\n\t\t\t\t  struct btrfs_qgroup *qgroup,\n\t\t\t\t  struct ulist *tmp, struct ulist *qgroups,\n\t\t\t\t  u64 seq)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tulist_reinit(tmp);\n\tret = ulist_add(qgroups, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ulist_add(tmp, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t} else {\n\t\t\tif (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\t\t}\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_calc_old_refcnt",
          "args": [
            "fs_info",
            "oper->ref_root",
            "tmp",
            "roots",
            "qgroups",
            "seq",
            "&old_roots",
            "0"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_calc_old_refcnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1458-1540",
          "snippet": "static int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "oper->ref_root"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_roots",
          "args": [
            "trans",
            "fs_info",
            "oper->bytenr",
            "elem.seq",
            "&roots"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1187-1199",
          "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_existing_refs",
          "args": [
            "trans",
            "fs_info",
            "oper"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "check_existing_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1773-1799",
          "snippet": "static int check_existing_refs(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint ret = 0;\n\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   oper->elem.seq, &roots);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\tif (unode->val == oper->ref_root) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int check_existing_refs(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint ret = 0;\n\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   oper->elem.seq, &roots);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\tif (unode->val == oper->ref_root) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_shared_accounting(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist *qgroups, *tmp;\n\tstruct btrfs_qgroup *qgroup;\n\tstruct seq_list elem = {};\n\tu64 seq;\n\tint old_roots = 0;\n\tint new_roots = 0;\n\tint ret = 0;\n\n\tif (oper->elem.seq) {\n\t\tret = check_existing_refs(trans, fs_info, oper);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret)\n\t\t\treturn 0;\n\t}\n\n\tqgroups = ulist_alloc(GFP_NOFS);\n\tif (!qgroups)\n\t\treturn -ENOMEM;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp) {\n\t\tulist_free(qgroups);\n\t\treturn -ENOMEM;\n\t}\n\n\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr, elem.seq,\n\t\t\t\t   &roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\tif (ret < 0) {\n\t\tulist_free(qgroups);\n\t\tulist_free(tmp);\n\t\treturn ret;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tseq = fs_info->qgroup_seq;\n\n\t/*\n\t * So roots is the list of all the roots currently pointing at the\n\t * bytenr, including the ref we are adding if we are adding, or not if\n\t * we are removing a ref.  So we pass in the ref_root to skip that root\n\t * in our calculations.  We set old_refnct and new_refcnt cause who the\n\t * hell knows what everything looked like before, and it doesn't matter\n\t * except...\n\t */\n\tret = qgroup_calc_old_refcnt(fs_info, oper->ref_root, tmp, roots, qgroups,\n\t\t\t\t     seq, &old_roots, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * Now adjust the refcounts of the qgroups that care about this\n\t * reference, either the old_count in the case of removal or new_count\n\t * in the case of an addition.\n\t */\n\tret = qgroup_calc_new_refcnt(fs_info, oper, qgroup, tmp, qgroups,\n\t\t\t\t     seq);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * ...in the case of removals.  If we had a removal before we got around\n\t * to processing this operation then we need to find that guy and count\n\t * his references as if they really existed so we don't end up screwing\n\t * up the exclusive counts.  Then whenever we go to process the delete\n\t * everything will be grand and we can account for whatever exclusive\n\t * changes need to be made there.  We also have to pass in old_roots so\n\t * we have an accurate count of the roots as it pertains to this\n\t * operations view of the world.\n\t */\n\tret = qgroup_account_deleted_refs(fs_info, oper, tmp, qgroups, seq,\n\t\t\t\t\t  &old_roots);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * We are adding our root, need to adjust up the number of roots,\n\t * otherwise old_roots is the number of roots we want.\n\t */\n\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\tnew_roots = old_roots + 1;\n\t} else {\n\t\tnew_roots = old_roots;\n\t\told_roots++;\n\t}\n\tfs_info->qgroup_seq += old_roots + 1;\n\n\n\t/*\n\t * And now the magic happens, bless Arne for having a pretty elegant\n\t * solution for this.\n\t */\n\tqgroup_adjust_counters(fs_info, oper->ref_root, oper->num_bytes,\n\t\t\t       qgroups, seq, old_roots, new_roots, 0);\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(qgroups);\n\tulist_free(roots);\n\tulist_free(tmp);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_existing_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1773-1799",
    "snippet": "static int check_existing_refs(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint ret = 0;\n\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   oper->elem.seq, &roots);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\tif (unode->val == oper->ref_root) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&oper->elem"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "roots"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "roots",
            "&uiter"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_roots",
          "args": [
            "trans",
            "fs_info",
            "oper->bytenr",
            "oper->elem.seq",
            "&roots"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1187-1199",
          "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int check_existing_refs(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_fs_info *fs_info,\n\t\t\t       struct btrfs_qgroup_operation *oper)\n{\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint ret = 0;\n\n\tret = btrfs_find_all_roots(trans, fs_info, oper->bytenr,\n\t\t\t\t   oper->elem.seq, &roots);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = 0;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\tif (unode->val == oper->ref_root) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tulist_free(roots);\n\tbtrfs_put_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "qgroup_adjust_counters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1694-1766",
    "snippet": "static int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qgroup_dirty",
          "args": [
            "fs_info",
            "qg"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "997-1002",
          "snippet": "static void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cur_new_count != new_roots && new_roots == 0"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "qgroups",
            "&uiter"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_adjust_counters(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, u64 num_bytes,\n\t\t\t\t  struct ulist *qgroups, u64 seq,\n\t\t\t\t  int old_roots, int new_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tu64 cur_new_count, cur_old_count;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(qgroups, &uiter))) {\n\t\tbool dirty = false;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\t/*\n\t\t * Wasn't referenced before but is now, add to the reference\n\t\t * counters.\n\t\t */\n\t\tif (qg->old_refcnt <= seq && qg->new_refcnt > seq) {\n\t\t\tqg->rfer += num_bytes;\n\t\t\tqg->rfer_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * Was referenced before but isn't now, subtract from the\n\t\t * reference counters.\n\t\t */\n\t\tif (qg->old_refcnt > seq && qg->new_refcnt <= seq) {\n\t\t\tqg->rfer -= num_bytes;\n\t\t\tqg->rfer_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (qg->old_refcnt < seq)\n\t\t\tcur_old_count = 0;\n\t\telse\n\t\t\tcur_old_count = qg->old_refcnt - seq;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tcur_new_count = 0;\n\t\telse\n\t\t\tcur_new_count = qg->new_refcnt - seq;\n\n\t\t/*\n\t\t * If our refcount was the same as the roots previously but our\n\t\t * new count isn't the same as the number of roots now then we\n\t\t * went from having a exclusive reference on this range to not.\n\t\t */\n\t\tif (old_roots && cur_old_count == old_roots &&\n\t\t    (cur_new_count != new_roots || new_roots == 0)) {\n\t\t\tWARN_ON(cur_new_count != new_roots && new_roots == 0);\n\t\t\tqg->excl -= num_bytes;\n\t\t\tqg->excl_cmpr -= num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\t/*\n\t\t * If we didn't reference all the roots before but now we do we\n\t\t * have an exclusive reference to this range.\n\t\t */\n\t\tif ((!old_roots || (old_roots && cur_old_count != old_roots))\n\t\t    && cur_new_count == new_roots) {\n\t\t\tqg->excl += num_bytes;\n\t\t\tqg->excl_cmpr += num_bytes;\n\t\t\tdirty = true;\n\t\t}\n\n\t\tif (dirty)\n\t\t\tqgroup_dirty(fs_info, qg);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_calc_new_refcnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1641-1689",
    "snippet": "static int qgroup_calc_new_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper,\n\t\t\t\t  struct btrfs_qgroup *qgroup,\n\t\t\t\t  struct ulist *tmp, struct ulist *qgroups,\n\t\t\t\t  u64 seq)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tulist_reinit(tmp);\n\tret = ulist_add(qgroups, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ulist_add(tmp, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t} else {\n\t\t\tif (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\t\t}\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "qgroups",
            "glist->group->qgroupid",
            "ptr_to_u64(glist->group)",
            "GFP_ATOMIC"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&uiter"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qgroup"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qgroup"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "tmp"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_calc_new_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper,\n\t\t\t\t  struct btrfs_qgroup *qgroup,\n\t\t\t\t  struct ulist *tmp, struct ulist *qgroups,\n\t\t\t\t  u64 seq)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tulist_reinit(tmp);\n\tret = ulist_add(qgroups, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = ulist_add(tmp, qgroup->qgroupid, ptr_to_u64(qgroup),\n\t\t\tGFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (oper->type == BTRFS_QGROUP_OPER_ADD_SHARED) {\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t} else {\n\t\t\tif (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\t\t}\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_account_deleted_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1546-1638",
    "snippet": "static int qgroup_account_deleted_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct btrfs_qgroup_operation *oper,\n\t\t\t\t       struct ulist *tmp,\n\t\t\t\t       struct ulist *qgroups, u64 seq,\n\t\t\t\t       int *old_roots)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tstruct btrfs_qgroup_operation *tmp_oper;\n\tstruct rb_node *n;\n\tint ret;\n\n\tulist_reinit(tmp);\n\n\t/*\n\t * We only walk forward in the tree since we're only interested in\n\t * removals that happened _after_  our operation.\n\t */\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = rb_next(&oper->n);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\tif (!n)\n\t\treturn 0;\n\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\twhile (tmp_oper->bytenr == oper->bytenr) {\n\t\t/*\n\t\t * If it's not a removal we don't care, additions work out\n\t\t * properly with our refcnt tracking.\n\t\t */\n\t\tif (tmp_oper->type != BTRFS_QGROUP_OPER_SUB_SHARED &&\n\t\t    tmp_oper->type != BTRFS_QGROUP_OPER_SUB_EXCL)\n\t\t\tgoto next;\n\t\tqg = find_qgroup_rb(fs_info, tmp_oper->ref_root);\n\t\tif (!qg)\n\t\t\tgoto next;\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t/*\n\t\t\t * We only want to increase old_roots if this qgroup is\n\t\t\t * not already in the list of qgroups.  If it is already\n\t\t\t * there then that means it must have been re-added or\n\t\t\t * the delete will be discarded because we had an\n\t\t\t * existing ref that we haven't looked up yet.  In this\n\t\t\t * case we don't want to increase old_roots.  So if ret\n\t\t\t * == 1 then we know that this is the first time we've\n\t\t\t * seen this qgroup and we can bump the old_roots.\n\t\t\t */\n\t\t\t(*old_roots)++;\n\t\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\nnext:\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\tn = rb_next(&tmp_oper->n);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tif (!n)\n\t\t\tbreak;\n\t\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t}\n\n\t/* Ok now process the qgroups we found */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (qg->old_refcnt < seq)\n\t\t\tqg->old_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->old_refcnt++;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tqg->new_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->new_refcnt++;\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "tmp",
            "glist->group->qgroupid",
            "ptr_to_u64(glist->group)",
            "GFP_ATOMIC"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&uiter"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup_operation",
            "n"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&tmp_oper->n"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qg"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qg"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "tmp_oper->ref_root"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup_operation",
            "n"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&oper->n"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "tmp"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_account_deleted_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t       struct btrfs_qgroup_operation *oper,\n\t\t\t\t       struct ulist *tmp,\n\t\t\t\t       struct ulist *qgroups, u64 seq,\n\t\t\t\t       int *old_roots)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct btrfs_qgroup *qg;\n\tstruct btrfs_qgroup_operation *tmp_oper;\n\tstruct rb_node *n;\n\tint ret;\n\n\tulist_reinit(tmp);\n\n\t/*\n\t * We only walk forward in the tree since we're only interested in\n\t * removals that happened _after_  our operation.\n\t */\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = rb_next(&oper->n);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\tif (!n)\n\t\treturn 0;\n\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\twhile (tmp_oper->bytenr == oper->bytenr) {\n\t\t/*\n\t\t * If it's not a removal we don't care, additions work out\n\t\t * properly with our refcnt tracking.\n\t\t */\n\t\tif (tmp_oper->type != BTRFS_QGROUP_OPER_SUB_SHARED &&\n\t\t    tmp_oper->type != BTRFS_QGROUP_OPER_SUB_EXCL)\n\t\t\tgoto next;\n\t\tqg = find_qgroup_rb(fs_info, tmp_oper->ref_root);\n\t\tif (!qg)\n\t\t\tgoto next;\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\t/*\n\t\t\t * We only want to increase old_roots if this qgroup is\n\t\t\t * not already in the list of qgroups.  If it is already\n\t\t\t * there then that means it must have been re-added or\n\t\t\t * the delete will be discarded because we had an\n\t\t\t * existing ref that we haven't looked up yet.  In this\n\t\t\t * case we don't want to increase old_roots.  So if ret\n\t\t\t * == 1 then we know that this is the first time we've\n\t\t\t * seen this qgroup and we can bump the old_roots.\n\t\t\t */\n\t\t\t(*old_roots)++;\n\t\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\nnext:\n\t\tspin_lock(&fs_info->qgroup_op_lock);\n\t\tn = rb_next(&tmp_oper->n);\n\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\tif (!n)\n\t\t\tbreak;\n\t\ttmp_oper = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t}\n\n\t/* Ok now process the qgroups we found */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tstruct btrfs_qgroup_list *glist;\n\n\t\tqg = u64_to_ptr(unode->aux);\n\t\tif (qg->old_refcnt < seq)\n\t\t\tqg->old_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->old_refcnt++;\n\t\tif (qg->new_refcnt < seq)\n\t\t\tqg->new_refcnt = seq + 1;\n\t\telse\n\t\t\tqg->new_refcnt++;\n\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_calc_old_refcnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1458-1540",
    "snippet": "static int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "tmp",
            "glist->group->qgroupid",
            "ptr_to_u64(glist->group)",
            "GFP_ATOMIC"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qg->groups",
            "next_group"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "tmp_unode->aux"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&tmp_uiter"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&tmp_uiter"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qg"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "qg"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "tmp"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "unode->val"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_calc_old_refcnt(struct btrfs_fs_info *fs_info,\n\t\t\t\t  u64 root_to_skip, struct ulist *tmp,\n\t\t\t\t  struct ulist *roots, struct ulist *qgroups,\n\t\t\t\t  u64 seq, int *old_roots, int rescan)\n{\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *tmp_unode;\n\tstruct ulist_iterator tmp_uiter;\n\tstruct btrfs_qgroup *qg;\n\tint ret;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(roots, &uiter))) {\n\t\t/* We don't count our current root here */\n\t\tif (unode->val == root_to_skip)\n\t\t\tcontinue;\n\t\tqg = find_qgroup_rb(fs_info, unode->val);\n\t\tif (!qg)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We could have a pending removal of this same ref so we may\n\t\t * not have actually found our ref root when doing\n\t\t * btrfs_find_all_roots, so we need to keep track of how many\n\t\t * old roots we find in case we removed ours and added a\n\t\t * different one at the same time.  I don't think this could\n\t\t * happen in practice but that sort of thinking leads to pain\n\t\t * and suffering and to the dark side.\n\t\t */\n\t\t(*old_roots)++;\n\n\t\tulist_reinit(tmp);\n\t\tret = ulist_add(qgroups, qg->qgroupid, ptr_to_u64(qg),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ulist_add(tmp, qg->qgroupid, ptr_to_u64(qg), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tULIST_ITER_INIT(&tmp_uiter);\n\t\twhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\n\t\t\tstruct btrfs_qgroup_list *glist;\n\n\t\t\tqg = u64_to_ptr(tmp_unode->aux);\n\t\t\t/*\n\t\t\t * We use this sequence number to keep from having to\n\t\t\t * run the whole list and 0 out the refcnt every time.\n\t\t\t * We basically use sequnce as the known 0 count and\n\t\t\t * then add 1 everytime we see a qgroup.  This is how we\n\t\t\t * get how many of the roots actually point up to the\n\t\t\t * upper level qgroups in order to determine exclusive\n\t\t\t * counts.\n\t\t\t *\n\t\t\t * For rescan we want to set old_refcnt to seq so our\n\t\t\t * exclusive calculations end up correct.\n\t\t\t */\n\t\t\tif (rescan)\n\t\t\t\tqg->old_refcnt = seq;\n\t\t\telse if (qg->old_refcnt < seq)\n\t\t\t\tqg->old_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->old_refcnt++;\n\n\t\t\tif (qg->new_refcnt < seq)\n\t\t\t\tqg->new_refcnt = seq + 1;\n\t\t\telse\n\t\t\t\tqg->new_refcnt++;\n\t\t\tlist_for_each_entry(glist, &qg->groups, next_group) {\n\t\t\t\tret = ulist_add(qgroups, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\t\tptr_to_u64(glist->group),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_excl_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1380-1452",
    "snippet": "static int qgroup_excl_accounting(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper)\n{\n\tstruct btrfs_qgroup *qgroup;\n\tstruct ulist *tmp;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint sign = 0;\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\t\tsign = 1;\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tsign = -1;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\tqgroup->rfer += sign * oper->num_bytes;\n\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\n\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\tqgroup->excl += sign * oper->num_bytes;\n\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\n\tqgroup_dirty(fs_info, qgroup);\n\n\t/* Get all of the parent groups that contain this qgroup */\n\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Iterate all of the parents and adjust their reference counts */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tqgroup = u64_to_ptr(unode->aux);\n\t\tqgroup->rfer += sign * oper->num_bytes;\n\t\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\t\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\t\tqgroup->excl += sign * oper->num_bytes;\n\t\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qgroup);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(tmp);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "tmp"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "tmp",
            "glist->group->qgroupid",
            "ptr_to_u64(glist->group)",
            "GFP_ATOMIC"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qgroup->groups",
            "next_group"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgroup_dirty",
          "args": [
            "fs_info",
            "qgroup"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "997-1002",
          "snippet": "static void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sign < 0 && qgroup->excl < oper->num_bytes"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_ptr",
          "args": [
            "unode->aux"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&uiter"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_u64",
          "args": [
            "glist->group"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "glist",
            "&qgroup->groups",
            "next_group"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sign < 0 && qgroup->excl < oper->num_bytes"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "oper->ref_root"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_excl_accounting(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_qgroup_operation *oper)\n{\n\tstruct btrfs_qgroup *qgroup;\n\tstruct ulist *tmp;\n\tstruct btrfs_qgroup_list *glist;\n\tstruct ulist_node *unode;\n\tstruct ulist_iterator uiter;\n\tint sign = 0;\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tqgroup = find_qgroup_rb(fs_info, oper->ref_root);\n\tif (!qgroup)\n\t\tgoto out;\n\tswitch (oper->type) {\n\tcase BTRFS_QGROUP_OPER_ADD_EXCL:\n\t\tsign = 1;\n\t\tbreak;\n\tcase BTRFS_QGROUP_OPER_SUB_EXCL:\n\t\tsign = -1;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\tqgroup->rfer += sign * oper->num_bytes;\n\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\n\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\tqgroup->excl += sign * oper->num_bytes;\n\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\n\tqgroup_dirty(fs_info, qgroup);\n\n\t/* Get all of the parent groups that contain this qgroup */\n\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t/* Iterate all of the parents and adjust their reference counts */\n\tULIST_ITER_INIT(&uiter);\n\twhile ((unode = ulist_next(tmp, &uiter))) {\n\t\tqgroup = u64_to_ptr(unode->aux);\n\t\tqgroup->rfer += sign * oper->num_bytes;\n\t\tqgroup->rfer_cmpr += sign * oper->num_bytes;\n\t\tWARN_ON(sign < 0 && qgroup->excl < oper->num_bytes);\n\t\tqgroup->excl += sign * oper->num_bytes;\n\t\tqgroup->excl_cmpr += sign * oper->num_bytes;\n\t\tqgroup_dirty(fs_info, qgroup);\n\n\t\t/* Add any parents of the parents */\n\t\tlist_for_each_entry(glist, &qgroup->groups, next_group) {\n\t\t\tret = ulist_add(tmp, glist->group->qgroupid,\n\t\t\t\t\tptr_to_u64(glist->group), GFP_ATOMIC);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\tspin_unlock(&fs_info->qgroup_lock);\n\tulist_free(tmp);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_qgroup_record_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1319-1373",
    "snippet": "int btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&oper->elem"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&oper->list",
            "&trans->qgroup_ref_list"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oper"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_qgroup_oper",
          "args": [
            "fs_info",
            "oper"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "insert_qgroup_oper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1274-1301",
          "snippet": "static int insert_qgroup_oper(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tp = &fs_info->qgroup_op_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else if (cmp) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\trb_link_node(&oper->n, parent, p);\n\trb_insert_color(&oper->n, &fs_info->qgroup_op_tree);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int insert_qgroup_oper(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tp = &fs_info->qgroup_op_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else if (cmp) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\trb_link_node(&oper->n, parent, p);\n\trb_insert_color(&oper->n, &fs_info->qgroup_op_tree);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oper"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qgroup_oper_exists",
          "args": [
            "fs_info",
            "oper"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_oper_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1227-1250",
          "snippet": "static int qgroup_oper_exists(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = fs_info->qgroup_op_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper_exist(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tn = n->rb_right;\n\t\t} else if (cmp) {\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_oper_exists(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = fs_info->qgroup_op_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper_exist(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tn = n->rb_right;\n\t\t} else if (cmp) {\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_btrfs_qgroup_record_ref",
          "args": [
            "oper"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oper->elem.list"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&fs_info->qgroup_op_seq"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*oper)",
            "GFP_NOFS"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_fstree",
          "args": [
            "ref_root"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "is_fstree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4180-4186",
          "snippet": "static inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_FIRST_FREE_OBJECTID 256ULL",
            "#define BTRFS_FS_TREE_OBJECTID 5ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_FIRST_FREE_OBJECTID 256ULL\n#define BTRFS_FS_TREE_OBJECTID 5ULL\n\nstatic inline int is_fstree(u64 rootid)\n{\n\tif (rootid == BTRFS_FS_TREE_OBJECTID ||\n\t    (s64)rootid >= (s64)BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_fs_info *fs_info, u64 ref_root,\n\t\t\t    u64 bytenr, u64 num_bytes,\n\t\t\t    enum btrfs_qgroup_operation_type type, int mod_seq)\n{\n\tstruct btrfs_qgroup_operation *oper;\n\tint ret;\n\n\tif (!is_fstree(ref_root) || !fs_info->quota_enabled)\n\t\treturn 0;\n\n\toper = kmalloc(sizeof(*oper), GFP_NOFS);\n\tif (!oper)\n\t\treturn -ENOMEM;\n\n\toper->ref_root = ref_root;\n\toper->bytenr = bytenr;\n\toper->num_bytes = num_bytes;\n\toper->type = type;\n\toper->seq = atomic_inc_return(&fs_info->qgroup_op_seq);\n\tINIT_LIST_HEAD(&oper->elem.list);\n\toper->elem.seq = 0;\n\n\ttrace_btrfs_qgroup_record_ref(oper);\n\n\tif (type == BTRFS_QGROUP_OPER_SUB_SUBTREE) {\n\t\t/*\n\t\t * If any operation for this bytenr/ref_root combo\n\t\t * exists, then we know it's not exclusively owned and\n\t\t * shouldn't be queued up.\n\t\t *\n\t\t * This also catches the case where we have a cloned\n\t\t * extent that gets queued up multiple times during\n\t\t * drop snapshot.\n\t\t */\n\t\tif (qgroup_oper_exists(fs_info, oper)) {\n\t\t\tkfree(oper);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = insert_qgroup_oper(fs_info, oper);\n\tif (ret) {\n\t\t/* Shouldn't happen so have an assert for developers */\n\t\tASSERT(0);\n\t\tkfree(oper);\n\t\treturn ret;\n\t}\n\tlist_add_tail(&oper->list, &trans->qgroup_ref_list);\n\n\tif (mod_seq)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &oper->elem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_qgroup_oper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1274-1301",
    "snippet": "static int insert_qgroup_oper(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tp = &fs_info->qgroup_op_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else if (cmp) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\trb_link_node(&oper->n, parent, p);\n\trb_insert_color(&oper->n, &fs_info->qgroup_op_tree);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&oper->n",
            "&fs_info->qgroup_op_tree"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&oper->n",
            "parent",
            "p"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_oper",
          "args": [
            "cur",
            "oper"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "comp_oper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1252-1272",
          "snippet": "static int comp_oper(struct btrfs_qgroup_operation *oper1,\n\t\t     struct btrfs_qgroup_operation *oper2)\n{\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->seq < oper2->seq)\n\t\treturn -1;\n\tif (oper1->seq > oper2->seq)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\tif (oper1->type < oper2->type)\n\t\treturn -1;\n\tif (oper1->type > oper2->type)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int comp_oper(struct btrfs_qgroup_operation *oper1,\n\t\t     struct btrfs_qgroup_operation *oper2)\n{\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->seq < oper2->seq)\n\t\treturn -1;\n\tif (oper1->seq > oper2->seq)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\tif (oper1->type < oper2->type)\n\t\treturn -1;\n\tif (oper1->type > oper2->type)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structbtrfs_qgroup_operation",
            "n"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int insert_qgroup_oper(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tp = &fs_info->qgroup_op_tree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tcur = rb_entry(parent, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tp = &(*p)->rb_right;\n\t\t} else if (cmp) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\trb_link_node(&oper->n, parent, p);\n\trb_insert_color(&oper->n, &fs_info->qgroup_op_tree);\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_oper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1252-1272",
    "snippet": "static int comp_oper(struct btrfs_qgroup_operation *oper1,\n\t\t     struct btrfs_qgroup_operation *oper2)\n{\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->seq < oper2->seq)\n\t\treturn -1;\n\tif (oper1->seq > oper2->seq)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\tif (oper1->type < oper2->type)\n\t\treturn -1;\n\tif (oper1->type > oper2->type)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int comp_oper(struct btrfs_qgroup_operation *oper1,\n\t\t     struct btrfs_qgroup_operation *oper2)\n{\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->seq < oper2->seq)\n\t\treturn -1;\n\tif (oper1->seq > oper2->seq)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\tif (oper1->type < oper2->type)\n\t\treturn -1;\n\tif (oper1->type > oper2->type)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "qgroup_oper_exists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1227-1250",
    "snippet": "static int qgroup_oper_exists(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = fs_info->qgroup_op_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper_exist(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tn = n->rb_right;\n\t\t} else if (cmp) {\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_oper_exist",
          "args": [
            "cur",
            "oper"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "comp_oper_exist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "1209-1225",
          "snippet": "static int comp_oper_exist(struct btrfs_qgroup_operation *oper1,\n\t\t\t   struct btrfs_qgroup_operation *oper2)\n{\n\t/*\n\t * Ignore seq and type here, we're looking for any operation\n\t * at all related to this extent on that root.\n\t */\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int comp_oper_exist(struct btrfs_qgroup_operation *oper1,\n\t\t\t   struct btrfs_qgroup_operation *oper2)\n{\n\t/*\n\t * Ignore seq and type here, we're looking for any operation\n\t * at all related to this extent on that root.\n\t */\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup_operation",
            "n"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_op_lock"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int qgroup_oper_exists(struct btrfs_fs_info *fs_info,\n\t\t\t      struct btrfs_qgroup_operation *oper)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup_operation *cur;\n\tint cmp;\n\n\tspin_lock(&fs_info->qgroup_op_lock);\n\tn = fs_info->qgroup_op_tree.rb_node;\n\twhile (n) {\n\t\tcur = rb_entry(n, struct btrfs_qgroup_operation, n);\n\t\tcmp = comp_oper_exist(cur, oper);\n\t\tif (cmp < 0) {\n\t\t\tn = n->rb_right;\n\t\t} else if (cmp) {\n\t\t\tn = n->rb_left;\n\t\t} else {\n\t\t\tspin_unlock(&fs_info->qgroup_op_lock);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->qgroup_op_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_oper_exist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1209-1225",
    "snippet": "static int comp_oper_exist(struct btrfs_qgroup_operation *oper1,\n\t\t\t   struct btrfs_qgroup_operation *oper2)\n{\n\t/*\n\t * Ignore seq and type here, we're looking for any operation\n\t * at all related to this extent on that root.\n\t */\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int comp_oper_exist(struct btrfs_qgroup_operation *oper1,\n\t\t\t   struct btrfs_qgroup_operation *oper2)\n{\n\t/*\n\t * Ignore seq and type here, we're looking for any operation\n\t * at all related to this extent on that root.\n\t */\n\tif (oper1->bytenr < oper2->bytenr)\n\t\treturn -1;\n\tif (oper1->bytenr > oper2->bytenr)\n\t\treturn 1;\n\tif (oper1->ref_root < oper2->ref_root)\n\t\treturn -1;\n\tif (oper1->ref_root > oper2->ref_root)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_limit_qgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1167-1207",
    "snippet": "int btrfs_limit_qgroup(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t       struct btrfs_qgroup_limit *limit)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = update_qgroup_limit_item(trans, quota_root, qgroupid,\n\t\t\t\t       limit->flags, limit->max_rfer,\n\t\t\t\t       limit->max_excl, limit->rsv_rfer,\n\t\t\t\t       limit->rsv_excl);\n\tif (ret) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tbtrfs_info(fs_info, \"unable to update quota limit for %llu\",\n\t\t       qgroupid);\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup->lim_flags = limit->flags;\n\tqgroup->max_rfer = limit->max_rfer;\n\tqgroup->max_excl = limit->max_excl;\n\tqgroup->rsv_rfer = limit->rsv_rfer;\n\tqgroup->rsv_excl = limit->rsv_excl;\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"unable to update quota limit for %llu\"",
            "qgroupid"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_qgroup_limit_item",
          "args": [
            "trans",
            "quota_root",
            "qgroupid",
            "limit->flags",
            "limit->max_rfer",
            "limit->max_excl",
            "limit->rsv_rfer",
            "limit->rsv_excl"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "update_qgroup_limit_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "646-687",
          "snippet": "static int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_limit_qgroup(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t       struct btrfs_qgroup_limit *limit)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = update_qgroup_limit_item(trans, quota_root, qgroupid,\n\t\t\t\t       limit->flags, limit->max_rfer,\n\t\t\t\t       limit->max_excl, limit->rsv_rfer,\n\t\t\t\t       limit->rsv_excl);\n\tif (ret) {\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\tbtrfs_info(fs_info, \"unable to update quota limit for %llu\",\n\t\t       qgroupid);\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup->lim_flags = limit->flags;\n\tqgroup->max_rfer = limit->max_rfer;\n\tqgroup->max_excl = limit->max_excl;\n\tqgroup->rsv_rfer = limit->rsv_rfer;\n\tqgroup->rsv_excl = limit->rsv_excl;\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_remove_qgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1131-1165",
    "snippet": "int btrfs_remove_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t} else {\n\t\t/* check if there are no relations to this qgroup */\n\t\tif (!list_empty(&qgroup->groups) ||\n\t\t    !list_empty(&qgroup->members)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = del_qgroup_item(trans, quota_root, qgroupid);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_qgroup_rb(quota_root->fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_qgroup_rb",
          "args": [
            "quota_root->fs_info",
            "qgroupid"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "del_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "188-198",
          "snippet": "static int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);\n\n\tif (!qgroup)\n\t\treturn -ENOENT;\n\n\trb_erase(&qgroup->node, &fs_info->qgroup_tree);\n\t__del_qgroup_rb(qgroup);\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);\n\n\tif (!qgroup)\n\t\treturn -ENOENT;\n\n\trb_erase(&qgroup->node, &fs_info->qgroup_tree);\n\t__del_qgroup_rb(qgroup);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_qgroup_item",
          "args": [
            "trans",
            "quota_root",
            "qgroupid"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "del_qgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "600-644",
          "snippet": "static int del_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int del_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&qgroup->members"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_remove_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t} else {\n\t\t/* check if there are no relations to this qgroup */\n\t\tif (!list_empty(&qgroup->groups) ||\n\t\t    !list_empty(&qgroup->members)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = del_qgroup_item(trans, quota_root, qgroupid);\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_qgroup_rb(quota_root->fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_create_qgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1097-1129",
    "snippet": "int btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qgroup"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qgroup"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "130-162",
          "snippet": "static struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_item",
          "args": [
            "trans",
            "quota_root",
            "qgroupid"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "532-598",
          "snippet": "static int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_create_qgroup(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *qgroup;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (qgroup) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tret = add_qgroup_item(trans, quota_root, qgroupid);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tqgroup = add_qgroup_rb(fs_info, qgroupid);\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tif (IS_ERR(qgroup))\n\t\tret = PTR_ERR(qgroup);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_del_qgroup_relation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1052-1095",
    "snippet": "int btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\tint err;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent)\n\t\t\tgoto exist;\n\t}\n\tret = -ENOENT;\n\tgoto out;\nexist:\n\tret = del_qgroup_relation_item(trans, quota_root, src, dst);\n\terr = del_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (err && !ret)\n\t\tret = err;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_relation_rb(fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_relation_rb",
          "args": [
            "fs_info",
            "src",
            "dst"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "del_relation_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "226-247",
          "snippet": "static int del_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tlist_del(&list->next_group);\n\t\t\tlist_del(&list->next_member);\n\t\t\tkfree(list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int del_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tlist_del(&list->next_group);\n\t\t\tlist_del(&list->next_member);\n\t\t\tkfree(list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_qgroup_relation_item",
          "args": [
            "trans",
            "quota_root",
            "dst",
            "src"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "del_qgroup_relation_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "501-530",
          "snippet": "static int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list",
            "&member->groups",
            "next_group"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "dst"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\tint err;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent)\n\t\t\tgoto exist;\n\t}\n\tret = -ENOENT;\n\tgoto out;\nexist:\n\tret = del_qgroup_relation_item(trans, quota_root, src, dst);\n\terr = del_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (err && !ret)\n\t\tret = err;\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tdel_relation_rb(fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_add_qgroup_relation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "1004-1050",
    "snippet": "int btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = add_qgroup_relation_item(trans, quota_root, src, dst);\n\tif (ret)\n\t\tgoto out;\n\n\tret = add_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (ret) {\n\t\tdel_qgroup_relation_item(trans, quota_root, src, dst);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tret = add_relation_rb(quota_root->fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_relation_rb",
          "args": [
            "quota_root->fs_info",
            "src",
            "dst"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "add_relation_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "201-223",
          "snippet": "static int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_qgroup_relation_item",
          "args": [
            "trans",
            "quota_root",
            "src",
            "dst"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "del_qgroup_relation_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "501-530",
          "snippet": "static int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_relation_item",
          "args": [
            "trans",
            "quota_root",
            "dst",
            "src"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_relation_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "477-499",
          "snippet": "static int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list",
            "&member->groups",
            "next_group"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "dst"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_fs_info *fs_info, u64 src, u64 dst)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup_list *list;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tquota_root = fs_info->quota_root;\n\tif (!quota_root) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tmember = find_qgroup_rb(fs_info, src);\n\tparent = find_qgroup_rb(fs_info, dst);\n\tif (!member || !parent) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* check if such qgroup relation exist firstly */\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = add_qgroup_relation_item(trans, quota_root, src, dst);\n\tif (ret)\n\t\tgoto out;\n\n\tret = add_qgroup_relation_item(trans, quota_root, dst, src);\n\tif (ret) {\n\t\tdel_qgroup_relation_item(trans, quota_root, src, dst);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&fs_info->qgroup_lock);\n\tret = add_relation_rb(quota_root->fs_info, src, dst);\n\tspin_unlock(&fs_info->qgroup_lock);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "qgroup_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "997-1002",
    "snippet": "static void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&qgroup->dirty",
            "&fs_info->dirty_qgroups"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&qgroup->dirty"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\n\t\t\t struct btrfs_qgroup *qgroup)\n{\n\tif (list_empty(&qgroup->dirty))\n\t\tlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\n}"
  },
  {
    "function_name": "btrfs_quota_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "955-995",
    "snippet": "int btrfs_quota_disable(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *quota_root;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tquota_root = fs_info->quota_root;\n\tfs_info->quota_root = NULL;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\n\tret = btrfs_clean_quota_tree(trans, quota_root);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_del_root(trans, tree_root, &quota_root->root_key);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_del(&quota_root->dirty_list);\n\n\tbtrfs_tree_lock(quota_root->node);\n\tclean_tree_block(trans, tree_root, quota_root->node);\n\tbtrfs_tree_unlock(quota_root->node);\n\tbtrfs_free_tree_block(trans, quota_root, quota_root->node, 0, 1);\n\n\tfree_extent_buffer(quota_root->node);\n\tfree_extent_buffer(quota_root->commit_root);\n\tkfree(quota_root);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "quota_root"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "quota_root->commit_root"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_tree_block",
          "args": [
            "trans",
            "quota_root",
            "quota_root->node",
            "0",
            "1"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6190-6246",
          "snippet": "void btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "quota_root->node"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "tree_root",
            "quota_root->node"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "quota_root->node"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&quota_root->dirty_list"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_root",
          "args": [
            "trans",
            "tree_root",
            "&quota_root->root_key"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/root-tree.c",
          "lines": "327-346",
          "snippet": "int btrfs_del_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_search_slot(trans, root, key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tBUG_ON(ret != 0);\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/err.h>\n\nint btrfs_del_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t   struct btrfs_key *key)\n{\n\tstruct btrfs_path *path;\n\tint ret;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_search_slot(trans, root, key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tBUG_ON(ret != 0);\n\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clean_quota_tree",
          "args": [
            "trans",
            "quota_root"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clean_quota_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "778-822",
          "snippet": "static int btrfs_clean_quota_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf = NULL;\n\tint ret;\n\tint nr = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = 0;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tnr = btrfs_header_nritems(leaf);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\t/*\n\t\t * delete the leaf one by one\n\t\t * since the whole tree is going\n\t\t * to be deleted.\n\t\t */\n\t\tpath->slots[0] = 0;\n\t\tret = btrfs_del_items(trans, root, path, 0, nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\troot->fs_info->pending_quota_state = 0;\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_clean_quota_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf = NULL;\n\tint ret;\n\tint nr = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = 0;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tnr = btrfs_header_nritems(leaf);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\t/*\n\t\t * delete the leaf one by one\n\t\t * since the whole tree is going\n\t\t * to be deleted.\n\t\t */\n\t\tpath->slots[0] = 0;\n\t\tret = btrfs_del_items(trans, root, path, 0, nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\troot->fs_info->pending_quota_state = 0;\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_qgroup_config",
          "args": [
            "fs_info"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_qgroup_config",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "458-475",
          "snippet": "void btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_quota_disable(struct btrfs_trans_handle *trans,\n\t\t\tstruct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *quota_root;\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\tgoto out;\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tquota_root = fs_info->quota_root;\n\tfs_info->quota_root = NULL;\n\tspin_unlock(&fs_info->qgroup_lock);\n\n\tbtrfs_free_qgroup_config(fs_info);\n\n\tret = btrfs_clean_quota_tree(trans, quota_root);\n\tif (ret)\n\t\tgoto out;\n\n\tret = btrfs_del_root(trans, tree_root, &quota_root->root_key);\n\tif (ret)\n\t\tgoto out;\n\n\tlist_del(&quota_root->dirty_list);\n\n\tbtrfs_tree_lock(quota_root->node);\n\tclean_tree_block(trans, tree_root, quota_root->node);\n\tbtrfs_tree_unlock(quota_root->node);\n\tbtrfs_free_tree_block(trans, quota_root, quota_root->node, 0, 1);\n\n\tfree_extent_buffer(quota_root->node);\n\tfree_extent_buffer(quota_root->commit_root);\n\tkfree(quota_root);\nout:\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_quota_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "824-953",
    "snippet": "int btrfs_quota_enable(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_qgroup *qgroup = NULL;\n\tint ret = 0;\n\tint slot;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (fs_info->quota_root) {\n\t\tfs_info->pending_quota_state = 1;\n\t\tgoto out;\n\t}\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * initially create the quota tree\n\t */\n\tquota_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t       BTRFS_QUOTA_TREE_OBJECTID);\n\tif (IS_ERR(quota_root)) {\n\t\tret =  PTR_ERR(quota_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_root;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*ptr));\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tleaf = path->nodes[0];\n\tptr = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_generation(leaf, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_version(leaf, ptr, BTRFS_QGROUP_STATUS_VERSION);\n\tfs_info->qgroup_flags = BTRFS_QGROUP_STATUS_FLAG_ON |\n\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\tbtrfs_set_qgroup_status_flags(leaf, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_rescan(leaf, ptr, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot_for_read(tree_root, &key, path, 1, 0);\n\tif (ret > 0)\n\t\tgoto out_add_root;\n\tif (ret < 0)\n\t\tgoto out_free_path;\n\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_ROOT_REF_KEY) {\n\t\t\tret = add_qgroup_item(trans, quota_root,\n\t\t\t\t\t      found_key.offset);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_path;\n\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out_free_path;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_next_item(tree_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_path;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_add_root:\n\tbtrfs_release_path(path);\n\tret = add_qgroup_item(trans, quota_root, BTRFS_FS_TREE_OBJECTID);\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tqgroup = add_qgroup_rb(fs_info, BTRFS_FS_TREE_OBJECTID);\n\tif (IS_ERR(qgroup)) {\n\t\tret = PTR_ERR(qgroup);\n\t\tgoto out_free_path;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_root = quota_root;\n\tfs_info->pending_quota_state = 1;\n\tspin_unlock(&fs_info->qgroup_lock);\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_root:\n\tif (ret) {\n\t\tfree_extent_buffer(quota_root->node);\n\t\tfree_extent_buffer(quota_root->commit_root);\n\t\tkfree(quota_root);\n\t}\nout:\n\tif (ret) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t}\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "fs_info->qgroup_ulist"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "quota_root"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "quota_root->commit_root"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->qgroup_lock"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qgroup"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qgroup"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_qgroup_rb",
          "args": [
            "fs_info",
            "BTRFS_FS_TREE_OBJECTID"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "130-162",
          "snippet": "static struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_qgroup_item",
          "args": [
            "trans",
            "quota_root",
            "BTRFS_FS_TREE_OBJECTID"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "532-598",
          "snippet": "static int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "tree_root",
            "path"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qgroup"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qgroup"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "tree_root",
            "&key",
            "path",
            "1",
            "0"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_rescan",
          "args": [
            "leaf",
            "ptr",
            "0"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_flags",
          "args": [
            "leaf",
            "ptr",
            "fs_info->qgroup_flags"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_version",
          "args": [
            "leaf",
            "ptr",
            "BTRFS_QGROUP_STATUS_VERSION"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_generation",
          "args": [
            "leaf",
            "ptr",
            "trans->transid"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_qgroup_status_item"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "quota_root",
            "path",
            "&key",
            "sizeof(*ptr)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "quota_root"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "quota_root"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_tree",
          "args": [
            "trans",
            "fs_info",
            "BTRFS_QUOTA_TREE_OBJECTID"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1313-1391",
          "snippet": "struct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct btrfs_root *btrfs_create_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t     u64 objectid)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *root;\n\tstruct btrfs_key key;\n\tint ret = 0;\n\tuuid_le uuid;\n\n\troot = btrfs_alloc_root(fs_info);\n\tif (!root)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t__setup_root(tree_root->nodesize, tree_root->sectorsize,\n\t\ttree_root->stripesize, root, fs_info, objectid);\n\troot->root_key.objectid = objectid;\n\troot->root_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot->root_key.offset = 0;\n\n\tleaf = btrfs_alloc_tree_block(trans, root, 0, objectid, NULL, 0, 0, 0);\n\tif (IS_ERR(leaf)) {\n\t\tret = PTR_ERR(leaf);\n\t\tleaf = NULL;\n\t\tgoto fail;\n\t}\n\n\tmemset_extent_buffer(leaf, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(leaf, leaf->start);\n\tbtrfs_set_header_generation(leaf, trans->transid);\n\tbtrfs_set_header_backref_rev(leaf, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(leaf, objectid);\n\troot->node = leaf;\n\n\twrite_extent_buffer(leaf, fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\twrite_extent_buffer(leaf, fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(leaf),\n\t\t\t    BTRFS_UUID_SIZE);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\troot->commit_root = btrfs_root_node(root);\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state);\n\n\troot->root_item.flags = 0;\n\troot->root_item.byte_limit = 0;\n\tbtrfs_set_root_bytenr(&root->root_item, leaf->start);\n\tbtrfs_set_root_generation(&root->root_item, trans->transid);\n\tbtrfs_set_root_level(&root->root_item, 0);\n\tbtrfs_set_root_refs(&root->root_item, 1);\n\tbtrfs_set_root_used(&root->root_item, leaf->len);\n\tbtrfs_set_root_last_snapshot(&root->root_item, 0);\n\tbtrfs_set_root_dirid(&root->root_item, 0);\n\tuuid_le_gen(&uuid);\n\tmemcpy(root->root_item.uuid, uuid.b, BTRFS_UUID_SIZE);\n\troot->root_item.drop_level = 0;\n\n\tkey.objectid = objectid;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_insert_root(trans, tree_root, &key, &root->root_item);\n\tif (ret)\n\t\tgoto fail;\n\n\tbtrfs_tree_unlock(leaf);\n\n\treturn root;\n\nfail:\n\tif (leaf) {\n\t\tbtrfs_tree_unlock(leaf);\n\t\tfree_extent_buffer(root->commit_root);\n\t\tfree_extent_buffer(leaf);\n\t}\n\tkfree(root);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->qgroup_ioctl_lock"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_quota_enable(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_qgroup *qgroup = NULL;\n\tint ret = 0;\n\tint slot;\n\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\tif (fs_info->quota_root) {\n\t\tfs_info->pending_quota_state = 1;\n\t\tgoto out;\n\t}\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * initially create the quota tree\n\t */\n\tquota_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t       BTRFS_QUOTA_TREE_OBJECTID);\n\tif (IS_ERR(quota_root)) {\n\t\tret =  PTR_ERR(quota_root);\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_root;\n\t}\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*ptr));\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tleaf = path->nodes[0];\n\tptr = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_generation(leaf, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_version(leaf, ptr, BTRFS_QGROUP_STATUS_VERSION);\n\tfs_info->qgroup_flags = BTRFS_QGROUP_STATUS_FLAG_ON |\n\t\t\t\tBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\tbtrfs_set_qgroup_status_flags(leaf, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_rescan(leaf, ptr, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_ROOT_REF_KEY;\n\tkey.offset = 0;\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot_for_read(tree_root, &key, path, 1, 0);\n\tif (ret > 0)\n\t\tgoto out_add_root;\n\tif (ret < 0)\n\t\tgoto out_free_path;\n\n\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_ROOT_REF_KEY) {\n\t\t\tret = add_qgroup_item(trans, quota_root,\n\t\t\t\t\t      found_key.offset);\n\t\t\tif (ret)\n\t\t\t\tgoto out_free_path;\n\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out_free_path;\n\t\t\t}\n\t\t}\n\t\tret = btrfs_next_item(tree_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_path;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\nout_add_root:\n\tbtrfs_release_path(path);\n\tret = add_qgroup_item(trans, quota_root, BTRFS_FS_TREE_OBJECTID);\n\tif (ret)\n\t\tgoto out_free_path;\n\n\tqgroup = add_qgroup_rb(fs_info, BTRFS_FS_TREE_OBJECTID);\n\tif (IS_ERR(qgroup)) {\n\t\tret = PTR_ERR(qgroup);\n\t\tgoto out_free_path;\n\t}\n\tspin_lock(&fs_info->qgroup_lock);\n\tfs_info->quota_root = quota_root;\n\tfs_info->pending_quota_state = 1;\n\tspin_unlock(&fs_info->qgroup_lock);\nout_free_path:\n\tbtrfs_free_path(path);\nout_free_root:\n\tif (ret) {\n\t\tfree_extent_buffer(quota_root->node);\n\t\tfree_extent_buffer(quota_root->commit_root);\n\t\tkfree(quota_root);\n\t}\nout:\n\tif (ret) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t}\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_clean_quota_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "778-822",
    "snippet": "static int btrfs_clean_quota_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf = NULL;\n\tint ret;\n\tint nr = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = 0;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tnr = btrfs_header_nritems(leaf);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\t/*\n\t\t * delete the leaf one by one\n\t\t * since the whole tree is going\n\t\t * to be deleted.\n\t\t */\n\t\tpath->slots[0] = 0;\n\t\tret = btrfs_del_items(trans, root, path, 0, nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\troot->fs_info->pending_quota_state = 0;\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_items",
          "args": [
            "trans",
            "root",
            "path",
            "0",
            "nr"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4930-5039",
          "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int btrfs_clean_quota_tree(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf = NULL;\n\tint ret;\n\tint nr = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tpath->leave_spinning = 1;\n\n\tkey.objectid = 0;\n\tkey.offset = 0;\n\tkey.type = 0;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tleaf = path->nodes[0];\n\t\tnr = btrfs_header_nritems(leaf);\n\t\tif (!nr)\n\t\t\tbreak;\n\t\t/*\n\t\t * delete the leaf one by one\n\t\t * since the whole tree is going\n\t\t * to be deleted.\n\t\t */\n\t\tpath->slots[0] = 0;\n\t\tret = btrfs_del_items(trans, root, path, 0, nr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tbtrfs_release_path(path);\n\t}\n\tret = 0;\nout:\n\troot->fs_info->pending_quota_state = 0;\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_qgroup_status_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "734-773",
    "snippet": "static int update_qgroup_status_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr(l, slot, struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_flags(l, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_generation(l, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_rescan(l, ptr,\n\t\t\t\tfs_info->qgroup_rescan_progress.objectid);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "l"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_rescan",
          "args": [
            "l",
            "ptr",
            "fs_info->qgroup_rescan_progress.objectid"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_generation",
          "args": [
            "l",
            "ptr",
            "trans->transid"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_status_flags",
          "args": [
            "l",
            "ptr",
            "fs_info->qgroup_flags"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_status_item"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int update_qgroup_status_item(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct btrfs_root *root)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_status_item *ptr;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_STATUS_KEY;\n\tkey.offset = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tptr = btrfs_item_ptr(l, slot, struct btrfs_qgroup_status_item);\n\tbtrfs_set_qgroup_status_flags(l, ptr, fs_info->qgroup_flags);\n\tbtrfs_set_qgroup_status_generation(l, ptr, trans->transid);\n\tbtrfs_set_qgroup_status_rescan(l, ptr,\n\t\t\t\tfs_info->qgroup_rescan_progress.objectid);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_qgroup_info_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "689-732",
    "snippet": "static int update_qgroup_info_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tint ret;\n\tint slot;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroup->qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_info = btrfs_item_ptr(l, slot, struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(l, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(l, qgroup_info, qgroup->rfer);\n\tbtrfs_set_qgroup_info_rfer_cmpr(l, qgroup_info, qgroup->rfer_cmpr);\n\tbtrfs_set_qgroup_info_excl(l, qgroup_info, qgroup->excl);\n\tbtrfs_set_qgroup_info_excl_cmpr(l, qgroup_info, qgroup->excl_cmpr);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "l"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_excl_cmpr",
          "args": [
            "l",
            "qgroup_info",
            "qgroup->excl_cmpr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_excl",
          "args": [
            "l",
            "qgroup_info",
            "qgroup->excl"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_rfer_cmpr",
          "args": [
            "l",
            "qgroup_info",
            "qgroup->rfer_cmpr"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_rfer",
          "args": [
            "l",
            "qgroup_info",
            "qgroup->rfer"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_generation",
          "args": [
            "l",
            "qgroup_info",
            "trans->transid"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_info_item"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_is_dummy_root",
          "args": [
            "root"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_is_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4198-4205",
          "snippet": "static inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_DUMMY_ROOT\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_DUMMY_ROOT\t\t4\n\nstatic inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_qgroup_info_item(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tint ret;\n\tint slot;\n\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroup->qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_info = btrfs_item_ptr(l, slot, struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(l, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(l, qgroup_info, qgroup->rfer);\n\tbtrfs_set_qgroup_info_rfer_cmpr(l, qgroup_info, qgroup->rfer_cmpr);\n\tbtrfs_set_qgroup_info_excl(l, qgroup_info, qgroup->excl);\n\tbtrfs_set_qgroup_info_excl_cmpr(l, qgroup_info, qgroup->excl_cmpr);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "update_qgroup_limit_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "646-687",
    "snippet": "static int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "l"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_rsv_excl",
          "args": [
            "l",
            "qgroup_limit",
            "rsv_excl"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_rsv_rfer",
          "args": [
            "l",
            "qgroup_limit",
            "rsv_rfer"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_max_excl",
          "args": [
            "l",
            "qgroup_limit",
            "max_excl"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_max_rfer",
          "args": [
            "l",
            "qgroup_limit",
            "max_rfer"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_flags",
          "args": [
            "l",
            "qgroup_limit",
            "flags"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_limit_item"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root, u64 qgroupid,\n\t\t\t\t    u64 flags, u64 max_rfer, u64 max_excl,\n\t\t\t\t    u64 rsv_rfer, u64 rsv_excl)\n{\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *l;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tint ret;\n\tint slot;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tkey.offset = qgroupid;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tif (ret > 0)\n\t\tret = -ENOENT;\n\n\tif (ret)\n\t\tgoto out;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tqgroup_limit = btrfs_item_ptr(l, slot, struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\n\tbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\n\tbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\n\tbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\n\tbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\n\n\tbtrfs_mark_buffer_dirty(l);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "del_qgroup_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "600-644",
    "snippet": "static int del_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "quota_root",
            "path"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "quota_root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int del_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\tif (ret)\n\t\tgoto out;\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\n\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_qgroup_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "532-598",
    "snippet": "static int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_rsv_excl",
          "args": [
            "leaf",
            "qgroup_limit",
            "0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_rsv_rfer",
          "args": [
            "leaf",
            "qgroup_limit",
            "0"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_max_excl",
          "args": [
            "leaf",
            "qgroup_limit",
            "0"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_max_rfer",
          "args": [
            "leaf",
            "qgroup_limit",
            "0"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_limit_flags",
          "args": [
            "leaf",
            "qgroup_limit",
            "0"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_qgroup_limit_item"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "quota_root",
            "path",
            "&key",
            "sizeof(*qgroup_limit)"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_excl_cmpr",
          "args": [
            "leaf",
            "qgroup_info",
            "0"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_excl",
          "args": [
            "leaf",
            "qgroup_info",
            "0"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_rfer_cmpr",
          "args": [
            "leaf",
            "qgroup_info",
            "0"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_rfer",
          "args": [
            "leaf",
            "qgroup_info",
            "0"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_qgroup_info_generation",
          "args": [
            "leaf",
            "qgroup_info",
            "trans->transid"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_qgroup_info_item"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_is_dummy_root",
          "args": [
            "quota_root"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_is_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4198-4205",
          "snippet": "static inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_DUMMY_ROOT\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_DUMMY_ROOT\t\t4\n\nstatic inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_item(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *quota_root, u64 qgroupid)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_qgroup_info_item *qgroup_info;\n\tstruct btrfs_qgroup_limit_item *qgroup_limit;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\tif (btrfs_test_is_dummy_root(quota_root))\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_INFO_KEY;\n\tkey.offset = qgroupid;\n\n\t/*\n\t * Avoid a transaction abort by catching -EEXIST here. In that\n\t * case, we proceed by re-initializing the existing structure\n\t * on disk.\n\t */\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_info));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t struct btrfs_qgroup_info_item);\n\tbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\n\tbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\n\tbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tbtrfs_release_path(path);\n\n\tkey.type = BTRFS_QGROUP_LIMIT_KEY;\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key,\n\t\t\t\t      sizeof(*qgroup_limit));\n\tif (ret && ret != -EEXIST)\n\t\tgoto out;\n\n\tleaf = path->nodes[0];\n\tqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t  struct btrfs_qgroup_limit_item);\n\tbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\n\tbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\n\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "del_qgroup_relation_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "501-530",
    "snippet": "static int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_item",
          "args": [
            "trans",
            "quota_root",
            "path"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3562-3567",
          "snippet": "static inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_del_item(struct btrfs_trans_handle *trans,\n\t\t\t\t struct btrfs_root *root,\n\t\t\t\t struct btrfs_path *path)\n{\n\treturn btrfs_del_items(trans, root, path, path->slots[0], 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "quota_root",
            "&key",
            "path",
            "-1",
            "1"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_del_item(trans, quota_root, path);\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_qgroup_relation_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "477-499",
    "snippet": "static int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[0]"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "quota_root",
            "path",
            "&key",
            "0"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *quota_root,\n\t\t\t\t    u64 src, u64 dst)\n{\n\tint ret;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tkey.objectid = src;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = dst;\n\n\tret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\n\n\tbtrfs_mark_buffer_dirty(path->nodes[0]);\n\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_free_qgroup_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "458-475",
    "snippet": "void btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "fs_info->qgroup_ulist"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__del_qgroup_rb",
          "args": [
            "qgroup"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__del_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "164-185",
          "snippet": "static void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&fs_info->qgroup_tree"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup",
            "node"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&fs_info->qgroup_tree"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct rb_node *n;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile ((n = rb_first(&fs_info->qgroup_tree))) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\trb_erase(n, &fs_info->qgroup_tree);\n\t\t__del_qgroup_rb(qgroup);\n\t}\n\t/*\n\t * we call btrfs_free_qgroup_config() when umounting\n\t * filesystem and disabling quota, so we set qgroup_ulit\n\t * to be null here to avoid double free.\n\t */\n\tulist_free(fs_info->qgroup_ulist);\n\tfs_info->qgroup_ulist = NULL;\n}"
  },
  {
    "function_name": "btrfs_read_qgroup_config",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "268-450",
    "snippet": "int btrfs_read_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *l;\n\tint slot;\n\tint ret = 0;\n\tu64 flags = 0;\n\tu64 rescan_progress = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* default this to quota off, in case no status key is found */\n\tfs_info->qgroup_flags = 0;\n\n\t/*\n\t * pass 1: read status, all qgroup infos and limits\n\t */\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct btrfs_qgroup *qgroup;\n\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\n\t\t\tstruct btrfs_qgroup_status_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_status_item);\n\n\t\t\tif (btrfs_qgroup_status_version(l, ptr) !=\n\t\t\t    BTRFS_QGROUP_STATUS_VERSION) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t \"old qgroup version, quota disabled\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (btrfs_qgroup_status_generation(l, ptr) !=\n\t\t\t    fs_info->generation) {\n\t\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t\"qgroup generation mismatch, \"\n\t\t\t\t\t\"marked as inconsistent\");\n\t\t\t}\n\t\t\tfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\n\t\t\t\t\t\t\t\t\t  ptr);\n\t\t\trescan_progress = btrfs_qgroup_status_rescan(l, ptr);\n\t\t\tgoto next1;\n\t\t}\n\n\t\tif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\n\t\t    found_key.type != BTRFS_QGROUP_LIMIT_KEY)\n\t\t\tgoto next1;\n\n\t\tqgroup = find_qgroup_rb(fs_info, found_key.offset);\n\t\tif ((qgroup && found_key.type == BTRFS_QGROUP_INFO_KEY) ||\n\t\t    (!qgroup && found_key.type == BTRFS_QGROUP_LIMIT_KEY)) {\n\t\t\tbtrfs_err(fs_info, \"inconsitent qgroup config\");\n\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t}\n\t\tif (!qgroup) {\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (found_key.type) {\n\t\tcase BTRFS_QGROUP_INFO_KEY: {\n\t\t\tstruct btrfs_qgroup_info_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_info_item);\n\t\t\tqgroup->rfer = btrfs_qgroup_info_rfer(l, ptr);\n\t\t\tqgroup->rfer_cmpr = btrfs_qgroup_info_rfer_cmpr(l, ptr);\n\t\t\tqgroup->excl = btrfs_qgroup_info_excl(l, ptr);\n\t\t\tqgroup->excl_cmpr = btrfs_qgroup_info_excl_cmpr(l, ptr);\n\t\t\t/* generation currently unused */\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_QGROUP_LIMIT_KEY: {\n\t\t\tstruct btrfs_qgroup_limit_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_limit_item);\n\t\t\tqgroup->lim_flags = btrfs_qgroup_limit_flags(l, ptr);\n\t\t\tqgroup->max_rfer = btrfs_qgroup_limit_max_rfer(l, ptr);\n\t\t\tqgroup->max_excl = btrfs_qgroup_limit_max_excl(l, ptr);\n\t\t\tqgroup->rsv_rfer = btrfs_qgroup_limit_rsv_rfer(l, ptr);\n\t\t\tqgroup->rsv_excl = btrfs_qgroup_limit_rsv_excl(l, ptr);\n\t\t\tbreak;\n\t\t}\n\t\t}\nnext1:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pass 2: read all qgroup relations\n\t */\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 0);\n\tif (ret)\n\t\tgoto out;\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type != BTRFS_QGROUP_RELATION_KEY)\n\t\t\tgoto next2;\n\n\t\tif (found_key.objectid > found_key.offset) {\n\t\t\t/* parent <- member, not needed to build config */\n\t\t\t/* FIXME should we omit the key completely? */\n\t\t\tgoto next2;\n\t\t}\n\n\t\tret = add_relation_rb(fs_info, found_key.objectid,\n\t\t\t\t      found_key.offset);\n\t\tif (ret == -ENOENT) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"orphan qgroup relation 0x%llx->0x%llx\",\n\t\t\t\tfound_key.objectid, found_key.offset);\n\t\t\tret = 0;\t/* ignore the error */\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\nnext2:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tfs_info->qgroup_flags |= flags;\n\tif (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON)) {\n\t\tfs_info->quota_enabled = 0;\n\t\tfs_info->pending_quota_state = 0;\n\t} else if (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN &&\n\t\t   ret >= 0) {\n\t\tret = qgroup_rescan_init(fs_info, rescan_progress, 0);\n\t}\n\tbtrfs_free_path(path);\n\n\tif (ret < 0) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "fs_info->qgroup_ulist"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qgroup_rescan_init",
          "args": [
            "fs_info",
            "rescan_progress",
            "0"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "qgroup_rescan_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "2685-2738",
          "snippet": "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);",
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags);\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\n\t\t   int init_flags)\n{\n\tint ret = 0;\n\n\tif (!init_flags &&\n\t    (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\n\t     !(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&fs_info->qgroup_rescan_lock);\n\tspin_lock(&fs_info->qgroup_lock);\n\n\tif (init_flags) {\n\t\tif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\n\t\t\tret = -EINPROGRESS;\n\t\telse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\n\t\t\tret = -EINVAL;\n\n\t\tif (ret) {\n\t\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\t\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\t\t\tgoto err;\n\t\t}\n\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\tmemset(&fs_info->qgroup_rescan_progress, 0,\n\t\tsizeof(fs_info->qgroup_rescan_progress));\n\tfs_info->qgroup_rescan_progress.objectid = progress_objectid;\n\n\tspin_unlock(&fs_info->qgroup_lock);\n\tmutex_unlock(&fs_info->qgroup_rescan_lock);\n\n\tinit_completion(&fs_info->qgroup_rescan_completion);\n\n\tmemset(&fs_info->qgroup_rescan_work, 0,\n\t       sizeof(fs_info->qgroup_rescan_work));\n\tbtrfs_init_work(&fs_info->qgroup_rescan_work,\n\t\t\tbtrfs_qgroup_rescan_helper,\n\t\t\tbtrfs_qgroup_rescan_worker, NULL, NULL);\n\n\tif (ret) {\nerr:\n\t\tbtrfs_info(fs_info, \"qgroup_rescan_init failed with %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "quota_root",
            "path"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"orphan qgroup relation 0x%llx->0x%llx\"",
            "found_key.objectid",
            "found_key.offset"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_relation_rb",
          "args": [
            "fs_info",
            "found_key.objectid",
            "found_key.offset"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "add_relation_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "201-223",
          "snippet": "static int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "l",
            "&found_key",
            "slot"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot_for_read",
          "args": [
            "quota_root",
            "&key",
            "path",
            "1",
            "0"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3057-3119",
          "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_limit_rsv_excl",
          "args": [
            "l",
            "ptr"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_limit_rsv_rfer",
          "args": [
            "l",
            "ptr"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_limit_max_excl",
          "args": [
            "l",
            "ptr"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_limit_max_rfer",
          "args": [
            "l",
            "ptr"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_limit_flags",
          "args": [
            "l",
            "ptr"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_limit_item"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_info_excl_cmpr",
          "args": [
            "l",
            "ptr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_info_excl",
          "args": [
            "l",
            "ptr"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_info_rfer_cmpr",
          "args": [
            "l",
            "ptr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_info_rfer",
          "args": [
            "l",
            "ptr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_info_item"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "qgroup"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "qgroup"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_qgroup_rb",
          "args": [
            "fs_info",
            "found_key.offset"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "add_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "130-162",
          "snippet": "static struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"inconsitent qgroup config\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "found_key.offset"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_status_rescan",
          "args": [
            "l",
            "ptr"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_status_flags",
          "args": [
            "l",
            "ptr"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"qgroup generation mismatch, \"\n\t\t\t\t\t\"marked as inconsistent\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_status_generation",
          "args": [
            "l",
            "ptr"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"old qgroup version, quota disabled\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_qgroup_status_version",
          "args": [
            "l",
            "ptr"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "l",
            "slot",
            "structbtrfs_qgroup_status_item"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_read_qgroup_config(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *quota_root = fs_info->quota_root;\n\tstruct btrfs_path *path = NULL;\n\tstruct extent_buffer *l;\n\tint slot;\n\tint ret = 0;\n\tu64 flags = 0;\n\tu64 rescan_progress = 0;\n\n\tif (!fs_info->quota_enabled)\n\t\treturn 0;\n\n\tfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\n\tif (!fs_info->qgroup_ulist) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t/* default this to quota off, in case no status key is found */\n\tfs_info->qgroup_flags = 0;\n\n\t/*\n\t * pass 1: read status, all qgroup infos and limits\n\t */\n\tkey.objectid = 0;\n\tkey.type = 0;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\n\tif (ret)\n\t\tgoto out;\n\n\twhile (1) {\n\t\tstruct btrfs_qgroup *qgroup;\n\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\n\t\t\tstruct btrfs_qgroup_status_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_status_item);\n\n\t\t\tif (btrfs_qgroup_status_version(l, ptr) !=\n\t\t\t    BTRFS_QGROUP_STATUS_VERSION) {\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t \"old qgroup version, quota disabled\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (btrfs_qgroup_status_generation(l, ptr) !=\n\t\t\t    fs_info->generation) {\n\t\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\t\"qgroup generation mismatch, \"\n\t\t\t\t\t\"marked as inconsistent\");\n\t\t\t}\n\t\t\tfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\n\t\t\t\t\t\t\t\t\t  ptr);\n\t\t\trescan_progress = btrfs_qgroup_status_rescan(l, ptr);\n\t\t\tgoto next1;\n\t\t}\n\n\t\tif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\n\t\t    found_key.type != BTRFS_QGROUP_LIMIT_KEY)\n\t\t\tgoto next1;\n\n\t\tqgroup = find_qgroup_rb(fs_info, found_key.offset);\n\t\tif ((qgroup && found_key.type == BTRFS_QGROUP_INFO_KEY) ||\n\t\t    (!qgroup && found_key.type == BTRFS_QGROUP_LIMIT_KEY)) {\n\t\t\tbtrfs_err(fs_info, \"inconsitent qgroup config\");\n\t\t\tflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\n\t\t}\n\t\tif (!qgroup) {\n\t\t\tqgroup = add_qgroup_rb(fs_info, found_key.offset);\n\t\t\tif (IS_ERR(qgroup)) {\n\t\t\t\tret = PTR_ERR(qgroup);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (found_key.type) {\n\t\tcase BTRFS_QGROUP_INFO_KEY: {\n\t\t\tstruct btrfs_qgroup_info_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_info_item);\n\t\t\tqgroup->rfer = btrfs_qgroup_info_rfer(l, ptr);\n\t\t\tqgroup->rfer_cmpr = btrfs_qgroup_info_rfer_cmpr(l, ptr);\n\t\t\tqgroup->excl = btrfs_qgroup_info_excl(l, ptr);\n\t\t\tqgroup->excl_cmpr = btrfs_qgroup_info_excl_cmpr(l, ptr);\n\t\t\t/* generation currently unused */\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_QGROUP_LIMIT_KEY: {\n\t\t\tstruct btrfs_qgroup_limit_item *ptr;\n\n\t\t\tptr = btrfs_item_ptr(l, slot,\n\t\t\t\t\t     struct btrfs_qgroup_limit_item);\n\t\t\tqgroup->lim_flags = btrfs_qgroup_limit_flags(l, ptr);\n\t\t\tqgroup->max_rfer = btrfs_qgroup_limit_max_rfer(l, ptr);\n\t\t\tqgroup->max_excl = btrfs_qgroup_limit_max_excl(l, ptr);\n\t\t\tqgroup->rsv_rfer = btrfs_qgroup_limit_rsv_rfer(l, ptr);\n\t\t\tqgroup->rsv_excl = btrfs_qgroup_limit_rsv_excl(l, ptr);\n\t\t\tbreak;\n\t\t}\n\t\t}\nnext1:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tbtrfs_release_path(path);\n\n\t/*\n\t * pass 2: read all qgroup relations\n\t */\n\tkey.objectid = 0;\n\tkey.type = BTRFS_QGROUP_RELATION_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 0);\n\tif (ret)\n\t\tgoto out;\n\twhile (1) {\n\t\tslot = path->slots[0];\n\t\tl = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(l, &found_key, slot);\n\n\t\tif (found_key.type != BTRFS_QGROUP_RELATION_KEY)\n\t\t\tgoto next2;\n\n\t\tif (found_key.objectid > found_key.offset) {\n\t\t\t/* parent <- member, not needed to build config */\n\t\t\t/* FIXME should we omit the key completely? */\n\t\t\tgoto next2;\n\t\t}\n\n\t\tret = add_relation_rb(fs_info, found_key.objectid,\n\t\t\t\t      found_key.offset);\n\t\tif (ret == -ENOENT) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"orphan qgroup relation 0x%llx->0x%llx\",\n\t\t\t\tfound_key.objectid, found_key.offset);\n\t\t\tret = 0;\t/* ignore the error */\n\t\t}\n\t\tif (ret)\n\t\t\tgoto out;\nnext2:\n\t\tret = btrfs_next_item(quota_root, path);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tfs_info->qgroup_flags |= flags;\n\tif (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON)) {\n\t\tfs_info->quota_enabled = 0;\n\t\tfs_info->pending_quota_state = 0;\n\t} else if (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN &&\n\t\t   ret >= 0) {\n\t\tret = qgroup_rescan_init(fs_info, rescan_progress, 0);\n\t}\n\tbtrfs_free_path(path);\n\n\tif (ret < 0) {\n\t\tulist_free(fs_info->qgroup_ulist);\n\t\tfs_info->qgroup_ulist = NULL;\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\n\t}\n\n\treturn ret < 0 ? ret : 0;\n}"
  },
  {
    "function_name": "btrfs_verify_qgroup_counts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "250-261",
    "snippet": "int btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nint btrfs_verify_qgroup_counts(struct btrfs_fs_info *fs_info, u64 qgroupid,\n\t\t\t       u64 rfer, u64 excl)\n{\n\tstruct btrfs_qgroup *qgroup;\n\n\tqgroup = find_qgroup_rb(fs_info, qgroupid);\n\tif (!qgroup)\n\t\treturn -EINVAL;\n\tif (qgroup->rfer != rfer || qgroup->excl != excl)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "del_relation_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "226-247",
    "snippet": "static int del_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tlist_del(&list->next_group);\n\t\t\tlist_del(&list->next_member);\n\t\t\tkfree(list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "list"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&list->next_member"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list",
            "&member->groups",
            "next_group"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "parentid"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int del_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist_for_each_entry(list, &member->groups, next_group) {\n\t\tif (list->group == parent) {\n\t\t\tlist_del(&list->next_group);\n\t\t\tlist_del(&list->next_member);\n\t\t\tkfree(list);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "add_relation_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "201-223",
    "snippet": "static int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&list->next_member",
            "&parent->members"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&list->next_group",
            "&member->groups"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*list)",
            "GFP_ATOMIC"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "parentid"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int add_relation_rb(struct btrfs_fs_info *fs_info,\n\t\t\t   u64 memberid, u64 parentid)\n{\n\tstruct btrfs_qgroup *member;\n\tstruct btrfs_qgroup *parent;\n\tstruct btrfs_qgroup_list *list;\n\n\tmember = find_qgroup_rb(fs_info, memberid);\n\tparent = find_qgroup_rb(fs_info, parentid);\n\tif (!member || !parent)\n\t\treturn -ENOENT;\n\n\tlist = kzalloc(sizeof(*list), GFP_ATOMIC);\n\tif (!list)\n\t\treturn -ENOMEM;\n\n\tlist->group = parent;\n\tlist->member = member;\n\tlist_add_tail(&list->next_group, &member->groups);\n\tlist_add_tail(&list->next_member, &parent->members);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "del_qgroup_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "188-198",
    "snippet": "static int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);\n\n\tif (!qgroup)\n\t\treturn -ENOENT;\n\n\trb_erase(&qgroup->node, &fs_info->qgroup_tree);\n\t__del_qgroup_rb(qgroup);\n\treturn 0;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__del_qgroup_rb",
          "args": [
            "qgroup"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__del_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "164-185",
          "snippet": "static void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&qgroup->node",
            "&fs_info->qgroup_tree"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_qgroup_rb",
          "args": [
            "fs_info",
            "qgroupid"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "find_qgroup_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
          "lines": "111-127",
          "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"ulist.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)\n{\n\tstruct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);\n\n\tif (!qgroup)\n\t\treturn -ENOENT;\n\n\trb_erase(&qgroup->node, &fs_info->qgroup_tree);\n\t__del_qgroup_rb(qgroup);\n\treturn 0;\n}"
  },
  {
    "function_name": "__del_qgroup_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "164-185",
    "snippet": "static void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "qgroup"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "list"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&list->next_member"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&qgroup->members",
            "structbtrfs_qgroup_list",
            "next_member"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&qgroup->members"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "list"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&qgroup->groups",
            "structbtrfs_qgroup_list",
            "next_group"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\n{\n\tstruct btrfs_qgroup_list *list;\n\n\tlist_del(&qgroup->dirty);\n\twhile (!list_empty(&qgroup->groups)) {\n\t\tlist = list_first_entry(&qgroup->groups,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_group);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\n\twhile (!list_empty(&qgroup->members)) {\n\t\tlist = list_first_entry(&qgroup->members,\n\t\t\t\t\tstruct btrfs_qgroup_list, next_member);\n\t\tlist_del(&list->next_group);\n\t\tlist_del(&list->next_member);\n\t\tkfree(list);\n\t}\n\tkfree(qgroup);\n}"
  },
  {
    "function_name": "add_qgroup_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "130-162",
    "snippet": "static struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&qgroup->node",
            "&fs_info->qgroup_tree"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&qgroup->node",
            "parent",
            "p"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&qgroup->dirty"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&qgroup->members"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&qgroup->groups"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*qgroup)",
            "GFP_ATOMIC"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structbtrfs_qgroup",
            "node"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  u64 qgroupid)\n{\n\tstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tqgroup = rb_entry(parent, struct btrfs_qgroup, node);\n\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\n\tqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\n\tif (!qgroup)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tqgroup->qgroupid = qgroupid;\n\tINIT_LIST_HEAD(&qgroup->groups);\n\tINIT_LIST_HEAD(&qgroup->members);\n\tINIT_LIST_HEAD(&qgroup->dirty);\n\n\trb_link_node(&qgroup->node, parent, p);\n\trb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\n\n\treturn qgroup;\n}"
  },
  {
    "function_name": "find_qgroup_rb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/qgroup.c",
    "lines": "111-127",
    "snippet": "static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"qgroup.h\"",
      "#include \"extent_io.h\"",
      "#include \"backref.h\"",
      "#include \"ulist.h\"",
      "#include \"locking.h\"",
      "#include \"disk-io.h\"",
      "#include \"transaction.h\"",
      "#include \"ctree.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_qgroup",
            "node"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qgroup.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"ulist.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void qgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info);\n\nstatic struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 qgroupid)\n{\n\tstruct rb_node *n = fs_info->qgroup_tree.rb_node;\n\tstruct btrfs_qgroup *qgroup;\n\n\twhile (n) {\n\t\tqgroup = rb_entry(n, struct btrfs_qgroup, node);\n\t\tif (qgroup->qgroupid < qgroupid)\n\t\t\tn = n->rb_left;\n\t\telse if (qgroup->qgroupid > qgroupid)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn qgroup;\n\t}\n\treturn NULL;\n}"
  }
]