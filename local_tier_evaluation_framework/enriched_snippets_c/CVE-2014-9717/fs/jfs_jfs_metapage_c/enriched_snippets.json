[
  {
    "function_name": "jfs_mpstat_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "832-835",
    "snippet": "static int jfs_mpstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_mpstat_proc_show, NULL);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "jfs_mpstat_proc_show",
            "NULL"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "single_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "557-575",
          "snippet": "int single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint single_open(struct file *file, int (*show)(struct seq_file *, void *),\n\t\tvoid *data)\n{\n\tstruct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL);\n\tint res = -ENOMEM;\n\n\tif (op) {\n\t\top->start = single_start;\n\t\top->next = single_next;\n\t\top->stop = single_stop;\n\t\top->show = show;\n\t\tres = seq_open(file, op);\n\t\tif (!res)\n\t\t\t((struct seq_file *)file->private_data)->private = data;\n\t\telse\n\t\t\tkfree(op);\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int jfs_mpstat_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, jfs_mpstat_proc_show, NULL);\n}"
  },
  {
    "function_name": "jfs_mpstat_proc_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "818-830",
    "snippet": "static int jfs_mpstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Metapage statistics\\n\"\n\t\t       \"=======================\\n\"\n\t\t       \"page allocations = %d\\n\"\n\t\t       \"page frees = %d\\n\"\n\t\t       \"lock waits = %d\\n\",\n\t\t       mpStat.pagealloc,\n\t\t       mpStat.pagefree,\n\t\t       mpStat.lockwait);\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"JFS Metapage statistics\\n\"\n\t\t       \"=======================\\n\"\n\t\t       \"page allocations = %d\\n\"\n\t\t       \"page frees = %d\\n\"\n\t\t       \"lock waits = %d\\n\"",
            "mpStat.pagealloc",
            "mpStat.pagefree",
            "mpStat.lockwait"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int jfs_mpstat_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m,\n\t\t       \"JFS Metapage statistics\\n\"\n\t\t       \"=======================\\n\"\n\t\t       \"page allocations = %d\\n\"\n\t\t       \"page frees = %d\\n\"\n\t\t       \"lock waits = %d\\n\",\n\t\t       mpStat.pagealloc,\n\t\t       mpStat.pagefree,\n\t\t       mpStat.lockwait);\n\treturn 0;\n}"
  },
  {
    "function_name": "__invalidate_metapages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "777-815",
    "snippet": "void __invalidate_metapages(struct inode *ip, s64 addr, int len)\n{\n\tsector_t lblock;\n\tint l2BlocksPerPage = PAGE_CACHE_SHIFT - ip->i_blkbits;\n\tint BlocksPerPage = 1 << l2BlocksPerPage;\n\t/* All callers are interested in block device's mapping */\n\tstruct address_space *mapping =\n\t\tJFS_SBI(ip->i_sb)->direct_inode->i_mapping;\n\tstruct metapage *mp;\n\tstruct page *page;\n\tunsigned int offset;\n\n\t/*\n\t * Mark metapages to discard.  They will eventually be\n\t * released, but should not be written.\n\t */\n\tfor (lblock = addr & ~(BlocksPerPage - 1); lblock < addr + len;\n\t     lblock += BlocksPerPage) {\n\t\tpage = find_lock_page(mapping, lblock >> l2BlocksPerPage);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\t\tmp = page_to_mp(page, offset);\n\t\t\tif (!mp)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index < addr)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index >= addr + len)\n\t\t\t\tbreak;\n\n\t\t\tclear_bit(META_dirty, &mp->flag);\n\t\t\tset_bit(META_discard, &mp->flag);\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_logsync",
          "args": [
            "mp"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_logsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "299-319",
          "snippet": "static void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_discard",
            "&mp->flag"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_dirty",
            "&mp->flag"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_mp",
          "args": [
            "page",
            "offset"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_mp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "159-162",
          "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "lblock >> l2BlocksPerPage"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "ip->i_sb"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid __invalidate_metapages(struct inode *ip, s64 addr, int len)\n{\n\tsector_t lblock;\n\tint l2BlocksPerPage = PAGE_CACHE_SHIFT - ip->i_blkbits;\n\tint BlocksPerPage = 1 << l2BlocksPerPage;\n\t/* All callers are interested in block device's mapping */\n\tstruct address_space *mapping =\n\t\tJFS_SBI(ip->i_sb)->direct_inode->i_mapping;\n\tstruct metapage *mp;\n\tstruct page *page;\n\tunsigned int offset;\n\n\t/*\n\t * Mark metapages to discard.  They will eventually be\n\t * released, but should not be written.\n\t */\n\tfor (lblock = addr & ~(BlocksPerPage - 1); lblock < addr + len;\n\t     lblock += BlocksPerPage) {\n\t\tpage = find_lock_page(mapping, lblock >> l2BlocksPerPage);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\t\tmp = page_to_mp(page, offset);\n\t\t\tif (!mp)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index < addr)\n\t\t\t\tcontinue;\n\t\t\tif (mp->index >= addr + len)\n\t\t\t\tbreak;\n\n\t\t\tclear_bit(META_dirty, &mp->flag);\n\t\t\tset_bit(META_discard, &mp->flag);\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
  },
  {
    "function_name": "release_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "743-775",
    "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_metapage",
          "args": [
            "page",
            "mp"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "drop_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "240-248",
          "snippet": "static inline void drop_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\n\t    test_bit(META_io, &mp->flag))\n\t\treturn;\n\tremove_metapage(page, mp);\n\tINCREMENT(mpStat.pagefree);\n\tfree_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void drop_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\n\t    test_bit(META_io, &mp->flag))\n\t\treturn;\n\tremove_metapage(page, mp);\n\tINCREMENT(mpStat.pagefree);\n\tfree_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_logsync",
          "args": [
            "mp"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_logsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "299-319",
          "snippet": "static void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_page",
          "args": [
            "page",
            "1"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_sync",
            "&mp->flag"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_sync",
            "&mp->flag"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mp->count"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_metapage",
          "args": [
            "mp"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "47-51",
          "snippet": "static inline void unlock_metapage(struct metapage *mp)\n{\n\tclear_bit_unlock(META_locked, &mp->flag);\n\twake_up(&mp->wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void unlock_metapage(struct metapage *mp)\n{\n\tclear_bit_unlock(META_locked, &mp->flag);\n\twake_up(&mp->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"release_metapage: mp = 0x%p, flag = 0x%lx\"",
            "mp",
            "mp->flag"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "put_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "729-741",
    "snippet": "void put_metapage(struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok) {\n\t\t/* Someone else will release this */\n\t\tunlock_page(mp->page);\n\t\treturn;\n\t}\n\tpage_cache_get(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n\trelease_metapage(mp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_metapage",
          "args": [
            "mp"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "release_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "743-775",
          "snippet": "void release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid release_metapage(struct metapage * mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"release_metapage: mp = 0x%p, flag = 0x%lx\", mp, mp->flag);\n\n\tBUG_ON(!page);\n\n\tlock_page(page);\n\tunlock_metapage(mp);\n\n\tassert(mp->count);\n\tif (--mp->count || mp->nohomeok) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn;\n\t}\n\n\tif (test_bit(META_dirty, &mp->flag)) {\n\t\tset_page_dirty(page);\n\t\tif (test_bit(META_sync, &mp->flag)) {\n\t\t\tclear_bit(META_sync, &mp->flag);\n\t\t\twrite_one_page(page, 1);\n\t\t\tlock_page(page); /* write_one_page unlocks the page */\n\t\t}\n\t} else if (mp->lsn)\t/* discard_metapage doesn't remove it */\n\t\tremove_from_logsync(mp);\n\n\t/* Try to keep metapages from using up too much memory */\n\tdrop_metapage(page, mp);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "mp->page"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_metapage",
          "args": [
            "mp"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "lock_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "73-77",
          "snippet": "static inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "mp->page"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid put_metapage(struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok) {\n\t\t/* Someone else will release this */\n\t\tunlock_page(mp->page);\n\t\treturn;\n\t}\n\tpage_cache_get(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n\trelease_metapage(mp);\n}"
  },
  {
    "function_name": "hold_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "724-727",
    "snippet": "void hold_metapage(struct metapage *mp)\n{\n\tlock_page(mp->page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "mp->page"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid hold_metapage(struct metapage *mp)\n{\n\tlock_page(mp->page);\n}"
  },
  {
    "function_name": "force_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "710-722",
    "snippet": "void force_metapage(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"force_metapage: mp = 0x%p\", mp);\n\tset_bit(META_forcewrite, &mp->flag);\n\tclear_bit(META_sync, &mp->flag);\n\tpage_cache_get(page);\n\tlock_page(page);\n\tset_page_dirty(page);\n\twrite_one_page(page, 1);\n\tclear_bit(META_forcewrite, &mp->flag);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_forcewrite",
            "&mp->flag"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_page",
          "args": [
            "page",
            "1"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_forcewrite",
            "&mp->flag"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"force_metapage: mp = 0x%p\"",
            "mp"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid force_metapage(struct metapage *mp)\n{\n\tstruct page *page = mp->page;\n\tjfs_info(\"force_metapage: mp = 0x%p\", mp);\n\tset_bit(META_forcewrite, &mp->flag);\n\tclear_bit(META_sync, &mp->flag);\n\tpage_cache_get(page);\n\tlock_page(page);\n\tset_page_dirty(page);\n\twrite_one_page(page, 1);\n\tclear_bit(META_forcewrite, &mp->flag);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "grab_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "700-708",
    "snippet": "void grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "mp->page"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_metapage",
          "args": [
            "mp"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "lock_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "73-77",
          "snippet": "static inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "mp->page"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"grab_metapage: mp = 0x%p\"",
            "mp"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nvoid grab_metapage(struct metapage * mp)\n{\n\tjfs_info(\"grab_metapage: mp = 0x%p\", mp);\n\tpage_cache_get(mp->page);\n\tlock_page(mp->page);\n\tmp->count++;\n\tlock_metapage(mp);\n\tunlock_page(mp->page);\n}"
  },
  {
    "function_name": "__get_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "593-698",
    "snippet": "struct metapage *__get_metapage(struct inode *inode, unsigned long lblock,\n\t\t\t\tunsigned int size, int absolute,\n\t\t\t\tunsigned long new)\n{\n\tint l2BlocksPerPage;\n\tint l2bsize;\n\tstruct address_space *mapping;\n\tstruct metapage *mp = NULL;\n\tstruct page *page;\n\tunsigned long page_index;\n\tunsigned long page_offset;\n\n\tjfs_info(\"__get_metapage: ino = %ld, lblock = 0x%lx, abs=%d\",\n\t\t inode->i_ino, lblock, absolute);\n\n\tl2bsize = inode->i_blkbits;\n\tl2BlocksPerPage = PAGE_CACHE_SHIFT - l2bsize;\n\tpage_index = lblock >> l2BlocksPerPage;\n\tpage_offset = (lblock - (page_index << l2BlocksPerPage)) << l2bsize;\n\tif ((page_offset + size) > PAGE_CACHE_SIZE) {\n\t\tjfs_err(\"MetaData crosses page boundary!!\");\n\t\tjfs_err(\"lblock = %lx, size  = %d\", lblock, size);\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tif (absolute)\n\t\tmapping = JFS_SBI(inode->i_sb)->direct_inode->i_mapping;\n\telse {\n\t\t/*\n\t\t * If an nfs client tries to read an inode that is larger\n\t\t * than any existing inodes, we may try to read past the\n\t\t * end of the inode map\n\t\t */\n\t\tif ((lblock << inode->i_blkbits) >= inode->i_size)\n\t\t\treturn NULL;\n\t\tmapping = inode->i_mapping;\n\t}\n\n\tif (new && (PSIZE == PAGE_CACHE_SIZE)) {\n\t\tpage = grab_cache_page(mapping, page_index);\n\t\tif (!page) {\n\t\t\tjfs_err(\"grab_cache_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tpage = read_mapping_page(mapping, page_index, NULL);\n\t\tif (IS_ERR(page) || !PageUptodate(page)) {\n\t\t\tjfs_err(\"read_mapping_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlock_page(page);\n\t}\n\n\tmp = page_to_mp(page, page_offset);\n\tif (mp) {\n\t\tif (mp->logical_size != size) {\n\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t  \"get_mp->logical_size != size\\n\");\n\t\t\tjfs_err(\"logical_size = %d, size = %d\",\n\t\t\t\tmp->logical_size, size);\n\t\t\tdump_stack();\n\t\t\tgoto unlock;\n\t\t}\n\t\tmp->count++;\n\t\tlock_metapage(mp);\n\t\tif (test_bit(META_discard, &mp->flag)) {\n\t\t\tif (!new) {\n\t\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t\t  \"using a discarded metapage\\n\");\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tclear_bit(META_discard, &mp->flag);\n\t\t}\n\t} else {\n\t\tINCREMENT(mpStat.pagealloc);\n\t\tmp = alloc_metapage(GFP_NOFS);\n\t\tmp->page = page;\n\t\tmp->flag = 0;\n\t\tmp->xflag = COMMIT_PAGE;\n\t\tmp->count = 1;\n\t\tmp->nohomeok = 0;\n\t\tmp->logical_size = size;\n\t\tmp->data = page_address(page) + page_offset;\n\t\tmp->index = lblock;\n\t\tif (unlikely(insert_metapage(page, mp))) {\n\t\t\tfree_metapage(mp);\n\t\t\tgoto unlock;\n\t\t}\n\t\tlock_metapage(mp);\n\t}\n\n\tif (new) {\n\t\tjfs_info(\"zeroing mp = 0x%p\", mp);\n\t\tmemset(mp->data, 0, PSIZE);\n\t}\n\n\tunlock_page(page);\n\tjfs_info(\"__get_metapage: returning = 0x%p data = 0x%p\", mp, mp->data);\n\treturn mp;\n\nunlock:\n\tunlock_page(page);\n\treturn NULL;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"__get_metapage: returning = 0x%p data = 0x%p\"",
            "mp",
            "mp->data"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mp->data",
            "0",
            "PSIZE"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"zeroing mp = 0x%p\"",
            "mp"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_metapage",
          "args": [
            "mp"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "lock_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "73-77",
          "snippet": "static inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_metapage",
          "args": [
            "mp"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "free_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "205-211",
          "snippet": "static inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "insert_metapage(page, mp)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_metapage",
          "args": [
            "page",
            "mp"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "insert_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "164-172",
          "snippet": "static inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_metapage",
          "args": [
            "GFP_NOFS"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "200-203",
          "snippet": "static inline struct metapage *alloc_metapage(gfp_t gfp_mask)\n{\n\treturn mempool_alloc(metapage_mempool, gfp_mask);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline struct metapage *alloc_metapage(gfp_t gfp_mask)\n{\n\treturn mempool_alloc(metapage_mempool, gfp_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "mpStat.pagealloc"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_discard",
            "&mp->flag"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_metapage",
          "args": [
            "mp"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "discard_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.h",
          "lines": "97-102",
          "snippet": "static inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}",
          "includes": [
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define META_discard\t4",
            "#define META_dirty\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/pagemap.h>\n\n#define META_discard\t4\n#define META_dirty\t2\n\nstatic inline void discard_metapage(struct metapage *mp)\n{\n\tclear_bit(META_dirty, &mp->flag);\n\tset_bit(META_discard, &mp->flag);\n\trelease_metapage(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_error",
          "args": [
            "inode->i_sb",
            "\"using a discarded metapage\\n\""
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/super.c",
          "lines": "95-111",
          "snippet": "void jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}",
          "includes": [
            "#include \"jfs_xattr.h\"",
            "#include \"jfs_debug.h\"",
            "#include \"jfs_acl.h\"",
            "#include \"jfs_imap.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_inode.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/crc32.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/mount.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_xattr.h\"\n#include \"jfs_debug.h\"\n#include \"jfs_acl.h\"\n#include \"jfs_imap.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_inode.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/blkdev.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/crc32.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/posix_acl.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/mount.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/completion.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid jfs_error(struct super_block *sb, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"ERROR: (device %s): %pf: %pV\\n\",\n\t       sb->s_id, __builtin_return_address(0), &vaf);\n\n\tva_end(args);\n\n\tjfs_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_discard",
            "&mp->flag"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_mp",
          "args": [
            "page",
            "page_offset"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_mp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "159-162",
          "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"read_mapping_page failed!\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "page_index",
            "NULL"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"grab_cache_page failed!\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "page_index"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "inode->i_sb"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_err",
          "args": [
            "\"MetaData crosses page boundary!!\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"__get_metapage: ino = %ld, lblock = 0x%lx, abs=%d\"",
            "inode->i_ino",
            "lblock",
            "absolute"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstruct metapage *__get_metapage(struct inode *inode, unsigned long lblock,\n\t\t\t\tunsigned int size, int absolute,\n\t\t\t\tunsigned long new)\n{\n\tint l2BlocksPerPage;\n\tint l2bsize;\n\tstruct address_space *mapping;\n\tstruct metapage *mp = NULL;\n\tstruct page *page;\n\tunsigned long page_index;\n\tunsigned long page_offset;\n\n\tjfs_info(\"__get_metapage: ino = %ld, lblock = 0x%lx, abs=%d\",\n\t\t inode->i_ino, lblock, absolute);\n\n\tl2bsize = inode->i_blkbits;\n\tl2BlocksPerPage = PAGE_CACHE_SHIFT - l2bsize;\n\tpage_index = lblock >> l2BlocksPerPage;\n\tpage_offset = (lblock - (page_index << l2BlocksPerPage)) << l2bsize;\n\tif ((page_offset + size) > PAGE_CACHE_SIZE) {\n\t\tjfs_err(\"MetaData crosses page boundary!!\");\n\t\tjfs_err(\"lblock = %lx, size  = %d\", lblock, size);\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\tif (absolute)\n\t\tmapping = JFS_SBI(inode->i_sb)->direct_inode->i_mapping;\n\telse {\n\t\t/*\n\t\t * If an nfs client tries to read an inode that is larger\n\t\t * than any existing inodes, we may try to read past the\n\t\t * end of the inode map\n\t\t */\n\t\tif ((lblock << inode->i_blkbits) >= inode->i_size)\n\t\t\treturn NULL;\n\t\tmapping = inode->i_mapping;\n\t}\n\n\tif (new && (PSIZE == PAGE_CACHE_SIZE)) {\n\t\tpage = grab_cache_page(mapping, page_index);\n\t\tif (!page) {\n\t\t\tjfs_err(\"grab_cache_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tSetPageUptodate(page);\n\t} else {\n\t\tpage = read_mapping_page(mapping, page_index, NULL);\n\t\tif (IS_ERR(page) || !PageUptodate(page)) {\n\t\t\tjfs_err(\"read_mapping_page failed!\");\n\t\t\treturn NULL;\n\t\t}\n\t\tlock_page(page);\n\t}\n\n\tmp = page_to_mp(page, page_offset);\n\tif (mp) {\n\t\tif (mp->logical_size != size) {\n\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t  \"get_mp->logical_size != size\\n\");\n\t\t\tjfs_err(\"logical_size = %d, size = %d\",\n\t\t\t\tmp->logical_size, size);\n\t\t\tdump_stack();\n\t\t\tgoto unlock;\n\t\t}\n\t\tmp->count++;\n\t\tlock_metapage(mp);\n\t\tif (test_bit(META_discard, &mp->flag)) {\n\t\t\tif (!new) {\n\t\t\t\tjfs_error(inode->i_sb,\n\t\t\t\t\t  \"using a discarded metapage\\n\");\n\t\t\t\tdiscard_metapage(mp);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tclear_bit(META_discard, &mp->flag);\n\t\t}\n\t} else {\n\t\tINCREMENT(mpStat.pagealloc);\n\t\tmp = alloc_metapage(GFP_NOFS);\n\t\tmp->page = page;\n\t\tmp->flag = 0;\n\t\tmp->xflag = COMMIT_PAGE;\n\t\tmp->count = 1;\n\t\tmp->nohomeok = 0;\n\t\tmp->logical_size = size;\n\t\tmp->data = page_address(page) + page_offset;\n\t\tmp->index = lblock;\n\t\tif (unlikely(insert_metapage(page, mp))) {\n\t\t\tfree_metapage(mp);\n\t\t\tgoto unlock;\n\t\t}\n\t\tlock_metapage(mp);\n\t}\n\n\tif (new) {\n\t\tjfs_info(\"zeroing mp = 0x%p\", mp);\n\t\tmemset(mp->data, 0, PSIZE);\n\t}\n\n\tunlock_page(page);\n\tjfs_info(\"__get_metapage: returning = 0x%p data = 0x%p\", mp, mp->data);\n\treturn mp;\n\nunlock:\n\tunlock_page(page);\n\treturn NULL;\n}"
  },
  {
    "function_name": "metapage_invalidatepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "575-583",
    "snippet": "static void metapage_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t    unsigned int length)\n{\n\tBUG_ON(offset || length < PAGE_CACHE_SIZE);\n\n\tBUG_ON(PageWriteback(page));\n\n\tmetapage_releasepage(page, 0);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "metapage_releasepage",
          "args": [
            "page",
            "0"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_releasepage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "546-573",
          "snippet": "static int metapage_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct metapage *mp;\n\tint ret = 1;\n\tint offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp)\n\t\t\tcontinue;\n\n\t\tjfs_info(\"metapage_releasepage: mp = 0x%p\", mp);\n\t\tif (mp->count || mp->nohomeok ||\n\t\t    test_bit(META_dirty, &mp->flag)) {\n\t\t\tjfs_info(\"count = %ld, nohomeok = %d\", mp->count,\n\t\t\t\t mp->nohomeok);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp->lsn)\n\t\t\tremove_from_logsync(mp);\n\t\tremove_metapage(page, mp);\n\t\tINCREMENT(mpStat.pagefree);\n\t\tfree_metapage(mp);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int metapage_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct metapage *mp;\n\tint ret = 1;\n\tint offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp)\n\t\t\tcontinue;\n\n\t\tjfs_info(\"metapage_releasepage: mp = 0x%p\", mp);\n\t\tif (mp->count || mp->nohomeok ||\n\t\t    test_bit(META_dirty, &mp->flag)) {\n\t\t\tjfs_info(\"count = %ld, nohomeok = %d\", mp->count,\n\t\t\t\t mp->nohomeok);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp->lsn)\n\t\t\tremove_from_logsync(mp);\n\t\tremove_metapage(page, mp);\n\t\tINCREMENT(mpStat.pagefree);\n\t\tfree_metapage(mp);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset || length < PAGE_CACHE_SIZE"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void metapage_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t    unsigned int length)\n{\n\tBUG_ON(offset || length < PAGE_CACHE_SIZE);\n\n\tBUG_ON(PageWriteback(page));\n\n\tmetapage_releasepage(page, 0);\n}"
  },
  {
    "function_name": "metapage_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "546-573",
    "snippet": "static int metapage_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct metapage *mp;\n\tint ret = 1;\n\tint offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp)\n\t\t\tcontinue;\n\n\t\tjfs_info(\"metapage_releasepage: mp = 0x%p\", mp);\n\t\tif (mp->count || mp->nohomeok ||\n\t\t    test_bit(META_dirty, &mp->flag)) {\n\t\t\tjfs_info(\"count = %ld, nohomeok = %d\", mp->count,\n\t\t\t\t mp->nohomeok);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp->lsn)\n\t\t\tremove_from_logsync(mp);\n\t\tremove_metapage(page, mp);\n\t\tINCREMENT(mpStat.pagefree);\n\t\tfree_metapage(mp);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_metapage",
          "args": [
            "mp"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "free_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "205-211",
          "snippet": "static inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "mpStat.pagefree"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_metapage",
          "args": [
            "page",
            "mp"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "remove_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "174-179",
          "snippet": "static inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_logsync",
          "args": [
            "mp"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_logsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "299-319",
          "snippet": "static void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"count = %ld, nohomeok = %d\"",
            "mp->count",
            "mp->nohomeok"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_dirty",
            "&mp->flag"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_info",
          "args": [
            "\"metapage_releasepage: mp = 0x%p\"",
            "mp"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_mp",
          "args": [
            "page",
            "offset"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_mp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "159-162",
          "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int metapage_releasepage(struct page *page, gfp_t gfp_mask)\n{\n\tstruct metapage *mp;\n\tint ret = 1;\n\tint offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp)\n\t\t\tcontinue;\n\n\t\tjfs_info(\"metapage_releasepage: mp = 0x%p\", mp);\n\t\tif (mp->count || mp->nohomeok ||\n\t\t    test_bit(META_dirty, &mp->flag)) {\n\t\t\tjfs_info(\"count = %ld, nohomeok = %d\", mp->count,\n\t\t\t\t mp->nohomeok);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mp->lsn)\n\t\t\tremove_from_logsync(mp);\n\t\tremove_metapage(page, mp);\n\t\tINCREMENT(mpStat.pagefree);\n\t\tfree_metapage(mp);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "metapage_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "490-544",
    "snippet": "static int metapage_readpage(struct file *fp, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct bio *bio = NULL;\n\tint block_offset;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;\n\tsector_t page_start;\t/* address of page in fs blocks */\n\tsector_t pblock;\n\tint xlen;\n\tunsigned int len;\n\tint offset;\n\n\tBUG_ON(!PageLocked(page));\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tblock_offset = 0;\n\twhile (block_offset < blocks_per_page) {\n\t\txlen = blocks_per_page - block_offset;\n\t\tpblock = metapage_get_blocks(inode, page_start + block_offset,\n\t\t\t\t\t     &xlen);\n\t\tif (pblock) {\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tinsert_metapage(page, NULL);\n\t\t\tinc_io(page);\n\t\t\tif (bio)\n\t\t\t\tsubmit_bio(READ, bio);\n\n\t\t\tbio = bio_alloc(GFP_NOFS, 1);\n\t\t\tbio->bi_bdev = inode->i_sb->s_bdev;\n\t\t\tbio->bi_iter.bi_sector =\n\t\t\t\tpblock << (inode->i_blkbits - 9);\n\t\t\tbio->bi_end_io = metapage_read_end_io;\n\t\t\tbio->bi_private = page;\n\t\t\tlen = xlen << inode->i_blkbits;\n\t\t\toffset = block_offset << inode->i_blkbits;\n\t\t\tif (bio_add_page(bio, page, len, offset) < len)\n\t\t\t\tgoto add_failed;\n\t\t\tblock_offset += xlen;\n\t\t} else\n\t\t\tblock_offset++;\n\t}\n\tif (bio)\n\t\tsubmit_bio(READ, bio);\n\telse\n\t\tunlock_page(page);\n\n\treturn 0;\n\nadd_failed:\n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tbio_put(bio);\n\tdec_io(page, last_read_complete);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_io",
          "args": [
            "page",
            "last_read_complete"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "dec_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "152-156",
          "snippet": "static inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\""
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "READ",
            "bio"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "len",
            "offset"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_io",
          "args": [
            "page"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "inc_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "147-150",
          "snippet": "static inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_metapage",
          "args": [
            "page",
            "NULL"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "insert_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "164-172",
          "snippet": "static inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_get_blocks",
          "args": [
            "inode",
            "page_start + block_offset",
            "&xlen"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "254-277",
          "snippet": "static sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int metapage_readpage(struct file *fp, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct bio *bio = NULL;\n\tint block_offset;\n\tint blocks_per_page = PAGE_CACHE_SIZE >> inode->i_blkbits;\n\tsector_t page_start;\t/* address of page in fs blocks */\n\tsector_t pblock;\n\tint xlen;\n\tunsigned int len;\n\tint offset;\n\n\tBUG_ON(!PageLocked(page));\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\tblock_offset = 0;\n\twhile (block_offset < blocks_per_page) {\n\t\txlen = blocks_per_page - block_offset;\n\t\tpblock = metapage_get_blocks(inode, page_start + block_offset,\n\t\t\t\t\t     &xlen);\n\t\tif (pblock) {\n\t\t\tif (!PagePrivate(page))\n\t\t\t\tinsert_metapage(page, NULL);\n\t\t\tinc_io(page);\n\t\t\tif (bio)\n\t\t\t\tsubmit_bio(READ, bio);\n\n\t\t\tbio = bio_alloc(GFP_NOFS, 1);\n\t\t\tbio->bi_bdev = inode->i_sb->s_bdev;\n\t\t\tbio->bi_iter.bi_sector =\n\t\t\t\tpblock << (inode->i_blkbits - 9);\n\t\t\tbio->bi_end_io = metapage_read_end_io;\n\t\t\tbio->bi_private = page;\n\t\t\tlen = xlen << inode->i_blkbits;\n\t\t\toffset = block_offset << inode->i_blkbits;\n\t\t\tif (bio_add_page(bio, page, len, offset) < len)\n\t\t\t\tgoto add_failed;\n\t\t\tblock_offset += xlen;\n\t\t} else\n\t\t\tblock_offset++;\n\t}\n\tif (bio)\n\t\tsubmit_bio(READ, bio);\n\telse\n\t\tunlock_page(page);\n\n\treturn 0;\n\nadd_failed:\n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tbio_put(bio);\n\tdec_io(page, last_read_complete);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "metapage_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "355-488",
    "snippet": "static int metapage_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct bio *bio = NULL;\n\tint block_offset;\t/* block offset of mp within page */\n\tstruct inode *inode = page->mapping->host;\n\tint blocks_per_mp = JFS_SBI(inode->i_sb)->nbperpage;\n\tint len;\n\tint xlen;\n\tstruct metapage *mp;\n\tint redirty = 0;\n\tsector_t lblock;\n\tint nr_underway = 0;\n\tsector_t pblock;\n\tsector_t next_block = 0;\n\tsector_t page_start;\n\tunsigned long bio_bytes = 0;\n\tunsigned long bio_offset = 0;\n\tint offset;\n\tint bad_blocks = 0;\n\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp || !test_bit(META_dirty, &mp->flag))\n\t\t\tcontinue;\n\n\t\tif (mp->nohomeok && !test_bit(META_forcewrite, &mp->flag)) {\n\t\t\tredirty = 1;\n\t\t\t/*\n\t\t\t * Make sure this page isn't blocked indefinitely.\n\t\t\t * If the journal isn't undergoing I/O, push it\n\t\t\t */\n\t\t\tif (mp->log && !(mp->log->cflag & logGC_PAGEOUT))\n\t\t\t\tjfs_flush_journal(mp->log, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclear_bit(META_dirty, &mp->flag);\n\t\tset_bit(META_io, &mp->flag);\n\t\tblock_offset = offset >> inode->i_blkbits;\n\t\tlblock = page_start + block_offset;\n\t\tif (bio) {\n\t\t\tif (xlen && lblock == next_block) {\n\t\t\t\t/* Contiguous, in memory & on disk */\n\t\t\t\tlen = min(xlen, blocks_per_mp);\n\t\t\t\txlen -= len;\n\t\t\t\tbio_bytes += len << inode->i_blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Not contiguous */\n\t\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) <\n\t\t\t    bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\t\t/*\n\t\t\t * Increment counter before submitting i/o to keep\n\t\t\t * count from hitting zero before we're through\n\t\t\t */\n\t\t\tinc_io(page);\n\t\t\tif (!bio->bi_iter.bi_size)\n\t\t\t\tgoto dump_bio;\n\t\t\tsubmit_bio(WRITE, bio);\n\t\t\tnr_underway++;\n\t\t\tbio = NULL;\n\t\t} else\n\t\t\tinc_io(page);\n\t\txlen = (PAGE_CACHE_SIZE - offset) >> inode->i_blkbits;\n\t\tpblock = metapage_get_blocks(inode, lblock, &xlen);\n\t\tif (!pblock) {\n\t\t\tprintk(KERN_ERR \"JFS: metapage_get_blocks failed\\n\");\n\t\t\t/*\n\t\t\t * We already called inc_io(), but can't cancel it\n\t\t\t * with dec_io() until we're done with the page\n\t\t\t */\n\t\t\tbad_blocks++;\n\t\t\tcontinue;\n\t\t}\n\t\tlen = min(xlen, (int)JFS_SBI(inode->i_sb)->nbperpage);\n\n\t\tbio = bio_alloc(GFP_NOFS, 1);\n\t\tbio->bi_bdev = inode->i_sb->s_bdev;\n\t\tbio->bi_iter.bi_sector = pblock << (inode->i_blkbits - 9);\n\t\tbio->bi_end_io = metapage_write_end_io;\n\t\tbio->bi_private = page;\n\n\t\t/* Don't call bio_add_page yet, we may add to this vec */\n\t\tbio_offset = offset;\n\t\tbio_bytes = len << inode->i_blkbits;\n\n\t\txlen -= len;\n\t\tnext_block = lblock + len;\n\t}\n\tif (bio) {\n\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) < bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\tif (!bio->bi_iter.bi_size)\n\t\t\tgoto dump_bio;\n\n\t\tsubmit_bio(WRITE, bio);\n\t\tnr_underway++;\n\t}\n\tif (redirty)\n\t\tredirty_page_for_writepage(wbc, page);\n\n\tunlock_page(page);\n\n\tif (bad_blocks)\n\t\tgoto err_out;\n\n\tif (nr_underway == 0)\n\t\tend_page_writeback(page);\n\n\treturn 0;\nadd_failed:\n\t/* We should never reach here, since we're only adding one vec */\n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tgoto skip;\ndump_bio:\n\tprint_hex_dump(KERN_ERR, \"JFS: dump of bio: \", DUMP_PREFIX_ADDRESS, 16,\n\t\t       4, bio, sizeof(*bio), 0);\nskip:\n\tbio_put(bio);\n\tunlock_page(page);\n\tdec_io(page, last_write_complete);\nerr_out:\n\twhile (bad_blocks--)\n\t\tdec_io(page, last_write_complete);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_io",
          "args": [
            "page",
            "last_write_complete"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "dec_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "152-156",
          "snippet": "static inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_ERR",
            "\"JFS: dump of bio: \"",
            "DUMP_PREFIX_ADDRESS",
            "16",
            "4",
            "bio",
            "sizeof(*bio)",
            "0"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\""
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_page_for_writepage",
          "args": [
            "wbc",
            "page"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "submit_bio",
          "args": [
            "WRITE",
            "bio"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "bl_submit_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/blocklayout.c",
          "lines": "104-115",
          "snippet": "static struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include \"../internal.h\"",
            "#include \"../nfs4session.h\"",
            "#include \"../pnfs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/bio.h>\t\t/* struct bio */",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include \"../internal.h\"\n#include \"../nfs4session.h\"\n#include \"../pnfs.h\"\n#include <linux/pagevec.h>\n#include <linux/prefetch.h>\n#include <linux/bio.h>\t\t/* struct bio */\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct bio *\nbl_submit_bio(int rw, struct bio *bio)\n{\n\tif (bio) {\n\t\tget_parallel(bio->bi_private);\n\t\tdprintk(\"%s submitting %s bio %u@%llu\\n\", __func__,\n\t\t\trw == READ ? \"read\" : \"write\", bio->bi_iter.bi_size,\n\t\t\t(unsigned long long)bio->bi_iter.bi_sector);\n\t\tsubmit_bio(rw, bio);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "bio_bytes",
            "bio_offset"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_alloc",
          "args": [
            "GFP_NOFS",
            "1"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_io_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2733-2746",
          "snippet": "struct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *btrfs_io_bio_alloc(gfp_t gfp_mask, unsigned int nr_iovecs)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_mask, nr_iovecs, btrfs_bioset);\n\tif (bio) {\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "xlen",
            "(int)JFS_SBI(inode->i_sb)->nbperpage"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JFS_SBI",
          "args": [
            "inode->i_sb"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "JFS_SBI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_incore.h",
          "lines": "217-220",
          "snippet": "static inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"jfs_dtree.h\"",
            "#include \"jfs_xtree.h\"",
            "#include \"jfs_types.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_dtree.h\"\n#include \"jfs_xtree.h\"\n#include \"jfs_types.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n\nstatic inline struct jfs_sb_info *JFS_SBI(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "metapage_get_blocks",
          "args": [
            "inode",
            "lblock",
            "&xlen"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "metapage_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "254-277",
          "snippet": "static sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_io",
          "args": [
            "page"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "inc_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "147-150",
          "snippet": "static inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "bio_bytes",
            "bio_offset"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_io",
            "&mp->flag"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_dirty",
            "&mp->flag"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jfs_flush_journal",
          "args": [
            "mp->log",
            "0"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "jfs_flush_journal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_logmgr.c",
          "lines": "1532-1638",
          "snippet": "void jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/delay.h>",
            "#include <linux/export.h>",
            "#include <linux/freezer.h>",
            "#include <linux/bio.h>",
            "#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */",
            "#include <linux/kthread.h>",
            "#include <linux/completion.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int lmNextPage(struct jfs_log * log);",
            "static int lbmLogInit(struct jfs_log * log);",
            "static void lbmLogShutdown(struct jfs_log * log);",
            "static struct lbuf *lbmAllocate(struct jfs_log * log, int);",
            "static void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);",
            "static int lbmIOWait(struct lbuf * bp, int flag);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/freezer.h>\n#include <linux/bio.h>\n#include <linux/buffer_head.h>\t\t/* for sync_blockdev() */\n#include <linux/kthread.h>\n#include <linux/completion.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic int lmNextPage(struct jfs_log * log);\nstatic int lbmLogInit(struct jfs_log * log);\nstatic void lbmLogShutdown(struct jfs_log * log);\nstatic struct lbuf *lbmAllocate(struct jfs_log * log, int);\nstatic void lbmDirectWrite(struct jfs_log * log, struct lbuf * bp, int flag);\nstatic int lbmIOWait(struct lbuf * bp, int flag);\n\nvoid jfs_flush_journal(struct jfs_log *log, int wait)\n{\n\tint i;\n\tstruct tblock *target = NULL;\n\n\t/* jfs_write_inode may call us during read-only mount */\n\tif (!log)\n\t\treturn;\n\n\tjfs_info(\"jfs_flush_journal: log:0x%p wait=%d\", log, wait);\n\n\tLOGGC_LOCK(log);\n\n\tif (!list_empty(&log->cqueue)) {\n\t\t/*\n\t\t * This ensures that we will keep writing to the journal as long\n\t\t * as there are unwritten commit records\n\t\t */\n\t\ttarget = list_entry(log->cqueue.prev, struct tblock, cqueue);\n\n\t\tif (test_bit(log_FLUSH, &log->flag)) {\n\t\t\t/*\n\t\t\t * We're already flushing.\n\t\t\t * if flush_tblk is NULL, we are flushing everything,\n\t\t\t * so leave it that way.  Otherwise, update it to the\n\t\t\t * latest transaction\n\t\t\t */\n\t\t\tif (log->flush_tblk)\n\t\t\t\tlog->flush_tblk = target;\n\t\t} else {\n\t\t\t/* Only flush until latest transaction is committed */\n\t\t\tlog->flush_tblk = target;\n\t\t\tset_bit(log_FLUSH, &log->flag);\n\n\t\t\t/*\n\t\t\t * Initiate I/O on outstanding transactions\n\t\t\t */\n\t\t\tif (!(log->cflag & logGC_PAGEOUT)) {\n\t\t\t\tlog->cflag |= logGC_PAGEOUT;\n\t\t\t\tlmGCwrite(log, 0);\n\t\t\t}\n\t\t}\n\t}\n\tif ((wait > 1) || test_bit(log_SYNCBARRIER, &log->flag)) {\n\t\t/* Flush until all activity complete */\n\t\tset_bit(log_FLUSH, &log->flag);\n\t\tlog->flush_tblk = NULL;\n\t}\n\n\tif (wait && target && !(target->flag & tblkGC_COMMITTED)) {\n\t\tDECLARE_WAITQUEUE(__wait, current);\n\n\t\tadd_wait_queue(&target->gcwait, &__wait);\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tLOGGC_UNLOCK(log);\n\t\tschedule();\n\t\tLOGGC_LOCK(log);\n\t\tremove_wait_queue(&target->gcwait, &__wait);\n\t}\n\tLOGGC_UNLOCK(log);\n\n\tif (wait < 2)\n\t\treturn;\n\n\twrite_special_inodes(log, filemap_fdatawrite);\n\n\t/*\n\t * If there was recent activity, we may need to wait\n\t * for the lazycommit thread to catch up\n\t */\n\tif ((!list_empty(&log->cqueue)) || !list_empty(&log->synclist)) {\n\t\tfor (i = 0; i < 200; i++) {\t/* Too much? */\n\t\t\tmsleep(250);\n\t\t\twrite_special_inodes(log, filemap_fdatawrite);\n\t\t\tif (list_empty(&log->cqueue) &&\n\t\t\t    list_empty(&log->synclist))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tassert(list_empty(&log->cqueue));\n\n#ifdef CONFIG_JFS_DEBUG\n\tif (!list_empty(&log->synclist)) {\n\t\tstruct logsyncblk *lp;\n\n\t\tprintk(KERN_ERR \"jfs_flush_journal: synclist not empty\\n\");\n\t\tlist_for_each_entry(lp, &log->synclist, synclist) {\n\t\t\tif (lp->xflag & COMMIT_PAGE) {\n\t\t\t\tstruct metapage *mp = (struct metapage *)lp;\n\t\t\t\tprint_hex_dump(KERN_ERR, \"metapage: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       mp, sizeof(struct metapage), 0);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"page: \",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16,\n\t\t\t\t\t       sizeof(long), mp->page,\n\t\t\t\t\t       sizeof(struct page), 0);\n\t\t\t} else\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tblock:\",\n\t\t\t\t\t       DUMP_PREFIX_ADDRESS, 16, 4,\n\t\t\t\t\t       lp, sizeof(struct tblock), 0);\n\t\t}\n\t}\n#else\n\tWARN_ON(!list_empty(&log->synclist));\n#endif\n\tclear_bit(log_FLUSH, &log->flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_forcewrite",
            "&mp->flag"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_mp",
          "args": [
            "page",
            "offset"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_mp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "159-162",
          "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageWriteback(page)"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(page)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "page"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic int metapage_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct bio *bio = NULL;\n\tint block_offset;\t/* block offset of mp within page */\n\tstruct inode *inode = page->mapping->host;\n\tint blocks_per_mp = JFS_SBI(inode->i_sb)->nbperpage;\n\tint len;\n\tint xlen;\n\tstruct metapage *mp;\n\tint redirty = 0;\n\tsector_t lblock;\n\tint nr_underway = 0;\n\tsector_t pblock;\n\tsector_t next_block = 0;\n\tsector_t page_start;\n\tunsigned long bio_bytes = 0;\n\tunsigned long bio_offset = 0;\n\tint offset;\n\tint bad_blocks = 0;\n\n\tpage_start = (sector_t)page->index <<\n\t\t     (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(PageWriteback(page));\n\tset_page_writeback(page);\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\n\t\tif (!mp || !test_bit(META_dirty, &mp->flag))\n\t\t\tcontinue;\n\n\t\tif (mp->nohomeok && !test_bit(META_forcewrite, &mp->flag)) {\n\t\t\tredirty = 1;\n\t\t\t/*\n\t\t\t * Make sure this page isn't blocked indefinitely.\n\t\t\t * If the journal isn't undergoing I/O, push it\n\t\t\t */\n\t\t\tif (mp->log && !(mp->log->cflag & logGC_PAGEOUT))\n\t\t\t\tjfs_flush_journal(mp->log, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclear_bit(META_dirty, &mp->flag);\n\t\tset_bit(META_io, &mp->flag);\n\t\tblock_offset = offset >> inode->i_blkbits;\n\t\tlblock = page_start + block_offset;\n\t\tif (bio) {\n\t\t\tif (xlen && lblock == next_block) {\n\t\t\t\t/* Contiguous, in memory & on disk */\n\t\t\t\tlen = min(xlen, blocks_per_mp);\n\t\t\t\txlen -= len;\n\t\t\t\tbio_bytes += len << inode->i_blkbits;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Not contiguous */\n\t\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) <\n\t\t\t    bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\t\t/*\n\t\t\t * Increment counter before submitting i/o to keep\n\t\t\t * count from hitting zero before we're through\n\t\t\t */\n\t\t\tinc_io(page);\n\t\t\tif (!bio->bi_iter.bi_size)\n\t\t\t\tgoto dump_bio;\n\t\t\tsubmit_bio(WRITE, bio);\n\t\t\tnr_underway++;\n\t\t\tbio = NULL;\n\t\t} else\n\t\t\tinc_io(page);\n\t\txlen = (PAGE_CACHE_SIZE - offset) >> inode->i_blkbits;\n\t\tpblock = metapage_get_blocks(inode, lblock, &xlen);\n\t\tif (!pblock) {\n\t\t\tprintk(KERN_ERR \"JFS: metapage_get_blocks failed\\n\");\n\t\t\t/*\n\t\t\t * We already called inc_io(), but can't cancel it\n\t\t\t * with dec_io() until we're done with the page\n\t\t\t */\n\t\t\tbad_blocks++;\n\t\t\tcontinue;\n\t\t}\n\t\tlen = min(xlen, (int)JFS_SBI(inode->i_sb)->nbperpage);\n\n\t\tbio = bio_alloc(GFP_NOFS, 1);\n\t\tbio->bi_bdev = inode->i_sb->s_bdev;\n\t\tbio->bi_iter.bi_sector = pblock << (inode->i_blkbits - 9);\n\t\tbio->bi_end_io = metapage_write_end_io;\n\t\tbio->bi_private = page;\n\n\t\t/* Don't call bio_add_page yet, we may add to this vec */\n\t\tbio_offset = offset;\n\t\tbio_bytes = len << inode->i_blkbits;\n\n\t\txlen -= len;\n\t\tnext_block = lblock + len;\n\t}\n\tif (bio) {\n\t\tif (bio_add_page(bio, page, bio_bytes, bio_offset) < bio_bytes)\n\t\t\t\tgoto add_failed;\n\t\tif (!bio->bi_iter.bi_size)\n\t\t\tgoto dump_bio;\n\n\t\tsubmit_bio(WRITE, bio);\n\t\tnr_underway++;\n\t}\n\tif (redirty)\n\t\tredirty_page_for_writepage(wbc, page);\n\n\tunlock_page(page);\n\n\tif (bad_blocks)\n\t\tgoto err_out;\n\n\tif (nr_underway == 0)\n\t\tend_page_writeback(page);\n\n\treturn 0;\nadd_failed:\n\t/* We should never reach here, since we're only adding one vec */\n\tprintk(KERN_ERR \"JFS: bio_add_page failed unexpectedly\\n\");\n\tgoto skip;\ndump_bio:\n\tprint_hex_dump(KERN_ERR, \"JFS: dump of bio: \", DUMP_PREFIX_ADDRESS, 16,\n\t\t       4, bio, sizeof(*bio), 0);\nskip:\n\tbio_put(bio);\n\tunlock_page(page);\n\tdec_io(page, last_write_complete);\nerr_out:\n\twhile (bad_blocks--)\n\t\tdec_io(page, last_write_complete);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "metapage_write_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "341-353",
    "snippet": "static void metapage_write_end_io(struct bio *bio, int err)\n{\n\tstruct page *page = bio->bi_private;\n\n\tBUG_ON(!PagePrivate(page));\n\n\tif (! test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tprintk(KERN_ERR \"metapage_write_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\tdec_io(page, last_write_complete);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_io",
          "args": [
            "page",
            "last_write_complete"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "dec_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "152-156",
          "snippet": "static inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"metapage_write_end_io: I/O error\\n\""
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PagePrivate(page)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void metapage_write_end_io(struct bio *bio, int err)\n{\n\tstruct page *page = bio->bi_private;\n\n\tBUG_ON(!PagePrivate(page));\n\n\tif (! test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tprintk(KERN_ERR \"metapage_write_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\tdec_io(page, last_write_complete);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "last_write_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "321-339",
    "snippet": "static void last_write_complete(struct page *page)\n{\n\tstruct metapage *mp;\n\tunsigned int offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\t\tif (mp && test_bit(META_io, &mp->flag)) {\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t\tclear_bit(META_io, &mp->flag);\n\t\t}\n\t\t/*\n\t\t * I'd like to call drop_metapage here, but I don't think it's\n\t\t * safe unless I have the page locked\n\t\t */\n\t}\n\tend_page_writeback(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "META_io",
            "&mp->flag"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_from_logsync",
          "args": [
            "mp"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "remove_from_logsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "299-319",
          "snippet": "static void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_io",
            "&mp->flag"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_mp",
          "args": [
            "page",
            "offset"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "page_to_mp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "159-162",
          "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void last_write_complete(struct page *page)\n{\n\tstruct metapage *mp;\n\tunsigned int offset;\n\n\tfor (offset = 0; offset < PAGE_CACHE_SIZE; offset += PSIZE) {\n\t\tmp = page_to_mp(page, offset);\n\t\tif (mp && test_bit(META_io, &mp->flag)) {\n\t\t\tif (mp->lsn)\n\t\t\t\tremove_from_logsync(mp);\n\t\t\tclear_bit(META_io, &mp->flag);\n\t\t}\n\t\t/*\n\t\t * I'd like to call drop_metapage here, but I don't think it's\n\t\t * safe unless I have the page locked\n\t\t */\n\t}\n\tend_page_writeback(page);\n}"
  },
  {
    "function_name": "remove_from_logsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "299-319",
    "snippet": "static void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGSYNC_UNLOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&mp->synclist"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOGSYNC_LOCK",
          "args": [
            "log",
            "flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void remove_from_logsync(struct metapage *mp)\n{\n\tstruct jfs_log *log = mp->log;\n\tunsigned long flags;\n/*\n * This can race.  Recheck that log hasn't been set to null, and after\n * acquiring logsync lock, recheck lsn\n */\n\tif (!log)\n\t\treturn;\n\n\tLOGSYNC_LOCK(log, flags);\n\tif (mp->lsn) {\n\t\tmp->log = NULL;\n\t\tmp->lsn = 0;\n\t\tmp->clsn = 0;\n\t\tlog->count--;\n\t\tlist_del(&mp->synclist);\n\t}\n\tLOGSYNC_UNLOCK(log, flags);\n}"
  },
  {
    "function_name": "metapage_read_end_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "286-297",
    "snippet": "static void metapage_read_end_io(struct bio *bio, int err)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tprintk(KERN_ERR \"metapage_read_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\n\tdec_io(page, last_read_complete);\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_io",
          "args": [
            "page",
            "last_read_complete"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "dec_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "152-156",
          "snippet": "static inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"metapage_read_end_io: I/O error\\n\""
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BIO_UPTODATE",
            "&bio->bi_flags"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void metapage_read_end_io(struct bio *bio, int err)\n{\n\tstruct page *page = bio->bi_private;\n\n\tif (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {\n\t\tprintk(KERN_ERR \"metapage_read_end_io: I/O error\\n\");\n\t\tSetPageError(page);\n\t}\n\n\tdec_io(page, last_read_complete);\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "last_read_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "279-284",
    "snippet": "static void last_read_complete(struct page *page)\n{\n\tif (!PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void last_read_complete(struct page *page)\n{\n\tif (!PageError(page))\n\t\tSetPageUptodate(page);\n\tunlock_page(page);\n}"
  },
  {
    "function_name": "metapage_get_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "254-277",
    "snippet": "static sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xtLookup",
          "args": [
            "inode",
            "(s64)lblock",
            "*len",
            "&xflag",
            "&xaddr",
            "len",
            "0"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "xtLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_xtree.c",
          "lines": "146-219",
          "snippet": "int xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_dinode.h\"",
            "#include \"jfs_dmap.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);",
            "static int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_dinode.h\"\n#include \"jfs_dmap.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nstatic int xtSearch(struct inode *ip, s64 xoff, s64 *next, int *cmpp,\n\t\t    struct btstack * btstack, int flag);\nstatic int xtSplitUp(tid_t tid,\n\t\t     struct inode *ip,\n\t\t     struct xtsplit * split, struct btstack * btstack);\n\nint xtLookup(struct inode *ip, s64 lstart,\n\t     s64 llen, int *pflag, s64 * paddr, s32 * plen, int no_check)\n{\n\tint rc = 0;\n\tstruct btstack btstack;\n\tint cmp;\n\ts64 bn;\n\tstruct metapage *mp;\n\txtpage_t *p;\n\tint index;\n\txad_t *xad;\n\ts64 next, size, xoff, xend;\n\tint xlen;\n\ts64 xaddr;\n\n\t*paddr = 0;\n\t*plen = llen;\n\n\tif (!no_check) {\n\t\t/* is lookup offset beyond eof ? */\n\t\tsize = ((u64) ip->i_size + (JFS_SBI(ip->i_sb)->bsize - 1)) >>\n\t\t    JFS_SBI(ip->i_sb)->l2bsize;\n\t\tif (lstart >= size)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * search for the xad entry covering the logical extent\n\t */\n//search:\n\tif ((rc = xtSearch(ip, lstart, &next, &cmp, &btstack, 0))) {\n\t\tjfs_err(\"xtLookup: xtSearch returned %d\", rc);\n\t\treturn rc;\n\t}\n\n\t/*\n\t *\tcompute the physical extent covering logical extent\n\t *\n\t * N.B. search may have failed (e.g., hole in sparse file),\n\t * and returned the index of the next entry.\n\t */\n\t/* retrieve search result */\n\tXT_GETSEARCH(ip, btstack.top, bn, mp, p, index);\n\n\t/* is xad found covering start of logical extent ?\n\t * lstart is a page start address,\n\t * i.e., lstart cannot start in a hole;\n\t */\n\tif (cmp) {\n\t\tif (next)\n\t\t\t*plen = min(next - lstart, llen);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * lxd covered by xad\n\t */\n\txad = &p->xad[index];\n\txoff = offsetXAD(xad);\n\txlen = lengthXAD(xad);\n\txend = xoff + xlen;\n\txaddr = addressXAD(xad);\n\n\t/* initialize new pxd */\n\t*pflag = xad->flag;\n\t*paddr = xaddr + (lstart - xoff);\n\t/* a page must be fully covered by an xad */\n\t*plen = min(xend - lstart, llen);\n\n      out:\n\tXT_PUTPAGE(mp);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic sector_t metapage_get_blocks(struct inode *inode, sector_t lblock,\n\t\t\t\t    int *len)\n{\n\tint rc = 0;\n\tint xflag;\n\ts64 xaddr;\n\tsector_t file_blocks = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\t\t       inode->i_blkbits;\n\n\tif (lblock >= file_blocks)\n\t\treturn 0;\n\tif (lblock + *len > file_blocks)\n\t\t*len = file_blocks - lblock;\n\n\tif (inode->i_ino) {\n\t\trc = xtLookup(inode, (s64)lblock, *len, &xflag, &xaddr, len, 0);\n\t\tif ((rc == 0) && *len)\n\t\t\tlblock = (sector_t)xaddr;\n\t\telse\n\t\t\tlblock = 0;\n\t} /* else no mapping */\n\n\treturn lblock;\n}"
  },
  {
    "function_name": "drop_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "240-248",
    "snippet": "static inline void drop_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\n\t    test_bit(META_io, &mp->flag))\n\t\treturn;\n\tremove_metapage(page, mp);\n\tINCREMENT(mpStat.pagefree);\n\tfree_metapage(mp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_metapage",
          "args": [
            "mp"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "free_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "205-211",
          "snippet": "static inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static mempool_t *metapage_mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "mpStat.pagefree"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_metapage",
          "args": [
            "page",
            "mp"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "remove_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "174-179",
          "snippet": "static inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "META_io",
            "&mp->flag"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void drop_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp->count || mp->nohomeok || test_bit(META_dirty, &mp->flag) ||\n\t    test_bit(META_io, &mp->flag))\n\t\treturn;\n\tremove_metapage(page, mp);\n\tINCREMENT(mpStat.pagefree);\n\tfree_metapage(mp);\n}"
  },
  {
    "function_name": "metapage_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "234-238",
    "snippet": "void metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *metapage_cache;",
      "static mempool_t *metapage_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "metapage_cache"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_destroy",
          "args": [
            "metapage_mempool"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mempool_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "730-734",
          "snippet": "static inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline void logfs_mempool_destroy(mempool_t *pool)\n{\n\tif (pool)\n\t\tmempool_destroy(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\nvoid metapage_exit(void)\n{\n\tmempool_destroy(metapage_mempool);\n\tkmem_cache_destroy(metapage_cache);\n}"
  },
  {
    "function_name": "metapage_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "213-232",
    "snippet": "int __init metapage_init(void)\n{\n\t/*\n\t * Allocate the metapage structures\n\t */\n\tmetapage_cache = kmem_cache_create(\"jfs_mp\", sizeof(struct metapage),\n\t\t\t\t\t   0, 0, init_once);\n\tif (metapage_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\n\t\t\t\t\t\t    metapage_cache);\n\n\tif (metapage_mempool == NULL) {\n\t\tkmem_cache_destroy(metapage_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define METAPOOL_MIN_PAGES 32"
    ],
    "globals_used": [
      "static struct kmem_cache *metapage_cache;",
      "static mempool_t *metapage_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "metapage_cache"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool_create_slab_pool",
          "args": [
            "METAPOOL_MIN_PAGES",
            "metapage_cache"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"jfs_mp\"",
            "sizeof(struct metapage)",
            "0",
            "0",
            "init_once"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define METAPOOL_MIN_PAGES 32\n\nstatic struct kmem_cache *metapage_cache;\nstatic mempool_t *metapage_mempool;\n\nint __init metapage_init(void)\n{\n\t/*\n\t * Allocate the metapage structures\n\t */\n\tmetapage_cache = kmem_cache_create(\"jfs_mp\", sizeof(struct metapage),\n\t\t\t\t\t   0, 0, init_once);\n\tif (metapage_cache == NULL)\n\t\treturn -ENOMEM;\n\n\tmetapage_mempool = mempool_create_slab_pool(METAPOOL_MIN_PAGES,\n\t\t\t\t\t\t    metapage_cache);\n\n\tif (metapage_mempool == NULL) {\n\t\tkmem_cache_destroy(metapage_cache);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "205-211",
    "snippet": "static inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *metapage_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_free",
          "args": [
            "mp",
            "metapage_mempool"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_free",
            "&mp->flag"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline void free_metapage(struct metapage *mp)\n{\n\tmp->flag = 0;\n\tset_bit(META_free, &mp->flag);\n\n\tmempool_free(mp, metapage_mempool);\n}"
  },
  {
    "function_name": "alloc_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "200-203",
    "snippet": "static inline struct metapage *alloc_metapage(gfp_t gfp_mask)\n{\n\treturn mempool_alloc(metapage_mempool, gfp_mask);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static mempool_t *metapage_mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool_alloc",
          "args": [
            "metapage_mempool",
            "gfp_mask"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic mempool_t *metapage_mempool;\n\nstatic inline struct metapage *alloc_metapage(gfp_t gfp_mask)\n{\n\treturn mempool_alloc(metapage_mempool, gfp_mask);\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "186-198",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct metapage *mp = (struct metapage *)foo;\n\n\tmp->lid = 0;\n\tmp->lsn = 0;\n\tmp->flag = 0;\n\tmp->data = NULL;\n\tmp->clsn = 0;\n\tmp->log = NULL;\n\tset_bit(META_free, &mp->flag);\n\tinit_waitqueue_head(&mp->wait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&mp->wait"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "META_free",
            "&mp->flag"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct metapage *mp = (struct metapage *)foo;\n\n\tmp->lid = 0;\n\tmp->lsn = 0;\n\tmp->flag = 0;\n\tmp->data = NULL;\n\tmp->clsn = 0;\n\tmp->log = NULL;\n\tset_bit(META_free, &mp->flag);\n\tinit_waitqueue_head(&mp->wait);\n}"
  },
  {
    "function_name": "remove_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "174-179",
    "snippet": "static inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tset_page_private(page, 0);\n\tClearPagePrivate(page);\n\tkunmap(page);\n}"
  },
  {
    "function_name": "insert_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "164-172",
    "snippet": "static inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long)mp"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tif (mp) {\n\t\tset_page_private(page, (unsigned long)mp);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "page_to_mp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "159-162",
    "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\treturn PagePrivate(page) ? (struct metapage *)page_private(page) : NULL;\n}"
  },
  {
    "function_name": "dec_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "152-156",
    "snippet": "static inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "page"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "search_binary_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1367-1417",
          "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(formats);",
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&mp_anchor(page)->io_count"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_anchor",
          "args": [
            "page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void dec_io(struct page *page, void (*handler) (struct page *))\n{\n\tif (atomic_dec_and_test(&mp_anchor(page)->io_count))\n\t\thandler(page);\n}"
  },
  {
    "function_name": "inc_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "147-150",
    "snippet": "static inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mp_anchor(page)->io_count"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_anchor",
          "args": [
            "page"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void inc_io(struct page *page)\n{\n\tatomic_inc(&mp_anchor(page)->io_count);\n}"
  },
  {
    "function_name": "remove_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "128-145",
    "snippet": "static inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a = mp_anchor(page);\n\tint l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\tint index;\n\n\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\n\tBUG_ON(a->mp[index] != mp);\n\n\ta->mp[index] = NULL;\n\tif (--a->mp_count == 0) {\n\t\tkfree(a);\n\t\tset_page_private(page, 0);\n\t\tClearPagePrivate(page);\n\t\tkunmap(page);\n\t}\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MPS_PER_PAGE (PAGE_CACHE_SIZE >> L2PSIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "a"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "a->mp[index] != mp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_anchor",
          "args": [
            "page"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define MPS_PER_PAGE (PAGE_CACHE_SIZE >> L2PSIZE)\n\nstatic inline void remove_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a = mp_anchor(page);\n\tint l2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\tint index;\n\n\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\n\tBUG_ON(a->mp[index] != mp);\n\n\ta->mp[index] = NULL;\n\tif (--a->mp_count == 0) {\n\t\tkfree(a);\n\t\tset_page_private(page, 0);\n\t\tClearPagePrivate(page);\n\t\tkunmap(page);\n\t}\n}"
  },
  {
    "function_name": "insert_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "101-126",
    "snippet": "static inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a;\n\tint index;\n\tint l2mp_blocks;\t/* log2 blocks per metapage */\n\n\tif (PagePrivate(page))\n\t\ta = mp_anchor(page);\n\telse {\n\t\ta = kzalloc(sizeof(struct meta_anchor), GFP_NOFS);\n\t\tif (!a)\n\t\t\treturn -ENOMEM;\n\t\tset_page_private(page, (unsigned long)a);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\n\tif (mp) {\n\t\tl2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\t\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\t\ta->mp_count++;\n\t\ta->mp[index] = mp;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define MPS_PER_PAGE (PAGE_CACHE_SIZE >> L2PSIZE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "(unsigned long)a"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct meta_anchor)",
            "GFP_NOFS"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mp_anchor",
          "args": [
            "page"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\n#define MPS_PER_PAGE (PAGE_CACHE_SIZE >> L2PSIZE)\n\nstatic inline int insert_metapage(struct page *page, struct metapage *mp)\n{\n\tstruct meta_anchor *a;\n\tint index;\n\tint l2mp_blocks;\t/* log2 blocks per metapage */\n\n\tif (PagePrivate(page))\n\t\ta = mp_anchor(page);\n\telse {\n\t\ta = kzalloc(sizeof(struct meta_anchor), GFP_NOFS);\n\t\tif (!a)\n\t\t\treturn -ENOMEM;\n\t\tset_page_private(page, (unsigned long)a);\n\t\tSetPagePrivate(page);\n\t\tkmap(page);\n\t}\n\n\tif (mp) {\n\t\tl2mp_blocks = L2PSIZE - page->mapping->host->i_blkbits;\n\t\tindex = (mp->index >> l2mp_blocks) & (MPS_PER_PAGE - 1);\n\t\ta->mp_count++;\n\t\ta->mp[index] = mp;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "page_to_mp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "94-99",
    "snippet": "static inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\treturn mp_anchor(page)->mp[offset >> L2PSIZE];\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mp_anchor",
          "args": [
            "page"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate",
          "args": [
            "page"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline struct metapage *page_to_mp(struct page *page, int offset)\n{\n\tif (!PagePrivate(page))\n\t\treturn NULL;\n\treturn mp_anchor(page)->mp[offset >> L2PSIZE];\n}"
  },
  {
    "function_name": "lock_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "73-77",
    "snippet": "static inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lock_metapage",
          "args": [
            "mp"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_metapage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
          "lines": "53-68",
          "snippet": "static inline void __lock_metapage(struct metapage *mp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tINCREMENT(mpStat.lockwait);\n\tadd_wait_queue_exclusive(&mp->wait, &wait);\n\tdo {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (metapage_locked(mp)) {\n\t\t\tunlock_page(mp->page);\n\t\t\tio_schedule();\n\t\t\tlock_page(mp->page);\n\t\t}\n\t} while (trylock_metapage(mp));\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&mp->wait, &wait);\n}",
          "includes": [
            "#include \"jfs_debug.h\"",
            "#include \"jfs_txnmgr.h\"",
            "#include \"jfs_metapage.h\"",
            "#include \"jfs_filsys.h\"",
            "#include \"jfs_superblock.h\"",
            "#include \"jfs_incore.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mempool.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void __lock_metapage(struct metapage *mp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tINCREMENT(mpStat.lockwait);\n\tadd_wait_queue_exclusive(&mp->wait, &wait);\n\tdo {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (metapage_locked(mp)) {\n\t\t\tunlock_page(mp->page);\n\t\t\tio_schedule();\n\t\t\tlock_page(mp->page);\n\t\t}\n\t} while (trylock_metapage(mp));\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&mp->wait, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_metapage",
          "args": [
            "mp"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void lock_metapage(struct metapage *mp)\n{\n\tif (trylock_metapage(mp))\n\t\t__lock_metapage(mp);\n}"
  },
  {
    "function_name": "__lock_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "53-68",
    "snippet": "static inline void __lock_metapage(struct metapage *mp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tINCREMENT(mpStat.lockwait);\n\tadd_wait_queue_exclusive(&mp->wait, &wait);\n\tdo {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (metapage_locked(mp)) {\n\t\t\tunlock_page(mp->page);\n\t\t\tio_schedule();\n\t\t\tlock_page(mp->page);\n\t\t}\n\t} while (trylock_metapage(mp));\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&mp->wait, &wait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "&mp->wait",
            "&wait"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_metapage",
          "args": [
            "mp"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "mp->page"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "io_schedule",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metapage_locked",
          "args": [
            "mp"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "&mp->wait",
            "&wait"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCREMENT",
          "args": [
            "mpStat.lockwait"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void __lock_metapage(struct metapage *mp)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tINCREMENT(mpStat.lockwait);\n\tadd_wait_queue_exclusive(&mp->wait, &wait);\n\tdo {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (metapage_locked(mp)) {\n\t\t\tunlock_page(mp->page);\n\t\t\tio_schedule();\n\t\t\tlock_page(mp->page);\n\t\t}\n\t} while (trylock_metapage(mp));\n\t__set_current_state(TASK_RUNNING);\n\tremove_wait_queue(&mp->wait, &wait);\n}"
  },
  {
    "function_name": "unlock_metapage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jfs/jfs_metapage.c",
    "lines": "47-51",
    "snippet": "static inline void unlock_metapage(struct metapage *mp)\n{\n\tclear_bit_unlock(META_locked, &mp->flag);\n\twake_up(&mp->wait);\n}",
    "includes": [
      "#include \"jfs_debug.h\"",
      "#include \"jfs_txnmgr.h\"",
      "#include \"jfs_metapage.h\"",
      "#include \"jfs_filsys.h\"",
      "#include \"jfs_superblock.h\"",
      "#include \"jfs_incore.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/mempool.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/bio.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&mp->wait"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "META_locked",
            "&mp->flag"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"jfs_debug.h\"\n#include \"jfs_txnmgr.h\"\n#include \"jfs_metapage.h\"\n#include \"jfs_filsys.h\"\n#include \"jfs_superblock.h\"\n#include \"jfs_incore.h\"\n#include <linux/seq_file.h>\n#include <linux/mempool.h>\n#include <linux/buffer_head.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic inline void unlock_metapage(struct metapage *mp)\n{\n\tclear_bit_unlock(META_locked, &mp->flag);\n\twake_up(&mp->wait);\n}"
  }
]