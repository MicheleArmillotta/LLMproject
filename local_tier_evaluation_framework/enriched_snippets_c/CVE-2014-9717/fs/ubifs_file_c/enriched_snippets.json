[
  {
    "function_name": "ap(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1541-1550",
    "snippet": "ifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint err;\n\n\terr = generic_file_mmap(file, vma);\n\tif (err)\n\t\treturn err;\n\tvma->vm_ops = &ubifs_file_vm_ops;\n\treturn 0;\n}\n\nconst struc",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vm_operations_struct ubifs_file_vm_ops = {\n\t.fault        = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = ubifs_vm_page_mkwrite,\n};\n\nstatic int"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmap(file, vma);",
          "args": [
            "if (",
            "r)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nstruct vm_operations_struct ubifs_file_vm_ops = {\n\t.fault        = filemap_fault,\n\t.map_pages = filemap_map_pages,\n\t.page_mkwrite = ubifs_vm_page_mkwrite,\n};\n\nstatic int;\n\nifs_file_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tint err;\n\n\terr = generic_file_mmap(file, vma);\n\tif (err)\n\t\treturn err;\n\tvma->vm_ops = &ubifs_file_vm_ops;\n\treturn 0;\n}\n\nconst struc"
  },
  {
    "function_name": "_mkwrite(struct vm_ar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1442-1533",
    "snippet": "ifs_vm_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct timespec now = ubifs_current_time(inode);\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint err, update_time;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld\",\tinode->i_ino, page->index,\n\t\ti_size_read(inode));\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn VM_FAULT_SIGBUS; /* -EROFS */\n\n\t/*\n\t * We have not locked @page so far so we may budget for changing the\n\t * page. Note, we cannot do this after we locked the page, because\n\t * budgeting may cause write-back which would cause deadlock.\n\t *\n\t * At the moment we do not know whether the page is dirty or not, so we\n\t * assume that it is not and budget for a new page. We could look at\n\t * the @PG_private flag and figure this out, but we may race with write\n\t * back and the page state may change by the time we lock it, so this\n\t * would need additional care. We do not bother with this at the\n\t * moment, although it might be good idea to do. Instead, we allocate\n\t * budget for a new page and amend it later on if the page was in fact\n\t * dirty.\n\t *\n\t * The budgeting-related logic of this function is similar to what we\n\t * do in 'ubifs_write_begin()' and 'ubifs_write_end()'. Glance there\n\t * for more comments.\n\t */\n\tupdate_time = mctime_update_needed(inode, &now);\n\tif (update_time)\n\t\t/*\n\t\t * We have to change inode time stamp which requires extra\n\t\t * budgeting.\n\t\t */\n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOSPC)\n\t\t\tubifs_warn(\"out of space for mmapped file (inode number %lu)\",\n\t\t\t\t   inode->i_ino);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t     page_offset(page) > i_size_read(inode))) {\n\t\t/* Page got truncated out from underneath us */\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (PagePrivate(page))\n\t\trelease_new_page_budget(c);\n\telse {\n\t\tif (!PageChecked(page))\n\t\t\tubifs_convert_page_budget(c);\n\t\tSetPagePrivate(page);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (update_time) {\n\t\tint release;\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\twait_for_stable_page(page);\n\treturn VM_FAULT_LOCKED;\n\nout_unlock:\n\tunlock_page(page);\n\tubifs_release_budget(c, &req);\n\tif (err)\n\t\terr = VM_FAULT_SIGBUS;\n\treturn err;\n}\n\nstatic cons",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\tubif",
          "args": [
            "_rel"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le_page(page);\n\tretu",
          "args": [
            "n VM"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\t}",
          "args": [
            "w",
            "t_"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t\tif (rele"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_sync(inode);\n\t\tmu",
          "args": [
            "ex_un"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\t\tre",
          "args": [
            "ease"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t\tinode->i"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\t\tm",
          "args": [
            "tex_l"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_nobuffers(page);\n\t}",
          "args": [
            "f (u"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->dirty_pg",
          "args": [
            "cnt);\n\t\t__set_pa"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(page);\n\t\tato",
          "args": [
            "ic_l"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_page_budget(c);\n\t\tSetPag",
          "args": [
            "P"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\t\tub",
          "args": [
            "fs_c"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age_budget(c);\n\telse {",
          "args": [],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\trel",
          "args": [
            "ase_"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->mappin",
          "args": [
            "!= inode->i_mapping ||\n\t\t     page_offset(page) > i_size_read(inode))) {\n\t\t/* Pag"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "sync_mapping_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "570-579",
          "snippet": "int sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_mapping_buffers(struct address_space *mapping)\n{\n\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\tif (buffer_mapping == NULL || list_empty(&mapping->private_list))\n\t\treturn 0;\n\n\treturn fsync_buffers_list(&buffer_mapping->private_lock,\n\t\t\t\t\t&mapping->private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node))) {",
          "args": [
            "/* Pa"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age) > i_si",
          "args": [
            "e_re"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e);\n\tif (",
          "args": [
            "nlik"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut of spac",
          "args": [
            "for mmapped file (inode number %lu)\",\n\t\t\t\t   inod",
            ";\n\t\treturn V"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {\n\t\tif",
          "args": [
            "(er"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "nlik"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_needed(inode, &now)",
          "args": [
            "if",
            "pdat"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_error)",
          "args": [
            "return V"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\n\tif (unli"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, pg",
          "args": [
            "%lu, i_size %lld\",\tinode->i_in",
            "page->index",
            "i_size_re",
            "node));\n\tubifs_ass"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node));\n\tub",
          "args": [
            "fs_as"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a->vm_file",
          "args": [
            ";\n\tstruct ub"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_vm_page_mkwrite(struct vm_area_struct *vma,\n\t\t\t\t struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct timespec now = ubifs_current_time(inode);\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint err, update_time;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld\",\tinode->i_ino, page->index,\n\t\ti_size_read(inode));\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn VM_FAULT_SIGBUS; /* -EROFS */\n\n\t/*\n\t * We have not locked @page so far so we may budget for changing the\n\t * page. Note, we cannot do this after we locked the page, because\n\t * budgeting may cause write-back which would cause deadlock.\n\t *\n\t * At the moment we do not know whether the page is dirty or not, so we\n\t * assume that it is not and budget for a new page. We could look at\n\t * the @PG_private flag and figure this out, but we may race with write\n\t * back and the page state may change by the time we lock it, so this\n\t * would need additional care. We do not bother with this at the\n\t * moment, although it might be good idea to do. Instead, we allocate\n\t * budget for a new page and amend it later on if the page was in fact\n\t * dirty.\n\t *\n\t * The budgeting-related logic of this function is similar to what we\n\t * do in 'ubifs_write_begin()' and 'ubifs_write_end()'. Glance there\n\t * for more comments.\n\t */\n\tupdate_time = mctime_update_needed(inode, &now);\n\tif (update_time)\n\t\t/*\n\t\t * We have to change inode time stamp which requires extra\n\t\t * budgeting.\n\t\t */\n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOSPC)\n\t\t\tubifs_warn(\"out of space for mmapped file (inode number %lu)\",\n\t\t\t\t   inode->i_ino);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tlock_page(page);\n\tif (unlikely(page->mapping != inode->i_mapping ||\n\t\t     page_offset(page) > i_size_read(inode))) {\n\t\t/* Page got truncated out from underneath us */\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (PagePrivate(page))\n\t\trelease_new_page_budget(c);\n\telse {\n\t\tif (!PageChecked(page))\n\t\t\tubifs_convert_page_budget(c);\n\t\tSetPagePrivate(page);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (update_time) {\n\t\tint release;\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\twait_for_stable_page(page);\n\treturn VM_FAULT_LOCKED;\n\nout_unlock:\n\tunlock_page(page);\n\tubifs_release_budget(c, &req);\n\tif (err)\n\t\terr = VM_FAULT_SIGBUS;\n\treturn err;\n}\n\nstatic cons"
  },
  {
    "function_name": "page(struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1423-1436",
    "snippet": "ifs_releasepage(struct page *page, gfp_t unused_gfp_flags)\n{\n\t/*\n\t * An attempt to release a dirty page without budgeting for it - should\n\t * not happen.\n\t */\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tubifs_assert(PagePrivate(page));\n\tubifs_assert(0);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n\treturn 1;\n}\n\n/*\n * mmap(",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ked(page);\n\tretu",
          "args": [
            "n 1;"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(page);\n\tClea",
          "args": [
            "Page"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0);\n\tClearPa",
          "args": [
            "e"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate(",
          "args": [
            "age));\n\tubifs_ass"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\tubi",
          "args": [
            "s_as"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(page))\n\t\tret",
          "args": [
            "rn 0"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_releasepage(struct page *page, gfp_t unused_gfp_flags)\n{\n\t/*\n\t * An attempt to release a dirty page without budgeting for it - should\n\t * not happen.\n\t */\n\tif (PageWriteback(page))\n\t\treturn 0;\n\tubifs_assert(PagePrivate(page));\n\tubifs_assert(0);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n\treturn 1;\n}\n\n/*\n * mmap("
  },
  {
    "function_name": "e_dirty(struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1410-1421",
    "snippet": "ifs_set_page_dirty(struct page *page)\n{\n\tint ret;\n\n\tret = __set_page_dirty_nobuffers(page);\n\t/*\n\t * An attempt to dirty a page without budgeting for it - should not\n\t * happen.\n\t */\n\tubifs_assert(ret == 0);\n\treturn ret;\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret == 0);",
          "args": [
            "eturn re"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_nobuffers(page);\n\t/*",
          "args": [
            "* An"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_set_page_dirty(struct page *page)\n{\n\tint ret;\n\n\tret = __set_page_dirty_nobuffers(page);\n\t/*\n\t * An attempt to dirty a page without budgeting for it - should not\n\t * happen.\n\t */\n\tubifs_assert(ret == 0);\n\treturn ret;\n}\n\nstatic int"
  },
  {
    "function_name": "ter(struct kiocb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1401-1408",
    "snippet": "t ubifs_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tint err = update_mctime(file_inode(iocb->ki_filp));\n\tif (err)\n\t\treturn err;\n\n\treturn generic_file_write_iter(iocb, from);\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_iter(iocb, from);",
          "args": [
            "}\n\ns",
            "tic"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(file_inode(i",
          "args": [
            "cb->ki_filp));\n\tif (err)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb->ki_fil",
          "args": [
            "));\n\tif (err)"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nt ubifs_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tint err = update_mctime(file_inode(iocb->ki_filp));\n\tif (err)\n\t\treturn err;\n\n\treturn generic_file_write_iter(iocb, from);\n}\n\nstatic int"
  },
  {
    "function_name": "(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1374-1399",
    "snippet": "date_mctime(struct inode *inode)\n{\n\tstruct timespec now = ubifs_current_time(inode);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tif (mctime_update_needed(inode, &now)) {\n\t\tint err, release;\n\t\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\t\terr = ubifs_budget_space(c, &req);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_budget(c, &req);\n\t}\n\n\treturn 0;\n}\n\nstatic ssiz",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\t}",
          "args": [
            "etur"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t\tif (rele"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_sync(inode);\n\t\tmu",
          "args": [
            "ex_un"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\t\tre",
          "args": [
            "ease"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t\tinode->i"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_len",
          "args": [
            "8) };\n\n\t\ter",
            "="
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_needed(inode, &now)",
          "args": [
            "{",
            "t er"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\ndate_mctime(struct inode *inode)\n{\n\tstruct timespec now = ubifs_current_time(inode);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tif (mctime_update_needed(inode, &now)) {\n\t\tint err, release;\n\t\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\t\terr = ubifs_budget_space(c, &req);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\trelease = ui->dirty;\n\t\tmark_inode_dirty_sync(inode);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t\tif (release)\n\t\t\tubifs_release_budget(c, &req);\n\t}\n\n\treturn 0;\n}\n\nstatic ssiz"
  },
  {
    "function_name": "_needed(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1357-1364",
    "snippet": "int mctime_update_needed(const struct inode *inode,\n\t\t\t\t       const struct timespec *now)\n{\n\tif (!timespec_equal(&inode->i_mtime, now) ||\n\t    !timespec_equal(&inode->i_ctime, now))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * upda",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "l(&inode->i_ct",
          "args": [
            "me, now))\n\t\tret",
            "n 1"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "l(&inode->i_mt",
          "args": [
            "me, now) ||",
            "!ti"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nint mctime_update_needed(const struct inode *inode,\n\t\t\t\t       const struct timespec *now)\n{\n\tif (!timespec_equal(&inode->i_mtime, now) ||\n\t    !timespec_equal(&inode->i_ctime, now))\n\t\treturn 1;\n\treturn 0;\n}\n\n/**\n * upda"
  },
  {
    "function_name": "truct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1311-1346",
    "snippet": "nc(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err;\n\n\tdbg_gen(\"syncing inode %lu\", inode->i_ino);\n\n\tif (c->ro_mount)\n\t\t/*\n\t\t * For some really strange reasons VFS does not filter out\n\t\t * 'fsync()' for R/O mounted file-systems as per 2.6.39.\n\t\t */\n\t\treturn 0;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Synchronize the inode unless this is a 'datasync()' call. */\n\tif (!datasync || (inode->i_state & I_DIRTY_DATASYNC)) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Nodes related to this inode may still sit in a write-buffer. Flush\n\t * them.\n\t */\n\terr = ubifs_sync_wbufs_by_inode(c, inode);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}\n\n/**\n * mcti",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&inode->i_mu",
          "args": [
            "ex);\n\treturn er"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_by_inode(c, inode);\no",
          "args": [
            "t",
            "mute"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_op->write_inode",
          "args": [
            "if",
            "err)"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "340-351",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node->i_mu",
          "args": [
            "ex);\n\n\t/* Synch"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_and_wait_range(inode->i_map",
          "args": [
            "ing, start, end)",
            "if (",
            "r)"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing ino",
          "args": [
            "e %lu\", inode->i_in",
            ";\n\n\tif (c->r"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nnc(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err;\n\n\tdbg_gen(\"syncing inode %lu\", inode->i_ino);\n\n\tif (c->ro_mount)\n\t\t/*\n\t\t * For some really strange reasons VFS does not filter out\n\t\t * 'fsync()' for R/O mounted file-systems as per 2.6.39.\n\t\t */\n\t\treturn 0;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&inode->i_mutex);\n\n\t/* Synchronize the inode unless this is a 'datasync()' call. */\n\tif (!datasync || (inode->i_state & I_DIRTY_DATASYNC)) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Nodes related to this inode may still sit in a write-buffer. Flush\n\t * them.\n\t */\n\terr = ubifs_sync_wbufs_by_inode(c, inode);\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn err;\n}\n\n/**\n * mcti"
  },
  {
    "function_name": "link(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1303-1309",
    "snippet": "ubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d, ui->data",
          "args": [
            ";",
            "eturn NU"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry->d_in",
          "args": [
            "de);\n\n\tnd_set_l"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nubifs_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ubifs_inode *ui = ubifs_inode(dentry->d_inode);\n\n\tnd_set_link(nd, ui->data);\n\treturn NULL;\n}\n\nint ubifs_f"
  },
  {
    "function_name": "atepage(struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1282-1301",
    "snippet": "bifs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tubifs_assert(PagePrivate(page));\n\tif (offset || length < PAGE_CACHE_SIZE)\n\t\t/* Partial page remains dirty */\n\t\treturn;\n\n\tif (PageChecked(page))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n}\n\nstatic void",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ked(page);\n}\n\nst",
          "args": [
            "tic"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(page);\n\tClea",
          "args": [
            "Page"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_pg",
          "args": [
            "cnt);\n\tClearPage"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing_page_budget(c);\n\n\tatomic",
          "args": [
            "l"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age_budget(c);\n\telse",
          "args": [
            "e"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\trel",
          "args": [
            "ase_"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate(",
          "args": [
            "age));\n\tif (offse"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\tif",
          "args": [
            "offs"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nbifs_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t unsigned int length)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tubifs_assert(PagePrivate(page));\n\tif (offset || length < PAGE_CACHE_SIZE)\n\t\t/* Partial page remains dirty */\n\t\treturn;\n\n\tif (PageChecked(page))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n}\n\nstatic void"
  },
  {
    "function_name": "(struct dentr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1257-1280",
    "snippet": "attr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tdbg_gen(\"ino %lu, mode %#x, ia_valid %#x\",\n\t\tinode->i_ino, inode->i_mode, attr->ia_valid);\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size < inode->i_size)\n\t\t/* Truncation to a smaller size */\n\t\terr = do_truncation(c, inode, attr);\n\telse\n\t\terr = do_setattr(c, inode, attr);\n\n\treturn err;\n}\n\nstatic void",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode, at",
          "args": [
            "r",
            "re",
            "rn e"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, inode, at",
          "args": [
            "r",
            "els",
            "er"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ced_i_size(c, inode);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ok(inode, attr)",
          "args": [
            "if",
            "rr)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, mo",
          "args": [
            "e %#x, ia_valid %#x\",\n\t\tinode->i_",
            "inode->i_mo",
            ", attr->ia_va",
            "d);\n\terr = ino"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n\tdbg_gen(\"ino %lu, mode %#x, ia_valid %#x\",\n\t\tinode->i_ino, inode->i_mode, attr->ia_valid);\n\terr = inode_change_ok(inode, attr);\n\tif (err)\n\t\treturn err;\n\n\terr = dbg_check_synced_i_size(c, inode);\n\tif (err)\n\t\treturn err;\n\n\tif ((attr->ia_valid & ATTR_SIZE) && attr->ia_size < inode->i_size)\n\t\t/* Truncation to a smaller size */\n\t\terr = do_truncation(c, inode, attr);\n\telse\n\t\terr = do_setattr(c, inode, attr);\n\n\treturn err;\n}\n\nstatic void"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1211-1255",
    "snippet": "_setattr(struct ubifs_info *c, struct inode *inode,\n\t\t      const struct iattr *attr)\n{\n\tint err, release;\n\tloff_t new_size = attr->ia_size;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tdbg_gen(\"size %lld -> %lld\", inode->i_size, new_size);\n\t\ttruncate_setsize(inode, new_size);\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* Truncation changes inode [mc]time */\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\t/* 'truncate_setsize()' changed @i_size, update @ui_size */\n\t\tui->ui_size = inode->i_size;\n\t}\n\n\tdo_attr_changes(inode, attr);\n\n\trelease = ui->dirty;\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\t/*\n\t\t * Inode length changed, so we have to make sure\n\t\t * @I_DIRTY_DATASYNC is set.\n\t\t */\n\t\t __mark_inode_dirty(inode, I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n\telse\n\t\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\treturn err;\n}\n\nint ubifs_s",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s_op->write_inode",
          "args": [
            "ret",
            "n er"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "340-351",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "))\n\t\ter",
          "args": [
            "= in"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\ti",
          "args": [
            "S_SY"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\n\tif (rele"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_sync(inode);\n\tmut",
          "args": [
            "x_unl"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty(inode, I_DIR",
          "args": [
            "Y_SYN",
            "| I_DIRTY_DATASYNC);\n\telse\n\t\tma"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(inode, attr)",
          "args": [
            "re",
            "ase"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\t\t/*",
          "args": [
            "'trun"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\tif (attr-"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize(inode, new_s",
          "args": [
            "ze);",
            "mutex"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lld -",
          "args": [
            "%lld\", inode->i_si",
            ", new_size);",
            "truncate"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "a_len",
          "args": [
            "8) };\n\n\terr"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_read_data_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb1ops.c",
          "lines": "89-95",
          "snippet": "static unsigned int\ncifs_read_data_length(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\n\t       le16_to_cpu(rsp->DataLength);\n}",
          "includes": [
            "#include \"cifs_unicode.h\"",
            "#include \"cifspdu.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifs_unicode.h\"\n#include \"cifspdu.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n\nstatic unsigned int\ncifs_read_data_length(char *buf)\n{\n\tREAD_RSP *rsp = (READ_RSP *)buf;\n\treturn (le16_to_cpu(rsp->DataLengthHigh) << 16) +\n\t       le16_to_cpu(rsp->DataLength);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_setattr(struct ubifs_info *c, struct inode *inode,\n\t\t      const struct iattr *attr)\n{\n\tint err, release;\n\tloff_t new_size = attr->ia_size;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_budget_req req = { .dirtied_ino = 1,\n\t\t\t\t.dirtied_ino_d = ALIGN(ui->data_len, 8) };\n\n\terr = ubifs_budget_space(c, &req);\n\tif (err)\n\t\treturn err;\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\tdbg_gen(\"size %lld -> %lld\", inode->i_size, new_size);\n\t\ttruncate_setsize(inode, new_size);\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\t/* Truncation changes inode [mc]time */\n\t\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t\t/* 'truncate_setsize()' changed @i_size, update @ui_size */\n\t\tui->ui_size = inode->i_size;\n\t}\n\n\tdo_attr_changes(inode, attr);\n\n\trelease = ui->dirty;\n\tif (attr->ia_valid & ATTR_SIZE)\n\t\t/*\n\t\t * Inode length changed, so we have to make sure\n\t\t * @I_DIRTY_DATASYNC is set.\n\t\t */\n\t\t __mark_inode_dirty(inode, I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n\telse\n\t\tmark_inode_dirty_sync(inode);\n\tmutex_unlock(&ui->ui_mutex);\n\n\tif (release)\n\t\tubifs_release_budget(c, &req);\n\tif (IS_SYNC(inode))\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\treturn err;\n}\n\nint ubifs_s"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1105-1199",
    "snippet": "_truncation(struct ubifs_info *c, struct inode *inode,\n\t\t\t const struct iattr *attr)\n{\n\tint err;\n\tstruct ubifs_budget_req req;\n\tloff_t old_size = inode->i_size, new_size = attr->ia_size;\n\tint offset = new_size & (UBIFS_BLOCK_SIZE - 1), budgeted = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tdbg_gen(\"ino %lu, size %lld -> %lld\", inode->i_ino, old_size, new_size);\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\n\t/*\n\t * If this is truncation to a smaller size, and we do not truncate on a\n\t * block boundary, budget for changing one data block, because the last\n\t * block will be re-written.\n\t */\n\tif (new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\treq.dirtied_page = 1;\n\n\treq.dirtied_ino = 1;\n\t/* A funny way to budget for truncation node */\n\treq.dirtied_ino_d = UBIFS_TRUN_NODE_SZ;\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\t/*\n\t\t * Treat truncations to zero as deletion and always allow them,\n\t\t * just like we do for '->unlink()'.\n\t\t */\n\t\tif (new_size || err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\ttruncate_setsize(inode, new_size);\n\n\tif (offset) {\n\t\tpgoff_t index = new_size >> PAGE_CACHE_SHIFT;\n\t\tstruct page *page;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (page) {\n\t\t\tif (PageDirty(page)) {\n\t\t\t\t/*\n\t\t\t\t * 'ubifs_jnl_truncate()' will try to truncate\n\t\t\t\t * the last data node, but it contains\n\t\t\t\t * out-of-date data because the page is dirty.\n\t\t\t\t * Write the page now, so that\n\t\t\t\t * 'ubifs_jnl_truncate()' will see an already\n\t\t\t\t * truncated (and up to date) data node.\n\t\t\t\t */\n\t\t\t\tubifs_assert(PagePrivate(page));\n\n\t\t\t\tclear_page_dirty_for_io(page);\n\t\t\t\tif (UBIFS_BLOCKS_PER_PAGE_SHIFT)\n\t\t\t\t\toffset = new_size &\n\t\t\t\t\t\t (PAGE_CACHE_SIZE - 1);\n\t\t\t\terr = do_writepage(page, offset);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_budg;\n\t\t\t\t/*\n\t\t\t\t * We could now tell 'ubifs_jnl_truncate()' not\n\t\t\t\t * to read the last block.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We could 'kmap()' the page and pass the data\n\t\t\t\t * to 'ubifs_jnl_truncate()' to save it from\n\t\t\t\t * having to read it.\n\t\t\t\t */\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tui->ui_size = inode->i_size;\n\t/* Truncation changes inode [mc]time */\n\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t/* Other attributes may be changed at the same time as well */\n\tdo_attr_changes(inode, attr);\n\terr = ubifs_jnl_truncate(c, inode, old_size, new_size);\n\tmutex_unlock(&ui->ui_mutex);\n\nout_budg:\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn err;\n}\n\n/**\n * do_s",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);\n\te",
          "args": [
            "s",
            "{"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\nout_budg:"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncate(c, inode, ol",
          "args": [
            "_",
            "ze, n",
            "_size);",
            "utex_unl"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(inode, attr)",
          "args": [
            "err",
            "ubi"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_time(inode);\n\t/*",
          "args": [
            "ther"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\tui->ui_si"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\t\t\t}",
          "args": [
            "}"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\t\t\tp",
          "args": [
            "ge_c"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\t\t\t\ti",
          "args": [
            "(er"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page, offset",
          "args": [
            ";",
            "page_c"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_for_io(page);\n\t\t\t\ti",
          "args": [
            "(UB"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate(",
          "args": [
            "age));\n\n\t\t\t\tclear"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));",
          "args": [
            "clea"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e)) {",
          "args": [
            "/*"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(inode->i_map",
          "args": [
            "ing, index);\n\t\ti",
            "(page"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ize(inode, new_s",
          "args": [
            "ze);",
            "if (offs"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "rr)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, siz",
          "args": [
            "of(s",
            "u",
            "ubifs_budget_req));\n\n\t/*\n\t * I"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, si",
          "args": [
            "e %lld -> %lld\", inode->i_in",
            "old_size, n",
            "_size);",
            "emset(&r"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tdb",
          "args": [
            "_gen("
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_truncation(struct ubifs_info *c, struct inode *inode,\n\t\t\t const struct iattr *attr)\n{\n\tint err;\n\tstruct ubifs_budget_req req;\n\tloff_t old_size = inode->i_size, new_size = attr->ia_size;\n\tint offset = new_size & (UBIFS_BLOCK_SIZE - 1), budgeted = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tdbg_gen(\"ino %lu, size %lld -> %lld\", inode->i_ino, old_size, new_size);\n\tmemset(&req, 0, sizeof(struct ubifs_budget_req));\n\n\t/*\n\t * If this is truncation to a smaller size, and we do not truncate on a\n\t * block boundary, budget for changing one data block, because the last\n\t * block will be re-written.\n\t */\n\tif (new_size & (UBIFS_BLOCK_SIZE - 1))\n\t\treq.dirtied_page = 1;\n\n\treq.dirtied_ino = 1;\n\t/* A funny way to budget for truncation node */\n\treq.dirtied_ino_d = UBIFS_TRUN_NODE_SZ;\n\terr = ubifs_budget_space(c, &req);\n\tif (err) {\n\t\t/*\n\t\t * Treat truncations to zero as deletion and always allow them,\n\t\t * just like we do for '->unlink()'.\n\t\t */\n\t\tif (new_size || err != -ENOSPC)\n\t\t\treturn err;\n\t\tbudgeted = 0;\n\t}\n\n\ttruncate_setsize(inode, new_size);\n\n\tif (offset) {\n\t\tpgoff_t index = new_size >> PAGE_CACHE_SHIFT;\n\t\tstruct page *page;\n\n\t\tpage = find_lock_page(inode->i_mapping, index);\n\t\tif (page) {\n\t\t\tif (PageDirty(page)) {\n\t\t\t\t/*\n\t\t\t\t * 'ubifs_jnl_truncate()' will try to truncate\n\t\t\t\t * the last data node, but it contains\n\t\t\t\t * out-of-date data because the page is dirty.\n\t\t\t\t * Write the page now, so that\n\t\t\t\t * 'ubifs_jnl_truncate()' will see an already\n\t\t\t\t * truncated (and up to date) data node.\n\t\t\t\t */\n\t\t\t\tubifs_assert(PagePrivate(page));\n\n\t\t\t\tclear_page_dirty_for_io(page);\n\t\t\t\tif (UBIFS_BLOCKS_PER_PAGE_SHIFT)\n\t\t\t\t\toffset = new_size &\n\t\t\t\t\t\t (PAGE_CACHE_SIZE - 1);\n\t\t\t\terr = do_writepage(page, offset);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_budg;\n\t\t\t\t/*\n\t\t\t\t * We could now tell 'ubifs_jnl_truncate()' not\n\t\t\t\t * to read the last block.\n\t\t\t\t */\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * We could 'kmap()' the page and pass the data\n\t\t\t\t * to 'ubifs_jnl_truncate()' to save it from\n\t\t\t\t * having to read it.\n\t\t\t\t */\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ui->ui_mutex);\n\tui->ui_size = inode->i_size;\n\t/* Truncation changes inode [mc]time */\n\tinode->i_mtime = inode->i_ctime = ubifs_current_time(inode);\n\t/* Other attributes may be changed at the same time as well */\n\tdo_attr_changes(inode, attr);\n\terr = ubifs_jnl_truncate(c, inode, old_size, new_size);\n\tmutex_unlock(&ui->ui_mutex);\n\nout_budg:\n\tif (budgeted)\n\t\tubifs_release_budget(c, &req);\n\telse {\n\t\tc->bi.nospace = c->bi.nospace_rp = 0;\n\t\tsmp_wmb();\n\t}\n\treturn err;\n}\n\n/**\n * do_s"
  },
  {
    "function_name": "es(struct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1071-1093",
    "snippet": "o_attr_changes(struct inode *inode, const struct iattr *attr)\n{\n\tif (attr->ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (attr->ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (attr->ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}\n\n/**\n * do_t",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SETID))",
          "args": [
            "mode &="
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode->i_gid",
          "args": [
            "&& !capable"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c(attr->ia_cti",
          "args": [
            "e,\n\t\t\t\t\t\tinode",
            "s_time_gran);\n\tif (attr-"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c(attr->ia_mti",
          "args": [
            "e,\n\t\t\t\t\t\tinode",
            "s_time_gran);\n\tif (attr-"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c(attr->ia_ati",
          "args": [
            "e,\n\t\t\t\t\t\tinode",
            "s_time_gran);\n\tif (attr-"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\no_attr_changes(struct inode *inode, const struct iattr *attr)\n{\n\tif (attr->ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (attr->ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (attr->ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}\n\n/**\n * do_t"
  },
  {
    "function_name": "ge(struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "1000-1064",
    "snippet": "ifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tloff_t i_size =  i_size_read(inode), synced_i_size;\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint err, len = i_size & (PAGE_CACHE_SIZE - 1);\n\tvoid *kaddr;\n\n\tdbg_gen(\"ino %lu, pg %lu, pg flags %#lx\",\n\t\tinode->i_ino, page->index, page->flags);\n\tubifs_assert(PagePrivate(page));\n\n\t/* Is the page fully outside @i_size? (truncate in progress) */\n\tif (page->index > end_index || (page->index == end_index && !len)) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&ui->ui_lock);\n\tsynced_i_size = ui->synced_i_size;\n\tspin_unlock(&ui->ui_lock);\n\n\t/* Is the page fully inside @i_size? */\n\tif (page->index < end_index) {\n\t\tif (page->index >= synced_i_size >> PAGE_CACHE_SHIFT) {\n\t\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t\t/*\n\t\t\t * The inode has been written, but the write-buffer has\n\t\t\t * not been synchronized, so in case of an unclean\n\t\t\t * reboot we may end up with some pages beyond inode\n\t\t\t * size, but they would be in the journal (because\n\t\t\t * commit flushes write buffers) and recovery would deal\n\t\t\t * with this.\n\t\t\t */\n\t\t}\n\t\treturn do_writepage(page, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * The page straddles @i_size. It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped. \"A file is mapped\n\t * in multiples of the page size. For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr + len, 0, PAGE_CACHE_SIZE - len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (i_size > synced_i_size) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\treturn do_writepage(page, len);\n\nout_unlock:\n\tunlock_page(page);\n\treturn err;\n}\n\n/**\n * do_a",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "age);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page, len);",
          "args": [
            "out_",
            "loc"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_op->write_inode",
          "args": [
            "if",
            "err)"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "340-351",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "(kaddr);\n\n\tif",
          "args": [
            "(i_si"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page(page);\n\tkunm",
          "args": [
            "p_at"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ len,",
          "args": [
            "0, PAGE_CAC",
            "_",
            "ZE - len);\n\tflush_dca"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\tmems",
          "args": [
            "t(ka"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page, PAGE_C",
          "args": [
            "CHE_",
            "ZE);\n\t}\n\n\t/*"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n\n\t/* Is th"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tsynced_i_"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate(",
          "args": [
            "age));\n\n\t/* Is th"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\n\t/*",
          "args": [
            "Is t"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, pg",
          "args": [
            "%lu, pg flags %#lx\",\n\t\tinode->i_",
            "page->index",
            "page->flags",
            "ubifs_ass"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node), sync",
          "args": [
            "d_i_s"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tlof",
          "args": [
            "_t i_"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tloff_t i_size =  i_size_read(inode), synced_i_size;\n\tpgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tint err, len = i_size & (PAGE_CACHE_SIZE - 1);\n\tvoid *kaddr;\n\n\tdbg_gen(\"ino %lu, pg %lu, pg flags %#lx\",\n\t\tinode->i_ino, page->index, page->flags);\n\tubifs_assert(PagePrivate(page));\n\n\t/* Is the page fully outside @i_size? (truncate in progress) */\n\tif (page->index > end_index || (page->index == end_index && !len)) {\n\t\terr = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tspin_lock(&ui->ui_lock);\n\tsynced_i_size = ui->synced_i_size;\n\tspin_unlock(&ui->ui_lock);\n\n\t/* Is the page fully inside @i_size? */\n\tif (page->index < end_index) {\n\t\tif (page->index >= synced_i_size >> PAGE_CACHE_SHIFT) {\n\t\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t\t/*\n\t\t\t * The inode has been written, but the write-buffer has\n\t\t\t * not been synchronized, so in case of an unclean\n\t\t\t * reboot we may end up with some pages beyond inode\n\t\t\t * size, but they would be in the journal (because\n\t\t\t * commit flushes write buffers) and recovery would deal\n\t\t\t * with this.\n\t\t\t */\n\t\t}\n\t\treturn do_writepage(page, PAGE_CACHE_SIZE);\n\t}\n\n\t/*\n\t * The page straddles @i_size. It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped. \"A file is mapped\n\t * in multiples of the page size. For a file that is not a multiple of\n\t * the page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tkaddr = kmap_atomic(page);\n\tmemset(kaddr + len, 0, PAGE_CACHE_SIZE - len);\n\tflush_dcache_page(page);\n\tkunmap_atomic(kaddr);\n\n\tif (i_size > synced_i_size) {\n\t\terr = inode->i_sb->s_op->write_inode(inode, NULL);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\treturn do_writepage(page, len);\n\nout_unlock:\n\tunlock_page(page);\n\treturn err;\n}\n\n/**\n * do_a"
  },
  {
    "function_name": "struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "897-952",
    "snippet": "_writepage(struct page *page, int len)\n{\n\tint err = 0, i, blen;\n\tunsigned int block;\n\tvoid *addr;\n\tunion ubifs_key key;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n#ifdef UBIFS_DEBUG\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tspin_lock(&ui->ui_lock);\n\tubifs_assert(page->index <= ui->synced_i_size >> PAGE_CACHE_SHIFT);\n\tspin_unlock(&ui->ui_lock);\n#endif\n\n\t/* Update radix tree tags */\n\tset_page_writeback(page);\n\n\taddr = kmap(page);\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\ti = 0;\n\twhile (len) {\n\t\tblen = min_t(int, len, UBIFS_BLOCK_SIZE);\n\t\tdata_key_init(c, &key, inode->i_ino, block);\n\t\terr = ubifs_jnl_write_data(c, inode, &key, addr, blen);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += blen;\n\t\tlen -= blen;\n\t}\n\tif (err) {\n\t\tSetPageError(page);\n\t\tubifs_err(\"cannot write page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tubifs_ro_mode(c, err);\n\t}\n\n\tubifs_assert(PagePrivate(page));\n\tif (PageChecked(page))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n\n\tkunmap(page);\n\tunlock_page(page);\n\tend_page_writeback(page);\n\treturn err;\n}\n\n/*\n * When",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eback(page);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\tend_",
          "args": [
            "age_"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlo",
          "args": [
            "k_pa"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_mount_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "369-382",
          "snippet": "void propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ked(page);\n\n\tkun",
          "args": [
            "ap(p"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(page);\n\tClea",
          "args": [
            "Page"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ec(&c->dirty_pg",
          "args": [
            "cnt);\n\tClearPage"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing_page_budget(c);\n\n\tatomic",
          "args": [
            "l"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age_budget(c);\n\telse",
          "args": [
            "e"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\trel",
          "args": [
            "ase_"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PagePrivate(",
          "args": [
            "age));\n\tif (PageC"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\tif",
          "args": [
            "Page"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\t}",
          "args": [
            "ifs"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot writ",
          "args": [
            "page %lu of inode %lu, error %d\",\n\t\t\t  page->",
            "inode->i_in",
            "err);\n\t\tubi",
            "_ro"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page);\n\t\tubi",
          "args": [
            "s_er"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te_data(c, inode, &k",
          "args": [
            "y",
            "addr,",
            "len)",
            "if",
            "err)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, ino",
          "args": [
            "e",
            "i_in",
            "block);\n\t\te",
            "= ub"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, UB",
          "args": [
            "FS_",
            "OCK",
            "IZE);\n\t\tdata_key"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bloc",
          "args": [
            "= p"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "452-455",
          "snippet": "void truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eback(page);\n\n\tadd",
          "args": [
            "= k"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n#endif\n\n\t/"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page->index",
          "args": [
            "= ui->synced_i_size >> PAGE_CACHE_SHIFT);\n\tspin_unlo"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tubifs_ass"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tspi",
          "args": [
            "_lock"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_writepage(struct page *page, int len)\n{\n\tint err = 0, i, blen;\n\tunsigned int block;\n\tvoid *addr;\n\tunion ubifs_key key;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\n#ifdef UBIFS_DEBUG\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tspin_lock(&ui->ui_lock);\n\tubifs_assert(page->index <= ui->synced_i_size >> PAGE_CACHE_SHIFT);\n\tspin_unlock(&ui->ui_lock);\n#endif\n\n\t/* Update radix tree tags */\n\tset_page_writeback(page);\n\n\taddr = kmap(page);\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\ti = 0;\n\twhile (len) {\n\t\tblen = min_t(int, len, UBIFS_BLOCK_SIZE);\n\t\tdata_key_init(c, &key, inode->i_ino, block);\n\t\terr = ubifs_jnl_write_data(c, inode, &key, addr, blen);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += blen;\n\t\tlen -= blen;\n\t}\n\tif (err) {\n\t\tSetPageError(page);\n\t\tubifs_err(\"cannot write page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tubifs_ro_mode(c, err);\n\t}\n\n\tubifs_assert(PagePrivate(page));\n\tif (PageChecked(page))\n\t\trelease_new_page_budget(c);\n\telse\n\t\trelease_existing_page_budget(c);\n\n\tatomic_long_dec(&c->dirty_pg_cnt);\n\tClearPagePrivate(page);\n\tClearPageChecked(page);\n\n\tkunmap(page);\n\tunlock_page(page);\n\tend_page_writeback(page);\n\treturn err;\n}\n\n/*\n * When"
  },
  {
    "function_name": "e(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "888-895",
    "snippet": "ifs_readpage(struct file *file, struct page *page)\n{\n\tif (ubifs_bulk_read(page))\n\t\treturn 0;\n\tdo_readpage(page);\n\tunlock_page(page);\n\treturn 0;\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "age);\n\tretu",
          "args": [
            "n 0;"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\tunlo",
          "args": [
            "k_pa"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad(page))\n\t\tret",
          "args": [
            "rn 0"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_readpage(struct file *file, struct page *page)\n{\n\tif (ubifs_bulk_read(page))\n\t\treturn 0;\n\tdo_readpage(page);\n\tunlock_page(page);\n\treturn 0;\n}\n\nstatic int"
  },
  {
    "function_name": "ad(struct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "822-886",
    "snippet": "ifs_bulk_read(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = page->index, last_page_read = ui->last_page_read;\n\tstruct bu_info *bu;\n\tint err = 0, allocated = 0;\n\n\tui->last_page_read = index;\n\tif (!c->bulk_read)\n\t\treturn 0;\n\n\t/*\n\t * Bulk-read is protected by @ui->ui_mutex, but it is an optimization,\n\t * so don't bother if we cannot lock the mutex.\n\t */\n\tif (!mutex_trylock(&ui->ui_mutex))\n\t\treturn 0;\n\n\tif (index != last_page_read + 1) {\n\t\t/* Turn off bulk-read if we stop reading sequentially */\n\t\tui->read_in_a_row = 1;\n\t\tif (ui->bulk_read)\n\t\t\tui->bulk_read = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!ui->bulk_read) {\n\t\tui->read_in_a_row += 1;\n\t\tif (ui->read_in_a_row < 3)\n\t\t\tgoto out_unlock;\n\t\t/* Three reads in a row, so switch on bulk-read */\n\t\tui->bulk_read = 1;\n\t}\n\n\t/*\n\t * If possible, try to use pre-allocated bulk-read information, which\n\t * is protected by @c->bu_mutex.\n\t */\n\tif (mutex_trylock(&c->bu_mutex))\n\t\tbu = &c->bu;\n\telse {\n\t\tbu = kmalloc(sizeof(struct bu_info), GFP_NOFS | __GFP_NOWARN);\n\t\tif (!bu)\n\t\t\tgoto out_unlock;\n\n\t\tbu->buf = NULL;\n\t\tallocated = 1;\n\t}\n\n\tbu->buf_len = c->max_bu_buf_len;\n\tdata_key_init(c, &bu->key, inode->i_ino,\n\t\t      page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT);\n\terr = ubifs_do_bulk_read(c, bu, page);\n\n\tif (!allocated)\n\t\tmutex_unlock(&c->bu_mutex);\n\telse\n\t\tkfree(bu);\n\nout_unlock:\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ut_un",
          "args": [
            "oc"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "522-528",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "&c->bu_mutex",
          "args": [
            ";\n\telse\n\t\tkf"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_read(c, bu, page)",
          "args": [
            "if",
            "!all"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &bu->key,",
          "args": [
            "i",
            "de->i_in",
            "pag",
            "< UBIFS_BLOCKS_PER_PAGE_SHIFT);\n\terr = ubi"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "bu_info), GFP_NOFS |",
            "GFP_NOWARN);\n\t\tif (!bu)"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "(&c->bu_mutex",
          "args": [
            ")\n\t\tbu = &c-"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&ui->ui_mute",
          "args": [
            "))\n\t\treturn 0"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tpgo",
          "args": [
            "f_t i"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_bulk_read(struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = page->index, last_page_read = ui->last_page_read;\n\tstruct bu_info *bu;\n\tint err = 0, allocated = 0;\n\n\tui->last_page_read = index;\n\tif (!c->bulk_read)\n\t\treturn 0;\n\n\t/*\n\t * Bulk-read is protected by @ui->ui_mutex, but it is an optimization,\n\t * so don't bother if we cannot lock the mutex.\n\t */\n\tif (!mutex_trylock(&ui->ui_mutex))\n\t\treturn 0;\n\n\tif (index != last_page_read + 1) {\n\t\t/* Turn off bulk-read if we stop reading sequentially */\n\t\tui->read_in_a_row = 1;\n\t\tif (ui->bulk_read)\n\t\t\tui->bulk_read = 0;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!ui->bulk_read) {\n\t\tui->read_in_a_row += 1;\n\t\tif (ui->read_in_a_row < 3)\n\t\t\tgoto out_unlock;\n\t\t/* Three reads in a row, so switch on bulk-read */\n\t\tui->bulk_read = 1;\n\t}\n\n\t/*\n\t * If possible, try to use pre-allocated bulk-read information, which\n\t * is protected by @c->bu_mutex.\n\t */\n\tif (mutex_trylock(&c->bu_mutex))\n\t\tbu = &c->bu;\n\telse {\n\t\tbu = kmalloc(sizeof(struct bu_info), GFP_NOFS | __GFP_NOWARN);\n\t\tif (!bu)\n\t\t\tgoto out_unlock;\n\n\t\tbu->buf = NULL;\n\t\tallocated = 1;\n\t}\n\n\tbu->buf_len = c->max_bu_buf_len;\n\tdata_key_init(c, &bu->key, inode->i_ino,\n\t\t      page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT);\n\terr = ubifs_do_bulk_read(c, bu, page);\n\n\tif (!allocated)\n\t\tmutex_unlock(&c->bu_mutex);\n\telse\n\t\tkfree(bu);\n\nout_unlock:\n\tmutex_unlock(&ui->ui_mutex);\n\treturn err;\n}\n\nstatic int"
  },
  {
    "function_name": "_read(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "714-811",
    "snippet": "ifs_do_bulk_read(struct ubifs_info *c, struct bu_info *bu,\n\t\t\t      struct page *page1)\n{\n\tpgoff_t offset = page1->index, end_index;\n\tstruct address_space *mapping = page1->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint err, page_idx, page_cnt, ret = 0, n = 0;\n\tint allocate = bu->buf ? 0 : 1;\n\tloff_t isize;\n\n\terr = ubifs_tnc_get_bu_keys(c, bu);\n\tif (err)\n\t\tgoto out_warn;\n\n\tif (bu->eof) {\n\t\t/* Turn off bulk-read at the end of the file */\n\t\tui->read_in_a_row = 1;\n\t\tui->bulk_read = 0;\n\t}\n\n\tpage_cnt = bu->blk_cnt >> UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tif (!page_cnt) {\n\t\t/*\n\t\t * This happens when there are multiple blocks per page and the\n\t\t * blocks for the first page we are looking for, are not\n\t\t * together. If all the pages were like this, bulk-read would\n\t\t * reduce performance, so we turn it off for a while.\n\t\t */\n\t\tgoto out_bu_off;\n\t}\n\n\tif (bu->cnt) {\n\t\tif (allocate) {\n\t\t\t/*\n\t\t\t * Allocate bulk-read buffer depending on how many data\n\t\t\t * nodes we are going to read.\n\t\t\t */\n\t\t\tbu->buf_len = bu->zbranch[bu->cnt - 1].offs +\n\t\t\t\t      bu->zbranch[bu->cnt - 1].len -\n\t\t\t\t      bu->zbranch[0].offs;\n\t\t\tubifs_assert(bu->buf_len > 0);\n\t\t\tubifs_assert(bu->buf_len <= c->leb_size);\n\t\t\tbu->buf = kmalloc(bu->buf_len, GFP_NOFS | __GFP_NOWARN);\n\t\t\tif (!bu->buf)\n\t\t\t\tgoto out_bu_off;\n\t\t}\n\n\t\terr = ubifs_tnc_bulk_read(c, bu);\n\t\tif (err)\n\t\t\tgoto out_warn;\n\t}\n\n\terr = populate_page(c, page1, bu, &n);\n\tif (err)\n\t\tgoto out_warn;\n\n\tunlock_page(page1);\n\tret = 1;\n\n\tisize = i_size_read(inode);\n\tif (isize == 0)\n\t\tgoto out_free;\n\tend_index = ((isize - 1) >> PAGE_CACHE_SHIFT);\n\n\tfor (page_idx = 1; page_idx < page_cnt; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\t\tstruct page *page;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\t\tpage = find_or_create_page(mapping, page_offset,\n\t\t\t\t\t   GFP_NOFS | __GFP_COLD);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (!PageUptodate(page))\n\t\t\terr = populate_page(c, page, bu, &n);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tui->last_page_read = offset + page_idx - 1;\n\nout_free:\n\tif (allocate)\n\t\tkfree(bu->buf);\n\treturn ret;\n\nout_warn:\n\tubifs_warn(\"ignoring error %d and skipping bulk-read\", err);\n\tgoto out_free;\n\nout_bu_off:\n\tui->read_in_a_row = ui->bulk_read = 0;\n\tgoto out_free;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnoring er",
          "args": [
            "or %d and skipping bulk-read\", err);\n\tgoto",
            "ut_"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tr",
          "args": [
            "turn re"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\t\tif",
          "args": [
            "err)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\tpag",
          "args": [
            "_cac"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, page, bu,",
          "args": [
            "&",
            ";",
            "lo",
            "_p"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page))\n\t\t\ter",
          "args": [
            "= p"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_page(mapping, pag",
          "args": [
            "_offset",
            "GFP",
            "GFP_COLD);\n\t\tif (!pag"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tif",
          "args": [
            "isize"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age1);\n\tret",
          "args": [
            "= 1;"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, page1, bu",
          "args": [
            ");\n\ti",
            "(e",
            ")"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k_read(c, bu);\n\t\tif",
          "args": [
            "(",
            "r)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf_len,",
          "args": [
            "GFP_NOFS |",
            "GFP_NOWARN);\n\t\t\tif (!bu"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bu->buf_len",
          "args": [
            "= c->leb_size);\n\t\t\tbu->buf"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bu->buf_len",
          "args": [
            "0);\n\t\t\tubifs_a"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bu_keys(c, bu);\n\tif",
          "args": [
            "e",
            ")"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tint",
          "args": [
            "err,"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_do_bulk_read(struct ubifs_info *c, struct bu_info *bu,\n\t\t\t      struct page *page1)\n{\n\tpgoff_t offset = page1->index, end_index;\n\tstruct address_space *mapping = page1->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint err, page_idx, page_cnt, ret = 0, n = 0;\n\tint allocate = bu->buf ? 0 : 1;\n\tloff_t isize;\n\n\terr = ubifs_tnc_get_bu_keys(c, bu);\n\tif (err)\n\t\tgoto out_warn;\n\n\tif (bu->eof) {\n\t\t/* Turn off bulk-read at the end of the file */\n\t\tui->read_in_a_row = 1;\n\t\tui->bulk_read = 0;\n\t}\n\n\tpage_cnt = bu->blk_cnt >> UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tif (!page_cnt) {\n\t\t/*\n\t\t * This happens when there are multiple blocks per page and the\n\t\t * blocks for the first page we are looking for, are not\n\t\t * together. If all the pages were like this, bulk-read would\n\t\t * reduce performance, so we turn it off for a while.\n\t\t */\n\t\tgoto out_bu_off;\n\t}\n\n\tif (bu->cnt) {\n\t\tif (allocate) {\n\t\t\t/*\n\t\t\t * Allocate bulk-read buffer depending on how many data\n\t\t\t * nodes we are going to read.\n\t\t\t */\n\t\t\tbu->buf_len = bu->zbranch[bu->cnt - 1].offs +\n\t\t\t\t      bu->zbranch[bu->cnt - 1].len -\n\t\t\t\t      bu->zbranch[0].offs;\n\t\t\tubifs_assert(bu->buf_len > 0);\n\t\t\tubifs_assert(bu->buf_len <= c->leb_size);\n\t\t\tbu->buf = kmalloc(bu->buf_len, GFP_NOFS | __GFP_NOWARN);\n\t\t\tif (!bu->buf)\n\t\t\t\tgoto out_bu_off;\n\t\t}\n\n\t\terr = ubifs_tnc_bulk_read(c, bu);\n\t\tif (err)\n\t\t\tgoto out_warn;\n\t}\n\n\terr = populate_page(c, page1, bu, &n);\n\tif (err)\n\t\tgoto out_warn;\n\n\tunlock_page(page1);\n\tret = 1;\n\n\tisize = i_size_read(inode);\n\tif (isize == 0)\n\t\tgoto out_free;\n\tend_index = ((isize - 1) >> PAGE_CACHE_SHIFT);\n\n\tfor (page_idx = 1; page_idx < page_cnt; page_idx++) {\n\t\tpgoff_t page_offset = offset + page_idx;\n\t\tstruct page *page;\n\n\t\tif (page_offset > end_index)\n\t\t\tbreak;\n\t\tpage = find_or_create_page(mapping, page_offset,\n\t\t\t\t\t   GFP_NOFS | __GFP_COLD);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (!PageUptodate(page))\n\t\t\terr = populate_page(c, page, bu, &n);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tui->last_page_read = offset + page_idx - 1;\n\nout_free:\n\tif (allocate)\n\t\tkfree(bu->buf);\n\treturn ret;\n\nout_warn:\n\tubifs_warn(\"ignoring error %d and skipping bulk-read\", err);\n\tgoto out_free;\n\nout_bu_off:\n\tui->read_in_a_row = ui->bulk_read = 0;\n\tgoto out_free;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "610-704",
    "snippet": "pulate_page(struct ubifs_info *c, struct page *page,\n\t\t\t struct bu_info *bu, int *n)\n{\n\tint i = 0, nn = *n, offs = bu->zbranch[0].offs, hole = 0, read = 0;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned int page_block;\n\tvoid *addr, *zaddr;\n\tpgoff_t end_index;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\n\taddr = zaddr = kmap(page);\n\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (!i_size || page->index > end_index) {\n\t\thole = 1;\n\t\tmemset(addr, 0, PAGE_CACHE_SIZE);\n\t\tgoto out_hole;\n\t}\n\n\tpage_block = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\twhile (1) {\n\t\tint err, len, out_len, dlen;\n\n\t\tif (nn >= bu->cnt) {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) == page_block) {\n\t\t\tstruct ubifs_data_node *dn;\n\n\t\t\tdn = bu->buf + (bu->zbranch[nn].offs - offs);\n\n\t\t\tubifs_assert(le64_to_cpu(dn->ch.sqnum) >\n\t\t\t\t     ubifs_inode(inode)->creat_sqnum);\n\n\t\t\tlen = le32_to_cpu(dn->size);\n\t\t\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\t\t\tgoto out_err;\n\n\t\t\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\t\t\tout_len = UBIFS_BLOCK_SIZE;\n\t\t\terr = ubifs_decompress(&dn->data, dlen, addr, &out_len,\n\t\t\t\t\t       le16_to_cpu(dn->compr_type));\n\t\t\tif (err || len != out_len)\n\t\t\t\tgoto out_err;\n\n\t\t\tif (len < UBIFS_BLOCK_SIZE)\n\t\t\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\t\t\tnn += 1;\n\t\t\tread = (i << UBIFS_BLOCK_SHIFT) + len;\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) < page_block) {\n\t\t\tnn += 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t\tpage_block += 1;\n\t}\n\n\tif (end_index == page->index) {\n\t\tint len = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (len && len < read)\n\t\t\tmemset(zaddr + len, 0, read - len);\n\t}\n\nout_hole:\n\tif (hole) {\n\t\tSetPageChecked(page);\n\t\tdbg_gen(\"hole\");\n\t}\n\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\t*n = nn;\n\treturn 0;\n\nout_err:\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tubifs_err(\"bad data node (block %u, inode %lu)\",\n\t\t  page_block, inode->i_ino);\n\treturn -EINVAL;\n}\n\n/**\n * ubif",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d data no",
          "args": [
            "e (block %u, inode %lu)\",\n\t\t  page_bl",
            "node->i_in",
            ";\n\treturn -E"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubif",
          "args": [
            "_err"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "page(page);\n\tkunm",
          "args": [
            "p(pa"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page);\n\tflus",
          "args": [
            "_dca"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date(page);\n\tSetP",
          "args": [
            "geEr"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*n =",
          "args": [
            "nn;"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page(page);\n\tkunm",
          "args": [
            "p(pa"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(page);\n\tflus",
          "args": [
            "_dca"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(page);\n\tClea",
          "args": [
            "Page"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\");\n\t}",
          "args": [
            "SetPa"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(page);\n\t\tdbg",
          "args": [
            "gen("
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ len,",
          "args": [
            "0, read - l",
            ")",
            "}\n\nout_ho"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, UBI",
          "args": [
            "S_BL",
            "K",
            "IZE);\n\t\t}\n\t\tif ("
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bu->zbra",
          "args": [
            "c",
            "nn].key) < page_bloc"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len,",
          "args": [
            ", UBIFS_BL",
            "K",
            "IZE - len);\n\n\t\t\tnn +="
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess(&dn->data, d",
          "args": [
            "en, addr,",
            "out_",
            "n,",
            "n->compr_type));\n\t\t\tif (err"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->compr_ty",
          "args": [
            "e));\n\t\t\tif (er"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->ch.len)",
          "args": [
            "UBIFS_DAT"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size);",
          "args": [
            "if (len"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu(",
          "args": [
            "n->ch.sqnum) >\n\t\t\t\t     ubifs_inode(inode)->creat_sqnum);\n\n\t\t\tlen ="
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->crea",
          "args": [
            "_sqnu"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->ch.sqnum",
          "args": [
            ">"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bu->zbra",
          "args": [
            "c",
            "nn].key) == page_blo"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, UBI",
          "args": [
            "S_BL",
            "K",
            "IZE);\n\t\t} else i"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, PAG",
          "args": [
            "_CAC",
            "_",
            "ZE);\n\t\tgoto out"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end",
          "args": [
            "inde"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_writepages_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "1712-1729",
          "snippet": "static void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_writepages_send(struct fuse_fill_wb_data *data)\n{\n\tstruct fuse_req *req = data->req;\n\tstruct inode *inode = data->inode;\n\tstruct fuse_conn *fc = get_fuse_conn(inode);\n\tstruct fuse_inode *fi = get_fuse_inode(inode);\n\tint num_pages = req->num_pages;\n\tint i;\n\n\treq->ff = fuse_file_get(data->ff);\n\tspin_lock(&fc->lock);\n\tlist_add_tail(&req->list, &fi->queued_writes);\n\tfuse_flush_writepages(inode);\n\tspin_unlock(&fc->lock);\n\n\tfor (i = 0; i < num_pages; i++)\n\t\tend_page_writeback(data->orig_pages[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "%lu, pg",
          "args": [
            "%lu, i_size %lld, flags %#lx\",\n\t\tinode->i_",
            "page->index",
            "i_size, pag",
            ">flags",
            "addr = z"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tuns",
          "args": [
            "gned"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\npulate_page(struct ubifs_info *c, struct page *page,\n\t\t\t struct bu_info *bu, int *n)\n{\n\tint i = 0, nn = *n, offs = bu->zbranch[0].offs, hole = 0, read = 0;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tunsigned int page_block;\n\tvoid *addr, *zaddr;\n\tpgoff_t end_index;\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\n\taddr = zaddr = kmap(page);\n\n\tend_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\tif (!i_size || page->index > end_index) {\n\t\thole = 1;\n\t\tmemset(addr, 0, PAGE_CACHE_SIZE);\n\t\tgoto out_hole;\n\t}\n\n\tpage_block = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\twhile (1) {\n\t\tint err, len, out_len, dlen;\n\n\t\tif (nn >= bu->cnt) {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) == page_block) {\n\t\t\tstruct ubifs_data_node *dn;\n\n\t\t\tdn = bu->buf + (bu->zbranch[nn].offs - offs);\n\n\t\t\tubifs_assert(le64_to_cpu(dn->ch.sqnum) >\n\t\t\t\t     ubifs_inode(inode)->creat_sqnum);\n\n\t\t\tlen = le32_to_cpu(dn->size);\n\t\t\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\t\t\tgoto out_err;\n\n\t\t\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\t\t\tout_len = UBIFS_BLOCK_SIZE;\n\t\t\terr = ubifs_decompress(&dn->data, dlen, addr, &out_len,\n\t\t\t\t\t       le16_to_cpu(dn->compr_type));\n\t\t\tif (err || len != out_len)\n\t\t\t\tgoto out_err;\n\n\t\t\tif (len < UBIFS_BLOCK_SIZE)\n\t\t\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\t\t\tnn += 1;\n\t\t\tread = (i << UBIFS_BLOCK_SHIFT) + len;\n\t\t} else if (key_block(c, &bu->zbranch[nn].key) < page_block) {\n\t\t\tnn += 1;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\thole = 1;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t\tpage_block += 1;\n\t}\n\n\tif (end_index == page->index) {\n\t\tint len = i_size & (PAGE_CACHE_SIZE - 1);\n\n\t\tif (len && len < read)\n\t\t\tmemset(zaddr + len, 0, read - len);\n\t}\n\nout_hole:\n\tif (hole) {\n\t\tSetPageChecked(page);\n\t\tdbg_gen(\"hole\");\n\t}\n\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\t*n = nn;\n\treturn 0;\n\nout_err:\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\tubifs_err(\"bad data node (block %u, inode %lu)\",\n\t\t  page_block, inode->i_ino);\n\treturn -EINVAL;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "nd(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "540-599",
    "snippet": "ifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tloff_t end_pos = pos + len;\n\tint appending = !!(end_pos > inode->i_size);\n\n\tdbg_gen(\"ino %lu, pos %llu, pg %lu, len %u, copied %d, i_size %lld\",\n\t\tinode->i_ino, pos, page->index, len, copied, inode->i_size);\n\n\tif (unlikely(copied < len && len == PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * VFS copied less data to the page that it intended and\n\t\t * declared in its '->write_begin()' call via the @len\n\t\t * argument. If the page was not up-to-date, and @len was\n\t\t * @PAGE_CACHE_SIZE, the 'ubifs_write_begin()' function did\n\t\t * not load it from the media (for optimization reasons). This\n\t\t * means that part of the page contains garbage. So read the\n\t\t * page now.\n\t\t */\n\t\tdbg_gen(\"copied %d instead of %d, read page and repeat\",\n\t\t\tcopied, len);\n\t\tcancel_budget(c, page, ui, appending);\n\t\tClearPageChecked(page);\n\n\t\t/*\n\t\t * Return 0 to force VFS to repeat the whole operation, or the\n\t\t * error code if 'do_readpage()' fails.\n\t\t */\n\t\tcopied = do_readpage(page);\n\t\tgoto out;\n\t}\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (appending) {\n\t\ti_size_write(inode, end_pos);\n\t\tui->ui_size = end_pos;\n\t\t/*\n\t\t * Note, we do not set @I_DIRTY_PAGES (which means that the\n\t\t * inode has dirty pages), this has been done in\n\t\t * '__set_page_dirty_nobuffers()'.\n\t\t */\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\nout:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn copied;\n}\n\n/**\n * popu",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease(page);\n\tretu",
          "args": [
            "n co"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\tpage",
          "args": [
            "cach"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t}\n\nout:"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ui->ui_mutex));\n\t\tmutex_un"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ui->ui_mute",
          "args": [
            "));\n\t\tmutex_u"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirty(inode, I_DIR",
          "args": [
            "Y_DAT",
            "YNC);\n\t\tubifs_as"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode, end_p",
          "args": [
            "s);",
            "i->ui_s"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_nobuffers(page);\n\t}",
          "args": [
            "f (a"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc(&c->dirty_pg",
          "args": [
            "cnt);\n\t\t__set_pa"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(page);\n\t\tato",
          "args": [
            "ic_l"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age)) {\n\t\tS",
          "args": [
            "tPag"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\tgot",
          "args": [
            "out"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ked(page);\n\n\t\t/*",
          "args": [
            "*"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, page, ui,",
          "args": [
            "a",
            "endi",
            ");",
            "ClearPag"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed %d i",
          "args": [
            "stead of %d, read page and repeat\",\n\t\t\tcopied,",
            "can",
            "l_b"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed < len",
          "args": [
            "&& len == PAGE_CACHE_SIZE)) {\n\t\t/*"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, po",
          "args": [
            "%llu, pg %lu, len %u, copied %d, i_size %lld\",\n\t\tinode->i_",
            "pos, page->",
            "dex",
            "len, copied",
            "ino",
            "->i_si",
            ");\n\n\tif (unli"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_write_end(struct file *file, struct address_space *mapping,\n\t\t\t   loff_t pos, unsigned len, unsigned copied,\n\t\t\t   struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tloff_t end_pos = pos + len;\n\tint appending = !!(end_pos > inode->i_size);\n\n\tdbg_gen(\"ino %lu, pos %llu, pg %lu, len %u, copied %d, i_size %lld\",\n\t\tinode->i_ino, pos, page->index, len, copied, inode->i_size);\n\n\tif (unlikely(copied < len && len == PAGE_CACHE_SIZE)) {\n\t\t/*\n\t\t * VFS copied less data to the page that it intended and\n\t\t * declared in its '->write_begin()' call via the @len\n\t\t * argument. If the page was not up-to-date, and @len was\n\t\t * @PAGE_CACHE_SIZE, the 'ubifs_write_begin()' function did\n\t\t * not load it from the media (for optimization reasons). This\n\t\t * means that part of the page contains garbage. So read the\n\t\t * page now.\n\t\t */\n\t\tdbg_gen(\"copied %d instead of %d, read page and repeat\",\n\t\t\tcopied, len);\n\t\tcancel_budget(c, page, ui, appending);\n\t\tClearPageChecked(page);\n\n\t\t/*\n\t\t * Return 0 to force VFS to repeat the whole operation, or the\n\t\t * error code if 'do_readpage()' fails.\n\t\t */\n\t\tcopied = do_readpage(page);\n\t\tgoto out;\n\t}\n\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tatomic_long_inc(&c->dirty_pg_cnt);\n\t\t__set_page_dirty_nobuffers(page);\n\t}\n\n\tif (appending) {\n\t\ti_size_write(inode, end_pos);\n\t\tui->ui_size = end_pos;\n\t\t/*\n\t\t * Note, we do not set @I_DIRTY_PAGES (which means that the\n\t\t * inode has dirty pages), this has been done in\n\t\t * '__set_page_dirty_nobuffers()'.\n\t\t */\n\t\t__mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n\t\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\nout:\n\tunlock_page(page);\n\tpage_cache_release(page);\n\treturn copied;\n}\n\n/**\n * popu"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "524-538",
    "snippet": "ancel_budget(struct ubifs_info *c, struct page *page,\n\t\t\t  struct ubifs_inode *ui, int appending)\n{\n\tif (appending) {\n\t\tif (!ui->dirty)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\tif (!PagePrivate(page)) {\n\t\tif (PageChecked(page))\n\t\t\trelease_new_page_budget(c);\n\t\telse\n\t\t\trelease_existing_page_budget(c);\n\t}\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ing_page_budget(c);\n\t}\n}\n\nst",
          "args": [
            "t"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age_budget(c);\n\t\telse",
          "args": [],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\t\tre",
          "args": [
            "ease"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age)) {\n\t\ti",
          "args": [
            "(Pa"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t}\n\tif (!P"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\t\tmu",
          "args": [
            "e",
            "un"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nancel_budget(struct ubifs_info *c, struct page *page,\n\t\t\t  struct ubifs_inode *ui, int appending)\n{\n\tif (appending) {\n\t\tif (!ui->dirty)\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t\tmutex_unlock(&ui->ui_mutex);\n\t}\n\tif (!PagePrivate(page)) {\n\t\tif (PageChecked(page))\n\t\t\trelease_new_page_budget(c);\n\t\telse\n\t\t\trelease_existing_page_budget(c);\n\t}\n}\n\nstatic int"
  },
  {
    "function_name": "egin(struct file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "425-512",
    "snippet": "ifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint uninitialized_var(err), appending = !!(pos + len > inode->i_size);\n\tint skipped_read = 0;\n\tstruct page *page;\n\n\tubifs_assert(ubifs_inode(inode)->ui_size == inode->i_size);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn -EROFS;\n\n\t/* Try out the fast-path part first */\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\t/* The page is not loaded from the flash */\n\t\tif (!(pos & ~PAGE_CACHE_MASK) && len == PAGE_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * We change whole page so no need to load it. But we\n\t\t\t * do not know whether this page exists on the media or\n\t\t\t * not, so we assume the latter because it requires\n\t\t\t * larger budget. The assumption is that it is better\n\t\t\t * to budget a bit more than to read the page from the\n\t\t\t * media. Thus, we are setting the @PG_checked flag\n\t\t\t * here.\n\t\t\t */\n\t\t\tSetPageChecked(page);\n\t\t\tskipped_read = 1;\n\t\t} else {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\terr = allocate_budget(c, page, ui, appending);\n\tif (unlikely(err)) {\n\t\tubifs_assert(err == -ENOSPC);\n\t\t/*\n\t\t * If we skipped reading the page because we were going to\n\t\t * write all of it, then it is not up to date.\n\t\t */\n\t\tif (skipped_read) {\n\t\t\tClearPageChecked(page);\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t\t/*\n\t\t * Budgeting failed which means it would have to force\n\t\t * write-back but didn't, because we set the @fast flag in the\n\t\t * request. Write-back cannot be done now, while we have the\n\t\t * page locked, because it would deadlock. Unlock and free\n\t\t * everything and fall-back to slow-path.\n\t\t */\n\t\tif (appending) {\n\t\t\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\t\t\tmutex_unlock(&ui->ui_mutex);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\treturn write_begin_slow(mapping, pos, len, pagep, flags);\n\t}\n\n\t/*\n\t * Whee, we acquired budgeting quickly - without involving\n\t * garbage-collection, committing or forcing write-back. We return\n\t * with @ui->ui_mutex locked if we are appending pages, and unlocked\n\t * otherwise. This is an optimization (slightly hacky though).\n\t */\n\t*pagep = page;\n\treturn 0;\n\n}\n\n/**\n * canc",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "low(mapping, pos",
          "args": [
            "len, p",
            "ep,",
            "lag",
            ";\n\t}",
            "/*"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\n\t\tre",
          "args": [
            "urn"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\tpag",
          "args": [
            "_cac"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&ui->ui_mute",
          "args": [
            ");\n\t\t}\n\t\tunlo"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ui->ui_mutex));\n\t\t\tmutex_u"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ui->ui_mute",
          "args": [
            "));\n\t\t\tmutex_"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date(page);\n\t\t}",
          "args": [
            "/*"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ked(page);\n\t\t\tCl",
          "args": [
            "arPa"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err == -ENOS",
          "args": [
            "C);\n\t\t/*\n\t\t *"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") {\n\t\tub",
          "args": [
            "fs_"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et(c, page, ui,",
          "args": [
            "a",
            "endi",
            ");",
            "if (unlik"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(page);\n\t}",
          "args": [
            "rr ="
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(page);\n\t\tCle",
          "args": [
            "rPag"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\t\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\t\t\tp",
          "args": [
            "ge_c"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\t\tif",
          "args": [
            "(err"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(page);\n\t\t\tsk",
          "args": [
            "pped"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page)) {\n\t\t/",
          "args": [
            "The"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e))\n\t\tre",
          "args": [
            "urn -"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ge_write_begin(mapping, ind",
          "args": [
            "x, flag",
            ";\n\tif",
            "unlik"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o_error)",
          "args": [
            "return -"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\n\tif (unli"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_inode(",
          "args": [
            "node)->ui_size == inode->i_size);\n\tubifs_ass"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->ui_s",
          "args": [
            "ze =="
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tpgo",
          "args": [
            "f_t i"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nifs_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned flags,\n\t\t\t     struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tint uninitialized_var(err), appending = !!(pos + len > inode->i_size);\n\tint skipped_read = 0;\n\tstruct page *page;\n\n\tubifs_assert(ubifs_inode(inode)->ui_size == inode->i_size);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\n\tif (unlikely(c->ro_error))\n\t\treturn -EROFS;\n\n\t/* Try out the fast-path part first */\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (unlikely(!page))\n\t\treturn -ENOMEM;\n\n\tif (!PageUptodate(page)) {\n\t\t/* The page is not loaded from the flash */\n\t\tif (!(pos & ~PAGE_CACHE_MASK) && len == PAGE_CACHE_SIZE) {\n\t\t\t/*\n\t\t\t * We change whole page so no need to load it. But we\n\t\t\t * do not know whether this page exists on the media or\n\t\t\t * not, so we assume the latter because it requires\n\t\t\t * larger budget. The assumption is that it is better\n\t\t\t * to budget a bit more than to read the page from the\n\t\t\t * media. Thus, we are setting the @PG_checked flag\n\t\t\t * here.\n\t\t\t */\n\t\t\tSetPageChecked(page);\n\t\t\tskipped_read = 1;\n\t\t} else {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\terr = allocate_budget(c, page, ui, appending);\n\tif (unlikely(err)) {\n\t\tubifs_assert(err == -ENOSPC);\n\t\t/*\n\t\t * If we skipped reading the page because we were going to\n\t\t * write all of it, then it is not up to date.\n\t\t */\n\t\tif (skipped_read) {\n\t\t\tClearPageChecked(page);\n\t\t\tClearPageUptodate(page);\n\t\t}\n\t\t/*\n\t\t * Budgeting failed which means it would have to force\n\t\t * write-back but didn't, because we set the @fast flag in the\n\t\t * request. Write-back cannot be done now, while we have the\n\t\t * page locked, because it would deadlock. Unlock and free\n\t\t * everything and fall-back to slow-path.\n\t\t */\n\t\tif (appending) {\n\t\t\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\t\t\tmutex_unlock(&ui->ui_mutex);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\n\t\treturn write_begin_slow(mapping, pos, len, pagep, flags);\n\t}\n\n\t/*\n\t * Whee, we acquired budgeting quickly - without involving\n\t * garbage-collection, committing or forcing write-back. We return\n\t * with @ui->ui_mutex locked if we are appending pages, and unlocked\n\t * otherwise. This is an optimization (slightly hacky though).\n\t */\n\t*pagep = page;\n\treturn 0;\n\n}\n\n/**\n * canc"
  },
  {
    "function_name": "et(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "329-391",
    "snippet": "locate_budget(struct ubifs_info *c, struct page *page,\n\t\t\t   struct ubifs_inode *ui, int appending)\n{\n\tstruct ubifs_budget_req req = { .fast = 1 };\n\n\tif (PagePrivate(page)) {\n\t\tif (!appending)\n\t\t\t/*\n\t\t\t * The page is dirty and we are not appending, which\n\t\t\t * means no budget is needed at all.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t/*\n\t\t\t * The page is dirty and we are appending, so the inode\n\t\t\t * has to be marked as dirty. However, it is already\n\t\t\t * dirty, so we do not need any budget. We may return,\n\t\t\t * but @ui->ui_mutex hast to be left locked because we\n\t\t\t * should prevent write-back from flushing the inode\n\t\t\t * and freeing the budget. The lock will be released in\n\t\t\t * 'ubifs_write_end()'.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The page is dirty, we are appending, the inode is clean, so\n\t\t * we need to budget the inode change.\n\t\t */\n\t\treq.dirtied_ino = 1;\n\t} else {\n\t\tif (PageChecked(page))\n\t\t\t/*\n\t\t\t * The page corresponds to a hole and does not\n\t\t\t * exist on the media. So changing it makes\n\t\t\t * make the amount of indexing information\n\t\t\t * larger, and we have to budget for a new\n\t\t\t * page.\n\t\t\t */\n\t\t\treq.new_page = 1;\n\t\telse\n\t\t\t/*\n\t\t\t * Not a hole, the change will not add any new\n\t\t\t * indexing information, budget for page\n\t\t\t * change.\n\t\t\t */\n\t\t\treq.dirtied_page = 1;\n\n\t\tif (appending) {\n\t\t\tmutex_lock(&ui->ui_mutex);\n\t\t\tif (!ui->dirty)\n\t\t\t\t/*\n\t\t\t\t * The inode is clean but we will have to mark\n\t\t\t\t * it as dirty because we are appending. This\n\t\t\t\t * needs a budget.\n\t\t\t\t */\n\t\t\t\treq.dirtied_ino = 1;\n\t\t}\n\t}\n\n\treturn ubifs_budget_space(c, &req);\n}\n\n/*\n * This",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "space(c, &req);\n}",
          "args": [
            "/",
            "* T"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t\t\tif (!ui"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\t\t/*",
          "args": [],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t\tif (ui->"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age)) {\n\t\ti",
          "args": [
            "(!a"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nlocate_budget(struct ubifs_info *c, struct page *page,\n\t\t\t   struct ubifs_inode *ui, int appending)\n{\n\tstruct ubifs_budget_req req = { .fast = 1 };\n\n\tif (PagePrivate(page)) {\n\t\tif (!appending)\n\t\t\t/*\n\t\t\t * The page is dirty and we are not appending, which\n\t\t\t * means no budget is needed at all.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t/*\n\t\t\t * The page is dirty and we are appending, so the inode\n\t\t\t * has to be marked as dirty. However, it is already\n\t\t\t * dirty, so we do not need any budget. We may return,\n\t\t\t * but @ui->ui_mutex hast to be left locked because we\n\t\t\t * should prevent write-back from flushing the inode\n\t\t\t * and freeing the budget. The lock will be released in\n\t\t\t * 'ubifs_write_end()'.\n\t\t\t */\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The page is dirty, we are appending, the inode is clean, so\n\t\t * we need to budget the inode change.\n\t\t */\n\t\treq.dirtied_ino = 1;\n\t} else {\n\t\tif (PageChecked(page))\n\t\t\t/*\n\t\t\t * The page corresponds to a hole and does not\n\t\t\t * exist on the media. So changing it makes\n\t\t\t * make the amount of indexing information\n\t\t\t * larger, and we have to budget for a new\n\t\t\t * page.\n\t\t\t */\n\t\t\treq.new_page = 1;\n\t\telse\n\t\t\t/*\n\t\t\t * Not a hole, the change will not add any new\n\t\t\t * indexing information, budget for page\n\t\t\t * change.\n\t\t\t */\n\t\t\treq.dirtied_page = 1;\n\n\t\tif (appending) {\n\t\t\tmutex_lock(&ui->ui_mutex);\n\t\t\tif (!ui->dirty)\n\t\t\t\t/*\n\t\t\t\t * The inode is clean but we will have to mark\n\t\t\t\t * it as dirty because we are appending. This\n\t\t\t\t * needs a budget.\n\t\t\t\t */\n\t\t\t\treq.dirtied_ino = 1;\n\t\t}\n\t}\n\n\treturn ubifs_budget_space(c, &req);\n}\n\n/*\n * This"
  },
  {
    "function_name": "low(struct addre",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "221-314",
    "snippet": "ite_begin_slow(struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, struct page **pagep,\n\t\t\t    unsigned flags)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint uninitialized_var(err), appending = !!(pos + len > inode->i_size);\n\tstruct page *page;\n\n\tdbg_gen(\"ino %lu, pos %llu, len %u, i_size %lld\",\n\t\tinode->i_ino, pos, len, inode->i_size);\n\n\t/*\n\t * At the slow path we have to budget before locking the page, because\n\t * budgeting may force write-back, which would wait on locked pages and\n\t * deadlock if we had the page locked. At this point we do not know\n\t * anything about the page, so assume that this is a new page which is\n\t * written to a hole. This corresponds to largest budget. Later the\n\t * budget will be amended if this is not true.\n\t */\n\tif (appending)\n\t\t/* We are appending data, budget for inode change */\n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (unlikely(!page)) {\n\t\tubifs_release_budget(c, &req);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tif (!(pos & ~PAGE_CACHE_MASK) && len == PAGE_CACHE_SIZE)\n\t\t\tSetPageChecked(page);\n\t\telse {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tubifs_release_budget(c, &req);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\tif (PagePrivate(page))\n\t\t/*\n\t\t * The page is dirty, which means it was budgeted twice:\n\t\t *   o first time the budget was allocated by the task which\n\t\t *     made the page dirty and set the PG_private flag;\n\t\t *   o and then we budgeted for it for the second time at the\n\t\t *     very beginning of this function.\n\t\t *\n\t\t * So what we have to do is to release the page budget we\n\t\t * allocated.\n\t\t */\n\t\trelease_new_page_budget(c);\n\telse if (!PageChecked(page))\n\t\t/*\n\t\t * We are changing a page which already exists on the media.\n\t\t * This means that changing the page does not make the amount\n\t\t * of indexing information larger, and this part of the budget\n\t\t * which we have already acquired may be released.\n\t\t */\n\t\tubifs_convert_page_budget(c);\n\n\tif (appending) {\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\t/*\n\t\t * 'ubifs_write_end()' is optimized from the fast-path part of\n\t\t * 'ubifs_write_begin()' and expects the @ui_mutex to be locked\n\t\t * if data is appended.\n\t\t */\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t/*\n\t\t\t * The inode is dirty already, so we may free the\n\t\t\t * budget we allocated.\n\t\t\t */\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\t*pagep = page;\n\treturn 0;\n}\n\n/**\n * allo",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\t}",
          "args": [
            "*",
            "ge"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_mute",
          "args": [
            ");\n\t\tif (ui->"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\t\t/",
          "args": [
            "*"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_page_budget(c);\n\n\tif (ap",
          "args": [
            "e"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\t/*",
          "args": [
            "*"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age_budget(c);\n\telse if",
          "args": [
            "("
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age))\n\t\t/*",
          "args": [
            "*"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(page);\n\t}",
          "args": [
            "f (P"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(page);\n\t\tCle",
          "args": [
            "rPag"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);",
          "args": [
            "turn"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lease(page);\n\t\t\t\tu",
          "args": [
            "ifs_"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\t\t\tp",
          "args": [
            "ge_c"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age);\n\t\t\tif",
          "args": [
            "(err"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(page);\n\t\tels",
          "args": [
            "{"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page)) {\n\t\ti",
          "args": [
            "(!("
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_budget(c, &req);",
          "args": [
            "e",
            "rn -"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e)) {",
          "args": [
            "bifs_"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ge_write_begin(mapping, ind",
          "args": [
            "x, flag",
            ";\n\tif",
            "unlik"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")\n\t\tretu",
          "args": [
            "n e"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "space(c, &req);\n\ti",
          "args": [
            "nlik"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, po",
          "args": [
            "%llu, len %u, i_size %lld\",\n\t\tinode->i_",
            "pos, len, i",
            "de-",
            "_si",
            ");\n\n\t/*\n\t * A"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nite_begin_slow(struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, struct page **pagep,\n\t\t\t    unsigned flags)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct ubifs_budget_req req = { .new_page = 1 };\n\tint uninitialized_var(err), appending = !!(pos + len > inode->i_size);\n\tstruct page *page;\n\n\tdbg_gen(\"ino %lu, pos %llu, len %u, i_size %lld\",\n\t\tinode->i_ino, pos, len, inode->i_size);\n\n\t/*\n\t * At the slow path we have to budget before locking the page, because\n\t * budgeting may force write-back, which would wait on locked pages and\n\t * deadlock if we had the page locked. At this point we do not know\n\t * anything about the page, so assume that this is a new page which is\n\t * written to a hole. This corresponds to largest budget. Later the\n\t * budget will be amended if this is not true.\n\t */\n\tif (appending)\n\t\t/* We are appending data, budget for inode change */\n\t\treq.dirtied_ino = 1;\n\n\terr = ubifs_budget_space(c, &req);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (unlikely(!page)) {\n\t\tubifs_release_budget(c, &req);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!PageUptodate(page)) {\n\t\tif (!(pos & ~PAGE_CACHE_MASK) && len == PAGE_CACHE_SIZE)\n\t\t\tSetPageChecked(page);\n\t\telse {\n\t\t\terr = do_readpage(page);\n\t\t\tif (err) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tubifs_release_budget(c, &req);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\n\tif (PagePrivate(page))\n\t\t/*\n\t\t * The page is dirty, which means it was budgeted twice:\n\t\t *   o first time the budget was allocated by the task which\n\t\t *     made the page dirty and set the PG_private flag;\n\t\t *   o and then we budgeted for it for the second time at the\n\t\t *     very beginning of this function.\n\t\t *\n\t\t * So what we have to do is to release the page budget we\n\t\t * allocated.\n\t\t */\n\t\trelease_new_page_budget(c);\n\telse if (!PageChecked(page))\n\t\t/*\n\t\t * We are changing a page which already exists on the media.\n\t\t * This means that changing the page does not make the amount\n\t\t * of indexing information larger, and this part of the budget\n\t\t * which we have already acquired may be released.\n\t\t */\n\t\tubifs_convert_page_budget(c);\n\n\tif (appending) {\n\t\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\t\t/*\n\t\t * 'ubifs_write_end()' is optimized from the fast-path part of\n\t\t * 'ubifs_write_begin()' and expects the @ui_mutex to be locked\n\t\t * if data is appended.\n\t\t */\n\t\tmutex_lock(&ui->ui_mutex);\n\t\tif (ui->dirty)\n\t\t\t/*\n\t\t\t * The inode is dirty already, so we may free the\n\t\t\t * budget we allocated.\n\t\t\t */\n\t\t\tubifs_release_dirty_inode_budget(c, ui);\n\t}\n\n\t*pagep = page;\n\treturn 0;\n}\n\n/**\n * allo"
  },
  {
    "function_name": "ing_page_budget(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "214-219",
    "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n}",
          "args": [
            "s",
            "tic"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
  },
  {
    "function_name": "age_budget(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "200-205",
    "snippet": "elease_new_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .recalculate = 1, .new_page = 1 };\n\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * rele",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_budget(c, &req);\n}",
          "args": [
            "/",
            "*"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_new_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .recalculate = 1, .new_page = 1 };\n\n\tubifs_release_budget(c, &req);\n}\n\n/**\n * rele"
  },
  {
    "function_name": "truct page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "105-191",
    "snippet": "_readpage(struct page *page)\n{\n\tvoid *addr;\n\tint err = 0, i;\n\tunsigned int block, beyond;\n\tstruct ubifs_data_node *dn;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\tubifs_assert(!PageChecked(page));\n\tubifs_assert(!PagePrivate(page));\n\n\taddr = kmap(page);\n\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tbeyond = (i_size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tif (block >= beyond) {\n\t\t/* Reading beyond inode */\n\t\tSetPageChecked(page);\n\t\tmemset(addr, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\n\tdn = kmalloc(UBIFS_MAX_DATA_NODE_SZ, GFP_NOFS);\n\tif (!dn) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tint ret;\n\n\t\tif (block >= beyond) {\n\t\t\t/* Reading beyond inode */\n\t\t\terr = -ENOENT;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else {\n\t\t\tret = read_block(inode, addr, block, dn);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\tbreak;\n\t\t\t} else if (block + 1 == beyond) {\n\t\t\t\tint dlen = le32_to_cpu(dn->size);\n\t\t\t\tint ilen = i_size & (UBIFS_BLOCK_SIZE - 1);\n\n\t\t\t\tif (ilen && ilen < dlen)\n\t\t\t\t\tmemset(addr + ilen, 0, dlen - ilen);\n\t\t\t}\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t}\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\t/* Not found, so it must be a hole */\n\t\t\tSetPageChecked(page);\n\t\t\tdbg_gen(\"hole\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_err(\"cannot read page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tgoto error;\n\t}\n\nout_free:\n\tkfree(dn);\nout:\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n\nerror:\n\tkfree(dn);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn err;\n}\n\n/**\n * rele",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page(page);\n\tkunm",
          "args": [
            "p(pa"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page);\n\tflus",
          "args": [
            "_dca"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "date(page);\n\tSetP",
          "args": [
            "geEr"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "learP",
          "args": [
            "ge"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page(page);\n\tkunm",
          "args": [
            "p(pa"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r(page);\n\tflus",
          "args": [
            "_dca"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(page);\n\tClea",
          "args": [
            "Page"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t:\n\tS",
          "args": [
            "tP"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot read",
          "args": [
            "page %lu of inode %lu, error %d\",\n\t\t\t  page->",
            "inode->i_in",
            "err);\n\t\tgot",
            "err"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\");",
          "args": [
            "oto ou"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(page);\n\t\t\tdb",
          "args": [
            "_gen"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilen,",
          "args": [
            "0, dlen - i",
            "n",
            "}\n\t\t}"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size);",
          "args": [
            "int il"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode, addr,",
          "args": [
            "block",
            "dn);",
            "if",
            "et"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, UBI",
          "args": [
            "S_BL",
            "K",
            "IZE);\n\t\t} else {"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_MAX_DA",
          "args": [
            "A_NODE_SZ, GFP_NOFS);",
            "f (!dn)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, PAG",
          "args": [
            "_CAC",
            "_",
            "ZE);\n\t\tgoto out"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(page);\n\t\tmem",
          "args": [
            "et(a"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blo",
          "args": [
            "k ="
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "truncate_data_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "452-455",
          "snippet": "void truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\nvoid truncate_data_blocks(struct dnode_of_data *dn)\n{\n\ttruncate_data_blocks_range(dn, ADDRS_PER_BLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "!PagePrivate",
          "args": [
            "page));\n\n\taddr = k"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\n\tad",
          "args": [
            "r ="
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!PageChecked",
          "args": [
            "page));\n\tubifs_ass"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "age));\n\tubi",
          "args": [
            "s_as"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, pg",
          "args": [
            "%lu, i_size %lld, flags %#lx\",\n\t\tinode->i_",
            "page->index",
            "i_size, pag",
            ">flags",
            "ubifs_ass"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tdb",
          "args": [
            "_gen("
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\n_readpage(struct page *page)\n{\n\tvoid *addr;\n\tint err = 0, i;\n\tunsigned int block, beyond;\n\tstruct ubifs_data_node *dn;\n\tstruct inode *inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\n\tdbg_gen(\"ino %lu, pg %lu, i_size %lld, flags %#lx\",\n\t\tinode->i_ino, page->index, i_size, page->flags);\n\tubifs_assert(!PageChecked(page));\n\tubifs_assert(!PagePrivate(page));\n\n\taddr = kmap(page);\n\n\tblock = page->index << UBIFS_BLOCKS_PER_PAGE_SHIFT;\n\tbeyond = (i_size + UBIFS_BLOCK_SIZE - 1) >> UBIFS_BLOCK_SHIFT;\n\tif (block >= beyond) {\n\t\t/* Reading beyond inode */\n\t\tSetPageChecked(page);\n\t\tmemset(addr, 0, PAGE_CACHE_SIZE);\n\t\tgoto out;\n\t}\n\n\tdn = kmalloc(UBIFS_MAX_DATA_NODE_SZ, GFP_NOFS);\n\tif (!dn) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tint ret;\n\n\t\tif (block >= beyond) {\n\t\t\t/* Reading beyond inode */\n\t\t\terr = -ENOENT;\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\t} else {\n\t\t\tret = read_block(inode, addr, block, dn);\n\t\t\tif (ret) {\n\t\t\t\terr = ret;\n\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\tbreak;\n\t\t\t} else if (block + 1 == beyond) {\n\t\t\t\tint dlen = le32_to_cpu(dn->size);\n\t\t\t\tint ilen = i_size & (UBIFS_BLOCK_SIZE - 1);\n\n\t\t\t\tif (ilen && ilen < dlen)\n\t\t\t\t\tmemset(addr + ilen, 0, dlen - ilen);\n\t\t\t}\n\t\t}\n\t\tif (++i >= UBIFS_BLOCKS_PER_PAGE)\n\t\t\tbreak;\n\t\tblock += 1;\n\t\taddr += UBIFS_BLOCK_SIZE;\n\t}\n\tif (err) {\n\t\tif (err == -ENOENT) {\n\t\t\t/* Not found, so it must be a hole */\n\t\t\tSetPageChecked(page);\n\t\t\tdbg_gen(\"hole\");\n\t\t\tgoto out_free;\n\t\t}\n\t\tubifs_err(\"cannot read page %lu of inode %lu, error %d\",\n\t\t\t  page->index, inode->i_ino, err);\n\t\tgoto error;\n\t}\n\nout_free:\n\tkfree(dn);\nout:\n\tSetPageUptodate(page);\n\tClearPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn 0;\n\nerror:\n\tkfree(dn);\n\tClearPageUptodate(page);\n\tSetPageError(page);\n\tflush_dcache_page(page);\n\tkunmap(page);\n\treturn err;\n}\n\n/**\n * rele"
  },
  {
    "function_name": "ruct inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
    "lines": "58-103",
    "snippet": "ad_block(struct inode *inode, void *addr, unsigned int block,\n\t\t      struct ubifs_data_node *dn)\n{\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err, len, out_len;\n\tunion ubifs_key key;\n\tunsigned int dlen;\n\n\tdata_key_init(c, &key, inode->i_ino, block);\n\terr = ubifs_tnc_lookup(c, &key, dn);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\t/* Not found, so it must be a hole */\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\treturn err;\n\t}\n\n\tubifs_assert(le64_to_cpu(dn->ch.sqnum) >\n\t\t     ubifs_inode(inode)->creat_sqnum);\n\tlen = le32_to_cpu(dn->size);\n\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\tgoto dump;\n\n\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\tout_len = UBIFS_BLOCK_SIZE;\n\terr = ubifs_decompress(&dn->data, dlen, addr, &out_len,\n\t\t\t       le16_to_cpu(dn->compr_type));\n\tif (err || len != out_len)\n\t\tgoto dump;\n\n\t/*\n\t * Data length can be less than a full block, even for blocks that are\n\t * not the last in the file (e.g., as a result of making a hole and\n\t * appending data). Ensure that the remainder is zeroed out.\n\t */\n\tif (len < UBIFS_BLOCK_SIZE)\n\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\treturn 0;\n\ndump:\n\tubifs_err(\"bad data node (block %u, inode %lu)\",\n\t\t  block, inode->i_ino);\n\tubifs_dump_node(c, dn);\n\treturn -EINVAL;\n}\n\nstatic int",
    "includes": [
      "ux/slab.h>\n\nstatic int r",
      "ux/namei.h>\n#include <lin",
      "ux/mount.h>\n#include <lin",
      "ux/aio.h>\n#include <lin",
      "fs.h\"\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "de(c, dn);\n\tret",
          "args": [
            "r",
            "-E"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d data no",
          "args": [
            "e (block %u, inode %lu)\",\n\t\t  block,",
            ">i_in",
            ";\n\tubifs_dum"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len,",
          "args": [
            ", UBIFS_BL",
            "K",
            "IZE - len);\n\n\treturn 0"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess(&dn->data, d",
          "args": [
            "en, addr,",
            "out_",
            "n,",
            "l",
            "n->compr_type));\n\tif (err |"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->compr_ty",
          "args": [
            "e));\n\tif (err"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->ch.len)",
          "args": [
            "UBIFS_DAT"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size);",
          "args": [
            "f (len <"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu(",
          "args": [
            "n->ch.sqnum) >\n\t\t     ubifs_inode(inode)->creat_sqnum);\n\tlen = le3"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->crea",
          "args": [
            "_sqnu"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->ch.sqnum",
          "args": [
            ">\n\t\t     ub"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "0, UBI",
          "args": [
            "S_BL",
            "K",
            "IZE);\n\t\treturn e"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, &key, dn)",
          "args": [
            "f (e",
            ")"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, ino",
          "args": [
            "e",
            "i_in",
            "block);\n\ter",
            "= ubi"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nad_block(struct inode *inode, void *addr, unsigned int block,\n\t\t      struct ubifs_data_node *dn)\n{\n\tstruct ubifs_info *c = inode->i_sb->s_fs_info;\n\tint err, len, out_len;\n\tunion ubifs_key key;\n\tunsigned int dlen;\n\n\tdata_key_init(c, &key, inode->i_ino, block);\n\terr = ubifs_tnc_lookup(c, &key, dn);\n\tif (err) {\n\t\tif (err == -ENOENT)\n\t\t\t/* Not found, so it must be a hole */\n\t\t\tmemset(addr, 0, UBIFS_BLOCK_SIZE);\n\t\treturn err;\n\t}\n\n\tubifs_assert(le64_to_cpu(dn->ch.sqnum) >\n\t\t     ubifs_inode(inode)->creat_sqnum);\n\tlen = le32_to_cpu(dn->size);\n\tif (len <= 0 || len > UBIFS_BLOCK_SIZE)\n\t\tgoto dump;\n\n\tdlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\tout_len = UBIFS_BLOCK_SIZE;\n\terr = ubifs_decompress(&dn->data, dlen, addr, &out_len,\n\t\t\t       le16_to_cpu(dn->compr_type));\n\tif (err || len != out_len)\n\t\tgoto dump;\n\n\t/*\n\t * Data length can be less than a full block, even for blocks that are\n\t * not the last in the file (e.g., as a result of making a hole and\n\t * appending data). Ensure that the remainder is zeroed out.\n\t */\n\tif (len < UBIFS_BLOCK_SIZE)\n\t\tmemset(addr + len, 0, UBIFS_BLOCK_SIZE - len);\n\n\treturn 0;\n\ndump:\n\tubifs_err(\"bad data node (block %u, inode %lu)\",\n\t\t  block, inode->i_ino);\n\tubifs_dump_node(c, dn);\n\treturn -EINVAL;\n}\n\nstatic int"
  }
]