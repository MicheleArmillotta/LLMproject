[
  {
    "function_name": "iterate_bdevs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1752-1786",
    "snippet": "void iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfunc(I_BDEV(inode), arg);\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *blockdev_superblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old_inode"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_sb_list_lock"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "I_BDEV(inode)",
            "arg"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6589-6594",
          "snippet": "static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)\n{\n\tset_buffer_uptodate(bh);\n\tmark_buffer_dirty(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "380-383",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "inode",
            "&blockdev_superblock->s_inodes",
            "i_sb_list"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct super_block *blockdev_superblock;\n\nvoid iterate_bdevs(void (*func)(struct block_device *, void *), void *arg)\n{\n\tstruct inode *inode, *old_inode = NULL;\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry(inode, &blockdev_superblock->s_inodes, i_sb_list) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW) ||\n\t\t    mapping->nrpages == 0) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t\t/*\n\t\t * We hold a reference to 'inode' so it couldn't have been\n\t\t * removed from s_inodes list while we dropped the\n\t\t * inode_sb_list_lock.  We cannot iput the inode now as we can\n\t\t * be holding the last reference and we cannot iput it under\n\t\t * inode_sb_list_lock. So we keep the reference and iput it\n\t\t * later.\n\t\t */\n\t\tiput(old_inode);\n\t\told_inode = inode;\n\n\t\tfunc(I_BDEV(inode), arg);\n\n\t\tspin_lock(&inode_sb_list_lock);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\tiput(old_inode);\n}"
  },
  {
    "function_name": "__invalidate_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1731-1749",
    "snippet": "int __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "bdev"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "77-91",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_inodes",
          "args": [
            "sb",
            "kill_dirty"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "626-660",
          "snippet": "int invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&inode_sb_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&inode_sb_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1094-1107",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, UINT_MAX);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (freed > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "ser_get_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "662-687",
          "snippet": "truct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}"
  },
  {
    "function_name": "lookup_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1697-1728",
    "snippet": "struct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = path.dentry->d_inode;\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (path.mnt->mnt_flags & MNT_NODEV)\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_acquire",
          "args": [
            "inode"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "bd_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "659-690",
          "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "pathname",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = path.dentry->d_inode;\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (path.mnt->mnt_flags & MNT_NODEV)\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}"
  },
  {
    "function_name": "ioctl_by_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1677-1685",
    "snippet": "int ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_ioctl",
          "args": [
            "bdev",
            "0",
            "cmd",
            "arg"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint ioctl_by_bdev(struct block_device *bdev, unsigned cmd, unsigned long arg)\n{\n\tint res;\n\tmm_segment_t old_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\tres = blkdev_ioctl(bdev, 0, cmd, arg);\n\tset_fs(old_fs);\n\treturn res;\n}"
  },
  {
    "function_name": "blkdev_releasepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1637-1645",
    "snippet": "static int blkdev_releasepage(struct page *page, gfp_t wait)\n{\n\tstruct super_block *super = BDEV_I(page->mapping->host)->bdev.bd_super;\n\n\tif (super && super->s_op->bdev_try_to_free_page)\n\t\treturn super->s_op->bdev_try_to_free_page(super, page, wait);\n\n\treturn try_to_free_buffers(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "try_to_free_buffers",
          "args": [
            "page"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_free_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3214-3260",
          "snippet": "int try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint try_to_free_buffers(struct page *page)\n{\n\tstruct address_space * const mapping = page->mapping;\n\tstruct buffer_head *buffers_to_free = NULL;\n\tint ret = 0;\n\n\tBUG_ON(!PageLocked(page));\n\tif (PageWriteback(page))\n\t\treturn 0;\n\n\tif (mapping == NULL) {\t\t/* can this still happen? */\n\t\tret = drop_buffers(page, &buffers_to_free);\n\t\tgoto out;\n\t}\n\n\tspin_lock(&mapping->private_lock);\n\tret = drop_buffers(page, &buffers_to_free);\n\n\t/*\n\t * If the filesystem writes its buffers by hand (eg ext3)\n\t * then we can have clean buffers against a dirty page.  We\n\t * clean the page here; otherwise the VM will never notice\n\t * that the filesystem did any IO at all.\n\t *\n\t * Also, during truncate, discard_buffer will have marked all\n\t * the page's buffers clean.  We discover that here and clean\n\t * the page also.\n\t *\n\t * private_lock must be held over this entire operation in order\n\t * to synchronise against __set_page_dirty_buffers and prevent the\n\t * dirty bit from being lost.\n\t */\n\tif (ret)\n\t\tcancel_dirty_page(page, PAGE_CACHE_SIZE);\n\tspin_unlock(&mapping->private_lock);\nout:\n\tif (buffers_to_free) {\n\t\tstruct buffer_head *bh = buffers_to_free;\n\n\t\tdo {\n\t\t\tstruct buffer_head *next = bh->b_this_page;\n\t\t\tfree_buffer_head(bh);\n\t\t\tbh = next;\n\t\t} while (bh != buffers_to_free);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "super->s_op->bdev_try_to_free_page",
          "args": [
            "super",
            "page",
            "wait"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_try_to_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "743-755",
          "snippet": "static int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_sync_fs(struct super_block *sb, int wait);",
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_sync_fs(struct super_block *sb, int wait);\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nstatic int bdev_try_to_free_page(struct super_block *sb, struct page *page,\n\t\t\t\t gfp_t wait)\n{\n\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\tWARN_ON(PageChecked(page));\n\tif (!page_has_buffers(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn journal_try_to_free_buffers(journal, page, \n\t\t\t\t\t\t   wait & ~__GFP_WAIT);\n\treturn try_to_free_buffers(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "page->mapping->host"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_releasepage(struct page *page, gfp_t wait)\n{\n\tstruct super_block *super = BDEV_I(page->mapping->host)->bdev.bd_super;\n\n\tif (super && super->s_op->bdev_try_to_free_page)\n\t\treturn super->s_op->bdev_try_to_free_page(super, page, wait);\n\n\treturn try_to_free_buffers(page);\n}"
  },
  {
    "function_name": "blkdev_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1617-1630",
    "snippet": "ssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = file->f_mapping->host;\n\tloff_t size = i_size_read(bd_inode);\n\tloff_t pos = iocb->ki_pos;\n\n\tif (pos >= size)\n\t\treturn 0;\n\n\tsize -= pos;\n\tiov_iter_truncate(to, size);\n\treturn generic_file_read_iter(iocb, to);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "to",
            "size"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bd_inode"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nssize_t blkdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *bd_inode = file->f_mapping->host;\n\tloff_t size = i_size_read(bd_inode);\n\tloff_t pos = iocb->ki_pos;\n\n\tif (pos >= size)\n\t\treturn 0;\n\n\tsize -= pos;\n\tiov_iter_truncate(to, size);\n\treturn generic_file_read_iter(iocb, to);\n}"
  },
  {
    "function_name": "blkdev_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1598-1614",
    "snippet": "ssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct blk_plug plug;\n\tssize_t ret;\n\n\tblk_start_plug(&plug);\n\tret = __generic_file_write_iter(iocb, from);\n\tif (ret > 0) {\n\t\tssize_t err;\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - ret",
            "ret"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_write_iter",
          "args": [
            "iocb",
            "from"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nssize_t blkdev_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct blk_plug plug;\n\tssize_t ret;\n\n\tblk_start_plug(&plug);\n\tret = __generic_file_write_iter(iocb, from);\n\tif (ret > 0) {\n\t\tssize_t err;\n\t\terr = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\tblk_finish_plug(&plug);\n\treturn ret;\n}"
  },
  {
    "function_name": "block_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1574-1589",
    "snippet": "static long block_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct block_device *bdev = I_BDEV(file->f_mapping->host);\n\tfmode_t mode = file->f_mode;\n\n\t/*\n\t * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have\n\t * to updated it before every ioctl.\n\t */\n\tif (file->f_flags & O_NDELAY)\n\t\tmode |= FMODE_NDELAY;\n\telse\n\t\tmode &= ~FMODE_NDELAY;\n\n\treturn blkdev_ioctl(bdev, mode, cmd, arg);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_ioctl",
          "args": [
            "bdev",
            "mode",
            "cmd",
            "arg"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic long block_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct block_device *bdev = I_BDEV(file->f_mapping->host);\n\tfmode_t mode = file->f_mode;\n\n\t/*\n\t * O_NDELAY can be altered using fcntl(.., F_SETFL, ..), so we have\n\t * to updated it before every ioctl.\n\t */\n\tif (file->f_flags & O_NDELAY)\n\t\tmode |= FMODE_NDELAY;\n\telse\n\t\tmode &= ~FMODE_NDELAY;\n\n\treturn blkdev_ioctl(bdev, mode, cmd, arg);\n}"
  },
  {
    "function_name": "blkdev_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1567-1572",
    "snippet": "static int blkdev_close(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev = I_BDEV(filp->f_mapping->host);\n\tblkdev_put(bdev, filp->f_mode);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "filp->f_mode"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "filp->f_mapping->host"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_close(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev = I_BDEV(filp->f_mapping->host);\n\tblkdev_put(bdev, filp->f_mode);\n\treturn 0;\n}"
  },
  {
    "function_name": "blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1519-1564",
    "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "bdev",
            "mode",
            "0"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1477-1517",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_flush_events",
          "args": [
            "bdev->bd_disk",
            "DISK_EVENT_MEDIA_CHANGE"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "--bdev->bd_contains->bd_holders < 0"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "--bdev->bd_holders < 0"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
  },
  {
    "function_name": "__blkdev_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1477-1517",
    "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "victim",
            "mode",
            "1"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1477-1517",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "652-655",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "owner"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk",
          "args": [
            "disk"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->release",
          "args": [
            "disk",
            "mode"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_write_inode",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "52-61",
          "snippet": "static void bdev_write_inode(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tWARN_ON_ONCE(write_inode_now(inode, true));\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_write_inode(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tWARN_ON_ONCE(write_inode_now(inode, true));\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_bdev",
          "args": [
            "bdev"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "kill_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "64-73",
          "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bdev->bd_holders"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&bdev->bd_mutex",
            "for_part"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
  },
  {
    "function_name": "blkdev_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1449-1475",
    "snippet": "static int blkdev_open(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev;\n\n\t/*\n\t * Preserve backwards compatibility and allow large file access\n\t * even if userspace doesn't ask for it explicitly. Some mkfs\n\t * binary needs it. We might want to drop this workaround\n\t * during an unstable branch.\n\t */\n\tfilp->f_flags |= O_LARGEFILE;\n\n\tif (filp->f_flags & O_NDELAY)\n\t\tfilp->f_mode |= FMODE_NDELAY;\n\tif (filp->f_flags & O_EXCL)\n\t\tfilp->f_mode |= FMODE_EXCL;\n\tif ((filp->f_flags & O_ACCMODE) == 3)\n\t\tfilp->f_mode |= FMODE_WRITE_IOCTL;\n\n\tbdev = bd_acquire(inode);\n\tif (bdev == NULL)\n\t\treturn -ENOMEM;\n\n\tfilp->f_mapping = bdev->bd_inode->i_mapping;\n\n\treturn blkdev_get(bdev, filp->f_mode, filp);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "filp->f_mode",
            "filp"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_acquire",
          "args": [
            "inode"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "bd_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "659-690",
          "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_open(struct inode * inode, struct file * filp)\n{\n\tstruct block_device *bdev;\n\n\t/*\n\t * Preserve backwards compatibility and allow large file access\n\t * even if userspace doesn't ask for it explicitly. Some mkfs\n\t * binary needs it. We might want to drop this workaround\n\t * during an unstable branch.\n\t */\n\tfilp->f_flags |= O_LARGEFILE;\n\n\tif (filp->f_flags & O_NDELAY)\n\t\tfilp->f_mode |= FMODE_NDELAY;\n\tif (filp->f_flags & O_EXCL)\n\t\tfilp->f_mode |= FMODE_EXCL;\n\tif ((filp->f_flags & O_ACCMODE) == 3)\n\t\tfilp->f_mode |= FMODE_WRITE_IOCTL;\n\n\tbdev = bd_acquire(inode);\n\tif (bdev == NULL)\n\t\treturn -ENOMEM;\n\n\tfilp->f_mapping = bdev->bd_inode->i_mapping;\n\n\treturn blkdev_get(bdev, filp->f_mode, filp);\n}"
  },
  {
    "function_name": "blkdev_get_by_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1432-1446",
    "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "mode",
            "holder"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "dev"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "bdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "594-625",
          "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_blk_aops;",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
            "static struct super_block *blockdev_superblock",
            "static LIST_HEAD(all_bdevs);",
            "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstatic struct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "blkdev_get_by_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1387-1407",
    "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "bdev"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get",
          "args": [
            "bdev",
            "mode",
            "holder"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_bdev",
          "args": [
            "path"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1697-1728",
          "snippet": "struct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = path.dentry->d_inode;\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (path.mnt->mnt_flags & MNT_NODEV)\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *lookup_bdev(const char *pathname)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\tstruct path path;\n\tint error;\n\n\tif (!pathname || !*pathname)\n\t\treturn ERR_PTR(-EINVAL);\n\n\terror = kern_path(pathname, LOOKUP_FOLLOW, &path);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tinode = path.dentry->d_inode;\n\terror = -ENOTBLK;\n\tif (!S_ISBLK(inode->i_mode))\n\t\tgoto fail;\n\terror = -EACCES;\n\tif (path.mnt->mnt_flags & MNT_NODEV)\n\t\tgoto fail;\n\terror = -ENOMEM;\n\tbdev = bd_acquire(inode);\n\tif (!bdev)\n\t\tgoto fail;\nout:\n\tpath_put(&path);\n\treturn bdev;\nfail:\n\tbdev = ERR_PTR(error);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
  },
  {
    "function_name": "blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1304-1367",
    "snippet": "int blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)\n{\n\tstruct block_device *whole = NULL;\n\tint res;\n\n\tWARN_ON_ONCE((mode & FMODE_EXCL) && !holder);\n\n\tif ((mode & FMODE_EXCL) && holder) {\n\t\twhole = bd_start_claiming(bdev, holder);\n\t\tif (IS_ERR(whole)) {\n\t\t\tbdput(bdev);\n\t\t\treturn PTR_ERR(whole);\n\t\t}\n\t}\n\n\tres = __blkdev_get(bdev, mode, 0);\n\n\tif (whole) {\n\t\tstruct gendisk *disk = whole->bd_disk;\n\n\t\t/* finish claiming */\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tspin_lock(&bdev_lock);\n\n\t\tif (!res) {\n\t\t\tBUG_ON(!bd_may_claim(bdev, whole, holder));\n\t\t\t/*\n\t\t\t * Note that for a whole device bd_holders\n\t\t\t * will be incremented twice, and bd_holder\n\t\t\t * will be set to bd_may_claim before being\n\t\t\t * set to holder\n\t\t\t */\n\t\t\twhole->bd_holders++;\n\t\t\twhole->bd_holder = bd_may_claim;\n\t\t\tbdev->bd_holders++;\n\t\t\tbdev->bd_holder = holder;\n\t\t}\n\n\t\t/* tell others that we're done */\n\t\tBUG_ON(whole->bd_claiming != holder);\n\t\twhole->bd_claiming = NULL;\n\t\twake_up_bit(&whole->bd_claiming, 0);\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * Block event polling for write claims if requested.  Any\n\t\t * write holder makes the write_holder state stick until\n\t\t * all are released.  This is good enough and tracking\n\t\t * individual writeable reference is too fragile given the\n\t\t * way @mode is used in blkdev_get/put().\n\t\t */\n\t\tif (!res && (mode & FMODE_WRITE) && !bdev->bd_write_holder &&\n\t\t    (disk->flags & GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE)) {\n\t\t\tbdev->bd_write_holder = true;\n\t\t\tdisk_block_events(disk);\n\t\t}\n\n\t\tmutex_unlock(&bdev->bd_mutex);\n\t\tbdput(whole);\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "whole"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "652-655",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_block_events",
          "args": [
            "disk"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&whole->bd_claiming",
            "0"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "whole->bd_claiming != holder"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bd_may_claim(bdev, whole, holder)"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_may_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "bd_may_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "727-743",
          "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_get",
          "args": [
            "bdev",
            "mode",
            "0"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1141-1283",
          "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tstruct module *owner;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\towner = disk->fops->owner;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk(disk);\n\t\t\t\t\tmodule_put(owner);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\t/* only one opener holds refs to the module and disk */\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk(disk);\n\tmodule_put(owner);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tstruct module *owner;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\towner = disk->fops->owner;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk(disk);\n\t\t\t\t\tmodule_put(owner);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\t/* only one opener holds refs to the module and disk */\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk(disk);\n\tmodule_put(owner);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "whole"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "whole"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_start_claiming",
          "args": [
            "bdev",
            "holder"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "bd_start_claiming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "811-859",
          "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(mode & FMODE_EXCL) && !holder"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nint blkdev_get(struct block_device *bdev, fmode_t mode, void *holder)\n{\n\tstruct block_device *whole = NULL;\n\tint res;\n\n\tWARN_ON_ONCE((mode & FMODE_EXCL) && !holder);\n\n\tif ((mode & FMODE_EXCL) && holder) {\n\t\twhole = bd_start_claiming(bdev, holder);\n\t\tif (IS_ERR(whole)) {\n\t\t\tbdput(bdev);\n\t\t\treturn PTR_ERR(whole);\n\t\t}\n\t}\n\n\tres = __blkdev_get(bdev, mode, 0);\n\n\tif (whole) {\n\t\tstruct gendisk *disk = whole->bd_disk;\n\n\t\t/* finish claiming */\n\t\tmutex_lock(&bdev->bd_mutex);\n\t\tspin_lock(&bdev_lock);\n\n\t\tif (!res) {\n\t\t\tBUG_ON(!bd_may_claim(bdev, whole, holder));\n\t\t\t/*\n\t\t\t * Note that for a whole device bd_holders\n\t\t\t * will be incremented twice, and bd_holder\n\t\t\t * will be set to bd_may_claim before being\n\t\t\t * set to holder\n\t\t\t */\n\t\t\twhole->bd_holders++;\n\t\t\twhole->bd_holder = bd_may_claim;\n\t\t\tbdev->bd_holders++;\n\t\t\tbdev->bd_holder = holder;\n\t\t}\n\n\t\t/* tell others that we're done */\n\t\tBUG_ON(whole->bd_claiming != holder);\n\t\twhole->bd_claiming = NULL;\n\t\twake_up_bit(&whole->bd_claiming, 0);\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * Block event polling for write claims if requested.  Any\n\t\t * write holder makes the write_holder state stick until\n\t\t * all are released.  This is good enough and tracking\n\t\t * individual writeable reference is too fragile given the\n\t\t * way @mode is used in blkdev_get/put().\n\t\t */\n\t\tif (!res && (mode & FMODE_WRITE) && !bdev->bd_write_holder &&\n\t\t    (disk->flags & GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE)) {\n\t\t\tbdev->bd_write_holder = true;\n\t\t\tdisk_block_events(disk);\n\t\t}\n\n\t\tmutex_unlock(&bdev->bd_mutex);\n\t\tbdput(whole);\n\t}\n\n\treturn res;\n}"
  },
  {
    "function_name": "__blkdev_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1141-1283",
    "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tstruct module *owner;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\towner = disk->fops->owner;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk(disk);\n\t\t\t\t\tmodule_put(owner);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\t/* only one opener holds refs to the module and disk */\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk(disk);\n\tmodule_put(owner);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "652-655",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "owner"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk",
          "args": [
            "disk"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_put",
          "args": [
            "bdev->bd_contains",
            "mode",
            "1"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1477-1517",
          "snippet": "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct block_device *victim = NULL;\n\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (for_part)\n\t\tbdev->bd_part_count--;\n\n\tif (!--bdev->bd_openers) {\n\t\tWARN_ON_ONCE(bdev->bd_holders);\n\t\tsync_blockdev(bdev);\n\t\tkill_bdev(bdev);\n\t\t/*\n\t\t * ->release can cause the queue to disappear, so flush all\n\t\t * dirty data before.\n\t\t */\n\t\tbdev_write_inode(bdev->bd_inode);\n\t}\n\tif (bdev->bd_contains == bdev) {\n\t\tif (disk->fops->release)\n\t\t\tdisk->fops->release(disk, mode);\n\t}\n\tif (!bdev->bd_openers) {\n\t\tstruct module *owner = disk->fops->owner;\n\n\t\tdisk_put_part(bdev->bd_part);\n\t\tbdev->bd_part = NULL;\n\t\tbdev->bd_disk = NULL;\n\t\tif (bdev != bdev->bd_contains)\n\t\t\tvictim = bdev->bd_contains;\n\t\tbdev->bd_contains = NULL;\n\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\tif (victim)\n\t\t__blkdev_put(victim, mode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "owner"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk",
          "args": [
            "disk"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_partitions",
          "args": [
            "bdev->bd_disk",
            "bdev"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rescan_partitions",
          "args": [
            "bdev->bd_disk",
            "bdev"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev->bd_disk->fops->open",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_set_size",
          "args": [
            "bdev",
            "(loff_t)bdev->bd_part->nr_sects << 9"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "bd_set_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1115-1129",
          "snippet": "void bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tmutex_lock(&bdev->bd_inode->i_mutex);\n\ti_size_write(bdev->bd_inode, size);\n\tmutex_unlock(&bdev->bd_inode->i_mutex);\n\twhile (bsize < PAGE_CACHE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tmutex_lock(&bdev->bd_inode->i_mutex);\n\ti_size_write(bdev->bd_inode, size);\n\tmutex_unlock(&bdev->bd_inode->i_mutex);\n\twhile (bsize < PAGE_CACHE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_get_part",
          "args": [
            "disk",
            "partno"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blkdev_get",
          "args": [
            "whole",
            "mode",
            "1"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__blkdev_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1141-1283",
          "snippet": "static int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tstruct module *owner;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\towner = disk->fops->owner;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk(disk);\n\t\t\t\t\tmodule_put(owner);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\t/* only one opener holds refs to the module and disk */\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk(disk);\n\tmodule_put(owner);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "for_part"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_partitions",
          "args": [
            "disk",
            "bdev"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rescan_partitions",
          "args": [
            "disk",
            "bdev"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_capacity",
          "args": [
            "disk"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "owner"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk",
          "args": [
            "disk"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_unblock_events",
          "args": [
            "disk"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_put_part",
          "args": [
            "bdev->bd_part"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->open",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_get_part",
          "args": [
            "disk",
            "partno"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&bdev->bd_mutex",
            "for_part"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk_block_events",
          "args": [
            "disk"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gendisk",
          "args": [
            "bdev->bd_dev",
            "&partno"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devcgroup_inode_permission",
          "args": [
            "bdev->bd_inode",
            "perm"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void __blkdev_put(struct block_device *bdev, fmode_t mode, int for_part);\n\nstatic int __blkdev_get(struct block_device *bdev, fmode_t mode, int for_part)\n{\n\tstruct gendisk *disk;\n\tstruct module *owner;\n\tint ret;\n\tint partno;\n\tint perm = 0;\n\n\tif (mode & FMODE_READ)\n\t\tperm |= MAY_READ;\n\tif (mode & FMODE_WRITE)\n\t\tperm |= MAY_WRITE;\n\t/*\n\t * hooks: /n/, see \"layering violations\".\n\t */\n\tif (!for_part) {\n\t\tret = devcgroup_inode_permission(bdev->bd_inode, perm);\n\t\tif (ret != 0) {\n\t\t\tbdput(bdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n restart:\n\n\tret = -ENXIO;\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\tgoto out;\n\towner = disk->fops->owner;\n\n\tdisk_block_events(disk);\n\tmutex_lock_nested(&bdev->bd_mutex, for_part);\n\tif (!bdev->bd_openers) {\n\t\tbdev->bd_disk = disk;\n\t\tbdev->bd_queue = disk->queue;\n\t\tbdev->bd_contains = bdev;\n\t\tif (!partno) {\n\t\t\tret = -ENXIO;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!bdev->bd_part)\n\t\t\t\tgoto out_clear;\n\n\t\t\tret = 0;\n\t\t\tif (disk->fops->open) {\n\t\t\t\tret = disk->fops->open(bdev, mode);\n\t\t\t\tif (ret == -ERESTARTSYS) {\n\t\t\t\t\t/* Lost a race with 'disk' being\n\t\t\t\t\t * deleted, try again.\n\t\t\t\t\t * See md.c\n\t\t\t\t\t */\n\t\t\t\t\tdisk_put_part(bdev->bd_part);\n\t\t\t\t\tbdev->bd_part = NULL;\n\t\t\t\t\tbdev->bd_disk = NULL;\n\t\t\t\t\tbdev->bd_queue = NULL;\n\t\t\t\t\tmutex_unlock(&bdev->bd_mutex);\n\t\t\t\t\tdisk_unblock_events(disk);\n\t\t\t\t\tput_disk(disk);\n\t\t\t\t\tmodule_put(owner);\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tbd_set_size(bdev,(loff_t)get_capacity(disk)<<9);\n\n\t\t\t/*\n\t\t\t * If the device is invalidated, rescan partition\n\t\t\t * if open succeeded or failed with -ENOMEDIUM.\n\t\t\t * The latter is necessary to prevent ghost\n\t\t\t * partitions on a removed medium.\n\t\t\t */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t} else {\n\t\t\tstruct block_device *whole;\n\t\t\twhole = bdget_disk(disk, 0);\n\t\t\tret = -ENOMEM;\n\t\t\tif (!whole)\n\t\t\t\tgoto out_clear;\n\t\t\tBUG_ON(for_part);\n\t\t\tret = __blkdev_get(whole, mode, 1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_clear;\n\t\t\tbdev->bd_contains = whole;\n\t\t\tbdev->bd_part = disk_get_part(disk, partno);\n\t\t\tif (!(disk->flags & GENHD_FL_UP) ||\n\t\t\t    !bdev->bd_part || !bdev->bd_part->nr_sects) {\n\t\t\t\tret = -ENXIO;\n\t\t\t\tgoto out_clear;\n\t\t\t}\n\t\t\tbd_set_size(bdev, (loff_t)bdev->bd_part->nr_sects << 9);\n\t\t}\n\t} else {\n\t\tif (bdev->bd_contains == bdev) {\n\t\t\tret = 0;\n\t\t\tif (bdev->bd_disk->fops->open)\n\t\t\t\tret = bdev->bd_disk->fops->open(bdev, mode);\n\t\t\t/* the same as first opener case, read comment there */\n\t\t\tif (bdev->bd_invalidated) {\n\t\t\t\tif (!ret)\n\t\t\t\t\trescan_partitions(bdev->bd_disk, bdev);\n\t\t\t\telse if (ret == -ENOMEDIUM)\n\t\t\t\t\tinvalidate_partitions(bdev->bd_disk, bdev);\n\t\t\t}\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock_bdev;\n\t\t}\n\t\t/* only one opener holds refs to the module and disk */\n\t\tput_disk(disk);\n\t\tmodule_put(owner);\n\t}\n\tbdev->bd_openers++;\n\tif (for_part)\n\t\tbdev->bd_part_count++;\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\treturn 0;\n\n out_clear:\n\tdisk_put_part(bdev->bd_part);\n\tbdev->bd_disk = NULL;\n\tbdev->bd_part = NULL;\n\tbdev->bd_queue = NULL;\n\tif (bdev != bdev->bd_contains)\n\t\t__blkdev_put(bdev->bd_contains, mode, 1);\n\tbdev->bd_contains = NULL;\n out_unlock_bdev:\n\tmutex_unlock(&bdev->bd_mutex);\n\tdisk_unblock_events(disk);\n\tput_disk(disk);\n\tmodule_put(owner);\n out:\n\tbdput(bdev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bd_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1115-1129",
    "snippet": "void bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tmutex_lock(&bdev->bd_inode->i_mutex);\n\ti_size_write(bdev->bd_inode, size);\n\tmutex_unlock(&bdev->bd_inode->i_mutex);\n\twhile (bsize < PAGE_CACHE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "bsize"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_inode->i_mutex"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "bdev->bd_inode",
            "size"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_inode->i_mutex"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_set_size(struct block_device *bdev, loff_t size)\n{\n\tunsigned bsize = bdev_logical_block_size(bdev);\n\n\tmutex_lock(&bdev->bd_inode->i_mutex);\n\ti_size_write(bdev->bd_inode, size);\n\tmutex_unlock(&bdev->bd_inode->i_mutex);\n\twhile (bsize < PAGE_CACHE_SIZE) {\n\t\tif (size & bsize)\n\t\t\tbreak;\n\t\tbsize <<= 1;\n\t}\n\tbdev->bd_block_size = bsize;\n\tbdev->bd_inode->i_blkbits = blksize_bits(bsize);\n}"
  },
  {
    "function_name": "check_disk_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1096-1111",
    "snippet": "int check_disk_change(struct block_device *bdev)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tconst struct block_device_operations *bdops = disk->fops;\n\tunsigned int events;\n\n\tevents = disk_clear_events(disk, DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST);\n\tif (!(events & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn 0;\n\n\tflush_disk(bdev, true);\n\tif (bdops->revalidate_disk)\n\t\tbdops->revalidate_disk(bdev->bd_disk);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdops->revalidate_disk",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1066-1084",
          "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_disk",
          "args": [
            "bdev",
            "true"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "flush_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1014-1029",
          "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_clear_events",
          "args": [
            "disk",
            "DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint check_disk_change(struct block_device *bdev)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tconst struct block_device_operations *bdops = disk->fops;\n\tunsigned int events;\n\n\tevents = disk_clear_events(disk, DISK_EVENT_MEDIA_CHANGE |\n\t\t\t\t   DISK_EVENT_EJECT_REQUEST);\n\tif (!(events & DISK_EVENT_MEDIA_CHANGE))\n\t\treturn 0;\n\n\tflush_disk(bdev, true);\n\tif (bdops->revalidate_disk)\n\t\tbdops->revalidate_disk(bdev->bd_disk);\n\treturn 1;\n}"
  },
  {
    "function_name": "revalidate_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1066-1084",
    "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "bdev"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "652-655",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_disk_size_change",
          "args": [
            "disk",
            "bdev"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "check_disk_size_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1039-1055",
          "snippet": "void check_disk_size_change(struct gendisk *disk, struct block_device *bdev)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tdisk_name(disk, 0, name);\n\t\tprintk(KERN_INFO\n\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t       name, bdev_size, disk_size);\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tflush_disk(bdev, false);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid check_disk_size_change(struct gendisk *disk, struct block_device *bdev)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tdisk_name(disk, 0, name);\n\t\tprintk(KERN_INFO\n\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t       name, bdev_size, disk_size);\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tflush_disk(bdev, false);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disk->fops->revalidate_disk",
          "args": [
            "disk"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1066-1084",
          "snippet": "int revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint revalidate_disk(struct gendisk *disk)\n{\n\tstruct block_device *bdev;\n\tint ret = 0;\n\n\tif (disk->fops->revalidate_disk)\n\t\tret = disk->fops->revalidate_disk(disk);\n\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\treturn ret;\n\n\tmutex_lock(&bdev->bd_mutex);\n\tcheck_disk_size_change(disk, bdev);\n\tbdev->bd_invalidated = 0;\n\tmutex_unlock(&bdev->bd_mutex);\n\tbdput(bdev);\n\treturn ret;\n}"
  },
  {
    "function_name": "check_disk_size_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1039-1055",
    "snippet": "void check_disk_size_change(struct gendisk *disk, struct block_device *bdev)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tdisk_name(disk, 0, name);\n\t\tprintk(KERN_INFO\n\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t       name, bdev_size, disk_size);\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tflush_disk(bdev, false);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_disk",
          "args": [
            "bdev",
            "false"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "flush_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1014-1029",
          "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "bdev->bd_inode",
            "disk_size"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"%s: detected capacity change from %lld to %lld\\n\"",
            "name",
            "bdev_size",
            "disk_size"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_name",
          "args": [
            "disk",
            "0",
            "name"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_capacity",
          "args": [
            "disk"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid check_disk_size_change(struct gendisk *disk, struct block_device *bdev)\n{\n\tloff_t disk_size, bdev_size;\n\n\tdisk_size = (loff_t)get_capacity(disk) << 9;\n\tbdev_size = i_size_read(bdev->bd_inode);\n\tif (disk_size != bdev_size) {\n\t\tchar name[BDEVNAME_SIZE];\n\n\t\tdisk_name(disk, 0, name);\n\t\tprintk(KERN_INFO\n\t\t       \"%s: detected capacity change from %lld to %lld\\n\",\n\t\t       name, bdev_size, disk_size);\n\t\ti_size_write(bdev->bd_inode, disk_size);\n\t\tflush_disk(bdev, false);\n\t}\n}"
  },
  {
    "function_name": "flush_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "1014-1029",
    "snippet": "static void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disk_part_scan_enabled",
          "args": [
            "bdev->bd_disk"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\"",
            "name"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_name",
          "args": [
            "bdev->bd_disk",
            "0",
            "name"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__invalidate_device",
          "args": [
            "bdev",
            "kill_dirty"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "__invalidate_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1731-1749",
          "snippet": "int __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __invalidate_device(struct block_device *bdev, bool kill_dirty)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tint res = 0;\n\n\tif (sb) {\n\t\t/*\n\t\t * no need to lock the super, get_super holds the\n\t\t * read mutex so the filesystem cannot go away\n\t\t * under us (->put_super runs with the write lock\n\t\t * hold).\n\t\t */\n\t\tshrink_dcache_sb(sb);\n\t\tres = invalidate_inodes(sb, kill_dirty);\n\t\tdrop_super(sb);\n\t}\n\tinvalidate_bdev(bdev);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void flush_disk(struct block_device *bdev, bool kill_dirty)\n{\n\tif (__invalidate_device(bdev, kill_dirty)) {\n\t\tchar name[BDEVNAME_SIZE] = \"\";\n\n\t\tif (bdev->bd_disk)\n\t\t\tdisk_name(bdev->bd_disk, 0, name);\n\t\tprintk(KERN_WARNING \"VFS: busy inodes on changed media or \"\n\t\t       \"resized disk %s\\n\", name);\n\t}\n\n\tif (!bdev->bd_disk)\n\t\treturn;\n\tif (disk_part_scan_enabled(bdev->bd_disk))\n\t\tbdev->bd_invalidated = 1;\n}"
  },
  {
    "function_name": "bd_unlink_disk_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "982-1000",
    "snippet": "void bd_unlink_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\n\tif (!WARN_ON_ONCE(holder == NULL) && !--holder->refcnt) {\n\t\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\t\tdel_symlink(bdev->bd_part->holder_dir,\n\t\t\t    &disk_to_dev(disk)->kobj);\n\t\tkobject_put(bdev->bd_part->holder_dir);\n\t\tlist_del_init(&holder->list);\n\t\tkfree(holder);\n\t}\n\n\tmutex_unlock(&bdev->bd_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "holder"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&holder->list"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "bdev->bd_part->holder_dir"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_symlink",
          "args": [
            "bdev->bd_part->holder_dir",
            "&disk_to_dev(disk)->kobj"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "del_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "884-887",
          "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "disk"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "holder == NULL"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_find_holder_disk",
          "args": [
            "bdev",
            "disk"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "bd_find_holder_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "868-877",
          "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bd_unlink_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\n\tif (!WARN_ON_ONCE(holder == NULL) && !--holder->refcnt) {\n\t\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\t\tdel_symlink(bdev->bd_part->holder_dir,\n\t\t\t    &disk_to_dev(disk)->kobj);\n\t\tkobject_put(bdev->bd_part->holder_dir);\n\t\tlist_del_init(&holder->list);\n\t\tkfree(holder);\n\t}\n\n\tmutex_unlock(&bdev->bd_mutex);\n}"
  },
  {
    "function_name": "bd_link_disk_holder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "917-969",
    "snippet": "int bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\tint ret = 0;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tWARN_ON_ONCE(!bdev->bd_holder);\n\n\t/* FIXME: remove the following once add_disk() handles errors */\n\tif (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))\n\t\tgoto out_unlock;\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (holder) {\n\t\tholder->refcnt++;\n\t\tgoto out_unlock;\n\t}\n\n\tholder = kzalloc(sizeof(*holder), GFP_KERNEL);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_LIST_HEAD(&holder->list);\n\tholder->disk = disk;\n\tholder->refcnt = 1;\n\n\tret = add_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = add_symlink(bdev->bd_part->holder_dir, &disk_to_dev(disk)->kobj);\n\tif (ret)\n\t\tgoto out_del;\n\t/*\n\t * bdev could be deleted beneath us which would implicitly destroy\n\t * the holder directory.  Hold on to it.\n\t */\n\tkobject_get(bdev->bd_part->holder_dir);\n\n\tlist_add(&holder->list, &bdev->bd_holder_disks);\n\tgoto out_unlock;\n\nout_del:\n\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\nout_free:\n\tkfree(holder);\nout_unlock:\n\tmutex_unlock(&bdev->bd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "holder"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_symlink",
          "args": [
            "disk->slave_dir",
            "&part_to_dev(bdev->bd_part)->kobj"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "del_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "884-887",
          "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&holder->list",
            "&bdev->bd_holder_disks"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_get",
          "args": [
            "bdev->bd_part->holder_dir"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_symlink",
          "args": [
            "bdev->bd_part->holder_dir",
            "&disk_to_dev(disk)->kobj"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "add_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "879-882",
          "snippet": "static int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}"
        }
      },
      {
        "call_info": {
          "callee": "disk_to_dev",
          "args": [
            "disk"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_to_dev",
          "args": [
            "bdev->bd_part"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&holder->list"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*holder)",
            "GFP_KERNEL"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_find_holder_disk",
          "args": [
            "bdev",
            "disk"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "bd_find_holder_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "868-877",
          "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!disk->slave_dir || !bdev->bd_part->holder_dir"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!bdev->bd_holder"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bd_link_disk_holder(struct block_device *bdev, struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\tint ret = 0;\n\n\tmutex_lock(&bdev->bd_mutex);\n\n\tWARN_ON_ONCE(!bdev->bd_holder);\n\n\t/* FIXME: remove the following once add_disk() handles errors */\n\tif (WARN_ON(!disk->slave_dir || !bdev->bd_part->holder_dir))\n\t\tgoto out_unlock;\n\n\tholder = bd_find_holder_disk(bdev, disk);\n\tif (holder) {\n\t\tholder->refcnt++;\n\t\tgoto out_unlock;\n\t}\n\n\tholder = kzalloc(sizeof(*holder), GFP_KERNEL);\n\tif (!holder) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tINIT_LIST_HEAD(&holder->list);\n\tholder->disk = disk;\n\tholder->refcnt = 1;\n\n\tret = add_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = add_symlink(bdev->bd_part->holder_dir, &disk_to_dev(disk)->kobj);\n\tif (ret)\n\t\tgoto out_del;\n\t/*\n\t * bdev could be deleted beneath us which would implicitly destroy\n\t * the holder directory.  Hold on to it.\n\t */\n\tkobject_get(bdev->bd_part->holder_dir);\n\n\tlist_add(&holder->list, &bdev->bd_holder_disks);\n\tgoto out_unlock;\n\nout_del:\n\tdel_symlink(disk->slave_dir, &part_to_dev(bdev->bd_part)->kobj);\nout_free:\n\tkfree(holder);\nout_unlock:\n\tmutex_unlock(&bdev->bd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "del_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "884-887",
    "snippet": "static void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_link",
          "args": [
            "from",
            "kobject_name(to)"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "142-152",
          "snippet": "void sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nvoid sysfs_remove_link(struct kobject *kobj, const char *name)\n{\n\tstruct kernfs_node *parent = NULL;\n\n\tif (!kobj)\n\t\tparent = sysfs_root_kn;\n\telse\n\t\tparent = kobj->sd;\n\n\tkernfs_remove_by_name(parent, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "to"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void del_symlink(struct kobject *from, struct kobject *to)\n{\n\tsysfs_remove_link(from, kobject_name(to));\n}"
  },
  {
    "function_name": "add_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "879-882",
    "snippet": "static int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_link",
          "args": [
            "from",
            "to",
            "kobject_name(to)"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_link_nowarn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/symlink.c",
          "lines": "105-109",
          "snippet": "int sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n\nint sysfs_create_link_nowarn(struct kobject *kobj, struct kobject *target,\n\t\t\t     const char *name)\n{\n\treturn sysfs_do_create_link(kobj, target, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_name",
          "args": [
            "to"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int add_symlink(struct kobject *from, struct kobject *to)\n{\n\treturn sysfs_create_link(from, to, kobject_name(to));\n}"
  },
  {
    "function_name": "bd_find_holder_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "868-877",
    "snippet": "static struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "holder",
            "&bdev->bd_holder_disks",
            "list"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct bd_holder_disk *bd_find_holder_disk(struct block_device *bdev,\n\t\t\t\t\t\t  struct gendisk *disk)\n{\n\tstruct bd_holder_disk *holder;\n\n\tlist_for_each_entry(holder, &bdev->bd_holder_disks, list)\n\t\tif (holder->disk == disk)\n\t\t\treturn holder;\n\treturn NULL;\n}"
  },
  {
    "function_name": "bd_start_claiming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "811-859",
    "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdput",
          "args": [
            "whole"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "bdput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "652-655",
          "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bd_prepare_to_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "bd_prepare_to_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "763-786",
          "snippet": "static int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_disk",
          "args": [
            "disk"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "disk->fops->owner"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdgrab",
          "args": [
            "bdev"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "bdgrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "633-637",
          "snippet": "struct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget_disk",
          "args": [
            "disk",
            "0"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENXIO"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_gendisk",
          "args": [
            "bdev->bd_dev",
            "&partno"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
  },
  {
    "function_name": "bd_prepare_to_claim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "763-786",
    "snippet": "static int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&whole->bd_claiming",
            "0"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_may_claim",
          "args": [
            "bdev",
            "whole",
            "holder"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "bd_may_claim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "727-743",
          "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic int bd_prepare_to_claim(struct block_device *bdev,\n\t\t\t       struct block_device *whole, void *holder)\n{\nretry:\n\t/* if someone else claimed, fail */\n\tif (!bd_may_claim(bdev, whole, holder))\n\t\treturn -EBUSY;\n\n\t/* if claiming is already in progress, wait for it to finish */\n\tif (whole->bd_claiming) {\n\t\twait_queue_head_t *wq = bit_waitqueue(&whole->bd_claiming, 0);\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(wq, &wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&bdev_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait);\n\t\tspin_lock(&bdev_lock);\n\t\tgoto retry;\n\t}\n\n\t/* yay, all mine */\n\treturn 0;\n}"
  },
  {
    "function_name": "bd_may_claim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "727-743",
    "snippet": "static bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic bool bd_may_claim(struct block_device *bdev, struct block_device *whole,\n\t\t\t void *holder)\n{\n\tif (bdev->bd_holder == holder)\n\t\treturn true;\t /* already a holder */\n\telse if (bdev->bd_holder != NULL)\n\t\treturn false; \t /* held by someone else */\n\telse if (bdev->bd_contains == bdev)\n\t\treturn true;  \t /* is a whole device which isn't held */\n\n\telse if (whole->bd_holder == bd_may_claim)\n\t\treturn true; \t /* is a partition of a device that is being partitioned */\n\telse if (whole->bd_holder != NULL)\n\t\treturn false;\t /* is a partition of a held device */\n\telse\n\t\treturn true;\t /* is a partition of an un-held device */\n}"
  },
  {
    "function_name": "bd_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "699-711",
    "snippet": "void bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\t__bd_forget(inode);\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tiput(bdev->bd_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bd_forget",
          "args": [
            "inode"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "__bd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "509-514",
          "snippet": "static inline void __bd_forget(struct inode *inode)\n{\n\tlist_del_init(&inode->i_devices);\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline void __bd_forget(struct inode *inode)\n{\n\tlist_del_init(&inode->i_devices);\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_is_blkdev_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "sb_is_blkdev_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "692-695",
          "snippet": "int sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *blockdev_superblock"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct super_block *blockdev_superblock;\n\nint sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\t__bd_forget(inode);\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tiput(bdev->bd_inode);\n}"
  },
  {
    "function_name": "sb_is_blkdev_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "692-695",
    "snippet": "int sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *blockdev_superblock"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct super_block *blockdev_superblock;\n\nint sb_is_blkdev_sb(struct super_block *sb)\n{\n\treturn sb == blockdev_superblock;\n}"
  },
  {
    "function_name": "bd_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "659-690",
    "snippet": "static struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_devices",
            "&bdev->bd_inodes"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdget",
          "args": [
            "inode->i_rdev"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "bdget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "594-625",
          "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations def_blk_aops;",
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
            "static struct super_block *blockdev_superblock",
            "static LIST_HEAD(all_bdevs);",
            "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstatic struct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_acquire(struct inode *inode)\n{\n\tstruct block_device *bdev;\n\n\tspin_lock(&bdev_lock);\n\tbdev = inode->i_bdev;\n\tif (bdev) {\n\t\tihold(bdev->bd_inode);\n\t\tspin_unlock(&bdev_lock);\n\t\treturn bdev;\n\t}\n\tspin_unlock(&bdev_lock);\n\n\tbdev = bdget(inode->i_rdev);\n\tif (bdev) {\n\t\tspin_lock(&bdev_lock);\n\t\tif (!inode->i_bdev) {\n\t\t\t/*\n\t\t\t * We take an additional reference to bd_inode,\n\t\t\t * and it's released in clear_inode() of inode.\n\t\t\t * So, we can access it via ->i_mapping always\n\t\t\t * without igrab().\n\t\t\t */\n\t\t\tihold(bdev->bd_inode);\n\t\t\tinode->i_bdev = bdev;\n\t\t\tinode->i_mapping = bdev->bd_inode->i_mapping;\n\t\t\tlist_add(&inode->i_devices, &bdev->bd_inodes);\n\t\t}\n\t\tspin_unlock(&bdev_lock);\n\t}\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "652-655",
    "snippet": "void bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid bdput(struct block_device *bdev)\n{\n\tiput(bdev->bd_inode);\n}"
  },
  {
    "function_name": "nr_blockdev_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "640-650",
    "snippet": "long nr_blockdev_pages(void)\n{\n\tstruct block_device *bdev;\n\tlong ret = 0;\n\tspin_lock(&bdev_lock);\n\tlist_for_each_entry(bdev, &all_bdevs, bd_list) {\n\t\tret += bdev->bd_inode->i_mapping->nrpages;\n\t}\n\tspin_unlock(&bdev_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
      "static LIST_HEAD(all_bdevs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "bdev",
            "&all_bdevs",
            "bd_list"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstatic LIST_HEAD(all_bdevs);\n\nlong nr_blockdev_pages(void)\n{\n\tstruct block_device *bdev;\n\tlong ret = 0;\n\tspin_lock(&bdev_lock);\n\tlist_for_each_entry(bdev, &all_bdevs, bd_list) {\n\t\tret += bdev->bd_inode->i_mapping->nrpages;\n\t}\n\tspin_unlock(&bdev_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "bdgrab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "633-637",
    "snippet": "struct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "bdev->bd_inode"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *bdgrab(struct block_device *bdev)\n{\n\tihold(bdev->bd_inode);\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "594-625",
    "snippet": "struct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations def_blk_aops;",
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);",
      "static struct super_block *blockdev_superblock",
      "static LIST_HEAD(all_bdevs);",
      "static const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&bdev->bd_list",
            "&all_bdevs"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "&inode->i_data",
            "GFP_USER"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "blockdev_superblock",
            "hash(dev)",
            "bdev_test",
            "bdev_set",
            "&dev"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "dev"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "576-579",
          "snippet": "static inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct address_space_operations def_blk_aops;\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\nstatic struct super_block *blockdev_superblock;\nstatic LIST_HEAD(all_bdevs);\nstatic const struct address_space_operations def_blk_aops = {\n\t.readpage\t= blkdev_readpage,\n\t.readpages\t= blkdev_readpages,\n\t.writepage\t= blkdev_writepage,\n\t.write_begin\t= blkdev_write_begin,\n\t.write_end\t= blkdev_write_end,\n\t.writepages\t= generic_writepages,\n\t.releasepage\t= blkdev_releasepage,\n\t.direct_IO\t= blkdev_direct_IO,\n\t.is_dirty_writeback = buffer_check_dirty_writeback,\n};\n\nstruct block_device *bdget(dev_t dev)\n{\n\tstruct block_device *bdev;\n\tstruct inode *inode;\n\n\tinode = iget5_locked(blockdev_superblock, hash(dev),\n\t\t\tbdev_test, bdev_set, &dev);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tbdev = &BDEV_I(inode)->bdev;\n\n\tif (inode->i_state & I_NEW) {\n\t\tbdev->bd_contains = NULL;\n\t\tbdev->bd_super = NULL;\n\t\tbdev->bd_inode = inode;\n\t\tbdev->bd_block_size = (1 << inode->i_blkbits);\n\t\tbdev->bd_part_count = 0;\n\t\tbdev->bd_invalidated = 0;\n\t\tinode->i_mode = S_IFBLK;\n\t\tinode->i_rdev = dev;\n\t\tinode->i_bdev = bdev;\n\t\tinode->i_data.a_ops = &def_blk_aops;\n\t\tmapping_set_gfp_mask(&inode->i_data, GFP_USER);\n\t\tspin_lock(&bdev_lock);\n\t\tlist_add(&bdev->bd_list, &all_bdevs);\n\t\tspin_unlock(&bdev_lock);\n\t\tunlock_new_inode(inode);\n\t}\n\treturn bdev;\n}"
  },
  {
    "function_name": "bdev_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "586-590",
    "snippet": "static int bdev_set(struct inode *inode, void *data)\n{\n\tBDEV_I(inode)->bdev.bd_dev = *(dev_t *)data;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int bdev_set(struct inode *inode, void *data)\n{\n\tBDEV_I(inode)->bdev.bd_dev = *(dev_t *)data;\n\treturn 0;\n}"
  },
  {
    "function_name": "bdev_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "581-584",
    "snippet": "static int bdev_test(struct inode *inode, void *data)\n{\n\treturn BDEV_I(inode)->bdev.bd_dev == *(dev_t *)data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int bdev_test(struct inode *inode, void *data)\n{\n\treturn BDEV_I(inode)->bdev.bd_dev == *(dev_t *)data;\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "576-579",
    "snippet": "static inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline unsigned long hash(dev_t dev)\n{\n\treturn MAJOR(dev)+MINOR(dev);\n}"
  },
  {
    "function_name": "bdev_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "553-569",
    "snippet": "void __init bdev_cache_init(void)\n{\n\tint err;\n\tstatic struct vfsmount *bd_mnt;\n\n\tbdev_cachep = kmem_cache_create(\"bdev_cache\", sizeof(struct bdev_inode),\n\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tinit_once);\n\terr = register_filesystem(&bd_type);\n\tif (err)\n\t\tpanic(\"Cannot register bdev pseudo-fs\");\n\tbd_mnt = kern_mount(&bd_type);\n\tif (IS_ERR(bd_mnt))\n\t\tpanic(\"Cannot create bdev pseudo-fs\");\n\tblockdev_superblock = bd_mnt->mnt_sb;   /* For writeback */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep",
      "static struct file_system_type bd_type = {\n\t.name\t\t= \"bdev\",\n\t.mount\t\t= bd_mount,\n\t.kill_sb\t= kill_anon_super,\n};",
      "static struct super_block *blockdev_superblock"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot create bdev pseudo-fs\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bd_mnt"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&bd_type"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot register bdev pseudo-fs\""
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&bd_type"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"bdev_cache\"",
            "sizeof(struct bdev_inode)",
            "0",
            "(SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC)",
            "init_once"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\nstatic struct file_system_type bd_type = {\n\t.name\t\t= \"bdev\",\n\t.mount\t\t= bd_mount,\n\t.kill_sb\t= kill_anon_super,\n};\nstatic struct super_block *blockdev_superblock;\n\nvoid __init bdev_cache_init(void)\n{\n\tint err;\n\tstatic struct vfsmount *bd_mnt;\n\n\tbdev_cachep = kmem_cache_create(\"bdev_cache\", sizeof(struct bdev_inode),\n\t\t\t0, (SLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT|\n\t\t\t\tSLAB_MEM_SPREAD|SLAB_PANIC),\n\t\t\tinit_once);\n\terr = register_filesystem(&bd_type);\n\tif (err)\n\t\tpanic(\"Cannot register bdev pseudo-fs\");\n\tbd_mnt = kern_mount(&bd_type);\n\tif (IS_ERR(bd_mnt))\n\t\tpanic(\"Cannot create bdev pseudo-fs\");\n\tblockdev_superblock = bd_mnt->mnt_sb;   /* For writeback */\n}"
  },
  {
    "function_name": "bd_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "539-543",
    "snippet": "static struct dentry *bd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"bdev:\", &bdev_sops, NULL, BDEVFS_MAGIC);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations bdev_sops = {\n\t.statfs = simple_statfs,\n\t.alloc_inode = bdev_alloc_inode,\n\t.destroy_inode = bdev_destroy_inode,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = bdev_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_pseudo",
          "args": [
            "fs_type",
            "\"bdev:\"",
            "&bdev_sops",
            "NULL",
            "BDEVFS_MAGIC"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "mount_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "216-260",
          "snippet": "struct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nstruct dentry *mount_pseudo(struct file_system_type *fs_type, char *name,\n\tconst struct super_operations *ops,\n\tconst struct dentry_operations *dops, unsigned long magic)\n{\n\tstruct super_block *s;\n\tstruct dentry *dentry;\n\tstruct inode *root;\n\tstruct qstr d_name = QSTR_INIT(name, strlen(name));\n\n\ts = sget(fs_type, NULL, set_anon_super, MS_NOUSER, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\ts->s_maxbytes = MAX_LFS_FILESIZE;\n\ts->s_blocksize = PAGE_SIZE;\n\ts->s_blocksize_bits = PAGE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = ops ? ops : &simple_super_operations;\n\ts->s_time_gran = 1;\n\troot = new_inode(s);\n\tif (!root)\n\t\tgoto Enomem;\n\t/*\n\t * since this is the first inode, make it number 1. New inodes created\n\t * after this must take care not to collide with it (by passing\n\t * max_reserved of 1 to iunique).\n\t */\n\troot->i_ino = 1;\n\troot->i_mode = S_IFDIR | S_IRUSR | S_IWUSR;\n\troot->i_atime = root->i_mtime = root->i_ctime = CURRENT_TIME;\n\tdentry = __d_alloc(s, &d_name);\n\tif (!dentry) {\n\t\tiput(root);\n\t\tgoto Enomem;\n\t}\n\td_instantiate(dentry, root);\n\ts->s_root = dentry;\n\ts->s_d_op = dops;\n\ts->s_flags |= MS_ACTIVE;\n\treturn dget(s->s_root);\n\nEnomem:\n\tdeactivate_locked_super(s);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic const struct super_operations bdev_sops = {\n\t.statfs = simple_statfs,\n\t.alloc_inode = bdev_alloc_inode,\n\t.destroy_inode = bdev_destroy_inode,\n\t.drop_inode = generic_delete_inode,\n\t.evict_inode = bdev_evict_inode,\n};\n\nstatic struct dentry *bd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"bdev:\", &bdev_sops, NULL, BDEVFS_MAGIC);\n}"
  },
  {
    "function_name": "bdev_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "516-529",
    "snippet": "static void bdev_evict_inode(struct inode *inode)\n{\n\tstruct block_device *bdev = &BDEV_I(inode)->bdev;\n\tstruct list_head *p;\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode); /* is it needed here? */\n\tclear_inode(inode);\n\tspin_lock(&bdev_lock);\n\twhile ( (p = bdev->bd_inodes.next) != &bdev->bd_inodes ) {\n\t\t__bd_forget(list_entry(p, struct inode, i_devices));\n\t}\n\tlist_del_init(&bdev->bd_list);\n\tspin_unlock(&bdev_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&bdev_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&bdev->bd_list"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&bdev_lock"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic void bdev_evict_inode(struct inode *inode)\n{\n\tstruct block_device *bdev = &BDEV_I(inode)->bdev;\n\tstruct list_head *p;\n\ttruncate_inode_pages_final(&inode->i_data);\n\tinvalidate_inode_buffers(inode); /* is it needed here? */\n\tclear_inode(inode);\n\tspin_lock(&bdev_lock);\n\twhile ( (p = bdev->bd_inodes.next) != &bdev->bd_inodes ) {\n\t\t__bd_forget(list_entry(p, struct inode, i_devices));\n\t}\n\tlist_del_init(&bdev->bd_list);\n\tspin_unlock(&bdev_lock);\n}"
  },
  {
    "function_name": "__bd_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "509-514",
    "snippet": "static inline void __bd_forget(struct inode *inode)\n{\n\tlist_del_init(&inode->i_devices);\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_devices"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline void __bd_forget(struct inode *inode)\n{\n\tlist_del_init(&inode->i_devices);\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "492-507",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct bdev_inode *ei = (struct bdev_inode *) foo;\n\tstruct block_device *bdev = &ei->bdev;\n\n\tmemset(bdev, 0, sizeof(*bdev));\n\tmutex_init(&bdev->bd_mutex);\n\tINIT_LIST_HEAD(&bdev->bd_inodes);\n\tINIT_LIST_HEAD(&bdev->bd_list);\n#ifdef CONFIG_SYSFS\n\tINIT_LIST_HEAD(&bdev->bd_holder_disks);\n#endif\n\tinode_init_once(&ei->vfs_inode);\n\t/* Initialize mutex for freeze. */\n\tmutex_init(&bdev->bd_fsfreeze_mutex);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bdev->bd_holder_disks"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bdev->bd_list"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&bdev->bd_inodes"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&bdev->bd_mutex"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bdev",
            "0",
            "sizeof(*bdev)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct bdev_inode *ei = (struct bdev_inode *) foo;\n\tstruct block_device *bdev = &ei->bdev;\n\n\tmemset(bdev, 0, sizeof(*bdev));\n\tmutex_init(&bdev->bd_mutex);\n\tINIT_LIST_HEAD(&bdev->bd_inodes);\n\tINIT_LIST_HEAD(&bdev->bd_list);\n#ifdef CONFIG_SYSFS\n\tINIT_LIST_HEAD(&bdev->bd_holder_disks);\n#endif\n\tinode_init_once(&ei->vfs_inode);\n\t/* Initialize mutex for freeze. */\n\tmutex_init(&bdev->bd_fsfreeze_mutex);\n}"
  },
  {
    "function_name": "bdev_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "487-490",
    "snippet": "static void bdev_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bdev_i_callback);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "bdev_i_callback"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, bdev_i_callback);\n}"
  },
  {
    "function_name": "bdev_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "479-485",
    "snippet": "static void bdev_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct bdev_inode *bdi = BDEV_I(inode);\n\n\tkmem_cache_free(bdev_cachep, bdi);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "bdev_cachep",
            "bdi"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\n\nstatic void bdev_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct bdev_inode *bdi = BDEV_I(inode);\n\n\tkmem_cache_free(bdev_cachep, bdi);\n}"
  },
  {
    "function_name": "bdev_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "471-477",
    "snippet": "static struct inode *bdev_alloc_inode(struct super_block *sb)\n{\n\tstruct bdev_inode *ei = kmem_cache_alloc(bdev_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * bdev_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "bdev_cachep",
            "GFP_KERNEL"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct kmem_cache * bdev_cachep;\n\nstatic struct inode *bdev_alloc_inode(struct super_block *sb)\n{\n\tstruct bdev_inode *ei = kmem_cache_alloc(bdev_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "bdev_direct_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "441-461",
    "snippet": "long bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "avail",
            "size"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "bd_start_claiming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "811-859",
          "snippet": "static struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nstatic struct block_device *bd_start_claiming(struct block_device *bdev,\n\t\t\t\t\t      void *holder)\n{\n\tstruct gendisk *disk;\n\tstruct block_device *whole;\n\tint partno, err;\n\n\tmight_sleep();\n\n\t/*\n\t * @bdev might not have been initialized properly yet, look up\n\t * and grab the outer block device the hard way.\n\t */\n\tdisk = get_gendisk(bdev->bd_dev, &partno);\n\tif (!disk)\n\t\treturn ERR_PTR(-ENXIO);\n\n\t/*\n\t * Normally, @bdev should equal what's returned from bdget_disk()\n\t * if partno is 0; however, some drivers (floppy) use multiple\n\t * bdev's for the same physical device and @bdev may be one of the\n\t * aliases.  Keep @bdev if partno is 0.  This means claimer\n\t * tracking is broken for those devices but it has always been that\n\t * way.\n\t */\n\tif (partno)\n\t\twhole = bdget_disk(disk, 0);\n\telse\n\t\twhole = bdgrab(bdev);\n\n\tmodule_put(disk->fops->owner);\n\tput_disk(disk);\n\tif (!whole)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* prepare to claim, if successful, mark claiming in progress */\n\tspin_lock(&bdev_lock);\n\n\terr = bd_prepare_to_claim(bdev, whole, holder);\n\tif (err == 0) {\n\t\twhole->bd_claiming = holder;\n\t\tspin_unlock(&bdev_lock);\n\t\treturn whole;\n\t} else {\n\t\tspin_unlock(&bdev_lock);\n\t\tbdput(whole);\n\t\treturn ERR_PTR(err);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->direct_access",
          "args": [
            "bdev",
            "sector",
            "addr",
            "pfn",
            "size"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_start_sect",
          "args": [
            "bdev"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part_nr_sects_read",
          "args": [
            "bdev->bd_part"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "size",
            "512"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nlong bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}"
  },
  {
    "function_name": "bdev_write_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "406-421",
    "snippet": "int bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tint rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);\n\tif (result)\n\t\tend_page_writeback(page);\n\telse\n\t\tunlock_page(page);\n\treturn result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "page"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->rw_page",
          "args": [
            "bdev",
            "sector + get_start_sect(bdev)",
            "page",
            "rw"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_start_sect",
          "args": [
            "bdev"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_writeback",
          "args": [
            "page"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_set_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "265-277",
          "snippet": "static void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))"
          ],
          "globals_used": [
            "static struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_ON_THRESH \t(nfs_congestion_kb >> (PAGE_SHIFT-10))\n\nstatic struct nfs_page *\nnfs_page_search_commits_for_head_request_locked(struct nfs_inode *nfsi,\n\t\t\t\t\t\tstruct page *page);\n\nstatic void nfs_set_page_writeback(struct page *page)\n{\n\tstruct nfs_server *nfss = NFS_SERVER(page_file_mapping(page)->host);\n\tint ret = test_set_page_writeback(page);\n\n\tWARN_ON_ONCE(ret != 0);\n\n\tif (atomic_long_inc_return(&nfss->writeback) >\n\t\t\tNFS_CONGESTION_ON_THRESH) {\n\t\tset_bdi_congested(&nfss->backing_dev_info,\n\t\t\t\t\tBLK_RW_ASYNC);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_write_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page, struct writeback_control *wbc)\n{\n\tint result;\n\tint rw = (wbc->sync_mode == WB_SYNC_ALL) ? WRITE_SYNC : WRITE;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\tset_page_writeback(page);\n\tresult = ops->rw_page(bdev, sector + get_start_sect(bdev), page, rw);\n\tif (result)\n\t\tend_page_writeback(page);\n\telse\n\t\tunlock_page(page);\n\treturn result;\n}"
  },
  {
    "function_name": "bdev_read_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "377-384",
    "snippet": "int bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->rw_page",
          "args": [
            "bdev",
            "sector + get_start_sect(bdev)",
            "page",
            "READ"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_start_sect",
          "args": [
            "bdev"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint bdev_read_page(struct block_device *bdev, sector_t sector,\n\t\t\tstruct page *page)\n{\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\tif (!ops->rw_page)\n\t\treturn -EOPNOTSUPP;\n\treturn ops->rw_page(bdev, sector + get_start_sect(bdev), page, READ);\n}"
  },
  {
    "function_name": "blkdev_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "338-358",
    "snippet": "int blkdev_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *bd_inode = filp->f_mapping->host;\n\tstruct block_device *bdev = I_BDEV(bd_inode);\n\tint error;\n\t\n\terror = filemap_write_and_wait_range(filp->f_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * There is no need to serialise calls to blkdev_issue_flush with\n\t * i_mutex and doing so causes performance issues with concurrent\n\t * O_SYNC writers to a block device.\n\t */\n\terror = blkdev_issue_flush(bdev, GFP_KERNEL, NULL);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "filp->f_mapping",
            "start",
            "end"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "bd_inode"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint blkdev_fsync(struct file *filp, loff_t start, loff_t end, int datasync)\n{\n\tstruct inode *bd_inode = filp->f_mapping->host;\n\tstruct block_device *bdev = I_BDEV(bd_inode);\n\tint error;\n\t\n\terror = filemap_write_and_wait_range(filp->f_mapping, start, end);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * There is no need to serialise calls to blkdev_issue_flush with\n\t * i_mutex and doing so causes performance issues with concurrent\n\t * O_SYNC writers to a block device.\n\t */\n\terror = blkdev_issue_flush(bdev, GFP_KERNEL, NULL);\n\tif (error == -EOPNOTSUPP)\n\t\terror = 0;\n\n\treturn error;\n}"
  },
  {
    "function_name": "block_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "327-336",
    "snippet": "static loff_t block_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *bd_inode = file->f_mapping->host;\n\tloff_t retval;\n\n\tmutex_lock(&bd_inode->i_mutex);\n\tretval = fixed_size_llseek(file, offset, whence, i_size_read(bd_inode));\n\tmutex_unlock(&bd_inode->i_mutex);\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bd_inode->i_mutex"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_size_llseek",
          "args": [
            "file",
            "offset",
            "whence",
            "i_size_read(bd_inode)"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_size_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "165-174",
          "snippet": "loff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t fixed_size_llseek(struct file *file, loff_t offset, int whence, loff_t size)\n{\n\tswitch (whence) {\n\tcase SEEK_SET: case SEEK_CUR: case SEEK_END:\n\t\treturn generic_file_llseek_size(file, offset, whence,\n\t\t\t\t\t\tsize, size);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "bd_inode"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bd_inode->i_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic loff_t block_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *bd_inode = file->f_mapping->host;\n\tloff_t retval;\n\n\tmutex_lock(&bd_inode->i_mutex);\n\tretval = fixed_size_llseek(file, offset, whence, i_size_read(bd_inode));\n\tmutex_unlock(&bd_inode->i_mutex);\n\treturn retval;\n}"
  },
  {
    "function_name": "blkdev_write_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "309-320",
    "snippet": "static int blkdev_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\tret = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_write_end",
          "args": [
            "file",
            "mapping",
            "pos",
            "len",
            "copied",
            "page",
            "fsdata"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2031-2064",
          "snippet": "int block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned start;\n\n\tstart = pos & (PAGE_CACHE_SIZE - 1);\n\n\tif (unlikely(copied < len)) {\n\t\t/*\n\t\t * The buffers that were written will now be uptodate, so we\n\t\t * don't have to worry about a readpage reading them and\n\t\t * overwriting a partial write. However if we have encountered\n\t\t * a short write and only partially written into a buffer, it\n\t\t * will not be marked uptodate, so a readpage might come in and\n\t\t * destroy our partial write.\n\t\t *\n\t\t * Do the simplest thing, and just treat any short write to a\n\t\t * non uptodate page as a zero-length write, and force the\n\t\t * caller to redo the whole thing.\n\t\t */\n\t\tif (!PageUptodate(page))\n\t\t\tcopied = 0;\n\n\t\tpage_zero_new_buffers(page, start+copied, start+len);\n\t}\n\tflush_dcache_page(page);\n\n\t/* This could be a short (even 0-length) commit */\n\t__block_commit_write(inode, page, start, start+copied);\n\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_write_end(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tint ret;\n\tret = block_write_end(file, mapping, pos, len, copied, page, fsdata);\n\n\tunlock_page(page);\n\tpage_cache_release(page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "blkdev_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "301-307",
    "snippet": "static int blkdev_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\t blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "blkdev_get_block"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\treturn block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\t blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_readpages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "295-299",
    "snippet": "static int blkdev_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mpage_readpages",
          "args": [
            "mapping",
            "pages",
            "nr_pages",
            "blkdev_get_block"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "mpage_readpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mpage.c",
          "lines": "355-386",
          "snippet": "int\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/highmem.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/bio.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/cleancache.h>\n#include <linux/pagevec.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/prefetch.h>\n#include <linux/highmem.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/bio.h>\n#include <linux/gfp.h>\n#include <linux/kdev_t.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint\nmpage_readpages(struct address_space *mapping, struct list_head *pages,\n\t\t\t\tunsigned nr_pages, get_block_t get_block)\n{\n\tstruct bio *bio = NULL;\n\tunsigned page_idx;\n\tsector_t last_block_in_bio = 0;\n\tstruct buffer_head map_bh;\n\tunsigned long first_logical_block = 0;\n\n\tmap_bh.b_state = 0;\n\tmap_bh.b_size = 0;\n\tfor (page_idx = 0; page_idx < nr_pages; page_idx++) {\n\t\tstruct page *page = list_entry(pages->prev, struct page, lru);\n\n\t\tprefetchw(&page->flags);\n\t\tlist_del(&page->lru);\n\t\tif (!add_to_page_cache_lru(page, mapping,\n\t\t\t\t\tpage->index, GFP_KERNEL)) {\n\t\t\tbio = do_mpage_readpage(bio, page,\n\t\t\t\t\tnr_pages - page_idx,\n\t\t\t\t\t&last_block_in_bio, &map_bh,\n\t\t\t\t\t&first_logical_block,\n\t\t\t\t\tget_block);\n\t\t}\n\t\tpage_cache_release(page);\n\t}\n\tBUG_ON(!list_empty(pages));\n\tif (bio)\n\t\tmpage_bio_submit(READ, bio);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_readpages(struct file *file, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\treturn mpage_readpages(mapping, pages, nr_pages, blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "290-293",
    "snippet": "static int blkdev_readpage(struct file * file, struct page * page)\n{\n\treturn block_read_full_page(page, blkdev_get_block);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "blkdev_get_block"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_readpage(struct file * file, struct page * page)\n{\n\treturn block_read_full_page(page, blkdev_get_block);\n}"
  },
  {
    "function_name": "blkdev_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "285-288",
    "snippet": "static int blkdev_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, blkdev_get_block, wbc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "blkdev_get_block",
            "wbc"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int blkdev_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, blkdev_get_block, wbc);\n}"
  },
  {
    "function_name": "thaw_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "255-282",
    "snippet": "int thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_super",
          "args": [
            "sb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->thaw_super",
          "args": [
            "sb"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint thaw_bdev(struct block_device *bdev, struct super_block *sb)\n{\n\tint error = -EINVAL;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (!bdev->bd_fsfreeze_count)\n\t\tgoto out;\n\n\terror = 0;\n\tif (--bdev->bd_fsfreeze_count > 0)\n\t\tgoto out;\n\n\tif (!sb)\n\t\tgoto out;\n\n\tif (sb->s_op->thaw_super)\n\t\terror = sb->s_op->thaw_super(sb);\n\telse\n\t\terror = thaw_super(sb);\n\tif (error) {\n\t\tbdev->bd_fsfreeze_count++;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn error;\n\t}\nout:\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "freeze_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "209-245",
    "snippet": "struct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_super",
          "args": [
            "sb"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_super",
          "args": [
            "sb"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeze_super",
          "args": [
            "sb"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->freeze_super",
          "args": [
            "sb"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_active_super",
          "args": [
            "bdev"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ser_get_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "662-687",
          "snippet": "truct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct super_block *freeze_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\tint error = 0;\n\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (++bdev->bd_fsfreeze_count > 1) {\n\t\t/*\n\t\t * We don't even need to grab a reference - the first call\n\t\t * to freeze_bdev grab an active reference and only the last\n\t\t * thaw_bdev drops it.\n\t\t */\n\t\tsb = get_super(bdev);\n\t\tdrop_super(sb);\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn sb;\n\t}\n\n\tsb = get_active_super(bdev);\n\tif (!sb)\n\t\tgoto out;\n\tif (sb->s_op->freeze_super)\n\t\terror = sb->s_op->freeze_super(sb);\n\telse\n\t\terror = freeze_super(sb);\n\tif (error) {\n\t\tdeactivate_super(sb);\n\t\tbdev->bd_fsfreeze_count--;\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\treturn ERR_PTR(error);\n\t}\n\tdeactivate_super(sb);\n out:\n\tsync_blockdev(bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\treturn sb;\t/* thaw_bdev releases s->s_umount */\n}"
  },
  {
    "function_name": "fsync_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "185-194",
    "snippet": "int fsync_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tif (sb) {\n\t\tint res = sync_filesystem(sb);\n\t\tdrop_super(sb);\n\t\treturn res;\n\t}\n\treturn sync_blockdev(bdev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_super",
          "args": [
            "sb"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_super",
          "args": [
            "bdev"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ser_get_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "662-687",
          "snippet": "truct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(super_blocks);",
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic LIST_HEAD(super_blocks);\ntatic DEFINE_SPINLOCK(sb_lock);\n\ntruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & MS_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint fsync_bdev(struct block_device *bdev)\n{\n\tstruct super_block *sb = get_super(bdev);\n\tif (sb) {\n\t\tint res = sync_filesystem(sb);\n\t\tdrop_super(sb);\n\t\treturn res;\n\t}\n\treturn sync_blockdev(bdev);\n}"
  },
  {
    "function_name": "sync_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "174-177",
    "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sync_blockdev",
          "args": [
            "bdev",
            "1"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "161-168",
          "snippet": "int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
  },
  {
    "function_name": "__sync_blockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "161-168",
    "snippet": "int __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "bdev->bd_inode->i_mapping"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint __sync_blockdev(struct block_device *bdev, int wait)\n{\n\tif (!bdev)\n\t\treturn 0;\n\tif (!wait)\n\t\treturn filemap_flush(bdev->bd_inode->i_mapping);\n\treturn filemap_write_and_wait(bdev->bd_inode->i_mapping);\n}"
  },
  {
    "function_name": "blkdev_direct_IO",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "149-159",
    "snippet": "static ssize_t\nblkdev_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn __blockdev_direct_IO(rw, iocb, inode, I_BDEV(inode), iter,\n\t\t\t\t    offset, blkdev_get_block,\n\t\t\t\t    NULL, NULL, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__blockdev_direct_IO",
          "args": [
            "rw",
            "iocb",
            "inode",
            "I_BDEV(inode)",
            "iter",
            "offset",
            "blkdev_get_block",
            "NULL",
            "NULL",
            "0"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__blockdev_direct_IO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "1304-1324",
          "snippet": "ssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nssize_t\n__blockdev_direct_IO(int rw, struct kiocb *iocb, struct inode *inode,\n\tstruct block_device *bdev, struct iov_iter *iter, loff_t offset,\n\tget_block_t get_block, dio_iodone_t end_io,\n\tdio_submit_t submit_io,\tint flags)\n{\n\t/*\n\t * The block device state is needed in the end to finally\n\t * submit everything.  Since it's likely to be cache cold\n\t * prefetch it here as first thing to hide some of the\n\t * latency.\n\t *\n\t * Attempt to prefetch the pieces we likely need later.\n\t */\n\tprefetch(&bdev->bd_disk->part_tbl);\n\tprefetch(bdev->bd_queue);\n\tprefetch((char *)bdev->bd_queue + SMP_CACHE_BYTES);\n\n\treturn do_blockdev_direct_IO(rw, iocb, inode, bdev, iter, offset,\n\t\t\t\t     get_block, end_io, submit_io, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic ssize_t\nblkdev_direct_IO(int rw, struct kiocb *iocb, struct iov_iter *iter,\n\t\t\tloff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\n\treturn __blockdev_direct_IO(rw, iocb, inode, I_BDEV(inode), iter,\n\t\t\t\t    offset, blkdev_get_block,\n\t\t\t\t    NULL, NULL, 0);\n}"
  },
  {
    "function_name": "blkdev_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "139-147",
    "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "I_BDEV",
          "args": [
            "inode"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "I_BDEV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "46-49",
          "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "sb_min_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "129-135",
    "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "size"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "sb->s_bdev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
  },
  {
    "function_name": "sb_set_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "116-125",
    "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_blocksize",
          "args": [
            "sb->s_bdev",
            "size"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
  },
  {
    "function_name": "set_blocksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "94-112",
    "snippet": "int set_blocksize(struct block_device *bdev, int size)\n{\n\t/* Size must be a power of two, and between 512 and PAGE_SIZE */\n\tif (size > PAGE_SIZE || size < 512 || !is_power_of_2(size))\n\t\treturn -EINVAL;\n\n\t/* Size cannot be smaller than the size supported by the device */\n\tif (size < bdev_logical_block_size(bdev))\n\t\treturn -EINVAL;\n\n\t/* Don't change the size if it is same as current */\n\tif (bdev->bd_block_size != size) {\n\t\tsync_blockdev(bdev);\n\t\tbdev->bd_block_size = size;\n\t\tbdev->bd_inode->i_blkbits = blksize_bits(size);\n\t\tkill_bdev(bdev);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_bdev",
          "args": [
            "bdev"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "kill_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "64-73",
          "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blksize_bits",
          "args": [
            "size"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_logical_block_size",
          "args": [
            "bdev"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "size"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint set_blocksize(struct block_device *bdev, int size)\n{\n\t/* Size must be a power of two, and between 512 and PAGE_SIZE */\n\tif (size > PAGE_SIZE || size < 512 || !is_power_of_2(size))\n\t\treturn -EINVAL;\n\n\t/* Size cannot be smaller than the size supported by the device */\n\tif (size < bdev_logical_block_size(bdev))\n\t\treturn -EINVAL;\n\n\t/* Don't change the size if it is same as current */\n\tif (bdev->bd_block_size != size) {\n\t\tsync_blockdev(bdev);\n\t\tbdev->bd_block_size = size;\n\t\tbdev->bd_inode->i_blkbits = blksize_bits(size);\n\t\tkill_bdev(bdev);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "invalidate_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "77-91",
    "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleancache_invalidate_inode",
          "args": [
            "mapping"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "mapping",
            "0",
            "-1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain_all",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_bh_lrus",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bh_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1445-1448",
          "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\tinvalidate_mapping_pages(mapping, 0, -1);\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
  },
  {
    "function_name": "kill_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "64-73",
    "snippet": "void kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_bh_lrus",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bh_lrus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1445-1448",
          "snippet": "void invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid invalidate_bh_lrus(void)\n{\n\ton_each_cpu_cond(has_bh_in_lru, invalidate_bh_lru, NULL, 1, GFP_KERNEL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid kill_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages == 0 && mapping->nrshadows == 0)\n\t\treturn;\n\n\tinvalidate_bh_lrus();\n\ttruncate_inode_pages(mapping, 0);\n}"
  },
  {
    "function_name": "bdev_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "52-61",
    "snippet": "static void bdev_write_inode(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tWARN_ON_ONCE(write_inode_now(inode, true));\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "write_inode_now(inode, true)"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "true"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic void bdev_write_inode(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\twhile (inode->i_state & I_DIRTY) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tWARN_ON_ONCE(write_inode_now(inode, true));\n\t\tspin_lock(&inode->i_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "I_BDEV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "46-49",
    "snippet": "inline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BDEV_I",
          "args": [
            "inode"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "BDEV_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "41-44",
          "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\ninline struct block_device *I_BDEV(struct inode *inode)\n{\n\treturn &BDEV_I(inode)->bdev;\n}"
  },
  {
    "function_name": "BDEV_I",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
    "lines": "41-44",
    "snippet": "static inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/aio.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/log2.h>",
      "#include <linux/namei.h>",
      "#include <linux/uio.h>",
      "#include <linux/mount.h>",
      "#include <linux/mpage.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/swap.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/magic.h>",
      "#include <linux/blkpg.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/highmem.h>",
      "#include <linux/device_cgroup.h>",
      "#include <linux/major.h>",
      "#include <linux/kmod.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "inode",
            "structbdev_inode",
            "vfs_inode"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic inline struct bdev_inode *BDEV_I(struct inode *inode)\n{\n\treturn container_of(inode, struct bdev_inode, vfs_inode);\n}"
  }
]