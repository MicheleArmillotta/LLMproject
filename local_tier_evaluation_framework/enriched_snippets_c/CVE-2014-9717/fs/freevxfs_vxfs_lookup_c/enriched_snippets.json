[
  {
    "function_name": "vxfs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "237-313",
    "snippet": "static int\nvxfs_readdir(struct file *fp, struct dir_context *ctx)\n{\n\tstruct inode\t\t*ip = file_inode(fp);\n\tstruct super_block\t*sbp = ip->i_sb;\n\tu_long\t\t\tbsize = sbp->s_blocksize;\n\tu_long\t\t\tpage, npages, block, pblocks, nblocks, offset;\n\tloff_t\t\t\tpos;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(fp, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit(ctx, \"..\", 2, VXFS_INO(ip)->vii_dotdot, DT_DIR))\n\t\t\treturn 0;\n\t\tctx->pos = 2;\n\t}\n\tpos = ctx->pos - 2;\n\t\n\tif (pos > VXFS_DIRROUND(ip->i_size))\n\t\treturn 0;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(sbp);\n\n\tpage = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\tblock = (u_long)(pos >> sbp->s_blocksize_bits) % pblocks;\n\n\tfor (; page < npages; page++, block = 0) {\n\t\tchar\t\t\t*kaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (char *)page_address(pp);\n\n\t\tfor (; block <= nblocks && block <= pblocks; block++) {\n\t\t\tchar\t\t\t*baddr, *limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)\n\t\t\t\t(offset ?\n\t\t\t\t (kaddr + offset) :\n\t\t\t\t (baddr + VXFS_DIRBLKOV(dbp)));\n\n\t\t\tfor (; (char *)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\n\t\t\t\toffset = (char *)de - kaddr;\n\t\t\t\tctx->pos = ((page << PAGE_CACHE_SHIFT) | offset) + 2;\n\t\t\t\tif (!dir_emit(ctx, de->d_name, de->d_namelen,\n\t\t\t\t\tde->d_ino, DT_UNKNOWN)) {\n\t\t\t\t\tvxfs_put_page(pp);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t\tvxfs_put_page(pp);\n\t\toffset = 0;\n\t}\n\tctx->pos = ((page << PAGE_CACHE_SHIFT) | offset) + 2;\n\treturn 0;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\tvxfs_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vxfs_put_page",
          "args": [
            "pp"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "49-54",
          "snippet": "inline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\ninline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->d_name",
            "de->d_namelen",
            "de->d_ino",
            "DT_UNKNOWN"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_next_entry",
          "args": [
            "de"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "93-97",
          "snippet": "static inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_DIRBLKOV",
          "args": [
            "dbp"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_DIRLEN",
          "args": [
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pp"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pp"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_get_page",
          "args": [
            "ip->i_mapping",
            "page"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "67-87",
          "snippet": "struct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\nstruct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pos >> sbp->s_blocksize_bits"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_BLOCK_PER_PAGE",
          "args": [
            "sbp"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_blocks",
          "args": [
            "ip"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "dir_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "71-76",
          "snippet": "static inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "ip"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "65-69",
          "snippet": "static inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_DIRROUND",
          "args": [
            "ip->i_size"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"..\"",
            "2",
            "VXFS_INO(ip)->vii_dotdot",
            "DT_DIR"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_INO",
          "args": [
            "ip"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dot",
          "args": [
            "fp",
            "ctx"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "fp"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readdir(struct file *, struct dir_context *);\n\nstatic int\nvxfs_readdir(struct file *fp, struct dir_context *ctx)\n{\n\tstruct inode\t\t*ip = file_inode(fp);\n\tstruct super_block\t*sbp = ip->i_sb;\n\tu_long\t\t\tbsize = sbp->s_blocksize;\n\tu_long\t\t\tpage, npages, block, pblocks, nblocks, offset;\n\tloff_t\t\t\tpos;\n\n\tif (ctx->pos == 0) {\n\t\tif (!dir_emit_dot(fp, ctx))\n\t\t\treturn 0;\n\t\tctx->pos = 1;\n\t}\n\tif (ctx->pos == 1) {\n\t\tif (!dir_emit(ctx, \"..\", 2, VXFS_INO(ip)->vii_dotdot, DT_DIR))\n\t\t\treturn 0;\n\t\tctx->pos = 2;\n\t}\n\tpos = ctx->pos - 2;\n\t\n\tif (pos > VXFS_DIRROUND(ip->i_size))\n\t\treturn 0;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(sbp);\n\n\tpage = pos >> PAGE_CACHE_SHIFT;\n\toffset = pos & ~PAGE_CACHE_MASK;\n\tblock = (u_long)(pos >> sbp->s_blocksize_bits) % pblocks;\n\n\tfor (; page < npages; page++, block = 0) {\n\t\tchar\t\t\t*kaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (char *)page_address(pp);\n\n\t\tfor (; block <= nblocks && block <= pblocks; block++) {\n\t\t\tchar\t\t\t*baddr, *limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)\n\t\t\t\t(offset ?\n\t\t\t\t (kaddr + offset) :\n\t\t\t\t (baddr + VXFS_DIRBLKOV(dbp)));\n\n\t\t\tfor (; (char *)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\n\t\t\t\toffset = (char *)de - kaddr;\n\t\t\t\tctx->pos = ((page << PAGE_CACHE_SHIFT) | offset) + 2;\n\t\t\t\tif (!dir_emit(ctx, de->d_name, de->d_namelen,\n\t\t\t\t\tde->d_ino, DT_UNKNOWN)) {\n\t\t\t\t\tvxfs_put_page(pp);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = 0;\n\t\t}\n\t\tvxfs_put_page(pp);\n\t\toffset = 0;\n\t}\n\tctx->pos = ((page << PAGE_CACHE_SHIFT) | offset) + 2;\n\treturn 0;\n}"
  },
  {
    "function_name": "vxfs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "205-222",
    "snippet": "static struct dentry *\nvxfs_lookup(struct inode *dip, struct dentry *dp, unsigned int flags)\n{\n\tstruct inode\t\t*ip = NULL;\n\tino_t\t\t\tino;\n\t\t\t \n\tif (dp->d_name.len > VXFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t\t\t \n\tino = vxfs_inode_by_name(dip, dp);\n\tif (ino) {\n\t\tip = vxfs_iget(dip->i_sb, ino);\n\t\tif (IS_ERR(ip))\n\t\t\treturn ERR_CAST(ip);\n\t}\n\td_add(dp, ip);\n\treturn NULL;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dp",
            "ip"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "ip"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ip"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_iget",
          "args": [
            "dip->i_sb",
            "ino"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_inode.c",
          "lines": "292-338",
          "snippet": "struct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs.h\"\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/pagemap.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstruct inode *\nvxfs_iget(struct super_block *sbp, ino_t ino)\n{\n\tstruct vxfs_inode_info\t\t*vip;\n\tconst struct address_space_operations\t*aops;\n\tstruct inode *ip;\n\n\tip = iget_locked(sbp, ino);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(ip->i_state & I_NEW))\n\t\treturn ip;\n\n\tvip = __vxfs_iget(ino, VXFS_SBI(sbp)->vsi_ilist);\n\tif (IS_ERR(vip)) {\n\t\tiget_failed(ip);\n\t\treturn ERR_CAST(vip);\n\t}\n\n\tvxfs_iinit(ip, vip);\n\n\tif (VXFS_ISIMMED(vip))\n\t\taops = &vxfs_immed_aops;\n\telse\n\t\taops = &vxfs_aops;\n\n\tif (S_ISREG(ip->i_mode)) {\n\t\tip->i_fop = &generic_ro_fops;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISDIR(ip->i_mode)) {\n\t\tip->i_op = &vxfs_dir_inode_ops;\n\t\tip->i_fop = &vxfs_dir_operations;\n\t\tip->i_mapping->a_ops = aops;\n\t} else if (S_ISLNK(ip->i_mode)) {\n\t\tif (!VXFS_ISIMMED(vip)) {\n\t\t\tip->i_op = &page_symlink_inode_operations;\n\t\t\tip->i_mapping->a_ops = &vxfs_aops;\n\t\t} else {\n\t\t\tip->i_op = &vxfs_immed_symlink_iops;\n\t\t\tvip->vii_immed.vi_immed[ip->i_size] = '\\0';\n\t\t}\n\t} else\n\t\tinit_special_inode(ip, ip->i_mode, old_decode_dev(vip->vii_rdev));\n\n\tunlock_new_inode(ip);\n\treturn ip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_inode_by_name",
          "args": [
            "dip",
            "dp"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_inode_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "174-189",
          "snippet": "static ino_t\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\n{\n\tstruct vxfs_direct\t\t*de;\n\tstruct page\t\t\t*pp;\n\tino_t\t\t\t\tino = 0;\n\n\tde = vxfs_find_entry(dip, dp, &pp);\n\tif (de) {\n\t\tino = de->d_ino;\n\t\tkunmap(pp);\n\t\tpage_cache_release(pp);\n\t}\n\t\n\treturn (ino);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic ino_t\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\n{\n\tstruct vxfs_direct\t\t*de;\n\tstruct page\t\t\t*pp;\n\tino_t\t\t\t\tino = 0;\n\n\tde = vxfs_find_entry(dip, dp, &pp);\n\tif (de) {\n\t\tino = de->d_ino;\n\t\tkunmap(pp);\n\t\tpage_cache_release(pp);\n\t}\n\t\n\treturn (ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic struct dentry *\nvxfs_lookup(struct inode *dip, struct dentry *dp, unsigned int flags)\n{\n\tstruct inode\t\t*ip = NULL;\n\tino_t\t\t\tino;\n\t\t\t \n\tif (dp->d_name.len > VXFS_NAMELEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t\t\t\t \n\tino = vxfs_inode_by_name(dip, dp);\n\tif (ino) {\n\t\tip = vxfs_iget(dip->i_sb, ino);\n\t\tif (IS_ERR(ip))\n\t\t\treturn ERR_CAST(ip);\n\t}\n\td_add(dp, ip);\n\treturn NULL;\n}"
  },
  {
    "function_name": "vxfs_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "174-189",
    "snippet": "static ino_t\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\n{\n\tstruct vxfs_direct\t\t*de;\n\tstruct page\t\t\t*pp;\n\tino_t\t\t\t\tino = 0;\n\n\tde = vxfs_find_entry(dip, dp, &pp);\n\tif (de) {\n\t\tino = de->d_ino;\n\t\tkunmap(pp);\n\t\tpage_cache_release(pp);\n\t}\n\t\n\treturn (ino);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "pp"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_find_entry",
          "args": [
            "dip",
            "dp",
            "&pp"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "113-160",
          "snippet": "static struct vxfs_direct *\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\n{\n\tu_long\t\t\t\tnpages, page, nblocks, pblocks, block;\n\tu_long\t\t\t\tbsize = ip->i_sb->s_blocksize;\n\tconst char\t\t\t*name = dp->d_name.name;\n\tint\t\t\t\tnamelen = dp->d_name.len;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(ip->i_sb);\n\t\n\tfor (page = 0; page < npages; page++) {\n\t\tcaddr_t\t\t\tkaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (caddr_t)page_address(pp);\n\n\t\tfor (block = 0; block <= nblocks && block <= pblocks; block++) {\n\t\t\tcaddr_t\t\t\tbaddr, limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\t\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)(baddr + VXFS_DIRBLKOV(dbp));\n\n\t\t\tfor (; (caddr_t)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vxfs_match(namelen, name, de)) {\n\t\t\t\t\t*ppp = pp;\n\t\t\t\t\treturn (de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvxfs_put_page(pp);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic struct vxfs_direct *\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\n{\n\tu_long\t\t\t\tnpages, page, nblocks, pblocks, block;\n\tu_long\t\t\t\tbsize = ip->i_sb->s_blocksize;\n\tconst char\t\t\t*name = dp->d_name.name;\n\tint\t\t\t\tnamelen = dp->d_name.len;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(ip->i_sb);\n\t\n\tfor (page = 0; page < npages; page++) {\n\t\tcaddr_t\t\t\tkaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (caddr_t)page_address(pp);\n\n\t\tfor (block = 0; block <= nblocks && block <= pblocks; block++) {\n\t\t\tcaddr_t\t\t\tbaddr, limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\t\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)(baddr + VXFS_DIRBLKOV(dbp));\n\n\t\t\tfor (; (caddr_t)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vxfs_match(namelen, name, de)) {\n\t\t\t\t\t*ppp = pp;\n\t\t\t\t\treturn (de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvxfs_put_page(pp);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic ino_t\nvxfs_inode_by_name(struct inode *dip, struct dentry *dp)\n{\n\tstruct vxfs_direct\t\t*de;\n\tstruct page\t\t\t*pp;\n\tino_t\t\t\t\tino = 0;\n\n\tde = vxfs_find_entry(dip, dp, &pp);\n\tif (de) {\n\t\tino = de->d_ino;\n\t\tkunmap(pp);\n\t\tpage_cache_release(pp);\n\t}\n\t\n\treturn (ino);\n}"
  },
  {
    "function_name": "vxfs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "113-160",
    "snippet": "static struct vxfs_direct *\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\n{\n\tu_long\t\t\t\tnpages, page, nblocks, pblocks, block;\n\tu_long\t\t\t\tbsize = ip->i_sb->s_blocksize;\n\tconst char\t\t\t*name = dp->d_name.name;\n\tint\t\t\t\tnamelen = dp->d_name.len;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(ip->i_sb);\n\t\n\tfor (page = 0; page < npages; page++) {\n\t\tcaddr_t\t\t\tkaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (caddr_t)page_address(pp);\n\n\t\tfor (block = 0; block <= nblocks && block <= pblocks; block++) {\n\t\t\tcaddr_t\t\t\tbaddr, limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\t\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)(baddr + VXFS_DIRBLKOV(dbp));\n\n\t\t\tfor (; (caddr_t)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vxfs_match(namelen, name, de)) {\n\t\t\t\t\t*ppp = pp;\n\t\t\t\t\treturn (de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvxfs_put_page(pp);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vxfs_put_page",
          "args": [
            "pp"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "49-54",
          "snippet": "inline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\ninline void\nvxfs_put_page(struct page *pp)\n{\n\tkunmap(pp);\n\tpage_cache_release(pp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "83-91",
          "snippet": "static inline int\nvxfs_match(int len, const char * const name, struct vxfs_direct *de)\n{\n\tif (len != de->d_namelen)\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline int\nvxfs_match(int len, const char * const name, struct vxfs_direct *de)\n{\n\tif (len != de->d_namelen)\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vxfs_next_entry",
          "args": [
            "de"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "93-97",
          "snippet": "static inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_DIRBLKOV",
          "args": [
            "dbp"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VXFS_DIRLEN",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pp"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pp"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vxfs_get_page",
          "args": [
            "ip->i_mapping",
            "page"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "vxfs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_subr.c",
          "lines": "67-87",
          "snippet": "struct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\tvxfs_readpage(struct file *, struct page *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic int\t\tvxfs_readpage(struct file *, struct page *);\n\nstruct page *\nvxfs_get_page(struct address_space *mapping, u_long n)\n{\n\tstruct page *\t\t\tpp;\n\n\tpp = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(pp)) {\n\t\tkmap(pp);\n\t\t/** if (!PageChecked(pp)) **/\n\t\t\t/** vxfs_check_page(pp); **/\n\t\tif (PageError(pp))\n\t\t\tgoto fail;\n\t}\n\t\n\treturn (pp);\n\t\t \nfail:\n\tvxfs_put_page(pp);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VXFS_BLOCK_PER_PAGE",
          "args": [
            "ip->i_sb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_blocks",
          "args": [
            "ip"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "dir_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "71-76",
          "snippet": "static inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "ip"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
          "lines": "65-69",
          "snippet": "static inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"vxfs_extern.h\"",
            "#include \"vxfs_inode.h\"",
            "#include \"vxfs_dir.h\"",
            "#include \"vxfs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/kernel.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic struct dentry *\tvxfs_lookup(struct inode *, struct dentry *, unsigned int);\n\nstatic struct vxfs_direct *\nvxfs_find_entry(struct inode *ip, struct dentry *dp, struct page **ppp)\n{\n\tu_long\t\t\t\tnpages, page, nblocks, pblocks, block;\n\tu_long\t\t\t\tbsize = ip->i_sb->s_blocksize;\n\tconst char\t\t\t*name = dp->d_name.name;\n\tint\t\t\t\tnamelen = dp->d_name.len;\n\n\tnpages = dir_pages(ip);\n\tnblocks = dir_blocks(ip);\n\tpblocks = VXFS_BLOCK_PER_PAGE(ip->i_sb);\n\t\n\tfor (page = 0; page < npages; page++) {\n\t\tcaddr_t\t\t\tkaddr;\n\t\tstruct page\t\t*pp;\n\n\t\tpp = vxfs_get_page(ip->i_mapping, page);\n\t\tif (IS_ERR(pp))\n\t\t\tcontinue;\n\t\tkaddr = (caddr_t)page_address(pp);\n\n\t\tfor (block = 0; block <= nblocks && block <= pblocks; block++) {\n\t\t\tcaddr_t\t\t\tbaddr, limit;\n\t\t\tstruct vxfs_dirblk\t*dbp;\n\t\t\tstruct vxfs_direct\t*de;\n\n\t\t\tbaddr = kaddr + (block * bsize);\n\t\t\tlimit = baddr + bsize - VXFS_DIRLEN(1);\n\t\t\t\n\t\t\tdbp = (struct vxfs_dirblk *)baddr;\n\t\t\tde = (struct vxfs_direct *)(baddr + VXFS_DIRBLKOV(dbp));\n\n\t\t\tfor (; (caddr_t)de <= limit; de = vxfs_next_entry(de)) {\n\t\t\t\tif (!de->d_reclen)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!de->d_ino)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (vxfs_match(namelen, name, de)) {\n\t\t\t\t\t*ppp = pp;\n\t\t\t\t\treturn (de);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvxfs_put_page(pp);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "vxfs_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "93-97",
    "snippet": "static inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline struct vxfs_direct *\nvxfs_next_entry(struct vxfs_direct *de)\n{\n\treturn ((struct vxfs_direct *)((char*)de + de->d_reclen));\n}"
  },
  {
    "function_name": "vxfs_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "83-91",
    "snippet": "static inline int\nvxfs_match(int len, const char * const name, struct vxfs_direct *de)\n{\n\tif (len != de->d_namelen)\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->d_name",
            "len"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline int\nvxfs_match(int len, const char * const name, struct vxfs_direct *de)\n{\n\tif (len != de->d_namelen)\n\t\treturn 0;\n\tif (!de->d_ino)\n\t\treturn 0;\n\treturn !memcmp(name, de->d_name, len);\n}"
  },
  {
    "function_name": "dir_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "71-76",
    "snippet": "static inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_blocks(struct inode *ip)\n{\n\tu_long\t\t\tbsize = ip->i_sb->s_blocksize;\n\treturn (ip->i_size + bsize - 1) & ~(bsize - 1);\n}"
  },
  {
    "function_name": "dir_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/freevxfs/vxfs_lookup.c",
    "lines": "65-69",
    "snippet": "static inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"vxfs_extern.h\"",
      "#include \"vxfs_inode.h\"",
      "#include \"vxfs_dir.h\"",
      "#include \"vxfs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/kernel.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vxfs_extern.h\"\n#include \"vxfs_inode.h\"\n#include \"vxfs_dir.h\"\n#include \"vxfs.h\"\n#include <linux/pagemap.h>\n#include <linux/kernel.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline u_long\ndir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
  }
]