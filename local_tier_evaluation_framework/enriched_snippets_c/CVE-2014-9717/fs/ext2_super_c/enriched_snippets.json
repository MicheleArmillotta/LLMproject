[
  {
    "function_name": "exit_ext2_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1569-1574",
    "snippet": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_ext2_xattr",
          "args": [],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ext2_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.h",
          "lines": "107-110",
          "snippet": "static inline void\nexit_ext2_xattr(void)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline void\nexit_ext2_xattr(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "210-218",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ext2_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&ext2_fs_type"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}"
  },
  {
    "function_name": "init_ext2_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1550-1567",
    "snippet": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit_ext2_xattr",
          "args": [],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "exit_ext2_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.h",
          "lines": "107-110",
          "snippet": "static inline void\nexit_ext2_xattr(void)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline void\nexit_ext2_xattr(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "210-218",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ext2_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&ext2_fs_type"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "198-208",
          "snippet": "static int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * ext2_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_ext2_xattr",
          "args": [],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "init_ext2_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.h",
          "lines": "101-105",
          "snippet": "static inline int\ninit_ext2_xattr(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline int\ninit_ext2_xattr(void)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct file_system_type ext2_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"ext2\",\n\t.mount\t\t= ext2_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_quota_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1487-1537",
    "snippet": "static ssize_t ext2_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != EXT2_BLOCK_SIZE(sb))\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "off+len-towrite"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "bh->b_page"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh->b_data+offset",
            "data",
            "tocopy"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE",
          "args": [
            "sb"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "1"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "765-776",
          "snippet": "int ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic ssize_t ext2_quota_write(struct super_block *sb, int type,\n\t\t\t\tconst char *data, size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t towrite = len;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\n\twhile (towrite > 0) {\n\t\ttocopy = sb->s_blocksize - offset < towrite ?\n\t\t\t\tsb->s_blocksize - offset : towrite;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 1);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tif (offset || tocopy != EXT2_BLOCK_SIZE(sb))\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\telse\n\t\t\tbh = sb_getblk(sb, tmp_bh.b_blocknr);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tlock_buffer(bh);\n\t\tmemcpy(bh->b_data+offset, data, tocopy);\n\t\tflush_dcache_page(bh->b_page);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t\toffset = 0;\n\t\ttowrite -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\nout:\n\tif (len == towrite)\n\t\treturn err;\n\tif (inode->i_size < off+len-towrite)\n\t\ti_size_write(inode, off+len-towrite);\n\tinode->i_version++;\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\treturn len - towrite;\n}"
  },
  {
    "function_name": "ext2_quota_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1442-1484",
    "snippet": "static ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "bh->b_data+offset",
            "tocopy"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "tmp_bh.b_blocknr"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "tocopy"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&tmp_bh"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_block",
          "args": [
            "inode",
            "blk",
            "&tmp_bh",
            "0"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "765-776",
          "snippet": "int ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nint ext2_get_block(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create)\n{\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint ret = ext2_get_blocks(inode, iblock, max_blocks,\n\t\t\t      bh_result, create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCK_SIZE_BITS",
          "args": [
            "sb"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_dqopt",
          "args": [
            "sb"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic ssize_t ext2_quota_read(struct super_block *sb, int type, char *data,\n\t\t\t       size_t len, loff_t off)\n{\n\tstruct inode *inode = sb_dqopt(sb)->files[type];\n\tsector_t blk = off >> EXT2_BLOCK_SIZE_BITS(sb);\n\tint err = 0;\n\tint offset = off & (sb->s_blocksize - 1);\n\tint tocopy;\n\tsize_t toread;\n\tstruct buffer_head tmp_bh;\n\tstruct buffer_head *bh;\n\tloff_t i_size = i_size_read(inode);\n\n\tif (off > i_size)\n\t\treturn 0;\n\tif (off+len > i_size)\n\t\tlen = i_size-off;\n\ttoread = len;\n\twhile (toread > 0) {\n\t\ttocopy = sb->s_blocksize - offset < toread ?\n\t\t\t\tsb->s_blocksize - offset : toread;\n\n\t\ttmp_bh.b_state = 0;\n\t\ttmp_bh.b_size = sb->s_blocksize;\n\t\terr = ext2_get_block(inode, blk, &tmp_bh, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (!buffer_mapped(&tmp_bh))\t/* A hole? */\n\t\t\tmemset(data, 0, tocopy);\n\t\telse {\n\t\t\tbh = sb_bread(sb, tmp_bh.b_blocknr);\n\t\t\tif (!bh)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(data, bh->b_data+offset, tocopy);\n\t\t\tbrelse(bh);\n\t\t}\n\t\toffset = 0;\n\t\ttoread -= tocopy;\n\t\tdata += tocopy;\n\t\tblk++;\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "ext2_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1430-1434",
    "snippet": "static struct dentry *ext2_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "ext2_fill_super"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\n\nstatic struct dentry *ext2_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);\n}"
  },
  {
    "function_name": "ext2_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1363-1428",
    "snippet": "static int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tspin_lock(&sbi->s_lock);\n\n\tif (test_opt (sb, MINIX_DF))\n\t\tsbi->s_overhead_last = 0;\n\telse if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long i, overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures). This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < sbi->s_groups_count; i++)\n\t\t\toverhead += ext2_bg_has_super(sb, i) +\n\t\t\t\text2_bg_num_gdb(sb, i);\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += (sbi->s_groups_count *\n\t\t\t     (2 + sbi->s_itb_per_group));\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT2_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = ext2_count_free_blocks(sb);\n\tes->s_free_blocks_count = cpu_to_le32(buf->f_bfree);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = ext2_count_free_inodes(sb);\n\tes->s_free_inodes_count = cpu_to_le32(buf->f_ffree);\n\tbuf->f_namelen = EXT2_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpup",
          "args": [
            "(void *)es->s_uuid + sizeof(u64)"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "buf->f_ffree"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "615-659",
          "snippet": "unsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_inodes_count"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "buf->f_bfree"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1446-1488",
          "snippet": "unsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_bg_num_gdb",
          "args": [
            "sb",
            "i"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_bg_num_gdb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1532-1535",
          "snippet": "unsigned long ext2_bg_num_gdb(struct super_block *sb, int group)\n{\n\treturn ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_bg_num_gdb(struct super_block *sb, int group)\n{\n\treturn ext2_bg_has_super(sb, group) ? EXT2_SB(sb)->s_gdb_count : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_bg_has_super",
          "args": [
            "sb",
            "i"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1515-1521",
          "snippet": "int ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nint ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "MINIX_DF"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_statfs (struct dentry * dentry, struct kstatfs * buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tu64 fsid;\n\n\tspin_lock(&sbi->s_lock);\n\n\tif (test_opt (sb, MINIX_DF))\n\t\tsbi->s_overhead_last = 0;\n\telse if (sbi->s_blocks_last != le32_to_cpu(es->s_blocks_count)) {\n\t\tunsigned long i, overhead = 0;\n\t\tsmp_rmb();\n\n\t\t/*\n\t\t * Compute the overhead (FS structures). This is constant\n\t\t * for a given filesystem unless the number of block groups\n\t\t * changes so we cache the previous value until it does.\n\t\t */\n\n\t\t/*\n\t\t * All of the blocks before first_data_block are\n\t\t * overhead\n\t\t */\n\t\toverhead = le32_to_cpu(es->s_first_data_block);\n\n\t\t/*\n\t\t * Add the overhead attributed to the superblock and\n\t\t * block group descriptors.  If the sparse superblocks\n\t\t * feature is turned on, then not all groups have this.\n\t\t */\n\t\tfor (i = 0; i < sbi->s_groups_count; i++)\n\t\t\toverhead += ext2_bg_has_super(sb, i) +\n\t\t\t\text2_bg_num_gdb(sb, i);\n\n\t\t/*\n\t\t * Every block group has an inode bitmap, a block\n\t\t * bitmap, and an inode table.\n\t\t */\n\t\toverhead += (sbi->s_groups_count *\n\t\t\t     (2 + sbi->s_itb_per_group));\n\t\tsbi->s_overhead_last = overhead;\n\t\tsmp_wmb();\n\t\tsbi->s_blocks_last = le32_to_cpu(es->s_blocks_count);\n\t}\n\n\tbuf->f_type = EXT2_SUPER_MAGIC;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = le32_to_cpu(es->s_blocks_count) - sbi->s_overhead_last;\n\tbuf->f_bfree = ext2_count_free_blocks(sb);\n\tes->s_free_blocks_count = cpu_to_le32(buf->f_bfree);\n\tbuf->f_bavail = buf->f_bfree - le32_to_cpu(es->s_r_blocks_count);\n\tif (buf->f_bfree < le32_to_cpu(es->s_r_blocks_count))\n\t\tbuf->f_bavail = 0;\n\tbuf->f_files = le32_to_cpu(es->s_inodes_count);\n\tbuf->f_ffree = ext2_count_free_inodes(sb);\n\tes->s_free_inodes_count = cpu_to_le32(buf->f_ffree);\n\tbuf->f_namelen = EXT2_NAME_LEN;\n\tfsid = le64_to_cpup((void *)es->s_uuid) ^\n\t       le64_to_cpup((void *)es->s_uuid + sizeof(u64));\n\tbuf->f_fsid.val[0] = fsid & 0xFFFFFFFFUL;\n\tbuf->f_fsid.val[1] = (fsid >> 32) & 0xFFFFFFFFUL;\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1267-1361",
    "snippet": "static int ext2_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_super_block * es;\n\tstruct ext2_mount_options old_opts;\n\tunsigned long old_sb_flags;\n\tint err;\n\n\tsync_filesystem(sb);\n\tspin_lock(&sbi->s_lock);\n\n\t/* Store the old options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_DAX) {\n\t\text2_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t \"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT2_MOUNT_DAX;\n\t}\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tspin_unlock(&sbi->s_lock);\n\t\treturn 0;\n\t}\n\tif (*flags & MS_RDONLY) {\n\t\tif (le16_to_cpu(es->s_state) & EXT2_VALID_FS ||\n\t\t    !(sbi->s_mount_state & EXT2_VALID_FS)) {\n\t\t\tspin_unlock(&sbi->s_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * OK, we are remounting a valid rw partition rdonly, so set\n\t\t * the rdonly flag and then mark the partition as valid again.\n\t\t */\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tes->s_mtime = cpu_to_le32(get_seconds());\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\terr = dquot_suspend(sb, -1);\n\t\tif (err < 0) {\n\t\t\tspin_lock(&sbi->s_lock);\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\text2_sync_super(sb, es, 1);\n\t} else {\n\t\t__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       ~EXT2_FEATURE_RO_COMPAT_SUPP);\n\t\tif (ret) {\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\",\n\t\t\t\tle32_to_cpu(ret));\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by e2fsck since we originally mounted the partition.)\n\t\t */\n\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\tif (!ext2_setup_super (sb, es, 0))\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\text2_write_super(sb);\n\n\t\tdquot_resume(sb, -1);\n\t}\n\n\treturn 0;\nrestore_opts:\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsb->s_flags = old_sb_flags;\n\tspin_unlock(&sbi->s_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_resume",
          "args": [
            "sb",
            "-1"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "2256-2289",
          "snippet": "int dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_resume(struct super_block *sb, int type)\n{\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *inode;\n\tint ret = 0, cnt;\n\tunsigned int flags;\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\tif (!sb_has_quota_suspended(sb, cnt)) {\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tinode = dqopt->files[cnt];\n\t\tdqopt->files[cnt] = NULL;\n\t\tspin_lock(&dq_state_lock);\n\t\tflags = dqopt->flags & dquot_state_flag(DQUOT_USAGE_ENABLED |\n\t\t\t\t\t\t\tDQUOT_LIMITS_ENABLED,\n\t\t\t\t\t\t\tcnt);\n\t\tdqopt->flags &= ~dquot_state_flag(DQUOT_STATE_FLAGS, cnt);\n\t\tspin_unlock(&dq_state_lock);\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t\tflags = dquot_generic_flag(flags, cnt);\n\t\tret = vfs_load_quota_inode(inode, cnt,\n\t\t\t\tdqopt->info[cnt].dqi_fmt_id, flags);\n\t\tiput(inode);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_write_super",
          "args": [
            "sb"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1261-1265",
          "snippet": "void ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_setup_super",
          "args": [
            "sb",
            "es",
            "0"
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "610-658",
          "snippet": "static int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_state"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\"",
            "le32_to_cpu(ret)"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ret"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT2_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_sync_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1185-1198",
          "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_suspend",
          "args": [
            "sb",
            "-1"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "sb"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "446-608",
          "snippet": "static int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct ext2_sb_info * sbi = EXT2_SB(sb);\n\tstruct ext2_super_block * es;\n\tstruct ext2_mount_options old_opts;\n\tunsigned long old_sb_flags;\n\tint err;\n\n\tsync_filesystem(sb);\n\tspin_lock(&sbi->s_lock);\n\n\t/* Store the old options */\n\told_sb_flags = sb->s_flags;\n\told_opts.s_mount_opt = sbi->s_mount_opt;\n\told_opts.s_resuid = sbi->s_resuid;\n\told_opts.s_resgid = sbi->s_resgid;\n\n\t/*\n\t * Allow the \"check\" option to be passed as a remount option.\n\t */\n\tif (!parse_options(data, sb)) {\n\t\terr = -EINVAL;\n\t\tgoto restore_opts;\n\t}\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((sbi->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ? MS_POSIXACL : 0);\n\n\tes = sbi->s_es;\n\tif ((sbi->s_mount_opt ^ old_opts.s_mount_opt) & EXT2_MOUNT_DAX) {\n\t\text2_msg(sb, KERN_WARNING, \"warning: refusing change of \"\n\t\t\t \"dax flag with busy inodes while remounting\");\n\t\tsbi->s_mount_opt ^= EXT2_MOUNT_DAX;\n\t}\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY)) {\n\t\tspin_unlock(&sbi->s_lock);\n\t\treturn 0;\n\t}\n\tif (*flags & MS_RDONLY) {\n\t\tif (le16_to_cpu(es->s_state) & EXT2_VALID_FS ||\n\t\t    !(sbi->s_mount_state & EXT2_VALID_FS)) {\n\t\t\tspin_unlock(&sbi->s_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * OK, we are remounting a valid rw partition rdonly, so set\n\t\t * the rdonly flag and then mark the partition as valid again.\n\t\t */\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tes->s_mtime = cpu_to_le32(get_seconds());\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\terr = dquot_suspend(sb, -1);\n\t\tif (err < 0) {\n\t\t\tspin_lock(&sbi->s_lock);\n\t\t\tgoto restore_opts;\n\t\t}\n\n\t\text2_sync_super(sb, es, 1);\n\t} else {\n\t\t__le32 ret = EXT2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t       ~EXT2_FEATURE_RO_COMPAT_SUPP);\n\t\tif (ret) {\n\t\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\t\"warning: couldn't remount RDWR because of \"\n\t\t\t\t\"unsupported optional features (%x).\",\n\t\t\t\tle32_to_cpu(ret));\n\t\t\terr = -EROFS;\n\t\t\tgoto restore_opts;\n\t\t}\n\t\t/*\n\t\t * Mounting a RDONLY partition read-write, so reread and\n\t\t * store the current valid flag.  (It may have been changed\n\t\t * by e2fsck since we originally mounted the partition.)\n\t\t */\n\t\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\t\tif (!ext2_setup_super (sb, es, 0))\n\t\t\tsb->s_flags &= ~MS_RDONLY;\n\t\tspin_unlock(&sbi->s_lock);\n\n\t\text2_write_super(sb);\n\n\t\tdquot_resume(sb, -1);\n\t}\n\n\treturn 0;\nrestore_opts:\n\tsbi->s_mount_opt = old_opts.s_mount_opt;\n\tsbi->s_resuid = old_opts.s_resuid;\n\tsbi->s_resgid = old_opts.s_resgid;\n\tsb->s_flags = old_sb_flags;\n\tspin_unlock(&sbi->s_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "ext2_write_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1261-1265",
    "snippet": "void ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1210-1229",
          "snippet": "static int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}"
  },
  {
    "function_name": "ext2_unfreeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1253-1259",
    "snippet": "static int ext2_unfreeze(struct super_block *sb)\n{\n\t/* Just write sb to clear EXT2_VALID_FS flag */\n\text2_write_super(sb);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_write_super",
          "args": [
            "sb"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1261-1265",
          "snippet": "void ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_unfreeze(struct super_block *sb)\n{\n\t/* Just write sb to clear EXT2_VALID_FS flag */\n\text2_write_super(sb);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1231-1251",
    "snippet": "static int ext2_freeze(struct super_block *sb)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\t/*\n\t * Open but unlinked files present? Keep EXT2_VALID_FS flag cleared\n\t * because we have unattached inodes and thus filesystem is not fully\n\t * consistent.\n\t */\n\tif (atomic_long_read(&sb->s_remove_count)) {\n\t\text2_sync_fs(sb, 1);\n\t\treturn 0;\n\t}\n\t/* Set EXT2_FS_VALID flag */\n\tspin_lock(&sbi->s_lock);\n\tsbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, sbi->s_es, 1);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_sync_super",
          "args": [
            "sb",
            "sbi->s_es",
            "1"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1185-1198",
          "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_sync_fs",
          "args": [
            "sb",
            "1"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1210-1229",
          "snippet": "static int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&sb->s_remove_count"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_freeze(struct super_block *sb)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\t/*\n\t * Open but unlinked files present? Keep EXT2_VALID_FS flag cleared\n\t * because we have unattached inodes and thus filesystem is not fully\n\t * consistent.\n\t */\n\tif (atomic_long_read(&sb->s_remove_count)) {\n\t\text2_sync_fs(sb, 1);\n\t\treturn 0;\n\t}\n\t/* Set EXT2_FS_VALID flag */\n\tspin_lock(&sbi->s_lock);\n\tsbi->s_es->s_state = cpu_to_le16(sbi->s_mount_state);\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, sbi->s_es, 1);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1210-1229",
    "snippet": "static int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
      "static int ext2_sync_fs(struct super_block *sb, int wait);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_sync_super",
          "args": [
            "sb",
            "es",
            "wait"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1185-1198",
          "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "~EXT2_VALID_FS"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"setting valid to 0\\n\""
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT2_VALID_FS"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_writeback_dquots",
          "args": [
            "sb",
            "-1"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_writeback_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "605-652",
          "snippet": "int dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_writeback_dquots(struct super_block *sb, int type)\n{\n\tstruct list_head *dirty;\n\tstruct dquot *dquot;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tint cnt;\n\tint err, ret = 0;\n\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_active(sb, cnt))\n\t\t\tcontinue;\n\t\tspin_lock(&dq_list_lock);\n\t\tdirty = &dqopt->info[cnt].dqi_dirty_list;\n\t\twhile (!list_empty(dirty)) {\n\t\t\tdquot = list_first_entry(dirty, struct dquot,\n\t\t\t\t\t\t dq_dirty);\n\t\t\t/* Dirty and inactive can be only bad dquot... */\n\t\t\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\t\t\tclear_dquot_dirty(dquot);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Now we have active dquot from which someone is\n \t\t\t * holding reference so we can safely just increase\n\t\t\t * use count */\n\t\t\tdqgrab(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tdqstats_inc(DQST_LOOKUPS);\n\t\t\terr = sb->dq_op->write_dquot(dquot);\n\t\t\tif (!ret && err)\n\t\t\t\tret = err;\n\t\t\tdqput(dquot);\n\t\t\tspin_lock(&dq_list_lock);\n\t\t}\n\t\tspin_unlock(&dq_list_lock);\n\t}\n\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif ((cnt == type || type == -1) && sb_has_quota_active(sb, cnt)\n\t\t    && info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\tdqstats_inc(DQST_SYNCS);\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\t/*\n\t * Write quota structures to quota file, sync_blockdev() will write\n\t * them to disk later\n\t */\n\tdquot_writeback_dquots(sb, -1);\n\n\tspin_lock(&sbi->s_lock);\n\tif (es->s_state & cpu_to_le16(EXT2_VALID_FS)) {\n\t\text2_debug(\"setting valid to 0\\n\");\n\t\tes->s_state &= cpu_to_le16(~EXT2_VALID_FS);\n\t}\n\tspin_unlock(&sbi->s_lock);\n\text2_sync_super(sb, es, wait);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext2_sync_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1185-1198",
    "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
      "static int ext2_sync_fs(struct super_block *sb, int wait);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "EXT2_SB(sb)->s_sbh"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "EXT2_SB(sb)->s_sbh"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "get_seconds()"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext2_count_free_inodes(sb)"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "615-659",
          "snippet": "unsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "ext2_count_free_blocks(sb)"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1446-1488",
          "snippet": "unsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&EXT2_SB(sb)->s_lock"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_clear_super_error",
          "args": [
            "sb"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_clear_super_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1165-1183",
          "snippet": "static void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
  },
  {
    "function_name": "ext2_clear_super_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "1165-1183",
    "snippet": "static void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "sbh"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"previous I/O error to superblock detected\\n\""
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "sbh"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_clear_super_error(struct super_block *sb)\n{\n\tstruct buffer_head *sbh = EXT2_SB(sb)->s_sbh;\n\n\tif (buffer_write_io_error(sbh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\text2_msg(sb, KERN_ERR,\n\t\t       \"previous I/O error to superblock detected\\n\");\n\t\tclear_buffer_write_io_error(sbh);\n\t\tset_buffer_uptodate(sbh);\n\t}\n}"
  },
  {
    "function_name": "ext2_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "777-1163",
    "snippet": "static int ext2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext2_sb_info * sbi;\n\tstruct ext2_super_block * es;\n\tstruct inode *root;\n\tunsigned long block;\n\tunsigned long sb_block = get_sb_block(&data);\n\tunsigned long logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long def_mount_opts;\n\tlong ret = -EINVAL;\n\tint blocksize = BLOCK_SIZE;\n\tint db_count;\n\tint i, j;\n\t__le32 features;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto failed;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tspin_lock_init(&sbi->s_lock);\n\n\t/*\n\t * See what the current blocksize for the device is, and\n\t * use that as the blocksize.  Otherwise (or if the blocksize\n\t * is smaller than the default) use the default.\n\t * This is important for devices that have a hardware\n\t * sectorsize that is larger than the default.\n\t */\n\tblocksize = sb_min_blocksize(sb, BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto failed_sbi;\n\t}\n\n\t/*\n\t * If the superblock doesn't start on a hardware sector boundary,\n\t * calculate the offset.  \n\t */\n\tif (blocksize != BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto failed_sbi;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext2 macro-instructions depend on its value\n\t */\n\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT2_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT2_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT2_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (def_mount_opts & EXT2_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (def_mount_opts & EXT2_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\t\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\t\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options((char *) data, sb))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?\n\t\t MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&\n\t    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t\tle32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY) &&\n\t    (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){\n\t\text2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t       le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* If the blocksize doesn't match, re-read the thing.. */\n\tif (sb->s_blocksize != blocksize) {\n\t\tbrelse(bh);\n\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto failed_sbi;\n\t\t}\n\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif(!bh) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: couldn't read\"\n\t\t\t\t\"superblock on 2nd try\");\n\t\t\tgoto failed_sbi;\n\t\t}\n\t\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);\n\tsb->s_max_links = EXT2_LINK_MAX;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||\n\t\t    !is_power_of_2(sbi->s_inode_size) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (sbi->s_frag_size == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_frags_per_block = sb->s_blocksize / sbi->s_frag_size;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tif (EXT2_INODE_SIZE(sb) == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize /\n\t\t\t\t\tsizeof (struct ext2_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits =\n\t\tilog2 (EXT2_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits =\n\t\tilog2 (EXT2_DESC_PER_BLOCK(sb));\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\tif (sb->s_blocksize != bh->b_size) {\n\t\tif (!silent)\n\t\t\text2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != sbi->s_frag_size) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: fragsize %lu != blocksize %lu\"\n\t\t\t\"(not supported yet)\",\n\t\t\tsbi->s_frag_size, sb->s_blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT2_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext2;\n \tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n \t\t\t\tle32_to_cpu(es->s_first_data_block) - 1)\n \t\t\t\t\t/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT2_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\tsbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);\n\tif (!sbi->s_debts) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount_group_desc;\n\t}\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbrelse (sbi->s_group_desc[j]);\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unable to read group descriptors\");\n\t\t\tgoto failed_mount_group_desc;\n\t\t}\n\t}\n\tif (!ext2_check_descriptors (sb)) {\n\t\text2_msg(sb, KERN_ERR, \"group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/*\n\t * Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler.\n\t */\n\tsbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text2_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\t\text2_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text2_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text2_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text2_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext2_sops;\n\tsb->s_export_op = &ext2_export_ops;\n\tsb->s_xattr = ext2_xattr_handlers;\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\troot = ext2_iget(sb, EXT2_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text2_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting ext3 filesystem as ext2\");\n\tif (ext2_setup_super (sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\text2_write_super(sb);\n\treturn 0;\n\ncantfind_ext2:\n\tif (!silent)\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: can't find an ext2 filesystem on dev %s.\",\n\t\t\tsb->s_id);\n\tgoto failed_mount;\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\nfailed_mount_group_desc:\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\nfailed_mount:\n\tbrelse(bh);\nfailed_sbi:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nfailed:\n\treturn ret;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);",
      "static const struct super_operations ext2_sops = {\n\t.alloc_inode\t= ext2_alloc_inode,\n\t.destroy_inode\t= ext2_destroy_inode,\n\t.write_inode\t= ext2_write_inode,\n\t.evict_inode\t= ext2_evict_inode,\n\t.put_super\t= ext2_put_super,\n\t.sync_fs\t= ext2_sync_fs,\n\t.freeze_fs\t= ext2_freeze,\n\t.unfreeze_fs\t= ext2_unfreeze,\n\t.statfs\t\t= ext2_statfs,\n\t.remount_fs\t= ext2_remount,\n\t.show_options\t= ext2_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext2_quota_read,\n\t.quota_write\t= ext2_quota_write,\n\t.get_dquots\t= ext2_get_dquots,\n#endif\n};",
      "static const struct export_operations ext2_export_ops = {\n\t.fh_to_dentry = ext2_fh_to_dentry,\n\t.fh_to_parent = ext2_fh_to_parent,\n\t.get_parent = ext2_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_debts"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_ERR",
            "\"error: can't find an ext2 filesystem on dev %s.\"",
            "sb->s_id"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_write_super",
          "args": [
            "sb"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_write_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1261-1265",
          "snippet": "void ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_write_super(struct super_block *sb)\n{\n\tif (!(sb->s_flags & MS_RDONLY))\n\t\text2_sync_fs(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_setup_super",
          "args": [
            "sb",
            "es",
            "sb->s_flags & MS_RDONLY"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_setup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "610-658",
          "snippet": "static int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_COMPAT_HAS_JOURNAL"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "root->i_mode"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_iget",
          "args": [
            "sb",
            "EXT2_ROOT_INO"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1312-1437",
          "snippet": "struct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "const struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nconst struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nconst struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstruct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_dirs_counter",
            "ext2_count_dirs(sb)",
            "GFP_KERNEL"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_dirs",
          "args": [
            "sb"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "662-674",
          "snippet": "unsigned long ext2_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_dirs (struct super_block * sb)\n{\n\tunsigned long count = 0;\n\tint i;\n\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tcount += le16_to_cpu(gdp->bg_used_dirs_count);\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeinodes_counter",
            "ext2_count_free_inodes(sb)",
            "GFP_KERNEL"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ialloc.c",
          "lines": "615-659",
          "snippet": "unsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <linux/random.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/sched.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <linux/random.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n#include <linux/sched.h>\n#include <linux/quotaops.h>\n\nunsigned long ext2_count_free_inodes (struct super_block * sb)\n{\n\tstruct ext2_group_desc *desc;\n\tunsigned long desc_count = 0;\n\tint i;\t\n\n#ifdef EXT2FS_DEBUG\n\tstruct ext2_super_block *es;\n\tunsigned long bitmap_count = 0;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT2_SB(sb)->s_es;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tunsigned x;\n\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_inode_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\n\t\tx = ext2_count_free(bitmap_bh, EXT2_INODES_PER_GROUP(sb) / 8);\n\t\tprintk(\"group %d: stored = %d, counted = %u\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_inodes_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(unsigned long)\n\t\tpercpu_counter_read(&EXT2_SB(sb)->s_freeinodes_counter),\n\t\tdesc_count, bitmap_count);\n\treturn desc_count;\n#else\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_inodes_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&sbi->s_freeblocks_counter",
            "ext2_count_free_blocks(sb)",
            "GFP_KERNEL"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1446-1488",
          "snippet": "unsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nunsigned long ext2_count_free_blocks (struct super_block * sb)\n{\n\tstruct ext2_group_desc * desc;\n\tunsigned long desc_count = 0;\n\tint i;\n#ifdef EXT2FS_DEBUG\n\tunsigned long bitmap_count, x;\n\tstruct ext2_super_block *es;\n\n\tes = EXT2_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tdesc = NULL;\n\tfor (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n\t\tstruct buffer_head *bitmap_bh;\n\t\tdesc = ext2_get_group_desc (sb, i, NULL);\n\t\tif (!desc)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (!bitmap_bh)\n\t\t\tcontinue;\n\t\t\n\t\tx = ext2_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk (\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(desc->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t\tbrelse(bitmap_bh);\n\t}\n\tprintk(\"ext2_count_free_blocks: stored = %lu, computed = %lu, %lu\\n\",\n\t\t(long)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n        for (i = 0; i < EXT2_SB(sb)->s_groups_count; i++) {\n                desc = ext2_get_group_desc (sb, i, NULL);\n                if (!desc)\n                        continue;\n                desc_count += le16_to_cpu(desc->bg_free_blocks_count);\n\t}\n\treturn desc_count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_rsv_window_add",
          "args": [
            "sb",
            "&sbi->s_rsv_window_head"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_rsv_window_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "329-357",
          "snippet": "void ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nvoid ext2_rsv_window_add(struct super_block *sb,\n\t\t    struct ext2_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT2_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text2_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext2_reserve_window_node *this;\n\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext2_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_rsv_window_lock"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&sbi->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_check_descriptors",
          "args": [
            "sb"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_check_descriptors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "660-708",
          "snippet": "static int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "descriptor_loc",
          "args": [
            "sb",
            "logic_sb_block",
            "i"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "descriptor_loc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "757-775",
          "snippet": "static unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "sbi->s_groups_count",
            "sizeof(*sbi->s_debts)",
            "GFP_KERNEL"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bgl_lock_init",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "db_count * sizeof (struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT2_DESC_PER_BLOCK(sb)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "EXT2_ADDR_PER_BLOCK(sb)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_ADDR_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_state"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_INODE_SIZE",
          "args": [
            "sb"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_power_of_2",
          "args": [
            "sbi->s_inode_size"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_max_size",
          "args": [
            "sb->s_blocksize_bits"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_max_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "715-755",
          "snippet": "static loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_remount (struct super_block * sb, int * flags, char * data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\n\nstatic loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT2_SUPER_MAGIC"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "logic_sb_block"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "blocksize"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT2_FEATURE_RO_COMPAT_SUPP"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~EXT2_FEATURE_INCOMPAT_SUPP"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_COMPAT_FEATURE",
          "args": [
            "sb",
            "~0U"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "sb"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "446-608",
          "snippet": "static int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);",
            "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "RESERVATION"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resgid)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le16_to_cpu(es->s_def_resuid)"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "logic_sb_block"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_min_blocksize",
          "args": [
            "sb",
            "BLOCK_SIZE"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "sb_min_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "129-135",
          "snippet": "int sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_min_blocksize(struct super_block *sb, int size)\n{\n\tint minsize = bdev_logical_block_size(sb->s_bdev);\n\tif (size < minsize)\n\t\tsize = minsize;\n\treturn sb_set_blocksize(sb, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct blockgroup_lock)",
            "GFP_KERNEL"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sb_block",
          "args": [
            "&data"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "get_sb_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "382-400",
          "snippet": "static unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\nstatic const struct super_operations ext2_sops = {\n\t.alloc_inode\t= ext2_alloc_inode,\n\t.destroy_inode\t= ext2_destroy_inode,\n\t.write_inode\t= ext2_write_inode,\n\t.evict_inode\t= ext2_evict_inode,\n\t.put_super\t= ext2_put_super,\n\t.sync_fs\t= ext2_sync_fs,\n\t.freeze_fs\t= ext2_freeze,\n\t.unfreeze_fs\t= ext2_unfreeze,\n\t.statfs\t\t= ext2_statfs,\n\t.remount_fs\t= ext2_remount,\n\t.show_options\t= ext2_show_options,\n#ifdef CONFIG_QUOTA\n\t.quota_read\t= ext2_quota_read,\n\t.quota_write\t= ext2_quota_write,\n\t.get_dquots\t= ext2_get_dquots,\n#endif\n};\nstatic const struct export_operations ext2_export_ops = {\n\t.fh_to_dentry = ext2_fh_to_dentry,\n\t.fh_to_parent = ext2_fh_to_parent,\n\t.get_parent = ext2_get_parent,\n};\n\nstatic int ext2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head * bh;\n\tstruct ext2_sb_info * sbi;\n\tstruct ext2_super_block * es;\n\tstruct inode *root;\n\tunsigned long block;\n\tunsigned long sb_block = get_sb_block(&data);\n\tunsigned long logic_sb_block;\n\tunsigned long offset = 0;\n\tunsigned long def_mount_opts;\n\tlong ret = -EINVAL;\n\tint blocksize = BLOCK_SIZE;\n\tint db_count;\n\tint i, j;\n\t__le32 features;\n\tint err;\n\n\terr = -ENOMEM;\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\tgoto failed;\n\n\tsbi->s_blockgroup_lock =\n\t\tkzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n\tif (!sbi->s_blockgroup_lock) {\n\t\tkfree(sbi);\n\t\tgoto failed;\n\t}\n\tsb->s_fs_info = sbi;\n\tsbi->s_sb_block = sb_block;\n\n\tspin_lock_init(&sbi->s_lock);\n\n\t/*\n\t * See what the current blocksize for the device is, and\n\t * use that as the blocksize.  Otherwise (or if the blocksize\n\t * is smaller than the default) use the default.\n\t * This is important for devices that have a hardware\n\t * sectorsize that is larger than the default.\n\t */\n\tblocksize = sb_min_blocksize(sb, BLOCK_SIZE);\n\tif (!blocksize) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n\t\tgoto failed_sbi;\n\t}\n\n\t/*\n\t * If the superblock doesn't start on a hardware sector boundary,\n\t * calculate the offset.  \n\t */\n\tif (blocksize != BLOCK_SIZE) {\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t} else {\n\t\tlogic_sb_block = sb_block;\n\t}\n\n\tif (!(bh = sb_bread(sb, logic_sb_block))) {\n\t\text2_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n\t\tgoto failed_sbi;\n\t}\n\t/*\n\t * Note: s_es must be initialized as soon as possible because\n\t *       some ext2 macro-instructions depend on its value\n\t */\n\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\tsbi->s_es = es;\n\tsb->s_magic = le16_to_cpu(es->s_magic);\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\t/* Set defaults before we parse the mount options */\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\tif (def_mount_opts & EXT2_DEFM_DEBUG)\n\t\tset_opt(sbi->s_mount_opt, DEBUG);\n\tif (def_mount_opts & EXT2_DEFM_BSDGROUPS)\n\t\tset_opt(sbi->s_mount_opt, GRPID);\n\tif (def_mount_opts & EXT2_DEFM_UID16)\n\t\tset_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (def_mount_opts & EXT2_DEFM_XATTR_USER)\n\t\tset_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (def_mount_opts & EXT2_DEFM_ACL)\n\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n\t\n\tif (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_PANIC)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_PANIC);\n\telse if (le16_to_cpu(sbi->s_es->s_errors) == EXT2_ERRORS_CONTINUE)\n\t\tset_opt(sbi->s_mount_opt, ERRORS_CONT);\n\telse\n\t\tset_opt(sbi->s_mount_opt, ERRORS_RO);\n\n\tsbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n\tsbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n\t\n\tset_opt(sbi->s_mount_opt, RESERVATION);\n\n\tif (!parse_options((char *) data, sb))\n\t\tgoto failed_mount;\n\n\tsb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n\t\t((EXT2_SB(sb)->s_mount_opt & EXT2_MOUNT_POSIX_ACL) ?\n\t\t MS_POSIXACL : 0);\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV &&\n\t    (EXT2_HAS_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n\t     EXT2_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: feature flags set on rev 0 fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\t/*\n\t * Check feature flags regardless of the revision level, since we\n\t * previously didn't change the revision level when setting the flags,\n\t * so there is a chance incompat flags are set on a rev 0 filesystem.\n\t */\n\tfeatures = EXT2_HAS_INCOMPAT_FEATURE(sb, ~EXT2_FEATURE_INCOMPAT_SUPP);\n\tif (features) {\n\t\text2_msg(sb, KERN_ERR,\t\"error: couldn't mount because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t\tle32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\tif (!(sb->s_flags & MS_RDONLY) &&\n\t    (features = EXT2_HAS_RO_COMPAT_FEATURE(sb, ~EXT2_FEATURE_RO_COMPAT_SUPP))){\n\t\text2_msg(sb, KERN_ERR, \"error: couldn't mount RDWR because of \"\n\t\t       \"unsupported optional features (%x)\",\n\t\t       le32_to_cpu(features));\n\t\tgoto failed_mount;\n\t}\n\n\tblocksize = BLOCK_SIZE << le32_to_cpu(sbi->s_es->s_log_block_size);\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX) {\n\t\tif (blocksize != PAGE_SIZE) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: unsupported blocksize for dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t\tif (!sb->s_bdev->bd_disk->fops->direct_access) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\t\"error: device does not support dax\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\t/* If the blocksize doesn't match, re-read the thing.. */\n\tif (sb->s_blocksize != blocksize) {\n\t\tbrelse(bh);\n\n\t\tif (!sb_set_blocksize(sb, blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: bad blocksize %d\", blocksize);\n\t\t\tgoto failed_sbi;\n\t\t}\n\n\t\tlogic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;\n\t\toffset = (sb_block*BLOCK_SIZE) % blocksize;\n\t\tbh = sb_bread(sb, logic_sb_block);\n\t\tif(!bh) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: couldn't read\"\n\t\t\t\t\"superblock on 2nd try\");\n\t\t\tgoto failed_sbi;\n\t\t}\n\t\tes = (struct ext2_super_block *) (((char *)bh->b_data) + offset);\n\t\tsbi->s_es = es;\n\t\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\t\text2_msg(sb, KERN_ERR, \"error: magic mismatch\");\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsb->s_maxbytes = ext2_max_size(sb->s_blocksize_bits);\n\tsb->s_max_links = EXT2_LINK_MAX;\n\n\tif (le32_to_cpu(es->s_rev_level) == EXT2_GOOD_OLD_REV) {\n\t\tsbi->s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;\n\t\tsbi->s_first_ino = EXT2_GOOD_OLD_FIRST_INO;\n\t} else {\n\t\tsbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n\t\tsbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n\t\tif ((sbi->s_inode_size < EXT2_GOOD_OLD_INODE_SIZE) ||\n\t\t    !is_power_of_2(sbi->s_inode_size) ||\n\t\t    (sbi->s_inode_size > blocksize)) {\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unsupported inode size: %d\",\n\t\t\t\tsbi->s_inode_size);\n\t\t\tgoto failed_mount;\n\t\t}\n\t}\n\n\tsbi->s_frag_size = EXT2_MIN_FRAG_SIZE <<\n\t\t\t\t   le32_to_cpu(es->s_log_frag_size);\n\tif (sbi->s_frag_size == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_frags_per_block = sb->s_blocksize / sbi->s_frag_size;\n\n\tsbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n\tsbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n\tsbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n\n\tif (EXT2_INODE_SIZE(sb) == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_inodes_per_block = sb->s_blocksize / EXT2_INODE_SIZE(sb);\n\tif (sbi->s_inodes_per_block == 0 || sbi->s_inodes_per_group == 0)\n\t\tgoto cantfind_ext2;\n\tsbi->s_itb_per_group = sbi->s_inodes_per_group /\n\t\t\t\t\tsbi->s_inodes_per_block;\n\tsbi->s_desc_per_block = sb->s_blocksize /\n\t\t\t\t\tsizeof (struct ext2_group_desc);\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = le16_to_cpu(es->s_state);\n\tsbi->s_addr_per_block_bits =\n\t\tilog2 (EXT2_ADDR_PER_BLOCK(sb));\n\tsbi->s_desc_per_block_bits =\n\t\tilog2 (EXT2_DESC_PER_BLOCK(sb));\n\n\tif (sb->s_magic != EXT2_SUPER_MAGIC)\n\t\tgoto cantfind_ext2;\n\n\tif (sb->s_blocksize != bh->b_size) {\n\t\tif (!silent)\n\t\t\text2_msg(sb, KERN_ERR, \"error: unsupported blocksize\");\n\t\tgoto failed_mount;\n\t}\n\n\tif (sb->s_blocksize != sbi->s_frag_size) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: fragsize %lu != blocksize %lu\"\n\t\t\t\"(not supported yet)\",\n\t\t\tsbi->s_frag_size, sb->s_blocksize);\n\t\tgoto failed_mount;\n\t}\n\n\tif (sbi->s_blocks_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #blocks per group too big: %lu\",\n\t\t\tsbi->s_blocks_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_frags_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #fragments per group too big: %lu\",\n\t\t\tsbi->s_frags_per_group);\n\t\tgoto failed_mount;\n\t}\n\tif (sbi->s_inodes_per_group > sb->s_blocksize * 8) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: #inodes per group too big: %lu\",\n\t\t\tsbi->s_inodes_per_group);\n\t\tgoto failed_mount;\n\t}\n\n\tif (EXT2_BLOCKS_PER_GROUP(sb) == 0)\n\t\tgoto cantfind_ext2;\n \tsbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n \t\t\t\tle32_to_cpu(es->s_first_data_block) - 1)\n \t\t\t\t\t/ EXT2_BLOCKS_PER_GROUP(sb)) + 1;\n\tdb_count = (sbi->s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /\n\t\t   EXT2_DESC_PER_BLOCK(sb);\n\tsbi->s_group_desc = kmalloc (db_count * sizeof (struct buffer_head *), GFP_KERNEL);\n\tif (sbi->s_group_desc == NULL) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount;\n\t}\n\tbgl_lock_init(sbi->s_blockgroup_lock);\n\tsbi->s_debts = kcalloc(sbi->s_groups_count, sizeof(*sbi->s_debts), GFP_KERNEL);\n\tif (!sbi->s_debts) {\n\t\text2_msg(sb, KERN_ERR, \"error: not enough memory\");\n\t\tgoto failed_mount_group_desc;\n\t}\n\tfor (i = 0; i < db_count; i++) {\n\t\tblock = descriptor_loc(sb, logic_sb_block, i);\n\t\tsbi->s_group_desc[i] = sb_bread(sb, block);\n\t\tif (!sbi->s_group_desc[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tbrelse (sbi->s_group_desc[j]);\n\t\t\text2_msg(sb, KERN_ERR,\n\t\t\t\t\"error: unable to read group descriptors\");\n\t\t\tgoto failed_mount_group_desc;\n\t\t}\n\t}\n\tif (!ext2_check_descriptors (sb)) {\n\t\text2_msg(sb, KERN_ERR, \"group descriptors corrupted\");\n\t\tgoto failed_mount2;\n\t}\n\tsbi->s_gdb_count = db_count;\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\t/* per fileystem reservation list head & lock */\n\tspin_lock_init(&sbi->s_rsv_window_lock);\n\tsbi->s_rsv_window_root = RB_ROOT;\n\t/*\n\t * Add a single, static dummy reservation to the start of the\n\t * reservation window list --- it gives us a placeholder for\n\t * append-at-start-of-list which makes the allocation logic\n\t * _much_ simpler.\n\t */\n\tsbi->s_rsv_window_head.rsv_start = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_end = EXT2_RESERVE_WINDOW_NOT_ALLOCATED;\n\tsbi->s_rsv_window_head.rsv_alloc_hit = 0;\n\tsbi->s_rsv_window_head.rsv_goal_size = 0;\n\text2_rsv_window_add(sb, &sbi->s_rsv_window_head);\n\n\terr = percpu_counter_init(&sbi->s_freeblocks_counter,\n\t\t\t\text2_count_free_blocks(sb), GFP_KERNEL);\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_freeinodes_counter,\n\t\t\t\text2_count_free_inodes(sb), GFP_KERNEL);\n\t}\n\tif (!err) {\n\t\terr = percpu_counter_init(&sbi->s_dirs_counter,\n\t\t\t\text2_count_dirs(sb), GFP_KERNEL);\n\t}\n\tif (err) {\n\t\text2_msg(sb, KERN_ERR, \"error: insufficient memory\");\n\t\tgoto failed_mount3;\n\t}\n\t/*\n\t * set up enough so that it can read an inode\n\t */\n\tsb->s_op = &ext2_sops;\n\tsb->s_export_op = &ext2_export_ops;\n\tsb->s_xattr = ext2_xattr_handlers;\n\n#ifdef CONFIG_QUOTA\n\tsb->dq_op = &dquot_operations;\n\tsb->s_qcop = &dquot_quotactl_ops;\n\tsb->s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP;\n#endif\n\n\troot = ext2_iget(sb, EXT2_ROOT_INO);\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto failed_mount3;\n\t}\n\tif (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n\t\tiput(root);\n\t\text2_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n\t\tgoto failed_mount3;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\text2_msg(sb, KERN_ERR, \"error: get root inode failed\");\n\t\tret = -ENOMEM;\n\t\tgoto failed_mount3;\n\t}\n\tif (EXT2_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting ext3 filesystem as ext2\");\n\tif (ext2_setup_super (sb, es, sb->s_flags & MS_RDONLY))\n\t\tsb->s_flags |= MS_RDONLY;\n\text2_write_super(sb);\n\treturn 0;\n\ncantfind_ext2:\n\tif (!silent)\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: can't find an ext2 filesystem on dev %s.\",\n\t\t\tsb->s_id);\n\tgoto failed_mount;\nfailed_mount3:\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\nfailed_mount2:\n\tfor (i = 0; i < db_count; i++)\n\t\tbrelse(sbi->s_group_desc[i]);\nfailed_mount_group_desc:\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\nfailed_mount:\n\tbrelse(bh);\nfailed_sbi:\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\nfailed:\n\treturn ret;\n}"
  },
  {
    "function_name": "descriptor_loc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "757-775",
    "snippet": "static unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "bg"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_bg_has_super",
          "args": [
            "sb",
            "bg"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "1515-1521",
          "snippet": "int ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nint ext2_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT2_HAS_RO_COMPAT_FEATURE(sb,EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)&&\n\t    !ext2_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT2_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_first_meta_bg"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic unsigned long descriptor_loc(struct super_block *sb,\n\t\t\t\t    unsigned long logic_sb_block,\n\t\t\t\t    int nr)\n{\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tunsigned long bg, first_meta_bg;\n\tint has_super = 0;\n\t\n\tfirst_meta_bg = le32_to_cpu(sbi->s_es->s_first_meta_bg);\n\n\tif (!EXT2_HAS_INCOMPAT_FEATURE(sb, EXT2_FEATURE_INCOMPAT_META_BG) ||\n\t    nr < first_meta_bg)\n\t\treturn (logic_sb_block + nr + 1);\n\tbg = sbi->s_desc_per_block * nr;\n\tif (ext2_bg_has_super(sb, bg))\n\t\thas_super = 1;\n\n\treturn ext2_group_first_block_no(sb, bg) + has_super;\n}"
  },
  {
    "function_name": "ext2_max_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "715-755",
    "snippet": "static loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\n\nstatic loff_t ext2_max_size(int bits)\n{\n\tloff_t res = EXT2_NDIR_BLOCKS;\n\tint meta_blocks;\n\tloff_t upper_limit;\n\n\t/* This is calculated to be the largest file size for a\n\t * dense, file such that the total number of\n\t * sectors in the file, including data and all indirect blocks,\n\t * does not exceed 2^32 -1\n\t * __u32 i_blocks representing the total number of\n\t * 512 bytes blocks of the file\n\t */\n\tupper_limit = (1LL << 32) - 1;\n\n\t/* total blocks in file system block size */\n\tupper_limit >>= (bits - 9);\n\n\n\t/* indirect blocks */\n\tmeta_blocks = 1;\n\t/* double indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2));\n\t/* tripple indirect blocks */\n\tmeta_blocks += 1 + (1LL << (bits-2)) + (1LL << (2*(bits-2)));\n\n\tupper_limit -= meta_blocks;\n\tupper_limit <<= bits;\n\n\tres += 1LL << (bits-2);\n\tres += 1LL << (2*(bits-2));\n\tres += 1LL << (3*(bits-2));\n\tres <<= bits;\n\tif (res > upper_limit)\n\t\tres = upper_limit;\n\n\tif (res > MAX_LFS_FILESIZE)\n\t\tres = MAX_LFS_FILESIZE;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ext2_check_descriptors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "660-708",
    "snippet": "static int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_error",
          "args": [
            "sb",
            "\"ext2_check_descriptors\"",
            "\"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\"",
            "i",
            "(unsigned long) le32_to_cpu(gdp->bg_inode_table)"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "47-80",
          "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gdp->bg_inode_table"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_group_first_block_no",
          "args": [
            "sb",
            "i"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/balloc.c",
          "lines": "39-71",
          "snippet": "struct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include \"ext2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include \"ext2.h\"\n\nstruct ext2_group_desc * ext2_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext2_group_desc * desc;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\n\tgroup_desc = block_group >> EXT2_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT2_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text2_error (sb, \"ext2_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext2_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_debug",
          "args": [
            "\"Checking group descriptors\""
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_check_descriptors(struct super_block *sb)\n{\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\text2_debug (\"Checking group descriptors\");\n\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tstruct ext2_group_desc *gdp = ext2_get_group_desc(sb, i, NULL);\n\t\text2_fsblk_t first_block = ext2_group_first_block_no(sb, i);\n\t\text2_fsblk_t last_block;\n\n\t\tif (i == sbi->s_groups_count - 1)\n\t\t\tlast_block = le32_to_cpu(sbi->s_es->s_blocks_count) - 1;\n\t\telse\n\t\t\tlast_block = first_block +\n\t\t\t\t(EXT2_BLOCKS_PER_GROUP(sb) - 1);\n\n\t\tif (le32_to_cpu(gdp->bg_block_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_block_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Block bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_block_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_bitmap) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_bitmap) > last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode bitmap for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_bitmap));\n\t\t\treturn 0;\n\t\t}\n\t\tif (le32_to_cpu(gdp->bg_inode_table) < first_block ||\n\t\t    le32_to_cpu(gdp->bg_inode_table) + sbi->s_itb_per_group - 1 >\n\t\t    last_block)\n\t\t{\n\t\t\text2_error (sb, \"ext2_check_descriptors\",\n\t\t\t\t    \"Inode table for group %d\"\n\t\t\t\t    \" not in group (block %lu)!\",\n\t\t\t\t    i, (unsigned long) le32_to_cpu(gdp->bg_inode_table));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ext2_setup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "610-658",
    "snippet": "static int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\"",
            "EXT2FS_VERSION",
            "EXT2FS_DATE",
            "sb->s_blocksize",
            "sbi->s_frag_size",
            "sbi->s_groups_count",
            "EXT2_BLOCKS_PER_GROUP(sb)",
            "EXT2_INODES_PER_GROUP(sb)",
            "sbi->s_mount_opt"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_INODES_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&es->s_mnt_count",
            "1"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT2_DFL_MAX_MNT_COUNT"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_max_mnt_count"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_checkinterval"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_setup_super (struct super_block * sb,\n\t\t\t      struct ext2_super_block * es,\n\t\t\t      int read_only)\n{\n\tint res = 0;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_MAX_SUPP_REV) {\n\t\text2_msg(sb, KERN_ERR,\n\t\t\t\"error: revision level too high, \"\n\t\t\t\"forcing read-only mode\");\n\t\tres = MS_RDONLY;\n\t}\n\tif (read_only)\n\t\treturn res;\n\tif (!(sbi->s_mount_state & EXT2_VALID_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting unchecked fs, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((sbi->s_mount_state & EXT2_ERROR_FS))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: mounting fs with errors, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if ((__s16) le16_to_cpu(es->s_max_mnt_count) >= 0 &&\n\t\t le16_to_cpu(es->s_mnt_count) >=\n\t\t (unsigned short) (__s16) le16_to_cpu(es->s_max_mnt_count))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: maximal mount count reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\telse if (le32_to_cpu(es->s_checkinterval) &&\n\t\t(le32_to_cpu(es->s_lastcheck) +\n\t\t\tle32_to_cpu(es->s_checkinterval) <= get_seconds()))\n\t\text2_msg(sb, KERN_WARNING,\n\t\t\t\"warning: checktime reached, \"\n\t\t\t\"running e2fsck is recommended\");\n\tif (!le16_to_cpu(es->s_max_mnt_count))\n\t\tes->s_max_mnt_count = cpu_to_le16(EXT2_DFL_MAX_MNT_COUNT);\n\tle16_add_cpu(&es->s_mnt_count, 1);\n\tif (test_opt (sb, DEBUG))\n\t\text2_msg(sb, KERN_INFO, \"%s, %s, bs=%lu, fs=%lu, gc=%lu, \"\n\t\t\t\"bpg=%lu, ipg=%lu, mo=%04lx]\",\n\t\t\tEXT2FS_VERSION, EXT2FS_DATE, sb->s_blocksize,\n\t\t\tsbi->s_frag_size,\n\t\t\tsbi->s_groups_count,\n\t\t\tEXT2_BLOCKS_PER_GROUP(sb),\n\t\t\tEXT2_INODES_PER_GROUP(sb),\n\t\t\tsbi->s_mount_opt);\n\treturn res;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "446-608",
    "snippet": "static int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);",
      "static const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_INFO",
            "\"reservations OFF\""
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "RESERVATION"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_opt",
          "args": [
            "sbi->s_mount_opt",
            "RESERVATION"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_set_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1239-1271",
          "snippet": "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\n\nstatic int ocfs2_check_set_options(struct super_block *sb,\n\t\t\t\t   struct mount_options *options)\n{\n\tif (options->mount_opt & OCFS2_MOUNT_USRQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\tmlog(ML_ERROR, \"User quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_GRPQUOTA &&\n\t    !OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\t OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\tmlog(ML_ERROR, \"Group quotas were requested, but this \"\n\t\t     \"filesystem does not have the feature enabled.\\n\");\n\t\treturn 0;\n\t}\n\tif (options->mount_opt & OCFS2_MOUNT_POSIX_ACL &&\n\t    !OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR)) {\n\t\tmlog(ML_ERROR, \"ACL support requested but extended attributes \"\n\t\t     \"feature is not enabled\\n\");\n\t\treturn 0;\n\t}\n\t/* No ACL setting specified? Use XATTR feature... */\n\tif (!(options->mount_opt & (OCFS2_MOUNT_POSIX_ACL |\n\t\t\t\t    OCFS2_MOUNT_NO_POSIX_ACL))) {\n\t\tif (OCFS2_HAS_INCOMPAT_FEATURE(sb, OCFS2_FEATURE_INCOMPAT_XATTR))\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_POSIX_ACL;\n\t\telse\n\t\t\toptions->mount_opt |= OCFS2_MOUNT_NO_POSIX_ACL;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "POSIX_ACL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "XATTR_USER"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "OLDALLOC"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "CHECK"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_PANIC"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_RO"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_PANIC"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_CONT"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_RO"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "ERRORS_CONT"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "GRPID"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_opt",
          "args": [
            "sbi->s_mount_opt",
            "MINIX_DF"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\nstatic const match_table_t tokens = {\n\t{Opt_bsd_df, \"bsddf\"},\n\t{Opt_minix_df, \"minixdf\"},\n\t{Opt_grpid, \"grpid\"},\n\t{Opt_grpid, \"bsdgroups\"},\n\t{Opt_nogrpid, \"nogrpid\"},\n\t{Opt_nogrpid, \"sysvgroups\"},\n\t{Opt_resgid, \"resgid=%u\"},\n\t{Opt_resuid, \"resuid=%u\"},\n\t{Opt_sb, \"sb=%u\"},\n\t{Opt_err_cont, \"errors=continue\"},\n\t{Opt_err_panic, \"errors=panic\"},\n\t{Opt_err_ro, \"errors=remount-ro\"},\n\t{Opt_nouid32, \"nouid32\"},\n\t{Opt_nocheck, \"check=none\"},\n\t{Opt_nocheck, \"nocheck\"},\n\t{Opt_debug, \"debug\"},\n\t{Opt_oldalloc, \"oldalloc\"},\n\t{Opt_orlov, \"orlov\"},\n\t{Opt_nobh, \"nobh\"},\n\t{Opt_user_xattr, \"user_xattr\"},\n\t{Opt_nouser_xattr, \"nouser_xattr\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_xip, \"xip\"},\n\t{Opt_dax, \"dax\"},\n\t{Opt_grpquota, \"grpquota\"},\n\t{Opt_ignore, \"noquota\"},\n\t{Opt_quota, \"quota\"},\n\t{Opt_usrquota, \"usrquota\"},\n\t{Opt_reservation, \"reservation\"},\n\t{Opt_noreservation, \"noreservation\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct super_block *sb)\n{\n\tchar *p;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep (&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_bsd_df:\n\t\t\tclear_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_minix_df:\n\t\t\tset_opt (sbi->s_mount_opt, MINIX_DF);\n\t\t\tbreak;\n\t\tcase Opt_grpid:\n\t\t\tset_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_nogrpid:\n\t\t\tclear_opt (sbi->s_mount_opt, GRPID);\n\t\t\tbreak;\n\t\tcase Opt_resuid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(uid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid uid value %d\", option);\n\t\t\t\treturn 0;\n\n\t\t\t}\n\t\t\tsbi->s_resuid = uid;\n\t\t\tbreak;\n\t\tcase Opt_resgid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(gid)) {\n\t\t\t\text2_msg(sb, KERN_ERR, \"Invalid gid value %d\", option);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsbi->s_resgid = gid;\n\t\t\tbreak;\n\t\tcase Opt_sb:\n\t\t\t/* handled by get_sb_block() instead of here */\n\t\t\t/* *sb_block = match_int(&args[0]); */\n\t\t\tbreak;\n\t\tcase Opt_err_panic:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tbreak;\n\t\tcase Opt_err_ro:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tbreak;\n\t\tcase Opt_err_cont:\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_RO);\n\t\t\tclear_opt (sbi->s_mount_opt, ERRORS_PANIC);\n\t\t\tset_opt (sbi->s_mount_opt, ERRORS_CONT);\n\t\t\tbreak;\n\t\tcase Opt_nouid32:\n\t\t\tset_opt (sbi->s_mount_opt, NO_UID32);\n\t\t\tbreak;\n\t\tcase Opt_nocheck:\n\t\t\tclear_opt (sbi->s_mount_opt, CHECK);\n\t\t\tbreak;\n\t\tcase Opt_debug:\n\t\t\tset_opt (sbi->s_mount_opt, DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_oldalloc:\n\t\t\tset_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_orlov:\n\t\t\tclear_opt (sbi->s_mount_opt, OLDALLOC);\n\t\t\tbreak;\n\t\tcase Opt_nobh:\n\t\t\tset_opt (sbi->s_mount_opt, NOBH);\n\t\t\tbreak;\n#ifdef CONFIG_EXT2_FS_XATTR\n\t\tcase Opt_user_xattr:\n\t\t\tset_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n\t\tcase Opt_nouser_xattr:\n\t\t\tclear_opt (sbi->s_mount_opt, XATTR_USER);\n\t\t\tbreak;\n#else\n\t\tcase Opt_user_xattr:\n\t\tcase Opt_nouser_xattr:\n\t\t\text2_msg(sb, KERN_INFO, \"(no)user_xattr options\"\n\t\t\t\t\"not supported\");\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\t\tcase Opt_acl:\n\t\t\tset_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n\t\tcase Opt_noacl:\n\t\t\tclear_opt(sbi->s_mount_opt, POSIX_ACL);\n\t\t\tbreak;\n#else\n\t\tcase Opt_acl:\n\t\tcase Opt_noacl:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"(no)acl options not supported\");\n\t\t\tbreak;\n#endif\n\t\tcase Opt_xip:\n\t\t\text2_msg(sb, KERN_INFO, \"use dax instead of xip\");\n\t\t\tset_opt(sbi->s_mount_opt, XIP);\n\t\t\t/* Fall through */\n\t\tcase Opt_dax:\n#ifdef CONFIG_FS_DAX\n\t\t\tset_opt(sbi->s_mount_opt, DAX);\n#else\n\t\t\text2_msg(sb, KERN_INFO, \"dax option not supported\");\n#endif\n\t\t\tbreak;\n\n#if defined(CONFIG_QUOTA)\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\t\tset_opt(sbi->s_mount_opt, USRQUOTA);\n\t\t\tbreak;\n\n\t\tcase Opt_grpquota:\n\t\t\tset_opt(sbi->s_mount_opt, GRPQUOTA);\n\t\t\tbreak;\n#else\n\t\tcase Opt_quota:\n\t\tcase Opt_usrquota:\n\t\tcase Opt_grpquota:\n\t\t\text2_msg(sb, KERN_INFO,\n\t\t\t\t\"quota operations not supported\");\n\t\t\tbreak;\n#endif\n\n\t\tcase Opt_reservation:\n\t\t\tset_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations ON\");\n\t\t\tbreak;\n\t\tcase Opt_noreservation:\n\t\t\tclear_opt(sbi->s_mount_opt, RESERVATION);\n\t\t\text2_msg(sb, KERN_INFO, \"reservations OFF\");\n\t\t\tbreak;\n\t\tcase Opt_ignore:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "get_sb_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "382-400",
    "snippet": "static unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_remount (struct super_block * sb, int * flags, char * data);",
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"EXT2-fs: Invalid sb specification: %s\\n\"",
            "(char *) *data"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "options",
            "&options",
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "options",
            "\"sb=\"",
            "3"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_remount (struct super_block * sb, int * flags, char * data);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic unsigned long get_sb_block(void **data)\n{\n\tunsigned long \tsb_block;\n\tchar \t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\tprintk(\"EXT2-fs: Invalid sb specification: %s\\n\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}"
  },
  {
    "function_name": "ext2_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "369-374",
    "snippet": "static struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext2_nfs_get_inode"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic struct dentry *ext2_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext2_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "362-367",
    "snippet": "static struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "ext2_nfs_get_inode"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic struct dentry *ext2_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    ext2_nfs_get_inode);\n}"
  },
  {
    "function_name": "ext2_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "336-360",
    "snippet": "static struct inode *ext2_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT2_FIRST_INO(sb) && ino != EXT2_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * ext2_iget isn't quite right if the inode is currently unallocated!\n\t * However ext2_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = ext2_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/inode.c",
          "lines": "1312-1437",
          "snippet": "struct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"ext2.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};",
            "const struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"acl.h\"\n#include \"ext2.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/fiemap.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n\nconst struct address_space_operations ext2_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_writepage,\n\t.write_begin\t\t= ext2_write_begin,\n\t.write_end\t\t= ext2_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate\t= block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\nconst struct address_space_operations ext2_nobh_aops = {\n\t.readpage\t\t= ext2_readpage,\n\t.readpages\t\t= ext2_readpages,\n\t.writepage\t\t= ext2_nobh_writepage,\n\t.write_begin\t\t= ext2_nobh_write_begin,\n\t.write_end\t\t= nobh_write_end,\n\t.bmap\t\t\t= ext2_bmap,\n\t.direct_IO\t\t= ext2_direct_IO,\n\t.writepages\t\t= ext2_writepages,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstruct inode *ext2_iget (struct super_block *sb, unsigned long ino)\n{\n\tstruct ext2_inode_info *ei;\n\tstruct buffer_head * bh;\n\tstruct ext2_inode *raw_inode;\n\tstruct inode *inode;\n\tlong ret = -EIO;\n\tint n;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT2_I(inode);\n\tei->i_block_alloc_info = NULL;\n\n\traw_inode = ext2_get_inode(inode->i_sb, ino, &bh);\n\tif (IS_ERR(raw_inode)) {\n\t\tret = PTR_ERR(raw_inode);\n \t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (!(test_opt (inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\tinode->i_size = le32_to_cpu(raw_inode->i_size);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(raw_inode->i_atime);\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(raw_inode->i_ctime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(raw_inode->i_mtime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0 && (inode->i_mode == 0 || ei->i_dtime)) {\n\t\t/* this inode is deleted */\n\t\tbrelse (bh);\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\tinode->i_blocks = le32_to_cpu(raw_inode->i_blocks);\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tei->i_faddr = le32_to_cpu(raw_inode->i_faddr);\n\tei->i_frag_no = raw_inode->i_frag;\n\tei->i_frag_size = raw_inode->i_fsize;\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl);\n\tei->i_dir_acl = 0;\n\tif (S_ISREG(inode->i_mode))\n\t\tinode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32;\n\telse\n\t\tei->i_dir_acl = le32_to_cpu(raw_inode->i_dir_acl);\n\tei->i_dtime = 0;\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_state = 0;\n\tei->i_block_group = (ino - 1) / EXT2_INODES_PER_GROUP(inode->i_sb);\n\tei->i_dir_start_lookup = 0;\n\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (n = 0; n < EXT2_N_BLOCKS; n++)\n\t\tei->i_data[n] = raw_inode->i_block[n];\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext2_file_inode_operations;\n\t\tif (test_opt(inode->i_sb, DAX)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_dax_file_operations;\n\t\t} else if (test_opt(inode->i_sb, NOBH)) {\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t} else {\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t\tinode->i_fop = &ext2_file_operations;\n\t\t}\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext2_dir_inode_operations;\n\t\tinode->i_fop = &ext2_dir_operations;\n\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\telse\n\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext2_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_op = &ext2_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext2_symlink_inode_operations;\n\t\t\tif (test_opt(inode->i_sb, NOBH))\n\t\t\t\tinode->i_mapping->a_ops = &ext2_nobh_aops;\n\t\t\telse\n\t\t\t\tinode->i_mapping->a_ops = &ext2_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &ext2_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse \n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t}\n\tbrelse (bh);\n\text2_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\t\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT2_SB(sb)->s_es->s_inodes_count"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_FIRST_INO",
          "args": [
            "sb"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic struct inode *ext2_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tif (ino < EXT2_FIRST_INO(sb) && ino != EXT2_ROOT_INO)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (ino > le32_to_cpu(EXT2_SB(sb)->s_es->s_inodes_count))\n\t\treturn ERR_PTR(-ESTALE);\n\n\t/*\n\t * ext2_iget isn't quite right if the inode is currently unallocated!\n\t * However ext2_iget currently does appropriate checks to handle stale\n\t * inodes so everything is OK.\n\t */\n\tinode = ext2_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "ext2_get_dquots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "311-314",
    "snippet": "static struct dquot **ext2_get_dquots(struct inode *inode)\n{\n\treturn EXT2_I(inode)->i_dquot;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct dquot **ext2_get_dquots(struct inode *inode)\n{\n\treturn EXT2_I(inode)->i_dquot;\n}"
  },
  {
    "function_name": "ext2_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "220-306",
    "snippet": "static int ext2_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tspin_lock(&sbi->s_lock);\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT2_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT2_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT2_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT2_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT2_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT2_ERRORS_PANIC ||\n\t\t    def_errors == EXT2_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT2_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT2_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\n#if defined(CONFIG_QUOTA)\n\tif (sbi->s_mount_opt & EXT2_MOUNT_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n#ifdef CONFIG_FS_DAX\n\tif (sbi->s_mount_opt & EXT2_MOUNT_XIP)\n\t\tseq_puts(seq, \",xip\");\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX)\n\t\tseq_puts(seq, \",dax\");\n#endif\n\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",noreservation\""
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "RESERVATION"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NOBH"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "POSIX_ACL"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "XATTR_USER"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "XATTR_USER"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "OLDALLOC"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "DEBUG"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "NO_UID32"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_CONT"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "es->s_errors"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",resgid=%u\"",
            "from_kgid_munged(&init_user_ns, sbi->s_resgid)"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resgid"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "make_kgid(&init_user_ns, EXT2_DEF_RESGID)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "EXT2_DEF_RESGID"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "sbi->s_resuid"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "make_kuid(&init_user_ns, EXT2_DEF_RESUID)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "EXT2_DEF_RESUID"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "GRPID"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "MINIX_DF"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_default_mount_opts"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic int ext2_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct super_block *sb = root->d_sb;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\tunsigned long def_mount_opts;\n\n\tspin_lock(&sbi->s_lock);\n\tdef_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n\n\tif (sbi->s_sb_block != 1)\n\t\tseq_printf(seq, \",sb=%lu\", sbi->s_sb_block);\n\tif (test_opt(sb, MINIX_DF))\n\t\tseq_puts(seq, \",minixdf\");\n\tif (test_opt(sb, GRPID))\n\t\tseq_puts(seq, \",grpid\");\n\tif (!test_opt(sb, GRPID) && (def_mount_opts & EXT2_DEFM_BSDGROUPS))\n\t\tseq_puts(seq, \",nogrpid\");\n\tif (!uid_eq(sbi->s_resuid, make_kuid(&init_user_ns, EXT2_DEF_RESUID)) ||\n\t    le16_to_cpu(es->s_def_resuid) != EXT2_DEF_RESUID) {\n\t\tseq_printf(seq, \",resuid=%u\",\n\t\t\t\tfrom_kuid_munged(&init_user_ns, sbi->s_resuid));\n\t}\n\tif (!gid_eq(sbi->s_resgid, make_kgid(&init_user_ns, EXT2_DEF_RESGID)) ||\n\t    le16_to_cpu(es->s_def_resgid) != EXT2_DEF_RESGID) {\n\t\tseq_printf(seq, \",resgid=%u\",\n\t\t\t\tfrom_kgid_munged(&init_user_ns, sbi->s_resgid));\n\t}\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\tint def_errors = le16_to_cpu(es->s_errors);\n\n\t\tif (def_errors == EXT2_ERRORS_PANIC ||\n\t\t    def_errors == EXT2_ERRORS_CONTINUE) {\n\t\t\tseq_puts(seq, \",errors=remount-ro\");\n\t\t}\n\t}\n\tif (test_opt(sb, ERRORS_CONT))\n\t\tseq_puts(seq, \",errors=continue\");\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tseq_puts(seq, \",errors=panic\");\n\tif (test_opt(sb, NO_UID32))\n\t\tseq_puts(seq, \",nouid32\");\n\tif (test_opt(sb, DEBUG))\n\t\tseq_puts(seq, \",debug\");\n\tif (test_opt(sb, OLDALLOC))\n\t\tseq_puts(seq, \",oldalloc\");\n\n#ifdef CONFIG_EXT2_FS_XATTR\n\tif (test_opt(sb, XATTR_USER))\n\t\tseq_puts(seq, \",user_xattr\");\n\tif (!test_opt(sb, XATTR_USER) &&\n\t    (def_mount_opts & EXT2_DEFM_XATTR_USER)) {\n\t\tseq_puts(seq, \",nouser_xattr\");\n\t}\n#endif\n\n#ifdef CONFIG_EXT2_FS_POSIX_ACL\n\tif (test_opt(sb, POSIX_ACL))\n\t\tseq_puts(seq, \",acl\");\n\tif (!test_opt(sb, POSIX_ACL) && (def_mount_opts & EXT2_DEFM_ACL))\n\t\tseq_puts(seq, \",noacl\");\n#endif\n\n\tif (test_opt(sb, NOBH))\n\t\tseq_puts(seq, \",nobh\");\n\n#if defined(CONFIG_QUOTA)\n\tif (sbi->s_mount_opt & EXT2_MOUNT_USRQUOTA)\n\t\tseq_puts(seq, \",usrquota\");\n\n\tif (sbi->s_mount_opt & EXT2_MOUNT_GRPQUOTA)\n\t\tseq_puts(seq, \",grpquota\");\n#endif\n\n#ifdef CONFIG_FS_DAX\n\tif (sbi->s_mount_opt & EXT2_MOUNT_XIP)\n\t\tseq_puts(seq, \",xip\");\n\tif (sbi->s_mount_opt & EXT2_MOUNT_DAX)\n\t\tseq_puts(seq, \",dax\");\n#endif\n\n\tif (!test_opt(sb, RESERVATION))\n\t\tseq_puts(seq, \",noreservation\");\n\n\tspin_unlock(&sbi->s_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "210-218",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ext2_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ext2_inode_cachep"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(ext2_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "198-208",
    "snippet": "static int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ext2_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ext2_inode_cache\"",
            "sizeof(struct ext2_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\text2_inode_cachep = kmem_cache_create(\"ext2_inode_cache\",\n\t\t\t\t\t     sizeof(struct ext2_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (ext2_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "186-196",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct ext2_inode_info *ei = (struct ext2_inode_info *) foo;\n\n\trwlock_init(&ei->i_meta_lock);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ei->xattr_sem"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&ei->i_meta_lock"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct ext2_inode_info *ei = (struct ext2_inode_info *) foo;\n\n\trwlock_init(&ei->i_meta_lock);\n#ifdef CONFIG_EXT2_FS_XATTR\n\tinit_rwsem(&ei->xattr_sem);\n#endif\n\tmutex_init(&ei->truncate_mutex);\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "ext2_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "181-184",
    "snippet": "static void ext2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ext2_i_callback);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ext2_i_callback"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, ext2_i_callback);\n}"
  },
  {
    "function_name": "ext2_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "175-179",
    "snippet": "static void ext2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext2_inode_cachep, EXT2_I(inode));\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * ext2_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ext2_inode_cachep",
            "EXT2_I(inode)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT2_I",
          "args": [
            "inode"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "717-720",
          "snippet": "static inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);",
            "extern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);",
            "extern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);",
            "extern void ext2_discard_reservation (struct inode *);",
            "extern void ext2_init_block_alloc_info(struct inode *);",
            "extern int ext2_add_link (struct dentry *, struct inode *);",
            "extern int ext2_make_empty(struct inode *, struct inode *);",
            "extern int ext2_empty_dir (struct inode *);",
            "extern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);",
            "extern void ext2_free_inode (struct inode *);",
            "extern void ext2_evict_inode(struct inode *);",
            "extern void ext2_set_inode_flags(struct inode *inode);",
            "extern void ext2_get_inode_flags(struct ext2_inode_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern ext2_fsblk_t ext2_new_block(struct inode *, unsigned long, int *);\nextern ext2_fsblk_t ext2_new_blocks(struct inode *, unsigned long,\n\t\t\t\tunsigned long *, int *);\nextern void ext2_free_blocks (struct inode *, unsigned long,\n\t\t\t      unsigned long);\nextern void ext2_discard_reservation (struct inode *);\nextern void ext2_init_block_alloc_info(struct inode *);\nextern int ext2_add_link (struct dentry *, struct inode *);\nextern int ext2_make_empty(struct inode *, struct inode *);\nextern int ext2_empty_dir (struct inode *);\nextern void ext2_set_link(struct inode *, struct ext2_dir_entry_2 *, struct page *, struct inode *, int);\nextern void ext2_free_inode (struct inode *);\nextern void ext2_evict_inode(struct inode *);\nextern void ext2_set_inode_flags(struct inode *inode);\nextern void ext2_get_inode_flags(struct ext2_inode_info *);\n\nstatic inline struct ext2_inode_info *EXT2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic void ext2_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(ext2_inode_cachep, EXT2_I(inode));\n}"
  },
  {
    "function_name": "ext2_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "160-173",
    "snippet": "static struct inode *ext2_alloc_inode(struct super_block *sb)\n{\n\tstruct ext2_inode_info *ei;\n\tei = kmem_cache_alloc(ext2_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);",
      "static struct kmem_cache * ext2_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ei->i_dquot",
            "0",
            "sizeof(ei->i_dquot)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ext2_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\nstatic struct kmem_cache * ext2_inode_cachep;\n\nstatic struct inode *ext2_alloc_inode(struct super_block *sb)\n{\n\tstruct ext2_inode_info *ei;\n\tei = kmem_cache_alloc(ext2_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\tei->i_block_alloc_info = NULL;\n\tei->vfs_inode.i_version = 1;\n#ifdef CONFIG_QUOTA\n\tmemset(&ei->i_dquot, 0, sizeof(ei->i_dquot));\n#endif\n\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "ext2_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "126-156",
    "snippet": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_blockgroup_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_dirs_counter"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeinodes_counter"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_debts"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_group_desc"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_sync_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1185-1198",
          "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sbi->s_mount_state"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext2_xattr_put_super",
          "args": [
            "sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_xattr_put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/xattr.h",
          "lines": "96-99",
          "snippet": "static inline void\next2_xattr_put_super(struct super_block *sb)\n{\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline void\next2_xattr_put_super(struct super_block *sb)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_disable",
          "args": [
            "sb",
            "-1",
            "DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1999-2127",
          "snippet": "int dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint dquot_disable(struct super_block *sb, int type, unsigned int flags)\n{\n\tint cnt, ret = 0;\n\tstruct quota_info *dqopt = sb_dqopt(sb);\n\tstruct inode *toputinode[MAXQUOTAS];\n\n\t/* Cannot turn off usage accounting without turning off limits, or\n\t * suspend quotas and simultaneously turn quotas off. */\n\tif ((flags & DQUOT_USAGE_ENABLED && !(flags & DQUOT_LIMITS_ENABLED))\n\t    || (flags & DQUOT_SUSPENDED && flags & (DQUOT_LIMITS_ENABLED |\n\t    DQUOT_USAGE_ENABLED)))\n\t\treturn -EINVAL;\n\n\t/* We need to serialize quota_off() for device */\n\tmutex_lock(&dqopt->dqonoff_mutex);\n\n\t/*\n\t * Skip everything if there's nothing to do. We have to do this because\n\t * sometimes we are called when fill_super() failed and calling\n\t * sync_fs() in such cases does no good.\n\t */\n\tif (!sb_any_quota_loaded(sb)) {\n\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\treturn 0;\n\t}\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\ttoputinode[cnt] = NULL;\n\t\tif (type != -1 && cnt != type)\n\t\t\tcontinue;\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tcontinue;\n\n\t\tif (flags & DQUOT_SUSPENDED) {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags |=\n\t\t\t\tdquot_state_flag(DQUOT_SUSPENDED, cnt);\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t} else {\n\t\t\tspin_lock(&dq_state_lock);\n\t\t\tdqopt->flags &= ~dquot_state_flag(flags, cnt);\n\t\t\t/* Turning off suspended quotas? */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt) &&\n\t\t\t    sb_has_quota_suspended(sb, cnt)) {\n\t\t\t\tdqopt->flags &=\t~dquot_state_flag(\n\t\t\t\t\t\t\tDQUOT_SUSPENDED, cnt);\n\t\t\t\tspin_unlock(&dq_state_lock);\n\t\t\t\tiput(dqopt->files[cnt]);\n\t\t\t\tdqopt->files[cnt] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspin_unlock(&dq_state_lock);\n\t\t}\n\n\t\t/* We still have to keep quota loaded? */\n\t\tif (sb_has_quota_loaded(sb, cnt) && !(flags & DQUOT_SUSPENDED))\n\t\t\tcontinue;\n\n\t\t/* Note: these are blocking operations */\n\t\tdrop_dquot_ref(sb, cnt);\n\t\tinvalidate_dquots(sb, cnt);\n\t\t/*\n\t\t * Now all dquots should be invalidated, all writes done so we\n\t\t * should be only users of the info. No locks needed.\n\t\t */\n\t\tif (info_dirty(&dqopt->info[cnt]))\n\t\t\tsb->dq_op->write_info(sb, cnt);\n\t\tif (dqopt->ops[cnt]->free_file_info)\n\t\t\tdqopt->ops[cnt]->free_file_info(sb, cnt);\n\t\tput_quota_format(dqopt->info[cnt].dqi_format);\n\n\t\ttoputinode[cnt] = dqopt->files[cnt];\n\t\tif (!sb_has_quota_loaded(sb, cnt))\n\t\t\tdqopt->files[cnt] = NULL;\n\t\tdqopt->info[cnt].dqi_flags = 0;\n\t\tdqopt->info[cnt].dqi_igrace = 0;\n\t\tdqopt->info[cnt].dqi_bgrace = 0;\n\t\tdqopt->ops[cnt] = NULL;\n\t}\n\tmutex_unlock(&dqopt->dqonoff_mutex);\n\n\t/* Skip syncing and setting flags if quota files are hidden */\n\tif (dqopt->flags & DQUOT_QUOTA_SYS_FILE)\n\t\tgoto put_inodes;\n\n\t/* Sync the superblock so that buffers with quota data are written to\n\t * disk (and so userspace sees correct data afterwards). */\n\tif (sb->s_op->sync_fs)\n\t\tsb->s_op->sync_fs(sb, 1);\n\tsync_blockdev(sb->s_bdev);\n\t/* Now the quota files are just ordinary files and we can set the\n\t * inode flags back. Moreover we discard the pagecache so that\n\t * userspace sees the writes we did bypassing the pagecache. We\n\t * must also discard the blockdev buffers so that we see the\n\t * changes done by userspace on the next quotaon() */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\tmutex_lock(&dqopt->dqonoff_mutex);\n\t\t\t/* If quota was reenabled in the meantime, we have\n\t\t\t * nothing to do */\n\t\t\tif (!sb_has_quota_loaded(sb, cnt)) {\n\t\t\t\tmutex_lock(&toputinode[cnt]->i_mutex);\n\t\t\t\ttoputinode[cnt]->i_flags &= ~(S_IMMUTABLE |\n\t\t\t\t  S_NOATIME | S_NOQUOTA);\n\t\t\t\ttruncate_inode_pages(&toputinode[cnt]->i_data,\n\t\t\t\t\t\t     0);\n\t\t\t\tmutex_unlock(&toputinode[cnt]->i_mutex);\n\t\t\t\tmark_inode_dirty_sync(toputinode[cnt]);\n\t\t\t}\n\t\t\tmutex_unlock(&dqopt->dqonoff_mutex);\n\t\t}\n\tif (sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\nput_inodes:\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (toputinode[cnt]) {\n\t\t\t/* On remount RO, we keep the inode pointer so that we\n\t\t\t * can reenable quota on the subsequent remount RW. We\n\t\t\t * have to check 'flags' variable and not use sb_has_\n\t\t\t * function because another quotaon / quotaoff could\n\t\t\t * change global state before we got here. We refuse\n\t\t\t * to suspend quotas when there is pending delete on\n\t\t\t * the quota file... */\n\t\t\tif (!(flags & DQUOT_SUSPENDED))\n\t\t\t\tiput(toputinode[cnt]);\n\t\t\telse if (!toputinode[cnt]->i_nlink)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "ext2_update_dynamic_rev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "101-124",
    "snippet": "void ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_DYNAMIC_REV"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT2_GOOD_OLD_INODE_SIZE"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT2_GOOD_OLD_FIRST_INO"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_WARNING",
            "\"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\"",
            "EXT2_DYNAMIC_REV"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_rev_level"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_update_dynamic_rev(struct super_block *sb)\n{\n\tstruct ext2_super_block *es = EXT2_SB(sb)->s_es;\n\n\tif (le32_to_cpu(es->s_rev_level) > EXT2_GOOD_OLD_REV)\n\t\treturn;\n\n\text2_msg(sb, KERN_WARNING,\n\t\t     \"warning: updating to rev %d because of \"\n\t\t     \"new feature flag, running e2fsck is recommended\",\n\t\t     EXT2_DYNAMIC_REV);\n\n\tes->s_first_ino = cpu_to_le32(EXT2_GOOD_OLD_FIRST_INO);\n\tes->s_inode_size = cpu_to_le16(EXT2_GOOD_OLD_INODE_SIZE);\n\tes->s_rev_level = cpu_to_le32(EXT2_DYNAMIC_REV);\n\t/* leave es->s_feature_*compat flags alone */\n\t/* es->s_uuid will be set by e2fsck if empty */\n\n\t/*\n\t * The rest of the superblock fields should be zero, and if not it\n\t * means they are likely already in use, so leave them alone.  We\n\t * can leave it up to e2fsck to clean up any inconsistencies there.\n\t */\n}"
  },
  {
    "function_name": "ext2_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "82-96",
    "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sEXT2-fs (%s): %pV\\n\"",
            "prefix",
            "sb->s_id",
            "&vaf"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "ext2_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
    "lines": "47-80",
    "snippet": "void ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext2.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/log2.h>",
      "#include <linux/mount.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/vfs.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/random.h>",
      "#include <linux/parser.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ext2_freeze(struct super_block *sb);",
      "static int ext2_unfreeze(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext2_msg",
          "args": [
            "sb",
            "KERN_CRIT",
            "\"error: remounting filesystem read-only\""
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "82-96",
          "snippet": "void ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_msg(struct super_block *sb, const char *prefix,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sEXT2-fs (%s): %pV\\n\", prefix, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_RO"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"EXT2-fs: panic from previous error\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "ERRORS_PANIC"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\"",
            "sb->s_id",
            "function",
            "&vaf"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext2_sync_super",
          "args": [
            "sb",
            "es",
            "1"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ext2_sync_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/super.c",
          "lines": "1185-1198",
          "snippet": "static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/log2.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/random.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);",
            "static int ext2_sync_fs(struct super_block *sb, int wait);",
            "static int ext2_freeze(struct super_block *sb);",
            "static int ext2_unfreeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic void ext2_sync_super(struct super_block *sb,\n\t\t\t    struct ext2_super_block *es, int wait);\nstatic int ext2_sync_fs(struct super_block *sb, int wait);\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nstatic void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es,\n\t\t\t    int wait)\n{\n\text2_clear_super_error(sb);\n\tspin_lock(&EXT2_SB(sb)->s_lock);\n\tes->s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));\n\tes->s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));\n\tes->s_wtime = cpu_to_le32(get_seconds());\n\t/* unlock before we do IO */\n\tspin_unlock(&EXT2_SB(sb)->s_lock);\n\tmark_buffer_dirty(EXT2_SB(sb)->s_sbh);\n\tif (wait)\n\t\tsync_dirty_buffer(EXT2_SB(sb)->s_sbh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXT2_ERROR_FS"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sbi->s_lock"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT2_SB",
          "args": [
            "sb"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "EXT2_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext2/ext2.h",
          "lines": "164-167",
          "snippet": "static inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/ext2_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned long ext2_count_free_blocks (struct super_block *);",
            "extern unsigned long ext2_count_dirs (struct super_block *);",
            "extern void ext2_check_blocks_bitmap (struct super_block *);",
            "extern unsigned long ext2_count_free_inodes (struct super_block *);",
            "extern void ext2_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext2_iget (struct super_block *, unsigned long);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/ext2_fs.h>\n#include <linux/fs.h>\n\nextern unsigned long ext2_count_free_blocks (struct super_block *);\nextern unsigned long ext2_count_dirs (struct super_block *);\nextern void ext2_check_blocks_bitmap (struct super_block *);\nextern unsigned long ext2_count_free_inodes (struct super_block *);\nextern void ext2_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext2_iget (struct super_block *, unsigned long);\n\nstatic inline struct ext2_sb_info *EXT2_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext2.h\"\n#include <asm/uaccess.h>\n#include <linux/quotaops.h>\n#include <linux/log2.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/random.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nstatic int ext2_freeze(struct super_block *sb);\nstatic int ext2_unfreeze(struct super_block *sb);\n\nvoid ext2_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tstruct ext2_super_block *es = sbi->s_es;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tspin_lock(&sbi->s_lock);\n\t\tsbi->s_mount_state |= EXT2_ERROR_FS;\n\t\tes->s_state |= cpu_to_le16(EXT2_ERROR_FS);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT2-fs (%s): error: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT2-fs: panic from previous error\\n\");\n\tif (test_opt(sb, ERRORS_RO)) {\n\t\text2_msg(sb, KERN_CRIT,\n\t\t\t     \"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n}"
  }
]