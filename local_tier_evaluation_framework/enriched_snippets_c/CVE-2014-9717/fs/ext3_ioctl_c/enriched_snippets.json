[
  {
    "function_name": "ext3_compat_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ioctl.c",
    "lines": "284-326",
    "snippet": "long ext3_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT3_IOC32_GETFLAGS:\n\t\tcmd = EXT3_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT3_IOC32_SETFLAGS:\n\t\tcmd = EXT3_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT3_IOC32_GETVERSION:\n\t\tcmd = EXT3_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT3_IOC32_SETVERSION:\n\t\tcmd = EXT3_IOC_SETVERSION;\n\t\tbreak;\n\tcase EXT3_IOC32_GROUP_EXTEND:\n\t\tcmd = EXT3_IOC_GROUP_EXTEND;\n\t\tbreak;\n\tcase EXT3_IOC32_GETVERSION_OLD:\n\t\tcmd = EXT3_IOC_GETVERSION_OLD;\n\t\tbreak;\n\tcase EXT3_IOC32_SETVERSION_OLD:\n\t\tcmd = EXT3_IOC_SETVERSION_OLD;\n\t\tbreak;\n#ifdef CONFIG_JBD_DEBUG\n\tcase EXT3_IOC32_WAIT_FOR_READONLY:\n\t\tcmd = EXT3_IOC_WAIT_FOR_READONLY;\n\t\tbreak;\n#endif\n\tcase EXT3_IOC32_GETRSVSZ:\n\t\tcmd = EXT3_IOC_GETRSVSZ;\n\t\tbreak;\n\tcase EXT3_IOC32_SETRSVSZ:\n\t\tcmd = EXT3_IOC_SETRSVSZ;\n\t\tbreak;\n\tcase EXT3_IOC_GROUP_ADD:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext3_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_ioctl",
          "args": [
            "file",
            "cmd",
            "(unsigned long) compat_ptr(arg)"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ioctl.c",
          "lines": "15-281",
          "snippet": "long ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\n\text3_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT3_IOC_GETFLAGS:\n\t\text3_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT3_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT3_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err;\n\t\tstruct ext3_iloc iloc;\n\t\tunsigned int oldflags;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext3_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\terr = -EPERM;\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT3_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tflags = flags & EXT3_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text3_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL))\n\t\t\terr = ext3_change_inode_journal_flag(inode, jflag);\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETVERSION:\n\tcase EXT3_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT3_IOC_SETVERSION:\n\tcase EXT3_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext3_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text3_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT3_IOC_SETRSVSZ: {\n\t\tint err;\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (rsv_window_size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT3_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text3_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext3_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\nsetrsvsz_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_EXTEND: {\n\t\text3_fsblk_t n_blocks_count;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\t\terr = ext3_group_extend(sb, EXT3_SB(sb)->s_es, n_blocks_count);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_extend_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_ADD: {\n\t\tstruct ext3_new_group_data input;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext3_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = ext3_group_add(sb, &input);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_add_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase FITRIM: {\n\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\t   sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tret = ext3_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\t sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n\nlong ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\n\text3_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT3_IOC_GETFLAGS:\n\t\text3_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT3_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT3_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err;\n\t\tstruct ext3_iloc iloc;\n\t\tunsigned int oldflags;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext3_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\terr = -EPERM;\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT3_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tflags = flags & EXT3_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text3_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL))\n\t\t\terr = ext3_change_inode_journal_flag(inode, jflag);\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETVERSION:\n\tcase EXT3_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT3_IOC_SETVERSION:\n\tcase EXT3_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext3_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text3_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT3_IOC_SETRSVSZ: {\n\t\tint err;\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (rsv_window_size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT3_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text3_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext3_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\nsetrsvsz_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_EXTEND: {\n\t\text3_fsblk_t n_blocks_count;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\t\terr = ext3_group_extend(sb, EXT3_SB(sb)->s_es, n_blocks_count);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_extend_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_ADD: {\n\t\tstruct ext3_new_group_data input;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext3_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = ext3_group_add(sb, &input);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_add_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase FITRIM: {\n\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\t   sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tret = ext3_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\t sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "arg"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n\nlong ext3_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\t/* These are just misnamed, they actually get/put from/to user an int */\n\tswitch (cmd) {\n\tcase EXT3_IOC32_GETFLAGS:\n\t\tcmd = EXT3_IOC_GETFLAGS;\n\t\tbreak;\n\tcase EXT3_IOC32_SETFLAGS:\n\t\tcmd = EXT3_IOC_SETFLAGS;\n\t\tbreak;\n\tcase EXT3_IOC32_GETVERSION:\n\t\tcmd = EXT3_IOC_GETVERSION;\n\t\tbreak;\n\tcase EXT3_IOC32_SETVERSION:\n\t\tcmd = EXT3_IOC_SETVERSION;\n\t\tbreak;\n\tcase EXT3_IOC32_GROUP_EXTEND:\n\t\tcmd = EXT3_IOC_GROUP_EXTEND;\n\t\tbreak;\n\tcase EXT3_IOC32_GETVERSION_OLD:\n\t\tcmd = EXT3_IOC_GETVERSION_OLD;\n\t\tbreak;\n\tcase EXT3_IOC32_SETVERSION_OLD:\n\t\tcmd = EXT3_IOC_SETVERSION_OLD;\n\t\tbreak;\n#ifdef CONFIG_JBD_DEBUG\n\tcase EXT3_IOC32_WAIT_FOR_READONLY:\n\t\tcmd = EXT3_IOC_WAIT_FOR_READONLY;\n\t\tbreak;\n#endif\n\tcase EXT3_IOC32_GETRSVSZ:\n\t\tcmd = EXT3_IOC_GETRSVSZ;\n\t\tbreak;\n\tcase EXT3_IOC32_SETRSVSZ:\n\t\tcmd = EXT3_IOC_SETRSVSZ;\n\t\tbreak;\n\tcase EXT3_IOC_GROUP_ADD:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn ext3_ioctl(file, cmd, (unsigned long) compat_ptr(arg));\n}"
  },
  {
    "function_name": "ext3_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ioctl.c",
    "lines": "15-281",
    "snippet": "long ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\n\text3_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT3_IOC_GETFLAGS:\n\t\text3_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT3_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT3_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err;\n\t\tstruct ext3_iloc iloc;\n\t\tunsigned int oldflags;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext3_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\terr = -EPERM;\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT3_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tflags = flags & EXT3_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text3_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL))\n\t\t\terr = ext3_change_inode_journal_flag(inode, jflag);\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETVERSION:\n\tcase EXT3_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT3_IOC_SETVERSION:\n\tcase EXT3_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext3_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text3_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT3_IOC_SETRSVSZ: {\n\t\tint err;\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (rsv_window_size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT3_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text3_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext3_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\nsetrsvsz_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_EXTEND: {\n\t\text3_fsblk_t n_blocks_count;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\t\terr = ext3_group_extend(sb, EXT3_SB(sb)->s_es, n_blocks_count);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_extend_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_ADD: {\n\t\tstruct ext3_new_group_data input;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext3_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = ext3_group_add(sb, &input);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_add_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase FITRIM: {\n\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\t   sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tret = ext3_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\t sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/mount.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(struct fstrim_range __user *)arg",
            "&range",
            "sizeof(range)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_trim_fs",
          "args": [
            "sb",
            "&range"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_trim_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "2085-2158",
          "snippet": "int ext3_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\text3_grpblk_t last_block, first_block;\n\tunsigned long group, first_group, last_group;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tuint64_t start, minlen, end, trimmed = 0;\n\text3_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n\text3_fsblk_t max_blks = le32_to_cpu(es->s_blocks_count);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\n\tif (minlen > EXT3_BLOCKS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\tsmp_rmb();\n\n\t/* Determine first and last group to examine based on start and len */\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) start,\n\t\t\t\t     &first_group, &first_block);\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) end,\n\t\t\t\t     &last_group, &last_block);\n\n\t/* end now represents the last block to discard in this group */\n\tend = EXT3_BLOCKS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgdp = ext3_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For all the groups except the last one, last block will\n\t\t * always be EXT3_BLOCKS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_block is\n\t\t * already computed earlier by ext3_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_block;\n\n\t\tif (le16_to_cpu(gdp->bg_free_blocks_count) >= minlen) {\n\t\t\tret = ext3_trim_all_free(sb, group, first_block,\n\t\t\t\t\t\t end, minlen);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\ttrimmed += ret;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first block to discard will be block #0.\n\t\t */\n\t\tfirst_block = 0;\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout:\n\trange->len = trimmed * sb->s_blocksize;\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\text3_grpblk_t last_block, first_block;\n\tunsigned long group, first_group, last_group;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tuint64_t start, minlen, end, trimmed = 0;\n\text3_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n\text3_fsblk_t max_blks = le32_to_cpu(es->s_blocks_count);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\n\tif (minlen > EXT3_BLOCKS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\tsmp_rmb();\n\n\t/* Determine first and last group to examine based on start and len */\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) start,\n\t\t\t\t     &first_group, &first_block);\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) end,\n\t\t\t\t     &last_group, &last_block);\n\n\t/* end now represents the last block to discard in this group */\n\tend = EXT3_BLOCKS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgdp = ext3_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For all the groups except the last one, last block will\n\t\t * always be EXT3_BLOCKS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_block is\n\t\t * already computed earlier by ext3_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_block;\n\n\t\tif (le16_to_cpu(gdp->bg_free_blocks_count) >= minlen) {\n\t\t\tret = ext3_trim_all_free(sb, group, first_block,\n\t\t\t\t\t\t end, minlen);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\ttrimmed += ret;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first block to discard will be block #0.\n\t\t */\n\t\tfirst_block = 0;\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout:\n\trange->len = trimmed * sb->s_blocksize;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&range",
            "(struct fstrim_range __user *)arg",
            "sizeof(range)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "filp"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_unlock_updates",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "journal_unlock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "487-495",
          "snippet": "void journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_unlock_updates (journal_t *journal)\n{\n\tJ_ASSERT(journal->j_barrier_count != 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t--journal->j_barrier_count;\n\tspin_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_transaction_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_flush",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "journal_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1549-1605",
          "snippet": "int journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\tspin_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tlog_wait_commit(journal, tid);\n\t} else {\n\t\tspin_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tcleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tmark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\tspin_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_lock_updates",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "journal_lock_updates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "438-479",
          "snippet": "void journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\nwait:\n\t/* Wait for previous locked operation to finish */\n\twait_event(journal->j_wait_transaction_locked,\n\t\t   journal->j_barrier_count == 0);\n\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Check reliably under the lock whether we are the ones winning the race\n\t * and locking the journal\n\t */\n\tif (journal->j_barrier_count > 0) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tgoto wait;\n\t}\n\t++journal->j_barrier_count;\n\n\t/* Wait until there are no running updates */\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tif (!transaction->t_updates) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tbreak;\n\t\t}\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\tspin_lock(&journal->j_state_lock);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_group_add",
          "args": [
            "sb",
            "&input"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "783-980",
          "snippet": "int ext3_group_add(struct super_block *sb, struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext3_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT3_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (le32_to_cpu(es->s_blocks_count) + input->blocks_count <\n\t    le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT3_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text3_warning(sb, __func__, \"inodes_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT3_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT3_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext3_iget(sb, EXT3_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext3_journal_start_sb(sb,\n\t\t\t\t       ext3_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * We will only either add reserved group blocks to a backup group\n\t * or remove reserved blocks for the first group in a new group block.\n\t * Doing both would be mean more complex code, and sane people don't\n\t * use non-sparse filesystems anymore.  This is already checked above.\n\t */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext3_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext3_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * OK, now we've set up the new group.  Time to make it active.\n\t *\n\t * We do not lock all allocations via s_resize_lock\n\t * so we have to be safe wrt. concurrent accesses the group\n\t * data.  So we need to be careful to set all of the relevant\n\t * group descriptor data etc. *before* we enable the group.\n\t *\n\t * The key field here is sbi->s_groups_count: as long as\n\t * that retains its old value, nobody is going to access the new\n\t * group.\n\t *\n\t * So first we update all the descriptor metadata for the new\n\t * group; then we update the total disk blocks count; then we\n\t * update the groups count to enable the group; then finally we\n\t * update the free space counts so that the system can start\n\t * using the new disk blocks.\n\t */\n\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext3_group_desc *)primary->b_data + gdb_off;\n\n\tgdp->bg_block_bitmap = cpu_to_le32(input->block_bitmap);\n\tgdp->bg_inode_bitmap = cpu_to_le32(input->inode_bitmap);\n\tgdp->bg_inode_table = cpu_to_le32(input->inode_table);\n\tgdp->bg_free_blocks_count = cpu_to_le16(input->free_blocks_count);\n\tgdp->bg_free_inodes_count = cpu_to_le16(EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tle32_add_cpu(&es->s_blocks_count, input->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold s_resize_lock\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold s_resize_lock over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\n\terr = ext3_journal_dirty_metadata(handle, primary);\n\tif (err)\n\t\tgoto exit_journal;\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\tle32_add_cpu(&es->s_r_blocks_count, input->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT3_INODES_PER_GROUP(sb));\n\n\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext3_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nint ext3_group_add(struct super_block *sb, struct ext3_new_group_data *input)\n{\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\tstruct ext3_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext3_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct buffer_head *primary = NULL;\n\tstruct ext3_group_desc *gdp;\n\tstruct inode *inode = NULL;\n\thandle_t *handle;\n\tint gdb_off, gdb_num;\n\tint err, err2;\n\n\tgdb_num = input->group / EXT3_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT3_DESC_PER_BLOCK(sb);\n\n\tif (gdb_off == 0 && !EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\n\tif (le32_to_cpu(es->s_blocks_count) + input->blocks_count <\n\t    le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(es->s_inodes_count) + EXT3_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text3_warning(sb, __func__, \"inodes_count overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT3_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT3_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext3_iget(sb, EXT3_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text3_warning(sb, __func__,\n\t\t\t\t     \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\n\tif ((err = verify_group_input(sb, input)))\n\t\tgoto exit_put;\n\n\tif ((err = setup_new_group_blocks(sb, input)))\n\t\tgoto exit_put;\n\n\t/*\n\t * We will always be modifying at least the superblock and a GDT\n\t * block.  If we are adding a group past the last current GDT block,\n\t * we will also modify the inode and the dindirect block.  If we\n\t * are adding a group with superblock/GDT backups  we will also\n\t * modify each of the reserved GDT dindirect blocks.\n\t */\n\thandle = ext3_journal_start_sb(sb,\n\t\t\t\t       ext3_bg_has_super(sb, input->group) ?\n\t\t\t\t       3 + reserved_gdb : 4);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&sbi->s_resize_lock);\n\tif (input->group != sbi->s_groups_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\terr = -EBUSY;\n\t\tgoto exit_journal;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle, sbi->s_sbh)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * We will only either add reserved group blocks to a backup group\n\t * or remove reserved blocks for the first group in a new group block.\n\t * Doing both would be mean more complex code, and sane people don't\n\t * use non-sparse filesystems anymore.  This is already checked above.\n\t */\n\tif (gdb_off) {\n\t\tprimary = sbi->s_group_desc[gdb_num];\n\t\tif ((err = ext3_journal_get_write_access(handle, primary)))\n\t\t\tgoto exit_journal;\n\n\t\tif (reserved_gdb && ext3_bg_num_gdb(sb, input->group) &&\n\t\t    (err = reserve_backup_gdb(handle, inode, input)))\n\t\t\tgoto exit_journal;\n\t} else if ((err = add_new_gdb(handle, inode, input, &primary)))\n\t\tgoto exit_journal;\n\n\t/*\n\t * OK, now we've set up the new group.  Time to make it active.\n\t *\n\t * We do not lock all allocations via s_resize_lock\n\t * so we have to be safe wrt. concurrent accesses the group\n\t * data.  So we need to be careful to set all of the relevant\n\t * group descriptor data etc. *before* we enable the group.\n\t *\n\t * The key field here is sbi->s_groups_count: as long as\n\t * that retains its old value, nobody is going to access the new\n\t * group.\n\t *\n\t * So first we update all the descriptor metadata for the new\n\t * group; then we update the total disk blocks count; then we\n\t * update the groups count to enable the group; then finally we\n\t * update the free space counts so that the system can start\n\t * using the new disk blocks.\n\t */\n\n\t/* Update group descriptor block for new group */\n\tgdp = (struct ext3_group_desc *)primary->b_data + gdb_off;\n\n\tgdp->bg_block_bitmap = cpu_to_le32(input->block_bitmap);\n\tgdp->bg_inode_bitmap = cpu_to_le32(input->inode_bitmap);\n\tgdp->bg_inode_table = cpu_to_le32(input->inode_table);\n\tgdp->bg_free_blocks_count = cpu_to_le16(input->free_blocks_count);\n\tgdp->bg_free_inodes_count = cpu_to_le16(EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * Make the new blocks and inodes valid next.  We do this before\n\t * increasing the group count so that once the group is enabled,\n\t * all of its blocks and inodes are already valid.\n\t *\n\t * We always allocate group-by-group, then block-by-block or\n\t * inode-by-inode within a group, so enabling these\n\t * blocks/inodes before the group is live won't actually let us\n\t * allocate the new space yet.\n\t */\n\tle32_add_cpu(&es->s_blocks_count, input->blocks_count);\n\tle32_add_cpu(&es->s_inodes_count, EXT3_INODES_PER_GROUP(sb));\n\n\t/*\n\t * We need to protect s_groups_count against other CPUs seeing\n\t * inconsistent state in the superblock.\n\t *\n\t * The precise rules we use are:\n\t *\n\t * * Writers of s_groups_count *must* hold s_resize_lock\n\t * AND\n\t * * Writers must perform a smp_wmb() after updating all dependent\n\t *   data and before modifying the groups count\n\t *\n\t * * Readers must hold s_resize_lock over the access\n\t * OR\n\t * * Readers must perform an smp_rmb() after reading the groups count\n\t *   and before reading any dependent data.\n\t *\n\t * NB. These rules can be relaxed when checking the group count\n\t * while freeing data, as we can only allocate from a block\n\t * group after serialising against the group count, and we can\n\t * only then free after serialising in turn against that\n\t * allocation.\n\t */\n\tsmp_wmb();\n\n\t/* Update the global fs size fields */\n\tsbi->s_groups_count++;\n\n\terr = ext3_journal_dirty_metadata(handle, primary);\n\tif (err)\n\t\tgoto exit_journal;\n\n\t/* Update the reserved block counts only once the new group is\n\t * active. */\n\tle32_add_cpu(&es->s_r_blocks_count, input->reserved_blocks);\n\n\t/* Update the free space counts */\n\tpercpu_counter_add(&sbi->s_freeblocks_counter,\n\t\t\t   input->free_blocks_count);\n\tpercpu_counter_add(&sbi->s_freeinodes_counter,\n\t\t\t   EXT3_INODES_PER_GROUP(sb));\n\n\terr = ext3_journal_dirty_metadata(handle, sbi->s_sbh);\n\nexit_journal:\n\tmutex_unlock(&sbi->s_resize_lock);\n\tif ((err2 = ext3_journal_stop(handle)) && !err)\n\t\terr = err2;\n\tif (!err) {\n\t\tupdate_backups(sb, sbi->s_sbh->b_blocknr, (char *)es,\n\t\t\t       sizeof(struct ext3_super_block));\n\t\tupdate_backups(sb, primary->b_blocknr, primary->b_data,\n\t\t\t       primary->b_size);\n\t}\nexit_put:\n\tiput(inode);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "filp"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_group_extend",
          "args": [
            "sb",
            "EXT3_SB(sb)->s_es",
            "n_blocks_count"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/resize.c",
          "lines": "991-1117",
          "snippet": "int ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nint ext3_group_extend(struct super_block *sb, struct ext3_super_block *es,\n\t\t      ext3_fsblk_t n_blocks_count)\n{\n\text3_fsblk_t o_blocks_count;\n\text3_grpblk_t last;\n\text3_grpblk_t add;\n\tstruct buffer_head * bh;\n\thandle_t *handle;\n\tint err;\n\tunsigned long freed_blocks;\n\n\t/* We don't need to worry about locking wrt other resizers just\n\t * yet: we're going to revalidate es->s_blocks_count after\n\t * taking the s_resize_lock below. */\n\to_blocks_count = le32_to_cpu(es->s_blocks_count);\n\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extending last group from \"E3FSBLK\n\t\t       \" up to \"E3FSBLK\" blocks\\n\",\n\t\t       o_blocks_count, n_blocks_count);\n\n\tif (n_blocks_count == 0 || n_blocks_count == o_blocks_count)\n\t\treturn 0;\n\n\tif (n_blocks_count > (sector_t)(~0ULL) >> (sb->s_blocksize_bits - 9)) {\n\t\tprintk(KERN_ERR \"EXT3-fs: filesystem on %s:\"\n\t\t\t\" too large to resize to \"E3FSBLK\" blocks safely\\n\",\n\t\t\tsb->s_id, n_blocks_count);\n\t\tif (sizeof(sector_t) < 8)\n\t\t\text3_warning(sb, __func__,\n\t\t\t\"CONFIG_LBDAF not enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (n_blocks_count < o_blocks_count) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't shrink FS - resize aborted\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Handle the remaining blocks in the last group only. */\n\tlast = (o_blocks_count - le32_to_cpu(es->s_first_data_block)) %\n\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\n\tif (last == 0) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"need to use ext2online to resize further\");\n\t\treturn -EPERM;\n\t}\n\n\tadd = EXT3_BLOCKS_PER_GROUP(sb) - last;\n\n\tif (o_blocks_count + add < o_blocks_count) {\n\t\text3_warning(sb, __func__, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (o_blocks_count + add > n_blocks_count)\n\t\tadd = n_blocks_count - o_blocks_count;\n\n\tif (o_blocks_count + add < n_blocks_count)\n\t\text3_warning(sb, __func__,\n\t\t\t     \"will only finish group (\"E3FSBLK\n\t\t\t     \" blocks, %u new)\",\n\t\t\t     o_blocks_count + add, add);\n\n\t/* See if the device is actually as big as what was requested */\n\tbh = sb_bread(sb, o_blocks_count + add -1);\n\tif (!bh) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"can't read last block, resize aborted\");\n\t\treturn -ENOSPC;\n\t}\n\tbrelse(bh);\n\n\t/* We will update the superblock, one block bitmap, and\n\t * one group descriptor via ext3_free_blocks().\n\t */\n\thandle = ext3_journal_start_sb(sb, 3);\n\tif (IS_ERR(handle)) {\n\t\terr = PTR_ERR(handle);\n\t\text3_warning(sb, __func__, \"error %d on journal start\",err);\n\t\tgoto exit_put;\n\t}\n\n\tmutex_lock(&EXT3_SB(sb)->s_resize_lock);\n\tif (o_blocks_count != le32_to_cpu(es->s_blocks_count)) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"multiple resizers run on filesystem!\");\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\tif ((err = ext3_journal_get_write_access(handle,\n\t\t\t\t\t\t EXT3_SB(sb)->s_sbh))) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal write access\", err);\n\t\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\tes->s_blocks_count = cpu_to_le32(o_blocks_count + add);\n\terr = ext3_journal_dirty_metadata(handle, EXT3_SB(sb)->s_sbh);\n\tmutex_unlock(&EXT3_SB(sb)->s_resize_lock);\n\tif (err) {\n\t\text3_warning(sb, __func__,\n\t\t\t     \"error %d on journal dirty metadata\", err);\n\t\text3_journal_stop(handle);\n\t\tgoto exit_put;\n\t}\n\text3_debug(\"freeing blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\text3_free_blocks_sb(handle, sb, o_blocks_count, add, &freed_blocks);\n\text3_debug(\"freed blocks \"E3FSBLK\" through \"E3FSBLK\"\\n\",\n\t\t   o_blocks_count, o_blocks_count + add);\n\tif ((err = ext3_journal_stop(handle)))\n\t\tgoto exit_put;\n\tif (test_opt(sb, DEBUG))\n\t\tprintk(KERN_DEBUG \"EXT3-fs: extended group to %u blocks\\n\",\n\t\t       le32_to_cpu(es->s_blocks_count));\n\tupdate_backups(sb, EXT3_SB(sb)->s_sbh->b_blocknr, (char *)es,\n\t\t       sizeof(struct ext3_super_block));\nexit_put:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "n_blocks_count",
            "(__u32 __user *)arg"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_init_block_alloc_info",
          "args": [
            "inode"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_init_block_alloc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "419-446",
          "snippet": "void ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ei->truncate_mutex"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "RESERVATION"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "rsv_window_size",
            "(int __user *)arg"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "inode->i_sb",
            "RESERVATION"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mark_iloc_dirty",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mark_iloc_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3391-3403",
          "snippet": "int ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint ext3_mark_iloc_dirty(handle_t *handle,\n\t\tstruct inode *inode, struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext3_do_update_inode() does journal_dirty_metadata */\n\terr = ext3_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_reserve_inode_write",
          "args": [
            "handle",
            "inode",
            "&iloc"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_reserve_inode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3410-3428",
          "snippet": "int\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nint\next3_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext3_iloc *iloc)\n{\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext3_get_inode_loc(inode, iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\t\terr = ext3_journal_get_write_access(handle, iloc->bh);\n\t\t\tif (err) {\n\t\t\t\tbrelse(iloc->bh);\n\t\t\t\tiloc->bh = NULL;\n\t\t\t}\n\t\t}\n\t}\n\text3_std_error(inode->i_sb, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start",
          "args": [
            "inode",
            "1"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "1263-1266",
          "snippet": "static inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);",
            "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks);\n\nstatic inline handle_t *ext3_journal_start(struct inode *inode, int nblocks)\n{\n\treturn ext3_journal_start_sb(inode->i_sb, nblocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "inode->i_generation",
            "(int __user *) arg"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_change_inode_journal_flag",
          "args": [
            "inode",
            "jflag"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_change_inode_journal_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "3522-3573",
          "snippet": "int ext3_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT3_JOURNAL(inode);\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\n\tjournal_lock_updates(journal);\n\tjournal_flush(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\tEXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;\n\telse\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;\n\text3_set_aops(inode);\n\n\tjournal_unlock_updates(journal);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext3_journal_start(inode, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\thandle->h_sync = 1;\n\text3_journal_stop(handle);\n\text3_std_error(inode->i_sb, err);\n\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);",
            "static int ext3_block_truncate_page(struct inode *inode, loff_t from);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\nstatic int ext3_block_truncate_page(struct inode *inode, loff_t from);\n\nint ext3_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT3_JOURNAL(inode);\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\n\tjournal_lock_updates(journal);\n\tjournal_flush(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\tEXT3_I(inode)->i_flags |= EXT3_JOURNAL_DATA_FL;\n\telse\n\t\tEXT3_I(inode)->i_flags &= ~EXT3_JOURNAL_DATA_FL;\n\text3_set_aops(inode);\n\n\tjournal_unlock_updates(journal);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext3_journal_start(inode, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext3_mark_inode_dirty(handle, inode);\n\thandle->h_sync = 1;\n\text3_journal_stop(handle);\n\text3_std_error(inode->i_sb, err);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_inode_flags",
          "args": [
            "inode"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_set_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2812-2827",
          "snippet": "void ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_writepage_trans_blocks(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int ext3_writepage_trans_blocks(struct inode *inode);\n\nvoid ext3_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT3_I(inode)->i_flags;\n\n\tinode->i_flags &= ~(S_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC);\n\tif (flags & EXT3_SYNC_FL)\n\t\tinode->i_flags |= S_SYNC;\n\tif (flags & EXT3_APPEND_FL)\n\t\tinode->i_flags |= S_APPEND;\n\tif (flags & EXT3_IMMUTABLE_FL)\n\t\tinode->i_flags |= S_IMMUTABLE;\n\tif (flags & EXT3_NOATIME_FL)\n\t\tinode->i_flags |= S_NOATIME;\n\tif (flags & EXT3_DIRSYNC_FL)\n\t\tinode->i_flags |= S_DIRSYNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_mask_flags",
          "args": [
            "inode->i_mode",
            "flags"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_mask_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "173-181",
          "snippet": "static inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)",
            "#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))"
          ],
          "globals_used": [
            "extern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\n#define EXT3_OTHER_FLMASK (EXT3_NODUMP_FL | EXT3_NOATIME_FL)\n#define EXT3_REG_FLMASK (~(EXT3_DIRSYNC_FL | EXT3_TOPDIR_FL))\n\nextern struct inode * ext3_new_inode (handle_t *, struct inode *,\n\t\t\t\t      const struct qstr *, umode_t);\n\nstatic inline __u32 ext3_mask_flags(umode_t mode, __u32 flags)\n{\n\tif (S_ISDIR(mode))\n\t\treturn flags;\n\telse if (S_ISREG(mode))\n\t\treturn flags & EXT3_REG_FLMASK;\n\telse\n\t\treturn flags & EXT3_OTHER_FLMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "flags",
            "(int __user *) arg"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_inode_flags",
          "args": [
            "ei"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_inode_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "2830-2846",
          "snippet": "void ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nvoid ext3_get_inode_flags(struct ext3_inode_info *ei)\n{\n\tunsigned int flags = ei->vfs_inode.i_flags;\n\n\tei->i_flags &= ~(EXT3_SYNC_FL|EXT3_APPEND_FL|\n\t\t\tEXT3_IMMUTABLE_FL|EXT3_NOATIME_FL|EXT3_DIRSYNC_FL);\n\tif (flags & S_SYNC)\n\t\tei->i_flags |= EXT3_SYNC_FL;\n\tif (flags & S_APPEND)\n\t\tei->i_flags |= EXT3_APPEND_FL;\n\tif (flags & S_IMMUTABLE)\n\t\tei->i_flags |= EXT3_IMMUTABLE_FL;\n\tif (flags & S_NOATIME)\n\t\tei->i_flags |= EXT3_NOATIME_FL;\n\tif (flags & S_DIRSYNC)\n\t\tei->i_flags |= EXT3_DIRSYNC_FL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"cmd = %u, arg = %lu\\n\"",
            "cmd",
            "arg"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/mount.h>\n\nlong ext3_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tunsigned int flags;\n\tunsigned short rsv_window_size;\n\n\text3_debug (\"cmd = %u, arg = %lu\\n\", cmd, arg);\n\n\tswitch (cmd) {\n\tcase EXT3_IOC_GETFLAGS:\n\t\text3_get_inode_flags(ei);\n\t\tflags = ei->i_flags & EXT3_FL_USER_VISIBLE;\n\t\treturn put_user(flags, (int __user *) arg);\n\tcase EXT3_IOC_SETFLAGS: {\n\t\thandle_t *handle = NULL;\n\t\tint err;\n\t\tstruct ext3_iloc iloc;\n\t\tunsigned int oldflags;\n\t\tunsigned int jflag;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EACCES;\n\n\t\tif (get_user(flags, (int __user *) arg))\n\t\t\treturn -EFAULT;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflags = ext3_mask_flags(inode->i_mode, flags);\n\n\t\tmutex_lock(&inode->i_mutex);\n\n\t\t/* Is it quota file? Do not allow user to mess with it */\n\t\terr = -EPERM;\n\t\tif (IS_NOQUOTA(inode))\n\t\t\tgoto flags_out;\n\n\t\toldflags = ei->i_flags;\n\n\t\t/* The JOURNAL_DATA flag is modifiable only by root */\n\t\tjflag = flags & EXT3_JOURNAL_DATA_FL;\n\n\t\t/*\n\t\t * The IMMUTABLE and APPEND_ONLY flags can only be changed by\n\t\t * the relevant capability.\n\t\t *\n\t\t * This test looks nicer. Thanks to Pauline Middelink\n\t\t */\n\t\tif ((flags ^ oldflags) & (EXT3_APPEND_FL | EXT3_IMMUTABLE_FL)) {\n\t\t\tif (!capable(CAP_LINUX_IMMUTABLE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\t/*\n\t\t * The JOURNAL_DATA flag can only be changed by\n\t\t * the relevant capability.\n\t\t */\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL)) {\n\t\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\t\tgoto flags_out;\n\t\t}\n\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto flags_out;\n\t\t}\n\t\tif (IS_SYNC(inode))\n\t\t\thandle->h_sync = 1;\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err)\n\t\t\tgoto flags_err;\n\n\t\tflags = flags & EXT3_FL_USER_MODIFIABLE;\n\t\tflags |= oldflags & ~EXT3_FL_USER_MODIFIABLE;\n\t\tei->i_flags = flags;\n\n\t\text3_set_inode_flags(inode);\n\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\n\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\nflags_err:\n\t\text3_journal_stop(handle);\n\t\tif (err)\n\t\t\tgoto flags_out;\n\n\t\tif ((jflag ^ oldflags) & (EXT3_JOURNAL_DATA_FL))\n\t\t\terr = ext3_change_inode_journal_flag(inode, jflag);\nflags_out:\n\t\tmutex_unlock(&inode->i_mutex);\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETVERSION:\n\tcase EXT3_IOC_GETVERSION_OLD:\n\t\treturn put_user(inode->i_generation, (int __user *) arg);\n\tcase EXT3_IOC_SETVERSION:\n\tcase EXT3_IOC_SETVERSION_OLD: {\n\t\thandle_t *handle;\n\t\tstruct ext3_iloc iloc;\n\t\t__u32 generation;\n\t\tint err;\n\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (get_user(generation, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setversion_out;\n\t\t}\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\thandle = ext3_journal_start(inode, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\terr = PTR_ERR(handle);\n\t\t\tgoto unlock_out;\n\t\t}\n\t\terr = ext3_reserve_inode_write(handle, inode, &iloc);\n\t\tif (err == 0) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tinode->i_generation = generation;\n\t\t\terr = ext3_mark_iloc_dirty(handle, inode, &iloc);\n\t\t}\n\t\text3_journal_stop(handle);\n\nunlock_out:\n\t\tmutex_unlock(&inode->i_mutex);\nsetversion_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GETRSVSZ:\n\t\tif (test_opt(inode->i_sb, RESERVATION)\n\t\t\t&& S_ISREG(inode->i_mode)\n\t\t\t&& ei->i_block_alloc_info) {\n\t\t\trsv_window_size = ei->i_block_alloc_info->rsv_window_node.rsv_goal_size;\n\t\t\treturn put_user(rsv_window_size, (int __user *)arg);\n\t\t}\n\t\treturn -ENOTTY;\n\tcase EXT3_IOC_SETRSVSZ: {\n\t\tint err;\n\n\t\tif (!test_opt(inode->i_sb, RESERVATION) ||!S_ISREG(inode->i_mode))\n\t\t\treturn -ENOTTY;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terr = -EACCES;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (get_user(rsv_window_size, (int __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto setrsvsz_out;\n\t\t}\n\n\t\tif (rsv_window_size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\trsv_window_size = EXT3_MAX_RESERVE_BLOCKS;\n\n\t\t/*\n\t\t * need to allocate reservation structure for this inode\n\t\t * before set the window size\n\t\t */\n\t\tmutex_lock(&ei->truncate_mutex);\n\t\tif (!ei->i_block_alloc_info)\n\t\t\text3_init_block_alloc_info(inode);\n\n\t\tif (ei->i_block_alloc_info){\n\t\t\tstruct ext3_reserve_window_node *rsv = &ei->i_block_alloc_info->rsv_window_node;\n\t\t\trsv->rsv_goal_size = rsv_window_size;\n\t\t}\n\t\tmutex_unlock(&ei->truncate_mutex);\nsetrsvsz_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_EXTEND: {\n\t\text3_fsblk_t n_blocks_count;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (get_user(n_blocks_count, (__u32 __user *)arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_extend_out;\n\t\t}\n\t\terr = ext3_group_extend(sb, EXT3_SB(sb)->s_es, n_blocks_count);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_extend_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase EXT3_IOC_GROUP_ADD: {\n\t\tstruct ext3_new_group_data input;\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tint err, err2;\n\n\t\tif (!capable(CAP_SYS_RESOURCE))\n\t\t\treturn -EPERM;\n\n\t\terr = mnt_want_write_file(filp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (copy_from_user(&input, (struct ext3_new_group_input __user *)arg,\n\t\t\t\tsizeof(input))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto group_add_out;\n\t\t}\n\n\t\terr = ext3_group_add(sb, &input);\n\t\tjournal_lock_updates(EXT3_SB(sb)->s_journal);\n\t\terr2 = journal_flush(EXT3_SB(sb)->s_journal);\n\t\tjournal_unlock_updates(EXT3_SB(sb)->s_journal);\n\t\tif (err == 0)\n\t\t\terr = err2;\ngroup_add_out:\n\t\tmnt_drop_write_file(filp);\n\t\treturn err;\n\t}\n\tcase FITRIM: {\n\n\t\tstruct super_block *sb = inode->i_sb;\n\t\tstruct fstrim_range range;\n\t\tint ret = 0;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&range, (struct fstrim_range __user *)arg,\n\t\t\t\t   sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\tret = ext3_trim_fs(sb, &range);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (copy_to_user((struct fstrim_range __user *)arg, &range,\n\t\t\t\t sizeof(range)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}"
  }
]