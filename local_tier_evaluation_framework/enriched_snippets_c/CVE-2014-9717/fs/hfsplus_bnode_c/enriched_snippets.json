[
  {
    "function_name": "hfs_bnode_need_zeroout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "663-671",
    "snippet": "bool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sbi->s_vhdr->attributes"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HFSPLUS_SB",
          "args": [
            "sb"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "HFSPLUS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/hfsplus_fs.h",
          "lines": "202-205",
          "snippet": "static inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mutex.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/mutex.h>\n#include <linux/fs.h>\n\nstatic inline struct hfsplus_sb_info *HFSPLUS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nbool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}"
  },
  {
    "function_name": "hfs_bnode_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "628-657",
    "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_free",
          "args": [
            "node"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "567-577",
          "snippet": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bmap_free",
          "args": [
            "node"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bmap_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/btree.c",
          "lines": "435-497",
          "snippet": "void hfs_bmap_free(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct page *page;\n\tu16 off, len;\n\tu32 nidx;\n\tu8 *data, byte, m;\n\n\thfs_dbg(BNODE_MOD, \"btree_free_node: %u\\n\", node->this);\n\tBUG_ON(!node->this);\n\ttree = node->tree;\n\tnidx = node->this;\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\treturn;\n\tlen = hfs_brec_lenoff(node, 2, &off);\n\twhile (nidx >= len * 8) {\n\t\tu32 i;\n\n\t\tnidx -= len * 8;\n\t\ti = node->next;\n\t\thfs_bnode_put(node);\n\t\tif (!i) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\",\n\t\t\t\tnode->this);\n\t\t\treturn;\n\t\t}\n\t\tnode = hfs_bnode_find(tree, i);\n\t\tif (IS_ERR(node))\n\t\t\treturn;\n\t\tif (node->type != HFS_NODE_MAP) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\",\n\t\t\t\tnode->this, node->type);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\tlen = hfs_brec_lenoff(node, 0, &off);\n\t}\n\toff += node->page_offset + nidx / 8;\n\tpage = node->page[off >> PAGE_CACHE_SHIFT];\n\tdata = kmap(page);\n\toff &= ~PAGE_CACHE_MASK;\n\tm = 1 << (~nidx & 7);\n\tbyte = data[off];\n\tif (!(byte & m)) {\n\t\tpr_crit(\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\",\n\t\t\tnode->this, node->type);\n\t\tkunmap(page);\n\t\thfs_bnode_put(node);\n\t\treturn;\n\t}\n\tdata[off] = byte & ~m;\n\tset_page_dirty(page);\n\tkunmap(page);\n\thfs_bnode_put(node);\n\ttree->free_nodes++;\n\tmark_inode_dirty(tree->inode);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/log2.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/log2.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nvoid hfs_bmap_free(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct page *page;\n\tu16 off, len;\n\tu32 nidx;\n\tu8 *data, byte, m;\n\n\thfs_dbg(BNODE_MOD, \"btree_free_node: %u\\n\", node->this);\n\tBUG_ON(!node->this);\n\ttree = node->tree;\n\tnidx = node->this;\n\tnode = hfs_bnode_find(tree, 0);\n\tif (IS_ERR(node))\n\t\treturn;\n\tlen = hfs_brec_lenoff(node, 2, &off);\n\twhile (nidx >= len * 8) {\n\t\tu32 i;\n\n\t\tnidx -= len * 8;\n\t\ti = node->next;\n\t\thfs_bnode_put(node);\n\t\tif (!i) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"unable to free bnode %u. \"\n\t\t\t\t\t\"bmap not found!\\n\",\n\t\t\t\tnode->this);\n\t\t\treturn;\n\t\t}\n\t\tnode = hfs_bnode_find(tree, i);\n\t\tif (IS_ERR(node))\n\t\t\treturn;\n\t\tif (node->type != HFS_NODE_MAP) {\n\t\t\t/* panic */;\n\t\t\tpr_crit(\"invalid bmap found! \"\n\t\t\t\t\t\"(%u,%d)\\n\",\n\t\t\t\tnode->this, node->type);\n\t\t\thfs_bnode_put(node);\n\t\t\treturn;\n\t\t}\n\t\tlen = hfs_brec_lenoff(node, 0, &off);\n\t}\n\toff += node->page_offset + nidx / 8;\n\tpage = node->page[off >> PAGE_CACHE_SHIFT];\n\tdata = kmap(page);\n\toff &= ~PAGE_CACHE_MASK;\n\tm = 1 << (~nidx & 7);\n\tbyte = data[off];\n\tif (!(byte & m)) {\n\t\tpr_crit(\"trying to free free bnode \"\n\t\t\t\t\"%u(%d)\\n\",\n\t\t\tnode->this, node->type);\n\t\tkunmap(page);\n\t\thfs_bnode_put(node);\n\t\treturn;\n\t}\n\tdata[off] = byte & ~m;\n\tset_page_dirty(page);\n\tkunmap(page);\n\thfs_bnode_put(node);\n\ttree->free_nodes++;\n\tmark_inode_dirty(tree->inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_clear",
          "args": [
            "node",
            "0",
            "tree->node_size"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "104-124",
          "snippet": "void hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_need_zeroout",
          "args": [
            "tree"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_need_zeroout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "663-671",
          "snippet": "bool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nbool hfs_bnode_need_zeroout(struct hfs_btree *tree)\n{\n\tstruct super_block *sb = tree->inode->i_sb;\n\tstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\n\tconst u32 volume_attr = be32_to_cpu(sbi->s_vhdr->attributes);\n\n\treturn tree->cnid == HFSPLUS_CAT_CNID &&\n\t\tvolume_attr & HFSPLUS_VOL_UNUSED_NODE_FIX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_unhash",
          "args": [
            "node"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_unhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "467-479",
          "snippet": "void hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFS_BNODE_DELETED",
            "&node->flags"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "node->page[i]"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&node->refcnt",
            "&tree->hash_lock"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!atomic_read(&node->refcnt)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"put_node(%d:%d): %d\\n\"",
            "node->tree->cnid",
            "node->this",
            "atomic_read(&node->refcnt)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "617-625",
    "snippet": "void hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"get_node(%d:%d): %d\\n\"",
            "node->tree->cnid",
            "node->this",
            "atomic_read(&node->refcnt)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&node->refcnt"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "579-615",
    "snippet": "struct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&node->lock_wq"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "HFS_BNODE_NEW",
            "&node->flags"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*pagep"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kmap(*++pagep)",
            "0",
            "PAGE_CACHE_SIZE"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++pagep"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kmap(*pagep) + node->page_offset",
            "0",
            "min_t(int, PAGE_CACHE_SIZE, tree->node_size)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "PAGE_CACHE_SIZE",
            "tree->node_size"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFS_BNODE_ERROR",
            "&node->flags"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfs_bnode_create",
          "args": [
            "tree",
            "num"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_bnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "401-465",
          "snippet": "static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_crit",
          "args": [
            "\"new node %u already hashed?\\n\"",
            "num"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_findhash",
          "args": [
            "tree",
            "num"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_findhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "384-399",
          "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_create(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct page **pagep;\n\tint i;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tspin_unlock(&tree->hash_lock);\n\tif (node) {\n\t\tpr_crit(\"new node %u already hashed?\\n\", num);\n\t\tWARN_ON(1);\n\t\treturn node;\n\t}\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags)) {\n\t\thfs_bnode_put(node);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\tpagep = node->page;\n\tmemset(kmap(*pagep) + node->page_offset, 0,\n\t       min_t(int, PAGE_CACHE_SIZE, tree->node_size));\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\tfor (i = 1; i < tree->pages_per_bnode; i++) {\n\t\tmemset(kmap(*++pagep), 0, PAGE_CACHE_SIZE);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\n\treturn node;\n}"
  },
  {
    "function_name": "hfs_bnode_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "567-577",
    "snippet": "void hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "node->page[i]"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_free(struct hfs_bnode *node)\n{\n#if 0\n\tint i;\n\n\tfor (i = 0; i < node->tree->pages_per_bnode; i++)\n\t\tif (node->page[i])\n\t\t\tpage_cache_release(node->page[i]);\n#endif\n\tkfree(node);\n}"
  },
  {
    "function_name": "hfs_bnode_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "482-565",
    "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "node"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&node->lock_wq"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "HFS_BNODE_NEW",
            "&node->flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFS_BNODE_ERROR",
            "&node->flags"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "off"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "node->page[0]"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "desc->num_recs"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "desc->next"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "desc->prev"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "node->page[0]"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFS_BNODE_NEW",
            "&node->flags"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hfs_bnode_create",
          "args": [
            "tree",
            "num"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__hfs_bnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "401-465",
          "snippet": "static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "node->lock_wq",
            "!test_bit(HFS_BNODE_NEW, &node->flags)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_get",
          "args": [
            "node"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "617-625",
          "snippet": "void hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_get(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tatomic_inc(&node->refcnt);\n\t\thfs_dbg(BNODE_REFS, \"get_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_findhash",
          "args": [
            "tree",
            "num"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_findhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "384-399",
          "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "hfs_bnode_unhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "467-479",
    "snippet": "void hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!*p"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_hash",
          "args": [
            "node->this"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "377-382",
          "snippet": "static inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"remove_node(%d:%d): %d\\n\"",
            "node->tree->cnid",
            "node->this",
            "atomic_read(&node->refcnt)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&node->refcnt"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_unhash(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode **p;\n\n\thfs_dbg(BNODE_REFS, \"remove_node(%d:%d): %d\\n\",\n\t\tnode->tree->cnid, node->this, atomic_read(&node->refcnt));\n\tfor (p = &node->tree->node_hash[hfs_bnode_hash(node->this)];\n\t     *p && *p != node; p = &(*p)->next_hash)\n\t\t;\n\tBUG_ON(!*p);\n\t*p = node->next_hash;\n\tnode->tree->node_hash_cnt--;\n}"
  },
  {
    "function_name": "__hfs_bnode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "401-465",
    "snippet": "static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFS_BNODE_ERROR",
            "&node->flags"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "block",
            "NULL"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "node2->lock_wq",
            "!test_bit(HFS_BNODE_NEW, &node2->flags)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "HFS_BNODE_NEW",
            "&node2->flags"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_hash",
          "args": [
            "cnid"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "377-382",
          "snippet": "static inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_findhash",
          "args": [
            "tree",
            "cnid"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_findhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "384-399",
          "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tree->hash_lock"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&node->lock_wq"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_REFS",
            "\"new_node(%d:%d): 1\\n\"",
            "node->tree->cnid",
            "node->this"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&node->refcnt",
            "1"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"request for non-existent node %d in B*Tree\\n\"",
            "cnid"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct super_block *sb;\n\tstruct hfs_bnode *node, *node2;\n\tstruct address_space *mapping;\n\tstruct page *page;\n\tint size, block, i, hash;\n\tloff_t off;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tsb = tree->inode->i_sb;\n\tsize = sizeof(struct hfs_bnode) + tree->pages_per_bnode *\n\t\tsizeof(struct page *);\n\tnode = kzalloc(size, GFP_KERNEL);\n\tif (!node)\n\t\treturn NULL;\n\tnode->tree = tree;\n\tnode->this = cnid;\n\tset_bit(HFS_BNODE_NEW, &node->flags);\n\tatomic_set(&node->refcnt, 1);\n\thfs_dbg(BNODE_REFS, \"new_node(%d:%d): 1\\n\",\n\t\tnode->tree->cnid, node->this);\n\tinit_waitqueue_head(&node->lock_wq);\n\tspin_lock(&tree->hash_lock);\n\tnode2 = hfs_bnode_findhash(tree, cnid);\n\tif (!node2) {\n\t\thash = hfs_bnode_hash(cnid);\n\t\tnode->next_hash = tree->node_hash[hash];\n\t\ttree->node_hash[hash] = node;\n\t\ttree->node_hash_cnt++;\n\t} else {\n\t\tspin_unlock(&tree->hash_lock);\n\t\tkfree(node);\n\t\twait_event(node2->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node2->flags));\n\t\treturn node2;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\n\tmapping = tree->inode->i_mapping;\n\toff = (loff_t)cnid << tree->node_size_shift;\n\tblock = off >> PAGE_CACHE_SHIFT;\n\tnode->page_offset = off & ~PAGE_CACHE_MASK;\n\tfor (i = 0; i < tree->pages_per_bnode; block++, i++) {\n\t\tpage = read_mapping_page(mapping, block, NULL);\n\t\tif (IS_ERR(page))\n\t\t\tgoto fail;\n\t\tif (PageError(page)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto fail;\n\t\t}\n\t\tpage_cache_release(page);\n\t\tnode->page[i] = page;\n\t}\n\n\treturn node;\nfail:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\treturn node;\n}"
  },
  {
    "function_name": "hfs_bnode_findhash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "384-399",
    "snippet": "struct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_hash",
          "args": [
            "cnid"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "377-382",
          "snippet": "static inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"request for non-existent node %d in B*Tree\\n\"",
            "cnid"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_findhash(struct hfs_btree *tree, u32 cnid)\n{\n\tstruct hfs_bnode *node;\n\n\tif (cnid >= tree->node_count) {\n\t\tpr_err(\"request for non-existent node %d in B*Tree\\n\",\n\t\t       cnid);\n\t\treturn NULL;\n\t}\n\n\tfor (node = tree->node_hash[hfs_bnode_hash(cnid)];\n\t\t\tnode; node = node->next_hash)\n\t\tif (node->this == cnid)\n\t\t\treturn node;\n\treturn NULL;\n}"
  },
  {
    "function_name": "hfs_bnode_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "377-382",
    "snippet": "static inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstatic inline int hfs_bnode_hash(u32 num)\n{\n\tnum = (num >> 16) + num;\n\tnum += num >> 8;\n\treturn num & (NODE_HASH_SIZE - 1);\n}"
  },
  {
    "function_name": "hfs_bnode_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "336-375",
    "snippet": "void hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t/* move down? */\n\tif (!node->prev && !node->next)\n\t\thfs_dbg(BNODE_MOD, \"hfs_btree_del_level\\n\");\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "HFS_BNODE_DELETED",
            "&node->flags"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"hfs_btree_del_level\\n\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_put",
          "args": [
            "tmp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "628-657",
          "snippet": "void hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_put(struct hfs_bnode *node)\n{\n\tif (node) {\n\t\tstruct hfs_btree *tree = node->tree;\n\t\tint i;\n\n\t\thfs_dbg(BNODE_REFS, \"put_node(%d:%d): %d\\n\",\n\t\t\tnode->tree->cnid, node->this,\n\t\t\tatomic_read(&node->refcnt));\n\t\tBUG_ON(!atomic_read(&node->refcnt));\n\t\tif (!atomic_dec_and_lock(&node->refcnt, &tree->hash_lock))\n\t\t\treturn;\n\t\tfor (i = 0; i < tree->pages_per_bnode; i++) {\n\t\t\tif (!node->page[i])\n\t\t\t\tcontinue;\n\t\t\tmark_page_accessed(node->page[i]);\n\t\t}\n\n\t\tif (test_bit(HFS_BNODE_DELETED, &node->flags)) {\n\t\t\thfs_bnode_unhash(node);\n\t\t\tspin_unlock(&tree->hash_lock);\n\t\t\tif (hfs_bnode_need_zeroout(tree))\n\t\t\t\thfs_bnode_clear(node, 0, tree->node_size);\n\t\t\thfs_bmap_free(node);\n\t\t\thfs_bnode_free(node);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock(&tree->hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "tmp",
            "&cnid",
            "offsetof(struct hfs_bnode_desc, prev)",
            "4"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp->prev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_find",
          "args": [
            "tree",
            "node->next"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "482-565",
          "snippet": "struct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct hfs_bnode *hfs_bnode_find(struct hfs_btree *tree, u32 num)\n{\n\tstruct hfs_bnode *node;\n\tstruct hfs_bnode_desc *desc;\n\tint i, rec_off, off, next_off;\n\tint entry_size, key_size;\n\n\tspin_lock(&tree->hash_lock);\n\tnode = hfs_bnode_findhash(tree, num);\n\tif (node) {\n\t\thfs_bnode_get(node);\n\t\tspin_unlock(&tree->hash_lock);\n\t\twait_event(node->lock_wq,\n\t\t\t!test_bit(HFS_BNODE_NEW, &node->flags));\n\t\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\t\tgoto node_error;\n\t\treturn node;\n\t}\n\tspin_unlock(&tree->hash_lock);\n\tnode = __hfs_bnode_create(tree, num);\n\tif (!node)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (test_bit(HFS_BNODE_ERROR, &node->flags))\n\t\tgoto node_error;\n\tif (!test_bit(HFS_BNODE_NEW, &node->flags))\n\t\treturn node;\n\n\tdesc = (struct hfs_bnode_desc *)(kmap(node->page[0]) +\n\t\t\tnode->page_offset);\n\tnode->prev = be32_to_cpu(desc->prev);\n\tnode->next = be32_to_cpu(desc->next);\n\tnode->num_recs = be16_to_cpu(desc->num_recs);\n\tnode->type = desc->type;\n\tnode->height = desc->height;\n\tkunmap(node->page[0]);\n\n\tswitch (node->type) {\n\tcase HFS_NODE_HEADER:\n\tcase HFS_NODE_MAP:\n\t\tif (node->height != 0)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_LEAF:\n\t\tif (node->height != 1)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tcase HFS_NODE_INDEX:\n\t\tif (node->height <= 1 || node->height > tree->depth)\n\t\t\tgoto node_error;\n\t\tbreak;\n\tdefault:\n\t\tgoto node_error;\n\t}\n\n\trec_off = tree->node_size - 2;\n\toff = hfs_bnode_read_u16(node, rec_off);\n\tif (off != sizeof(struct hfs_bnode_desc))\n\t\tgoto node_error;\n\tfor (i = 1; i <= node->num_recs; off = next_off, i++) {\n\t\trec_off -= 2;\n\t\tnext_off = hfs_bnode_read_u16(node, rec_off);\n\t\tif (next_off <= off ||\n\t\t    next_off > tree->node_size ||\n\t\t    next_off & 1)\n\t\t\tgoto node_error;\n\t\tentry_size = next_off - off;\n\t\tif (node->type != HFS_NODE_INDEX &&\n\t\t    node->type != HFS_NODE_LEAF)\n\t\t\tcontinue;\n\t\tkey_size = hfs_bnode_read_u16(node, off) + 2;\n\t\tif (key_size >= entry_size || key_size & 1)\n\t\t\tgoto node_error;\n\t}\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\treturn node;\n\nnode_error:\n\tset_bit(HFS_BNODE_ERROR, &node->flags);\n\tclear_bit(HFS_BNODE_NEW, &node->flags);\n\twake_up(&node->lock_wq);\n\thfs_bnode_put(node);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tmp->next"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tmp"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_unlink(struct hfs_bnode *node)\n{\n\tstruct hfs_btree *tree;\n\tstruct hfs_bnode *tmp;\n\t__be32 cnid;\n\n\ttree = node->tree;\n\tif (node->prev) {\n\t\ttmp = hfs_bnode_find(tree, node->prev);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->next = node->next;\n\t\tcnid = cpu_to_be32(tmp->next);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, next), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_head = node->next;\n\n\tif (node->next) {\n\t\ttmp = hfs_bnode_find(tree, node->next);\n\t\tif (IS_ERR(tmp))\n\t\t\treturn;\n\t\ttmp->prev = node->prev;\n\t\tcnid = cpu_to_be32(tmp->prev);\n\t\thfs_bnode_write(tmp, &cnid,\n\t\t\toffsetof(struct hfs_bnode_desc, prev), 4);\n\t\thfs_bnode_put(tmp);\n\t} else if (node->type == HFS_NODE_LEAF)\n\t\ttree->leaf_tail = node->prev;\n\n\t/* move down? */\n\tif (!node->prev && !node->next)\n\t\thfs_dbg(BNODE_MOD, \"hfs_btree_del_level\\n\");\n\tif (!node->parent) {\n\t\ttree->root = 0;\n\t\ttree->depth = 0;\n\t}\n\tset_bit(HFS_BNODE_DELETED, &node->flags);\n}"
  },
  {
    "function_name": "hfs_bnode_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "299-334",
    "snippet": "void hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "BNODE_MOD",
            "\"\\n\""
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "BNODE_MOD",
            "\" (%d)\"",
            "tmp"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "key_off"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "BNODE_MOD",
            "\",%d)\"",
            "be32_to_cpu(cnid)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "cnid"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "node",
            "&cnid",
            "key_off + tmp",
            "4"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_dbg_cont",
          "args": [
            "BNODE_MOD",
            "\" (%d\"",
            "tmp"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\" %d\"",
            "key_off"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "desc.num_recs"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"%d, %d, %d, %d, %d\\n\"",
            "be32_to_cpu(desc.next)",
            "be32_to_cpu(desc.prev)",
            "desc.type",
            "desc.height",
            "be16_to_cpu(desc.num_recs)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "desc.num_recs"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "desc.prev"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "desc.next"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"bnode: %d\\n\"",
            "node->this"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_dump(struct hfs_bnode *node)\n{\n\tstruct hfs_bnode_desc desc;\n\t__be32 cnid;\n\tint i, off, key_off;\n\n\thfs_dbg(BNODE_MOD, \"bnode: %d\\n\", node->this);\n\thfs_bnode_read(node, &desc, 0, sizeof(desc));\n\thfs_dbg(BNODE_MOD, \"%d, %d, %d, %d, %d\\n\",\n\t\tbe32_to_cpu(desc.next), be32_to_cpu(desc.prev),\n\t\tdesc.type, desc.height, be16_to_cpu(desc.num_recs));\n\n\toff = node->tree->node_size - 2;\n\tfor (i = be16_to_cpu(desc.num_recs); i >= 0; off -= 2, i--) {\n\t\tkey_off = hfs_bnode_read_u16(node, off);\n\t\thfs_dbg(BNODE_MOD, \" %d\", key_off);\n\t\tif (i && node->type == HFS_NODE_INDEX) {\n\t\t\tint tmp;\n\n\t\t\tif (node->tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t\t\t\t\tnode->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\t\t\ttmp = hfs_bnode_read_u16(node, key_off) + 2;\n\t\t\telse\n\t\t\t\ttmp = node->tree->max_key_len + 2;\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d\", tmp);\n\t\t\thfs_bnode_read(node, &cnid, key_off + tmp, 4);\n\t\t\thfs_dbg_cont(BNODE_MOD, \",%d)\", be32_to_cpu(cnid));\n\t\t} else if (i && node->type == HFS_NODE_LEAF) {\n\t\t\tint tmp;\n\n\t\t\ttmp = hfs_bnode_read_u16(node, key_off);\n\t\t\thfs_dbg_cont(BNODE_MOD, \" (%d)\", tmp);\n\t\t}\n\t}\n\thfs_dbg_cont(BNODE_MOD, \"\\n\");\n}"
  },
  {
    "function_name": "hfs_bnode_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "186-297",
    "snippet": "void hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*dst_page"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_ptr",
            "src_ptr",
            "l"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "l"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kmap(*++dst_page)",
            "kmap(*++src_page)",
            "l"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++src_page"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++dst_page"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kmap(*dst_page) + src",
            "kmap(*src_page) + src",
            "l"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE - src"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dst_ptr - l",
            "src_ptr - l",
            "l"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kmap(*dst_page) + src",
            "kmap(*src_page) + src",
            "len"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "kmap(*dst_page)",
            "kmap(*src_page)",
            "src"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"movebytes: %u,%u,%u\\n\"",
            "dst",
            "src",
            "len"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_move(struct hfs_bnode *node, int dst, int src, int len)\n{\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"movebytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\tsrc += node->page_offset;\n\tdst += node->page_offset;\n\tif (dst > src) {\n\t\tsrc += len - 1;\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc = (src & ~PAGE_CACHE_MASK) + 1;\n\t\tdst += len - 1;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst = (dst & ~PAGE_CACHE_MASK) + 1;\n\n\t\tif (src == dst) {\n\t\t\twhile (src < len) {\n\t\t\t\tmemmove(kmap(*dst_page), kmap(*src_page), src);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tlen -= src;\n\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\tsrc_page--;\n\t\t\t\tdst_page--;\n\t\t\t}\n\t\t\tsrc -= len;\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, len);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (src < dst) {\n\t\t\t\t\tl = src;\n\t\t\t\t\tsrc = PAGE_CACHE_SIZE;\n\t\t\t\t\tdst -= l;\n\t\t\t\t} else {\n\t\t\t\t\tl = dst;\n\t\t\t\t\tsrc -= l;\n\t\t\t\t\tdst = PAGE_CACHE_SIZE;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr - l, src_ptr - l, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (dst == PAGE_CACHE_SIZE)\n\t\t\t\t\tdst_page--;\n\t\t\t\telse\n\t\t\t\t\tsrc_page--;\n\t\t\t} while ((len -= l));\n\t\t}\n\t} else {\n\t\tsrc_page = node->page + (src >> PAGE_CACHE_SHIFT);\n\t\tsrc &= ~PAGE_CACHE_MASK;\n\t\tdst_page = node->page + (dst >> PAGE_CACHE_SHIFT);\n\t\tdst &= ~PAGE_CACHE_MASK;\n\n\t\tif (src == dst) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\t\tmemmove(kmap(*dst_page) + src,\n\t\t\t\tkmap(*src_page) + src, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\n\t\t\twhile ((len -= l) != 0) {\n\t\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\t\tmemmove(kmap(*++dst_page),\n\t\t\t\t\tkmap(*++src_page), l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t}\n\t\t} else {\n\t\t\tvoid *src_ptr, *dst_ptr;\n\n\t\t\tdo {\n\t\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\t\tif (PAGE_CACHE_SIZE - src <\n\t\t\t\t\t\tPAGE_CACHE_SIZE - dst) {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\t\tsrc = 0;\n\t\t\t\t\tdst += l;\n\t\t\t\t} else {\n\t\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\t\tsrc += l;\n\t\t\t\t\tdst = 0;\n\t\t\t\t}\n\t\t\t\tl = min(len, l);\n\t\t\t\tmemmove(dst_ptr, src_ptr, l);\n\t\t\t\tkunmap(*src_page);\n\t\t\t\tset_page_dirty(*dst_page);\n\t\t\t\tkunmap(*dst_page);\n\t\t\t\tif (!dst)\n\t\t\t\t\tdst_page++;\n\t\t\t\telse\n\t\t\t\t\tsrc_page++;\n\t\t\t} while ((len -= l));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "126-184",
    "snippet": "void hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*dst_page"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_ptr",
            "src_ptr",
            "l"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "l"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kmap(*++dst_page)",
            "kmap(*++src_page)",
            "l"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++src_page"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++dst_page"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*dst_page"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*src_page"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kmap(*dst_page) + src",
            "kmap(*src_page) + src",
            "l"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*src_page"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*dst_page"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE - src"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_dbg",
          "args": [
            "BNODE_MOD",
            "\"copybytes: %u,%u,%u\\n\"",
            "dst",
            "src",
            "len"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_copy(struct hfs_bnode *dst_node, int dst,\n\t\t    struct hfs_bnode *src_node, int src, int len)\n{\n\tstruct hfs_btree *tree;\n\tstruct page **src_page, **dst_page;\n\tint l;\n\n\thfs_dbg(BNODE_MOD, \"copybytes: %u,%u,%u\\n\", dst, src, len);\n\tif (!len)\n\t\treturn;\n\ttree = src_node->tree;\n\tsrc += src_node->page_offset;\n\tdst += dst_node->page_offset;\n\tsrc_page = src_node->page + (src >> PAGE_CACHE_SHIFT);\n\tsrc &= ~PAGE_CACHE_MASK;\n\tdst_page = dst_node->page + (dst >> PAGE_CACHE_SHIFT);\n\tdst &= ~PAGE_CACHE_MASK;\n\n\tif (src == dst) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE - src);\n\t\tmemcpy(kmap(*dst_page) + src, kmap(*src_page) + src, l);\n\t\tkunmap(*src_page);\n\t\tset_page_dirty(*dst_page);\n\t\tkunmap(*dst_page);\n\n\t\twhile ((len -= l) != 0) {\n\t\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\t\tmemcpy(kmap(*++dst_page), kmap(*++src_page), l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t}\n\t} else {\n\t\tvoid *src_ptr, *dst_ptr;\n\n\t\tdo {\n\t\t\tsrc_ptr = kmap(*src_page) + src;\n\t\t\tdst_ptr = kmap(*dst_page) + dst;\n\t\t\tif (PAGE_CACHE_SIZE - src < PAGE_CACHE_SIZE - dst) {\n\t\t\t\tl = PAGE_CACHE_SIZE - src;\n\t\t\t\tsrc = 0;\n\t\t\t\tdst += l;\n\t\t\t} else {\n\t\t\t\tl = PAGE_CACHE_SIZE - dst;\n\t\t\t\tsrc += l;\n\t\t\t\tdst = 0;\n\t\t\t}\n\t\t\tl = min(len, l);\n\t\t\tmemcpy(dst_ptr, src_ptr, l);\n\t\t\tkunmap(*src_page);\n\t\t\tset_page_dirty(*dst_page);\n\t\t\tkunmap(*dst_page);\n\t\t\tif (!dst)\n\t\t\t\tdst_page++;\n\t\t\telse\n\t\t\t\tsrc_page++;\n\t\t} while ((len -= l));\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "104-124",
    "snippet": "void hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*pagep"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kmap(*++pagep)",
            "0",
            "l"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++pagep"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kmap(*pagep) + off",
            "0",
            "l"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE - off"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_clear(struct hfs_bnode *node, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemset(kmap(*pagep) + off, 0, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemset(kmap(*++pagep), 0, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_write_u16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "97-102",
    "snippet": "void hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_write",
          "args": [
            "node",
            "&v",
            "off",
            "2"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "74-95",
          "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "data"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write_u16(struct hfs_bnode *node, int off, u16 data)\n{\n\t__be16 v = cpu_to_be16(data);\n\t/* TODO: optimize later... */\n\thfs_bnode_write(node, &v, off, 2);\n}"
  },
  {
    "function_name": "hfs_bnode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "74-95",
    "snippet": "void hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "*pagep"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kmap(*++pagep)",
            "buf",
            "l"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++pagep"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kmap(*pagep) + off",
            "buf",
            "l"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE - off"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_write(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(kmap(*pagep) + off, buf, l);\n\tset_page_dirty(*pagep);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(kmap(*++pagep), buf, l);\n\t\tset_page_dirty(*pagep);\n\t\tkunmap(*pagep);\n\t}\n}"
  },
  {
    "function_name": "hfs_bnode_read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "58-72",
    "snippet": "void hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "node",
            "key",
            "off",
            "key_len"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read_u16",
          "args": [
            "node",
            "off"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read_u16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "42-48",
          "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read_key(struct hfs_bnode *node, void *key, int off)\n{\n\tstruct hfs_btree *tree;\n\tint key_len;\n\n\ttree = node->tree;\n\tif (node->type == HFS_NODE_LEAF ||\n\t    tree->attributes & HFS_TREE_VARIDXKEYS ||\n\t    node->tree->cnid == HFSPLUS_ATTR_CNID)\n\t\tkey_len = hfs_bnode_read_u16(node, off) + 2;\n\telse\n\t\tkey_len = tree->max_key_len + 2;\n\n\thfs_bnode_read(node, key, off, key_len);\n}"
  },
  {
    "function_name": "hfs_bnode_read_u8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "50-56",
    "snippet": "u8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "node",
            "&data",
            "off",
            "1"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu8 hfs_bnode_read_u8(struct hfs_bnode *node, int off)\n{\n\tu8 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 1);\n\treturn data;\n}"
  },
  {
    "function_name": "hfs_bnode_read_u16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "42-48",
    "snippet": "u16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "data"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hfs_bnode_read",
          "args": [
            "node",
            "&data",
            "off",
            "2"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "hfs_bnode_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
          "lines": "21-40",
          "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
          "includes": [
            "#include \"hfsplus_raw.h\"",
            "#include \"hfsplus_fs.h\"",
            "#include <linux/swap.h>",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nu16 hfs_bnode_read_u16(struct hfs_bnode *node, int off)\n{\n\t__be16 data;\n\t/* TODO: optimize later... */\n\thfs_bnode_read(node, &data, off, 2);\n\treturn be16_to_cpu(data);\n}"
  },
  {
    "function_name": "hfs_bnode_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/bnode.c",
    "lines": "21-40",
    "snippet": "void hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}",
    "includes": [
      "#include \"hfsplus_raw.h\"",
      "#include \"hfsplus_fs.h\"",
      "#include <linux/swap.h>",
      "#include <linux/fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "kmap(*++pagep)",
            "l"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*++pagep"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pagep"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "kmap(*pagep) + off",
            "l"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pagep"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "len",
            "PAGE_CACHE_SIZE - off"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hfsplus_raw.h\"\n#include \"hfsplus_fs.h\"\n#include <linux/swap.h>\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid hfs_bnode_read(struct hfs_bnode *node, void *buf, int off, int len)\n{\n\tstruct page **pagep;\n\tint l;\n\n\toff += node->page_offset;\n\tpagep = node->page + (off >> PAGE_CACHE_SHIFT);\n\toff &= ~PAGE_CACHE_MASK;\n\n\tl = min_t(int, len, PAGE_CACHE_SIZE - off);\n\tmemcpy(buf, kmap(*pagep) + off, l);\n\tkunmap(*pagep);\n\n\twhile ((len -= l) != 0) {\n\t\tbuf += l;\n\t\tl = min_t(int, len, PAGE_CACHE_SIZE);\n\t\tmemcpy(buf, kmap(*++pagep), l);\n\t\tkunmap(*pagep);\n\t}\n}"
  }
]