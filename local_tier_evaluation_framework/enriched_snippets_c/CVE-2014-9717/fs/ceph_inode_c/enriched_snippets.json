[
  {
    "function_name": "ceph_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1990-2016",
    "snippet": "int ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\n\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_INODE_ALL, false);\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = ceph_translate_ino(inode->i_sb, inode->i_ino);\n\t\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\t\tstat->dev = ceph_snap(inode);\n\t\telse\n\t\t\tstat->dev = 0;\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tif (ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb),\n\t\t\t\t\t\tRBYTES))\n\t\t\t\tstat->size = ci->i_rbytes;\n\t\t\telse\n\t\t\t\tstat->size = ci->i_files + ci->i_subdirs;\n\t\t\tstat->blocks = 0;\n\t\t\tstat->blksize = 65536;\n\t\t}\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_test_mount_opt",
          "args": [
            "ceph_sb_to_client(inode->i_sb)",
            "RBYTES"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_translate_ino",
          "args": [
            "inode->i_sb",
            "inode->i_ino"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_translate_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "400-405",
          "snippet": "static inline ino_t ceph_translate_ino(struct super_block *sb, ino_t ino)\n{\n\tif (ceph_test_mount_opt(ceph_sb_to_client(sb), INO32))\n\t\tino = ceph_ino_to_ino32(ino);\n\treturn ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_translate_ino(struct super_block *sb, ino_t ino)\n{\n\tif (ceph_test_mount_opt(ceph_sb_to_client(sb), INO32))\n\t\tino = ceph_ino_to_ino32(ino);\n\treturn ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "inode",
            "CEPH_STAT_CAP_INODE_ALL",
            "false"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint err;\n\n\terr = ceph_do_getattr(inode, CEPH_STAT_CAP_INODE_ALL, false);\n\tif (!err) {\n\t\tgeneric_fillattr(inode, stat);\n\t\tstat->ino = ceph_translate_ino(inode->i_sb, inode->i_ino);\n\t\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\t\tstat->dev = ceph_snap(inode);\n\t\telse\n\t\t\tstat->dev = 0;\n\t\tif (S_ISDIR(inode->i_mode)) {\n\t\t\tif (ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb),\n\t\t\t\t\t\tRBYTES))\n\t\t\t\tstat->size = ci->i_rbytes;\n\t\t\telse\n\t\t\t\tstat->size = ci->i_files + ci->i_subdirs;\n\t\t\tstat->blocks = 0;\n\t\t\tstat->blksize = 65536;\n\t\t}\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1972-1984",
    "snippet": "int ceph_permission(struct inode *inode, int mask)\n{\n\tint err;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\terr = ceph_do_getattr(inode, CEPH_CAP_AUTH_SHARED, false);\n\n\tif (!err)\n\t\terr = generic_permission(inode, mask);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_do_getattr",
          "args": [
            "inode",
            "CEPH_CAP_AUTH_SHARED",
            "false"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_do_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "751-754",
          "snippet": "static inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_do_getattr(struct inode *inode, int mask, bool force)\n{\n\treturn __ceph_do_getattr(inode, NULL, mask, force);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_permission(struct inode *inode, int mask)\n{\n\tint err;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\terr = ceph_do_getattr(inode, CEPH_CAP_AUTH_SHARED, false);\n\n\tif (!err)\n\t\terr = generic_permission(inode, mask);\n\treturn err;\n}"
  },
  {
    "function_name": "__ceph_do_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1924-1965",
    "snippet": "int __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_getattr result=%d\\n\"",
            "err"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_GETATTR",
            "USE_ANY_MDS"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_caps_issued_mask",
          "args": [
            "ceph_inode(inode)",
            "mask",
            "1"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_caps_issued_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "540-548",
          "snippet": "static inline int ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask,\n\t\t\t\t\tint touch)\n{\n\tint r;\n\tspin_lock(&ci->i_ceph_lock);\n\tr = __ceph_caps_issued_mask(ci, mask, touch);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn r;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int ceph_caps_issued_mask(struct ceph_inode_info *ci, int mask,\n\t\t\t\t\tint touch)\n{\n\tint r;\n\tspin_lock(&ci->i_ceph_lock);\n\tr = __ceph_caps_issued_mask(ci, mask, touch);\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_getattr inode %p mask %s mode 0%o\\n\"",
            "inode",
            "ceph_cap_string(mask)",
            "inode->i_mode"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "mask"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"do_getattr inode %p SNAPDIR\\n\"",
            "inode"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_do_getattr(struct inode *inode, struct page *locked_page,\n\t\t      int mask, bool force)\n{\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct ceph_mds_request *req;\n\tint err;\n\n\tif (ceph_snap(inode) == CEPH_SNAPDIR) {\n\t\tdout(\"do_getattr inode %p SNAPDIR\\n\", inode);\n\t\treturn 0;\n\t}\n\n\tdout(\"do_getattr inode %p mask %s mode 0%o\\n\",\n\t     inode, ceph_cap_string(mask), inode->i_mode);\n\tif (!force && ceph_caps_issued_mask(ceph_inode(inode), mask, 1))\n\t\treturn 0;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_GETATTR, USE_ANY_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\treq->r_inode = inode;\n\tihold(inode);\n\treq->r_num_caps = 1;\n\treq->r_args.getattr.mask = cpu_to_le32(mask);\n\treq->r_locked_page = locked_page;\n\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\tif (locked_page && err == 0) {\n\t\tu64 inline_version = req->r_reply_info.targeti.inline_version;\n\t\tif (inline_version == 0) {\n\t\t\t/* the reply is supposed to contain inline data */\n\t\t\terr = -EINVAL;\n\t\t} else if (inline_version == CEPH_INLINE_NONE) {\n\t\t\terr = -ENODATA;\n\t\t} else {\n\t\t\terr = req->r_reply_info.targeti.inline_len;\n\t\t}\n\t}\n\tceph_mdsc_put_request(req);\n\tdout(\"do_getattr result=%d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1715-1918",
    "snippet": "int ceph_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tconst unsigned int ia_valid = attr->ia_valid;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;\n\tint issued;\n\tint release = 0, dirtied = 0;\n\tint mask = 0;\n\tint err = 0;\n\tint inode_dirty_flags = 0;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err != 0)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ia_valid & ATTR_UID) {\n\t\tdout(\"setattr %p uid %d -> %d\\n\", inode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kuid(&init_user_ns, attr->ia_uid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !uid_eq(attr->ia_uid, inode->i_uid)) {\n\t\t\treq->r_args.setattr.uid = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, attr->ia_uid));\n\t\t\tmask |= CEPH_SETATTR_UID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tdout(\"setattr %p gid %d -> %d\\n\", inode,\n\t\t     from_kgid(&init_user_ns, inode->i_gid),\n\t\t     from_kgid(&init_user_ns, attr->ia_gid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !gid_eq(attr->ia_gid, inode->i_gid)) {\n\t\t\treq->r_args.setattr.gid = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, attr->ia_gid));\n\t\t\tmask |= CEPH_SETATTR_GID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MODE) {\n\t\tdout(\"setattr %p mode 0%o -> 0%o\\n\", inode, inode->i_mode,\n\t\t     attr->ia_mode);\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   attr->ia_mode != inode->i_mode) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\treq->r_args.setattr.mode = cpu_to_le32(attr->ia_mode);\n\t\t\tmask |= CEPH_SETATTR_MODE;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\n\tif (ia_valid & ATTR_ATIME) {\n\t\tdout(\"setattr %p atime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,\n\t\t     attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_atime,\n\t\t\t\t\t    &attr->ia_atime) < 0) {\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_atime, &attr->ia_atime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.atime,\n\t\t\t\t\t     &attr->ia_atime);\n\t\t\tmask |= CEPH_SETATTR_ATIME;\n\t\t\trelease |= CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MTIME) {\n\t\tdout(\"setattr %p mtime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t     attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_mtime,\n\t\t\t\t\t    &attr->ia_mtime) < 0) {\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_mtime, &attr->ia_mtime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.mtime,\n\t\t\t\t\t     &attr->ia_mtime);\n\t\t\tmask |= CEPH_SETATTR_MTIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tdout(\"setattr %p size %lld -> %lld\\n\", inode,\n\t\t     inode->i_size, attr->ia_size);\n\t\tif ((issued & CEPH_CAP_FILE_EXCL) &&\n\t\t    attr->ia_size > inode->i_size) {\n\t\t\tinode->i_size = attr->ia_size;\n\t\t\tinode->i_blocks =\n\t\t\t\t(attr->ia_size + (1 << 9) - 1) >> 9;\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t\tci->i_reported_size = attr->ia_size;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   attr->ia_size != inode->i_size) {\n\t\t\treq->r_args.setattr.size = cpu_to_le64(attr->ia_size);\n\t\t\treq->r_args.setattr.old_size =\n\t\t\t\tcpu_to_le64(inode->i_size);\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\n\t/* these do nothing */\n\tif (ia_valid & ATTR_CTIME) {\n\t\tbool only = (ia_valid & (ATTR_SIZE|ATTR_MTIME|ATTR_ATIME|\n\t\t\t\t\t ATTR_MODE|ATTR_UID|ATTR_GID)) == 0;\n\t\tdout(\"setattr %p ctime %ld.%ld -> %ld.%ld (%s)\\n\", inode,\n\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t     attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec,\n\t\t     only ? \"ctime only\" : \"ignored\");\n\t\tinode->i_ctime = attr->ia_ctime;\n\t\tif (only) {\n\t\t\t/*\n\t\t\t * if kernel wants to dirty ctime but nothing else,\n\t\t\t * we need to choose a cap to dirty under, or do\n\t\t\t * a almost-no-op setattr\n\t\t\t */\n\t\t\tif (issued & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\telse if (issued & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\telse if (issued & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_XATTR_EXCL;\n\t\t\telse\n\t\t\t\tmask |= CEPH_SETATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_FILE)\n\t\tdout(\"setattr %p ATTR_FILE ... hrm!\\n\", inode);\n\n\tif (dirtied) {\n\t\tinode_dirty_flags = __ceph_mark_dirty_caps(ci, dirtied);\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\trelease &= issued;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (inode_dirty_flags)\n\t\t__mark_inode_dirty(inode, inode_dirty_flags);\n\n\tif (ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, attr->ia_mode);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\tif (mask) {\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_inode_drop = release;\n\t\treq->r_args.setattr.mask = cpu_to_le32(mask);\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t}\n\tdout(\"setattr %p result=%d (%s locally, %d remote)\\n\", inode, err,\n\t     ceph_cap_string(dirtied), mask);\n\n\tceph_mdsc_put_request(req);\n\tif (mask & CEPH_SETATTR_SIZE)\n\t\t__ceph_do_pending_vmtruncate(inode);\n\treturn err;\nout_put:\n\tceph_mdsc_put_request(req);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_mdsc_put_request",
          "args": [
            "req"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_put_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "377-380",
          "snippet": "static inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline void ceph_mdsc_put_request(struct ceph_mds_request *req)\n{\n\tkref_put(&req->r_kref, ceph_mdsc_release_request);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_do_pending_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_pending_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1634-1689",
          "snippet": "void __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p result=%d (%s locally, %d remote)\\n\"",
            "inode",
            "err",
            "ceph_cap_string(dirtied)",
            "mask"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "dirtied"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_do_request",
          "args": [
            "mdsc",
            "NULL",
            "req"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_do_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2212-2284",
          "snippet": "int ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __wake_requests(struct ceph_mds_client *mdsc,\n\t\t\t    struct list_head *head);\n\nint ceph_mdsc_do_request(struct ceph_mds_client *mdsc,\n\t\t\t struct inode *dir,\n\t\t\t struct ceph_mds_request *req)\n{\n\tint err;\n\n\tdout(\"do_request on %p\\n\", req);\n\n\t/* take CAP_PIN refs for r_inode, r_locked_dir, r_old_dentry */\n\tif (req->r_inode)\n\t\tceph_get_cap_refs(ceph_inode(req->r_inode), CEPH_CAP_PIN);\n\tif (req->r_locked_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_locked_dir), CEPH_CAP_PIN);\n\tif (req->r_old_dentry_dir)\n\t\tceph_get_cap_refs(ceph_inode(req->r_old_dentry_dir),\n\t\t\t\t  CEPH_CAP_PIN);\n\n\t/* issue */\n\tmutex_lock(&mdsc->mutex);\n\t__register_request(mdsc, req, dir);\n\t__do_request(mdsc, req);\n\n\tif (req->r_err) {\n\t\terr = req->r_err;\n\t\t__unregister_request(mdsc, req);\n\t\tdout(\"do_request early error %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* wait */\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request waiting\\n\");\n\tif (req->r_timeout) {\n\t\terr = (long)wait_for_completion_killable_timeout(\n\t\t\t&req->r_completion, req->r_timeout);\n\t\tif (err == 0)\n\t\t\terr = -EIO;\n\t} else if (req->r_wait_for_completion) {\n\t\terr = req->r_wait_for_completion(mdsc, req);\n\t} else {\n\t\terr = wait_for_completion_killable(&req->r_completion);\n\t}\n\tdout(\"do_request waited, got %d\\n\", err);\n\tmutex_lock(&mdsc->mutex);\n\n\t/* only abort if we didn't race with a real reply */\n\tif (req->r_got_result) {\n\t\terr = le32_to_cpu(req->r_reply_info.head->result);\n\t} else if (err < 0) {\n\t\tdout(\"aborted request %lld with %d\\n\", req->r_tid, err);\n\n\t\t/*\n\t\t * ensure we aren't running concurrently with\n\t\t * ceph_fill_trace or ceph_readdir_prepopulate, which\n\t\t * rely on locks (dir mutex) held by our caller.\n\t\t */\n\t\tmutex_lock(&req->r_fill_mutex);\n\t\treq->r_err = err;\n\t\treq->r_aborted = true;\n\t\tmutex_unlock(&req->r_fill_mutex);\n\n\t\tif (req->r_locked_dir &&\n\t\t    (req->r_op & CEPH_MDS_OP_WRITE))\n\t\t\tceph_invalidate_dir_request(req);\n\t} else {\n\t\terr = req->r_err;\n\t}\n\nout:\n\tmutex_unlock(&mdsc->mutex);\n\tdout(\"do_request %p done, result %d\\n\", req, err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "mask"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "attr->ia_mode"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "inode_dirty_flags"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_mark_dirty_caps",
          "args": [
            "ci",
            "dirtied"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_mark_dirty_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1389-1423",
          "snippet": "int __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_mark_dirty_caps(struct ceph_inode_info *ci, int mask)\n{\n\tstruct ceph_mds_client *mdsc =\n\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tint was = ci->i_dirty_caps;\n\tint dirty = 0;\n\n\tdout(\"__mark_dirty_caps %p %s dirty %s -> %s\\n\", &ci->vfs_inode,\n\t     ceph_cap_string(mask), ceph_cap_string(was),\n\t     ceph_cap_string(was | mask));\n\tci->i_dirty_caps |= mask;\n\tif (was == 0) {\n\t\tif (!ci->i_head_snapc)\n\t\t\tci->i_head_snapc = ceph_get_snap_context(\n\t\t\t\tci->i_snap_realm->cached_context);\n\t\tdout(\" inode %p now dirty snapc %p auth cap %p\\n\",\n\t\t     &ci->vfs_inode, ci->i_head_snapc, ci->i_auth_cap);\n\t\tWARN_ON(!ci->i_auth_cap);\n\t\tBUG_ON(!list_empty(&ci->i_dirty_item));\n\t\tspin_lock(&mdsc->cap_dirty_lock);\n\t\tlist_add(&ci->i_dirty_item, &mdsc->cap_dirty);\n\t\tspin_unlock(&mdsc->cap_dirty_lock);\n\t\tif (ci->i_flushing_caps == 0) {\n\t\t\tihold(inode);\n\t\t\tdirty |= I_DIRTY_SYNC;\n\t\t}\n\t}\n\tBUG_ON(list_empty(&ci->i_dirty_item));\n\tif (((was | ci->i_flushing_caps) & CEPH_CAP_FILE_BUFFER) &&\n\t    (mask & CEPH_CAP_FILE_BUFFER))\n\t\tdirty |= I_DIRTY_DATASYNC;\n\t__cap_delay_requeue(mdsc, ci);\n\treturn dirty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p ATTR_FILE ... hrm!\\n\"",
            "inode"
          ],
          "line": 1881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p ctime %ld.%ld -> %ld.%ld (%s)\\n\"",
            "inode",
            "inode->i_ctime.tv_sec",
            "inode->i_ctime.tv_nsec",
            "attr->ia_ctime.tv_sec",
            "attr->ia_ctime.tv_nsec",
            "only ? \"ctime only\" : \"ignored\""
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_size"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "attr->ia_size"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p size %lld -> %lld\\n\"",
            "inode",
            "inode->i_size",
            "attr->ia_size"
          ],
          "line": 1834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&req->r_args.setattr.mtime",
            "&attr->ia_mtime"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_mtime",
            "&attr->ia_mtime"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_mtime",
            "&attr->ia_mtime"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p mtime %ld.%ld -> %ld.%ld\\n\"",
            "inode",
            "inode->i_mtime.tv_sec",
            "inode->i_mtime.tv_nsec",
            "attr->ia_mtime.tv_sec",
            "attr->ia_mtime.tv_nsec"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_encode_timespec",
          "args": [
            "&req->r_args.setattr.atime",
            "&attr->ia_atime"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_equal",
          "args": [
            "&inode->i_atime",
            "&attr->ia_atime"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_atime",
            "&attr->ia_atime"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p atime %ld.%ld -> %ld.%ld\\n\"",
            "inode",
            "inode->i_atime.tv_sec",
            "inode->i_atime.tv_nsec",
            "attr->ia_atime.tv_sec",
            "attr->ia_atime.tv_nsec"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "attr->ia_mode"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p mode 0%o -> 0%o\\n\"",
            "inode",
            "inode->i_mode",
            "attr->ia_mode"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns, attr->ia_gid)"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p gid %d -> %d\\n\"",
            "inode",
            "from_kgid(&init_user_ns, inode->i_gid)",
            "from_kgid(&init_user_ns, attr->ia_gid)"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "inode->i_gid"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns, attr->ia_uid)"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "inode->i_uid"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p uid %d -> %d\\n\"",
            "inode",
            "from_kuid(&init_user_ns, inode->i_uid)",
            "from_kuid(&init_user_ns, attr->ia_uid)"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "inode->i_uid"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"setattr %p issued %s\\n\"",
            "inode",
            "ceph_cap_string(issued)"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "NULL"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mdsc_create_request",
          "args": [
            "mdsc",
            "CEPH_MDS_OP_SETATTR",
            "USE_AUTH_MDS"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mdsc_create_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "1640-1665",
          "snippet": "struct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_mds_request *\nceph_mdsc_create_request(struct ceph_mds_client *mdsc, int op, int mode)\n{\n\tstruct ceph_mds_request *req = kzalloc(sizeof(*req), GFP_NOFS);\n\n\tif (!req)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&req->r_fill_mutex);\n\treq->r_mdsc = mdsc;\n\treq->r_started = jiffies;\n\treq->r_resend_mds = -1;\n\tINIT_LIST_HEAD(&req->r_unsafe_dir_item);\n\treq->r_fmode = -1;\n\tkref_init(&req->r_kref);\n\tINIT_LIST_HEAD(&req->r_wait);\n\tinit_completion(&req->r_completion);\n\tinit_completion(&req->r_safe_completion);\n\tINIT_LIST_HEAD(&req->r_unsafe_item);\n\n\treq->r_stamp = CURRENT_TIME;\n\n\treq->r_op = op;\n\treq->r_direct_mode = mode;\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tconst unsigned int ia_valid = attr->ia_valid;\n\tstruct ceph_mds_request *req;\n\tstruct ceph_mds_client *mdsc = ceph_sb_to_client(dentry->d_sb)->mdsc;\n\tint issued;\n\tint release = 0, dirtied = 0;\n\tint mask = 0;\n\tint err = 0;\n\tint inode_dirty_flags = 0;\n\n\tif (ceph_snap(inode) != CEPH_NOSNAP)\n\t\treturn -EROFS;\n\n\terr = inode_change_ok(inode, attr);\n\tif (err != 0)\n\t\treturn err;\n\n\treq = ceph_mdsc_create_request(mdsc, CEPH_MDS_OP_SETATTR,\n\t\t\t\t       USE_AUTH_MDS);\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tissued = __ceph_caps_issued(ci, NULL);\n\tdout(\"setattr %p issued %s\\n\", inode, ceph_cap_string(issued));\n\n\tif (ia_valid & ATTR_UID) {\n\t\tdout(\"setattr %p uid %d -> %d\\n\", inode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kuid(&init_user_ns, attr->ia_uid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !uid_eq(attr->ia_uid, inode->i_uid)) {\n\t\t\treq->r_args.setattr.uid = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, attr->ia_uid));\n\t\t\tmask |= CEPH_SETATTR_UID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_GID) {\n\t\tdout(\"setattr %p gid %d -> %d\\n\", inode,\n\t\t     from_kgid(&init_user_ns, inode->i_gid),\n\t\t     from_kgid(&init_user_ns, attr->ia_gid));\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   !gid_eq(attr->ia_gid, inode->i_gid)) {\n\t\t\treq->r_args.setattr.gid = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, attr->ia_gid));\n\t\t\tmask |= CEPH_SETATTR_GID;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MODE) {\n\t\tdout(\"setattr %p mode 0%o -> 0%o\\n\", inode, inode->i_mode,\n\t\t     attr->ia_mode);\n\t\tif (issued & CEPH_CAP_AUTH_EXCL) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t} else if ((issued & CEPH_CAP_AUTH_SHARED) == 0 ||\n\t\t\t   attr->ia_mode != inode->i_mode) {\n\t\t\tinode->i_mode = attr->ia_mode;\n\t\t\treq->r_args.setattr.mode = cpu_to_le32(attr->ia_mode);\n\t\t\tmask |= CEPH_SETATTR_MODE;\n\t\t\trelease |= CEPH_CAP_AUTH_SHARED;\n\t\t}\n\t}\n\n\tif (ia_valid & ATTR_ATIME) {\n\t\tdout(\"setattr %p atime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_atime.tv_sec, inode->i_atime.tv_nsec,\n\t\t     attr->ia_atime.tv_sec, attr->ia_atime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_atime,\n\t\t\t\t\t    &attr->ia_atime) < 0) {\n\t\t\tinode->i_atime = attr->ia_atime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_atime, &attr->ia_atime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.atime,\n\t\t\t\t\t     &attr->ia_atime);\n\t\t\tmask |= CEPH_SETATTR_ATIME;\n\t\t\trelease |= CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_MTIME) {\n\t\tdout(\"setattr %p mtime %ld.%ld -> %ld.%ld\\n\", inode,\n\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t     attr->ia_mtime.tv_sec, attr->ia_mtime.tv_nsec);\n\t\tif (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\tci->i_time_warp_seq++;\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_WR) &&\n\t\t\t   timespec_compare(&inode->i_mtime,\n\t\t\t\t\t    &attr->ia_mtime) < 0) {\n\t\t\tinode->i_mtime = attr->ia_mtime;\n\t\t\tdirtied |= CEPH_CAP_FILE_WR;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   !timespec_equal(&inode->i_mtime, &attr->ia_mtime)) {\n\t\t\tceph_encode_timespec(&req->r_args.setattr.mtime,\n\t\t\t\t\t     &attr->ia_mtime);\n\t\t\tmask |= CEPH_SETATTR_MTIME;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_SIZE) {\n\t\tdout(\"setattr %p size %lld -> %lld\\n\", inode,\n\t\t     inode->i_size, attr->ia_size);\n\t\tif ((issued & CEPH_CAP_FILE_EXCL) &&\n\t\t    attr->ia_size > inode->i_size) {\n\t\t\tinode->i_size = attr->ia_size;\n\t\t\tinode->i_blocks =\n\t\t\t\t(attr->ia_size + (1 << 9) - 1) >> 9;\n\t\t\tinode->i_ctime = attr->ia_ctime;\n\t\t\tci->i_reported_size = attr->ia_size;\n\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t} else if ((issued & CEPH_CAP_FILE_SHARED) == 0 ||\n\t\t\t   attr->ia_size != inode->i_size) {\n\t\t\treq->r_args.setattr.size = cpu_to_le64(attr->ia_size);\n\t\t\treq->r_args.setattr.old_size =\n\t\t\t\tcpu_to_le64(inode->i_size);\n\t\t\tmask |= CEPH_SETATTR_SIZE;\n\t\t\trelease |= CEPH_CAP_FILE_SHARED | CEPH_CAP_FILE_RD |\n\t\t\t\tCEPH_CAP_FILE_WR;\n\t\t}\n\t}\n\n\t/* these do nothing */\n\tif (ia_valid & ATTR_CTIME) {\n\t\tbool only = (ia_valid & (ATTR_SIZE|ATTR_MTIME|ATTR_ATIME|\n\t\t\t\t\t ATTR_MODE|ATTR_UID|ATTR_GID)) == 0;\n\t\tdout(\"setattr %p ctime %ld.%ld -> %ld.%ld (%s)\\n\", inode,\n\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t     attr->ia_ctime.tv_sec, attr->ia_ctime.tv_nsec,\n\t\t     only ? \"ctime only\" : \"ignored\");\n\t\tinode->i_ctime = attr->ia_ctime;\n\t\tif (only) {\n\t\t\t/*\n\t\t\t * if kernel wants to dirty ctime but nothing else,\n\t\t\t * we need to choose a cap to dirty under, or do\n\t\t\t * a almost-no-op setattr\n\t\t\t */\n\t\t\tif (issued & CEPH_CAP_AUTH_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_AUTH_EXCL;\n\t\t\telse if (issued & CEPH_CAP_FILE_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_FILE_EXCL;\n\t\t\telse if (issued & CEPH_CAP_XATTR_EXCL)\n\t\t\t\tdirtied |= CEPH_CAP_XATTR_EXCL;\n\t\t\telse\n\t\t\t\tmask |= CEPH_SETATTR_CTIME;\n\t\t}\n\t}\n\tif (ia_valid & ATTR_FILE)\n\t\tdout(\"setattr %p ATTR_FILE ... hrm!\\n\", inode);\n\n\tif (dirtied) {\n\t\tinode_dirty_flags = __ceph_mark_dirty_caps(ci, dirtied);\n\t\tinode->i_ctime = CURRENT_TIME;\n\t}\n\n\trelease &= issued;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (inode_dirty_flags)\n\t\t__mark_inode_dirty(inode, inode_dirty_flags);\n\n\tif (ia_valid & ATTR_MODE) {\n\t\terr = posix_acl_chmod(inode, attr->ia_mode);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\n\n\tif (mask) {\n\t\treq->r_inode = inode;\n\t\tihold(inode);\n\t\treq->r_inode_drop = release;\n\t\treq->r_args.setattr.mask = cpu_to_le32(mask);\n\t\treq->r_num_caps = 1;\n\t\terr = ceph_mdsc_do_request(mdsc, NULL, req);\n\t}\n\tdout(\"setattr %p result=%d (%s locally, %d remote)\\n\", inode, err,\n\t     ceph_cap_string(dirtied), mask);\n\n\tceph_mdsc_put_request(req);\n\tif (mask & CEPH_SETATTR_SIZE)\n\t\t__ceph_do_pending_vmtruncate(inode);\n\treturn err;\nout_put:\n\tceph_mdsc_put_request(req);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_sym_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1694-1699",
    "snippet": "static void *ceph_sym_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dentry->d_inode);\n\tnd_set_link(nd, ci->i_symlink);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "ci->i_symlink"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void *ceph_sym_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(dentry->d_inode);\n\tnd_set_link(nd, ci->i_symlink);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__ceph_do_pending_vmtruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1634-1689",
    "snippet": "void __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "CHECK_CAPS_AUTHONLY",
            "NULL"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "to"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__do_pending_vmtruncate %p (%d) to %lld\\n\"",
            "inode",
            "ci->i_truncate_pending",
            "to"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ci->i_rd_ref || ci->i_wr_ref"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "&inode->i_data",
            "0",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__do_pending_vmtruncate %p flushing snaps first\\n\"",
            "inode"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"__do_pending_vmtruncate %p none pending\\n\"",
            "inode"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}"
  },
  {
    "function_name": "ceph_queue_vmtruncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1614-1628",
    "snippet": "void ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_vmtruncate %p failed, pending=%d\\n\"",
            "inode",
            "ci->i_truncate_pending"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_vmtruncate %p\\n\"",
            "inode"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ceph_sb_to_client(inode->i_sb)->trunc_wq",
            "&ci->i_vmtruncate_work"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "inode->i_sb"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "ceph_vmtruncate_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1599-1608",
    "snippet": "static void ceph_vmtruncate_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_vmtruncate_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tdout(\"vmtruncate_work %p\\n\", inode);\n\t__ceph_do_pending_vmtruncate(inode);\n\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ceph_invalidate_work(struct work_struct *work);",
      "static void ceph_writeback_work(struct work_struct *work);",
      "static void ceph_vmtruncate_work(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_do_pending_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_do_pending_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1634-1689",
          "snippet": "void __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid __ceph_do_pending_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tu64 to;\n\tint wrbuffer_refs, finish = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\nretry:\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_truncate_pending == 0) {\n\t\tdout(\"__do_pending_vmtruncate %p none pending\\n\", inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\treturn;\n\t}\n\n\t/*\n\t * make sure any dirty snapped pages are flushed before we\n\t * possibly truncate them.. so write AND block!\n\t */\n\tif (ci->i_wrbuffer_ref_head < ci->i_wrbuffer_ref) {\n\t\tdout(\"__do_pending_vmtruncate %p flushing snaps first\\n\",\n\t\t     inode);\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tfilemap_write_and_wait_range(&inode->i_data, 0,\n\t\t\t\t\t     inode->i_sb->s_maxbytes);\n\t\tgoto retry;\n\t}\n\n\t/* there should be no reader or writer */\n\tWARN_ON_ONCE(ci->i_rd_ref || ci->i_wr_ref);\n\n\tto = ci->i_truncate_size;\n\twrbuffer_refs = ci->i_wrbuffer_ref;\n\tdout(\"__do_pending_vmtruncate %p (%d) to %lld\\n\", inode,\n\t     ci->i_truncate_pending, to);\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, to);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (to == ci->i_truncate_size) {\n\t\tci->i_truncate_pending = 0;\n\t\tfinish = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tif (!finish)\n\t\tgoto retry;\n\n\tmutex_unlock(&ci->i_truncate_mutex);\n\n\tif (wrbuffer_refs == 0)\n\t\tceph_check_caps(ci, CHECK_CAPS_AUTHONLY, NULL);\n\n\twake_up_all(&ci->i_cap_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"vmtruncate_work %p\\n\"",
            "inode"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structceph_inode_info",
            "i_vmtruncate_work"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_invalidate_work(struct work_struct *work);\nstatic void ceph_writeback_work(struct work_struct *work);\nstatic void ceph_vmtruncate_work(struct work_struct *work);\n\nstatic void ceph_vmtruncate_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_vmtruncate_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tdout(\"vmtruncate_work %p\\n\", inode);\n\t__ceph_do_pending_vmtruncate(inode);\n\tiput(inode);\n}"
  },
  {
    "function_name": "ceph_invalidate_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1547-1591",
    "snippet": "static void ceph_invalidate_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_pg_inv_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\tu32 orig_gen;\n\tint check = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"invalidate_pages %p gen %d revoking %d\\n\", inode,\n\t     ci->i_rdcache_gen, ci->i_rdcache_revoking);\n\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\tgoto out;\n\t}\n\torig_gen = ci->i_rdcache_gen;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, 0);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (orig_gen == ci->i_rdcache_gen &&\n\t    orig_gen == ci->i_rdcache_revoking) {\n\t\tdout(\"invalidate_pages %p gen %d successful\\n\", inode,\n\t\t     ci->i_rdcache_gen);\n\t\tci->i_rdcache_revoking--;\n\t\tcheck = 1;\n\t} else {\n\t\tdout(\"invalidate_pages %p gen %d raced, now %d revoking %d\\n\",\n\t\t     inode, orig_gen, ci->i_rdcache_gen,\n\t\t     ci->i_rdcache_revoking);\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&ci->i_truncate_mutex);\nout:\n\tif (check)\n\t\tceph_check_caps(ci, 0, NULL);\n\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ceph_invalidate_work(struct work_struct *work);",
      "static void ceph_writeback_work(struct work_struct *work);",
      "static void ceph_vmtruncate_work(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_check_caps",
          "args": [
            "ci",
            "0",
            "NULL"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_check_caps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1504-1751",
          "snippet": "void ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_check_caps(struct ceph_inode_info *ci, int flags,\n\t\t     struct ceph_mds_session *session)\n{\n\tstruct ceph_fs_client *fsc = ceph_inode_to_client(&ci->vfs_inode);\n\tstruct ceph_mds_client *mdsc = fsc->mdsc;\n\tstruct inode *inode = &ci->vfs_inode;\n\tstruct ceph_cap *cap;\n\tint file_wanted, used, cap_used;\n\tint took_snap_rwsem = 0;             /* true if mdsc->snap_rwsem held */\n\tint issued, implemented, want, retain, revoking, flushing = 0;\n\tint mds = -1;   /* keep track of how far we've gone through i_caps list\n\t\t\t   to avoid an infinite loop on retry */\n\tstruct rb_node *p;\n\tint tried_invalidate = 0;\n\tint delayed = 0, sent = 0, force_requeue = 0, num;\n\tint queue_invalidate = 0;\n\tint is_delayed = flags & CHECK_CAPS_NODELAY;\n\n\t/* if we are unmounting, flush any unused caps immediately. */\n\tif (mdsc->stopping)\n\t\tis_delayed = 1;\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\tif (ci->i_ceph_flags & CEPH_I_FLUSH)\n\t\tflags |= CHECK_CAPS_FLUSH;\n\n\t/* flush snaps first time around only */\n\tif (!list_empty(&ci->i_cap_snaps))\n\t\t__ceph_flush_snaps(ci, &session, 0);\n\tgoto retry_locked;\nretry:\n\tspin_lock(&ci->i_ceph_lock);\nretry_locked:\n\tfile_wanted = __ceph_caps_file_wanted(ci);\n\tused = __ceph_caps_used(ci);\n\twant = file_wanted | used;\n\tissued = __ceph_caps_issued(ci, &implemented);\n\trevoking = implemented & ~issued;\n\n\tretain = want | CEPH_CAP_PIN;\n\tif (!mdsc->stopping && inode->i_nlink > 0) {\n\t\tif (want) {\n\t\t\tretain |= CEPH_CAP_ANY;       /* be greedy */\n\t\t} else {\n\t\t\tretain |= CEPH_CAP_ANY_SHARED;\n\t\t\t/*\n\t\t\t * keep RD only if we didn't have the file open RW,\n\t\t\t * because then the mds would revoke it anyway to\n\t\t\t * journal max_size=0.\n\t\t\t */\n\t\t\tif (ci->i_max_size == 0)\n\t\t\t\tretain |= CEPH_CAP_ANY_RD;\n\t\t}\n\t}\n\n\tdout(\"check_caps %p file_want %s used %s dirty %s flushing %s\"\n\t     \" issued %s revoking %s retain %s %s%s%s\\n\", inode,\n\t     ceph_cap_string(file_wanted),\n\t     ceph_cap_string(used), ceph_cap_string(ci->i_dirty_caps),\n\t     ceph_cap_string(ci->i_flushing_caps),\n\t     ceph_cap_string(issued), ceph_cap_string(revoking),\n\t     ceph_cap_string(retain),\n\t     (flags & CHECK_CAPS_AUTHONLY) ? \" AUTHONLY\" : \"\",\n\t     (flags & CHECK_CAPS_NODELAY) ? \" NODELAY\" : \"\",\n\t     (flags & CHECK_CAPS_FLUSH) ? \" FLUSH\" : \"\");\n\n\t/*\n\t * If we no longer need to hold onto old our caps, and we may\n\t * have cached pages, but don't want them, then try to invalidate.\n\t * If we fail, it's because pages are locked.... try again later.\n\t */\n\tif ((!is_delayed || mdsc->stopping) &&\n\t    ci->i_wrbuffer_ref == 0 &&               /* no dirty pages... */\n\t    inode->i_data.nrpages &&                 /* have cached pages */\n\t    (file_wanted == 0 ||                     /* no open files */\n\t     (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t  CEPH_CAP_FILE_LAZYIO))) && /*  or revoking cache */\n\t    !tried_invalidate) {\n\t\tdout(\"check_caps trying to invalidate on %p\\n\", inode);\n\t\tif (try_nonblocking_invalidate(inode) < 0) {\n\t\t\tif (revoking & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t\tCEPH_CAP_FILE_LAZYIO)) {\n\t\t\t\tdout(\"check_caps queuing invalidate\\n\");\n\t\t\t\tqueue_invalidate = 1;\n\t\t\t\tci->i_rdcache_revoking = ci->i_rdcache_gen;\n\t\t\t} else {\n\t\t\t\tdout(\"check_caps failed to invalidate pages\\n\");\n\t\t\t\t/* we failed to invalidate pages.  check these\n\t\t\t\t   caps again later. */\n\t\t\t\tforce_requeue = 1;\n\t\t\t\t__cap_set_timeouts(mdsc, ci);\n\t\t\t}\n\t\t}\n\t\ttried_invalidate = 1;\n\t\tgoto retry_locked;\n\t}\n\n\tnum = 0;\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tnum++;\n\n\t\t/* avoid looping forever */\n\t\tif (mds >= cap->mds ||\n\t\t    ((flags & CHECK_CAPS_AUTHONLY) && cap != ci->i_auth_cap))\n\t\t\tcontinue;\n\n\t\t/* NOTE: no side-effects allowed, until we take s_mutex */\n\n\t\tcap_used = used;\n\t\tif (ci->i_auth_cap && cap != ci->i_auth_cap)\n\t\t\tcap_used &= ~ci->i_auth_cap->issued;\n\n\t\trevoking = cap->implemented & ~cap->issued;\n\t\tdout(\" mds%d cap %p used %s issued %s implemented %s revoking %s\\n\",\n\t\t     cap->mds, cap, ceph_cap_string(cap->issued),\n\t\t     ceph_cap_string(cap_used),\n\t\t     ceph_cap_string(cap->implemented),\n\t\t     ceph_cap_string(revoking));\n\n\t\tif (cap == ci->i_auth_cap &&\n\t\t    (cap->issued & CEPH_CAP_FILE_WR)) {\n\t\t\t/* request larger max_size from MDS? */\n\t\t\tif (ci->i_wanted_max_size > ci->i_max_size &&\n\t\t\t    ci->i_wanted_max_size > ci->i_requested_max_size) {\n\t\t\t\tdout(\"requesting new max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\n\t\t\t/* approaching file_max? */\n\t\t\tif ((inode->i_size << 1) >= ci->i_max_size &&\n\t\t\t    (ci->i_reported_size << 1) < ci->i_max_size) {\n\t\t\t\tdout(\"i_size approaching max_size\\n\");\n\t\t\t\tgoto ack;\n\t\t\t}\n\t\t}\n\t\t/* flush anything dirty? */\n\t\tif (cap == ci->i_auth_cap && (flags & CHECK_CAPS_FLUSH) &&\n\t\t    ci->i_dirty_caps) {\n\t\t\tdout(\"flushing dirty caps\\n\");\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* completed revocation? going down and there are no caps? */\n\t\tif (revoking && (revoking & cap_used) == 0) {\n\t\t\tdout(\"completed revocation of %s\\n\",\n\t\t\t     ceph_cap_string(cap->implemented & ~cap->issued));\n\t\t\tgoto ack;\n\t\t}\n\n\t\t/* want more caps from mds? */\n\t\tif (want & ~(cap->mds_wanted | cap->issued))\n\t\t\tgoto ack;\n\n\t\t/* things we might delay */\n\t\tif ((cap->issued & ~retain) == 0 &&\n\t\t    cap->mds_wanted == want)\n\t\t\tcontinue;     /* nope, all good */\n\n\t\tif (is_delayed)\n\t\t\tgoto ack;\n\n\t\t/* delay? */\n\t\tif ((ci->i_ceph_flags & CEPH_I_NODELAY) == 0 &&\n\t\t    time_before(jiffies, ci->i_hold_caps_max)) {\n\t\t\tdout(\" delaying issued %s -> %s, wanted %s -> %s\\n\",\n\t\t\t     ceph_cap_string(cap->issued),\n\t\t\t     ceph_cap_string(cap->issued & retain),\n\t\t\t     ceph_cap_string(cap->mds_wanted),\n\t\t\t     ceph_cap_string(want));\n\t\t\tdelayed++;\n\t\t\tcontinue;\n\t\t}\n\nack:\n\t\tif (ci->i_ceph_flags & CEPH_I_NOFLUSH) {\n\t\t\tdout(\" skipping %p I_NOFLUSH set\\n\", inode);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (session && session != cap->session) {\n\t\t\tdout(\"oops, wrong session %p mutex\\n\", session);\n\t\t\tmutex_unlock(&session->s_mutex);\n\t\t\tsession = NULL;\n\t\t}\n\t\tif (!session) {\n\t\t\tsession = cap->session;\n\t\t\tif (mutex_trylock(&session->s_mutex) == 0) {\n\t\t\t\tdout(\"inverting session/ino locks on %p\\n\",\n\t\t\t\t     session);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tif (took_snap_rwsem) {\n\t\t\t\t\tup_read(&mdsc->snap_rwsem);\n\t\t\t\t\ttook_snap_rwsem = 0;\n\t\t\t\t}\n\t\t\t\tmutex_lock(&session->s_mutex);\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\t\t/* take snap_rwsem after session mutex */\n\t\tif (!took_snap_rwsem) {\n\t\t\tif (down_read_trylock(&mdsc->snap_rwsem) == 0) {\n\t\t\t\tdout(\"inverting snap/in locks on %p\\n\",\n\t\t\t\t     inode);\n\t\t\t\tspin_unlock(&ci->i_ceph_lock);\n\t\t\t\tdown_read(&mdsc->snap_rwsem);\n\t\t\t\ttook_snap_rwsem = 1;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\ttook_snap_rwsem = 1;\n\t\t}\n\n\t\tif (cap == ci->i_auth_cap && ci->i_dirty_caps)\n\t\t\tflushing = __mark_caps_flushing(inode, session);\n\t\telse\n\t\t\tflushing = 0;\n\n\t\tmds = cap->mds;  /* remember mds, so we don't repeat */\n\t\tsent++;\n\n\t\t/* __send_cap drops i_ceph_lock */\n\t\tdelayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, cap_used,\n\t\t\t\t      want, retain, flushing, NULL);\n\t\tgoto retry; /* retake i_ceph_lock and restart our cap scan. */\n\t}\n\n\t/*\n\t * Reschedule delayed caps release if we delayed anything,\n\t * otherwise cancel.\n\t */\n\tif (delayed && is_delayed)\n\t\tforce_requeue = 1;   /* __send_cap delayed release; requeue */\n\tif (!delayed && !is_delayed)\n\t\t__cap_delay_cancel(mdsc, ci);\n\telse if (!is_delayed || force_requeue)\n\t\t__cap_delay_requeue(mdsc, ci);\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (queue_invalidate)\n\t\tceph_queue_invalidate(inode);\n\n\tif (session)\n\t\tmutex_unlock(&session->s_mutex);\n\tif (took_snap_rwsem)\n\t\tup_read(&mdsc->snap_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_revoking_other",
          "args": [
            "ci",
            "NULL",
            "CEPH_CAP_FILE_CACHE"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_revoking_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "801-814",
          "snippet": "int __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_revoking_other(struct ceph_inode_info *ci,\n\t\t\t       struct ceph_cap *ocap, int mask)\n{\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap != ocap &&\n\t\t    (cap->implemented & ~cap->issued & mask))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_pages %p gen %d raced, now %d revoking %d\\n\"",
            "inode",
            "orig_gen",
            "ci->i_rdcache_gen",
            "ci->i_rdcache_revoking"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_pages %p gen %d successful\\n\"",
            "inode",
            "ci->i_rdcache_gen"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "0"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"invalidate_pages %p gen %d revoking %d\\n\"",
            "inode",
            "ci->i_rdcache_gen",
            "ci->i_rdcache_revoking"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structceph_inode_info",
            "i_pg_inv_work"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_invalidate_work(struct work_struct *work);\nstatic void ceph_writeback_work(struct work_struct *work);\nstatic void ceph_vmtruncate_work(struct work_struct *work);\n\nstatic void ceph_invalidate_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_pg_inv_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\tu32 orig_gen;\n\tint check = 0;\n\n\tmutex_lock(&ci->i_truncate_mutex);\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"invalidate_pages %p gen %d revoking %d\\n\", inode,\n\t     ci->i_rdcache_gen, ci->i_rdcache_revoking);\n\tif (ci->i_rdcache_revoking != ci->i_rdcache_gen) {\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t\tspin_unlock(&ci->i_ceph_lock);\n\t\tmutex_unlock(&ci->i_truncate_mutex);\n\t\tgoto out;\n\t}\n\torig_gen = ci->i_rdcache_gen;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\ttruncate_pagecache(inode, 0);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (orig_gen == ci->i_rdcache_gen &&\n\t    orig_gen == ci->i_rdcache_revoking) {\n\t\tdout(\"invalidate_pages %p gen %d successful\\n\", inode,\n\t\t     ci->i_rdcache_gen);\n\t\tci->i_rdcache_revoking--;\n\t\tcheck = 1;\n\t} else {\n\t\tdout(\"invalidate_pages %p gen %d raced, now %d revoking %d\\n\",\n\t\t     inode, orig_gen, ci->i_rdcache_gen,\n\t\t     ci->i_rdcache_revoking);\n\t\tif (__ceph_caps_revoking_other(ci, NULL, CEPH_CAP_FILE_CACHE))\n\t\t\tcheck = 1;\n\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\tmutex_unlock(&ci->i_truncate_mutex);\nout:\n\tif (check)\n\t\tceph_check_caps(ci, 0, NULL);\n\tiput(inode);\n}"
  },
  {
    "function_name": "ceph_queue_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1531-1541",
    "snippet": "void ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_invalidate %p failed\\n\"",
            "inode"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_invalidate %p\\n\"",
            "inode"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ceph_inode_to_client(inode)->pg_inv_wq",
            "&ceph_inode(inode)->i_pg_inv_work"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_invalidate(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->pg_inv_wq,\n\t\t       &ceph_inode(inode)->i_pg_inv_work)) {\n\t\tdout(\"ceph_queue_invalidate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_invalidate %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "ceph_writeback_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1517-1526",
    "snippet": "static void ceph_writeback_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_wb_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tdout(\"writeback %p\\n\", inode);\n\tfilemap_fdatawrite(&inode->i_data);\n\tiput(inode);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ceph_invalidate_work(struct work_struct *work);",
      "static void ceph_writeback_work(struct work_struct *work);",
      "static void ceph_vmtruncate_work(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "&inode->i_data"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"writeback %p\\n\"",
            "inode"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structceph_inode_info",
            "i_wb_work"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_invalidate_work(struct work_struct *work);\nstatic void ceph_writeback_work(struct work_struct *work);\nstatic void ceph_vmtruncate_work(struct work_struct *work);\n\nstatic void ceph_writeback_work(struct work_struct *work)\n{\n\tstruct ceph_inode_info *ci = container_of(work, struct ceph_inode_info,\n\t\t\t\t\t\t  i_wb_work);\n\tstruct inode *inode = &ci->vfs_inode;\n\n\tdout(\"writeback %p\\n\", inode);\n\tfilemap_fdatawrite(&inode->i_data);\n\tiput(inode);\n}"
  },
  {
    "function_name": "ceph_queue_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1505-1515",
    "snippet": "void ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_writeback %p failed\\n\"",
            "inode"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ceph_queue_writeback %p\\n\"",
            "inode"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "ceph_inode_to_client(inode)->wb_wq",
            "&ceph_inode(inode)->i_wb_work"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "inode"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_writeback(struct inode *inode)\n{\n\tihold(inode);\n\tif (queue_work(ceph_inode_to_client(inode)->wb_wq,\n\t\t       &ceph_inode(inode)->i_wb_work)) {\n\t\tdout(\"ceph_queue_writeback %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_writeback %p failed\\n\", inode);\n\t\tiput(inode);\n\t}\n}"
  },
  {
    "function_name": "ceph_inode_set_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1482-1499",
    "snippet": "int ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"set_size %p %llu -> %llu\\n\"",
            "inode",
            "inode->i_size",
            "size"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_inode_set_size(struct inode *inode, loff_t size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint ret = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tdout(\"set_size %p %llu -> %llu\\n\", inode, inode->i_size, size);\n\tinode->i_size = size;\n\tinode->i_blocks = (size + (1 << 9) - 1) >> 9;\n\n\t/* tell the MDS if we are approaching max_size */\n\tif ((size << 1) >= ci->i_max_size &&\n\t    (ci->i_reported_size << 1) < ci->i_max_size)\n\t\tret = 1;\n\n\tspin_unlock(&ci->i_ceph_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "ceph_readdir_prepopulate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1336-1480",
    "snippet": "int ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct dentry *parent = req->r_dentry;\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct qstr dname;\n\tstruct dentry *dn;\n\tstruct inode *in;\n\tint err = 0, ret, i;\n\tstruct inode *snapdir = NULL;\n\tstruct ceph_mds_request_head *rhead = req->r_request->front.iov_base;\n\tstruct ceph_dentry_info *di;\n\tu64 r_readdir_offset = req->r_readdir_offset;\n\tu32 frag = le32_to_cpu(rhead->args.readdir.frag);\n\n\tif (rinfo->dir_dir &&\n\t    le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\tdout(\"readdir_prepopulate got new frag %x -> %x\\n\",\n\t\t     frag, le32_to_cpu(rinfo->dir_dir->frag));\n\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\tif (ceph_frag_is_leftmost(frag))\n\t\t\tr_readdir_offset = 2;\n\t\telse\n\t\t\tr_readdir_offset = 0;\n\t}\n\n\tif (req->r_aborted)\n\t\treturn readdir_prepopulate_inodes_only(req, session);\n\n\tif (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {\n\t\tsnapdir = ceph_get_snapdir(parent->d_inode);\n\t\tparent = d_find_alias(snapdir);\n\t\tdout(\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t} else {\n\t\tdout(\"readdir_prepopulate %d items under dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t\tif (rinfo->dir_dir)\n\t\t\tceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);\n\t}\n\n\t/* FIXME: release caps/leases if error occurs */\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\n\t\tdname.name = rinfo->dir_dname[i];\n\t\tdname.len = rinfo->dir_dname_len[i];\n\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\nretry_lookup:\n\t\tdn = d_lookup(parent, &dname);\n\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t     parent, dname.len, dname.name, dn);\n\n\t\tif (!dn) {\n\t\t\tdn = d_alloc(parent, &dname);\n\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t     dname.len, dname.name, dn);\n\t\t\tif (dn == NULL) {\n\t\t\t\tdout(\"d_alloc badness\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ceph_init_dentry(dn);\n\t\t\tif (ret < 0) {\n\t\t\t\tdput(dn);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (dn->d_inode &&\n\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t     dn, dn->d_inode);\n\t\t\td_delete(dn);\n\t\t\tdput(dn);\n\t\t\tgoto retry_lookup;\n\t\t} else {\n\t\t\t/* reorder parent's d_subdirs */\n\t\t\tspin_lock(&parent->d_lock);\n\t\t\tspin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tlist_move(&dn->d_child, &parent->d_subdirs);\n\t\t\tspin_unlock(&dn->d_lock);\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\n\t\t/* inode */\n\t\tif (dn->d_inode) {\n\t\t\tin = dn->d_inode;\n\t\t} else {\n\t\t\tin = ceph_get_inode(parent->d_sb, vino);\n\t\t\tif (IS_ERR(in)) {\n\t\t\t\tdout(\"new_inode badness\\n\");\n\t\t\t\td_drop(dn);\n\t\t\t\tdput(dn);\n\t\t\t\terr = PTR_ERR(in);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t       req->r_request_started, -1,\n\t\t\t       &req->r_caps_reservation) < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p\\n\", in);\n\t\t\tif (!dn->d_inode)\n\t\t\t\tiput(in);\n\t\t\td_drop(dn);\n\t\t\tgoto next_item;\n\t\t}\n\n\t\tif (!dn->d_inode) {\n\t\t\tstruct dentry *realdn = splice_dentry(dn, in, NULL);\n\t\t\tif (IS_ERR(realdn)) {\n\t\t\t\terr = PTR_ERR(realdn);\n\t\t\t\td_drop(dn);\n\t\t\t\tdn = NULL;\n\t\t\t\tgoto next_item;\n\t\t\t}\n\t\t\tdn = realdn;\n\t\t}\n\n\t\tdi = dn->d_fsdata;\n\t\tdi->offset = ceph_make_fpos(frag, i + r_readdir_offset);\n\n\t\tupdate_dentry_lease(dn, rinfo->dir_dlease[i],\n\t\t\t\t    req->r_session,\n\t\t\t\t    req->r_request_started);\nnext_item:\n\t\tif (dn)\n\t\t\tdput(dn);\n\t}\n\tif (err == 0)\n\t\treq->r_did_prepopulate = true;\n\nout:\n\tif (snapdir) {\n\t\tiput(snapdir);\n\t\tdput(parent);\n\t}\n\tdout(\"readdir_prepopulate done\\n\");\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readdir_prepopulate done\\n\""
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "snapdir"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dentry_lease",
          "args": [
            "dn",
            "rinfo->dir_dlease[i]",
            "req->r_session",
            "req->r_request_started"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "update_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "923-968",
          "snippet": "static void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_make_fpos",
          "args": [
            "frag",
            "i + r_readdir_offset"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_make_fpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "513-516",
          "snippet": "static inline loff_t ceph_make_fpos(unsigned frag, unsigned off)\n{\n\treturn ((loff_t)frag << 32) | (loff_t)off;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline loff_t ceph_make_fpos(unsigned frag, unsigned off)\n{\n\treturn ((loff_t)frag << 32) | (loff_t)off;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dn"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realdn"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realdn"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_dentry",
          "args": [
            "dn",
            "in",
            "NULL"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "splice_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "978-1013",
          "snippet": "static struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_inode badness on %p\\n\"",
            "in"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_inode",
          "args": [
            "in",
            "NULL",
            "&rinfo->dir_in[i]",
            "NULL",
            "session",
            "req->r_request_started",
            "-1",
            "&req->r_caps_reservation"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "662-918",
          "snippet": "static int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ceph_symlink_iops;",
            "const struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};",
            "static const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct inode_operations ceph_symlink_iops;\nconst struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};\nstatic const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};\n\nstatic int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "in"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"new_inode badness\\n\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "in"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_inode",
          "args": [
            "parent->d_sb",
            "vino"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "48-65",
          "snippet": "struct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&dn->d_child",
            "&parent->d_subdirs"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dn->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dn"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" dn %p points to wrong inode %p\\n\"",
            "dn",
            "dn->d_inode"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dn->d_inode"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "dn->d_inode"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "dn"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_alloc badness\\n\""
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_alloc %p '%.*s' = %p\\n\"",
            "parent",
            "dname.len",
            "dname.name",
            "dn"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&dname"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_lookup on parent=%p name=%.*s got %p\\n\"",
            "parent",
            "dname.len",
            "dname.name",
            "dn"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&dname"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rinfo->dir_in[i].in->snapid"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "dname.name",
            "dname.len"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_dirfrag",
          "args": [
            "parent->d_inode",
            "rinfo->dir_dir"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_dirfrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "240-301",
          "snippet": "static int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readdir_prepopulate %d items under dn %p\\n\"",
            "rinfo->dir_nr",
            "parent"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\"",
            "rinfo->dir_nr",
            "parent"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "snapdir"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "865-875",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_snapdir",
          "args": [
            "parent->d_inode"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_snapdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "70-90",
          "snippet": "struct inode *ceph_get_snapdir(struct inode *parent)\n{\n\tstruct ceph_vino vino = {\n\t\t.ino = ceph_ino(parent),\n\t\t.snap = CEPH_SNAPDIR,\n\t};\n\tstruct inode *inode = ceph_get_inode(parent->i_sb, vino);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tBUG_ON(!S_ISDIR(parent->i_mode));\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tinode->i_mode = parent->i_mode;\n\tinode->i_uid = parent->i_uid;\n\tinode->i_gid = parent->i_gid;\n\tinode->i_op = &ceph_snapdir_iops;\n\tinode->i_fop = &ceph_snapdir_fops;\n\tci->i_snap_caps = CEPH_CAP_PIN; /* so we can open */\n\tci->i_rbytes = 0;\n\treturn inode;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_snapdir(struct inode *parent)\n{\n\tstruct ceph_vino vino = {\n\t\t.ino = ceph_ino(parent),\n\t\t.snap = CEPH_SNAPDIR,\n\t};\n\tstruct inode *inode = ceph_get_inode(parent->i_sb, vino);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tBUG_ON(!S_ISDIR(parent->i_mode));\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tinode->i_mode = parent->i_mode;\n\tinode->i_uid = parent->i_uid;\n\tinode->i_gid = parent->i_gid;\n\tinode->i_op = &ceph_snapdir_iops;\n\tinode->i_fop = &ceph_snapdir_fops;\n\tci->i_snap_caps = CEPH_CAP_PIN; /* so we can open */\n\tci->i_rbytes = 0;\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rinfo->head->op"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readdir_prepopulate_inodes_only",
          "args": [
            "req",
            "session"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "readdir_prepopulate_inodes_only",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1303-1334",
          "snippet": "static int readdir_prepopulate_inodes_only(struct ceph_mds_request *req,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tint i, err = 0;\n\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\t\tstruct inode *in;\n\t\tint rc;\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\n\t\tin = ceph_get_inode(req->r_dentry->d_sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tdout(\"new_inode badness got %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t\trc = fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t\treq->r_request_started, -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p got %d\\n\", in, rc);\n\t\t\terr = rc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int readdir_prepopulate_inodes_only(struct ceph_mds_request *req,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tint i, err = 0;\n\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\t\tstruct inode *in;\n\t\tint rc;\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\n\t\tin = ceph_get_inode(req->r_dentry->d_sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tdout(\"new_inode badness got %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t\trc = fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t\treq->r_request_started, -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p got %d\\n\", in, rc);\n\t\t\terr = rc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_frag_is_leftmost",
          "args": [
            "frag"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"readdir_prepopulate got new frag %x -> %x\\n\"",
            "frag",
            "le32_to_cpu(rinfo->dir_dir->frag)"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_readdir_prepopulate(struct ceph_mds_request *req,\n\t\t\t     struct ceph_mds_session *session)\n{\n\tstruct dentry *parent = req->r_dentry;\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct qstr dname;\n\tstruct dentry *dn;\n\tstruct inode *in;\n\tint err = 0, ret, i;\n\tstruct inode *snapdir = NULL;\n\tstruct ceph_mds_request_head *rhead = req->r_request->front.iov_base;\n\tstruct ceph_dentry_info *di;\n\tu64 r_readdir_offset = req->r_readdir_offset;\n\tu32 frag = le32_to_cpu(rhead->args.readdir.frag);\n\n\tif (rinfo->dir_dir &&\n\t    le32_to_cpu(rinfo->dir_dir->frag) != frag) {\n\t\tdout(\"readdir_prepopulate got new frag %x -> %x\\n\",\n\t\t     frag, le32_to_cpu(rinfo->dir_dir->frag));\n\t\tfrag = le32_to_cpu(rinfo->dir_dir->frag);\n\t\tif (ceph_frag_is_leftmost(frag))\n\t\t\tr_readdir_offset = 2;\n\t\telse\n\t\t\tr_readdir_offset = 0;\n\t}\n\n\tif (req->r_aborted)\n\t\treturn readdir_prepopulate_inodes_only(req, session);\n\n\tif (le32_to_cpu(rinfo->head->op) == CEPH_MDS_OP_LSSNAP) {\n\t\tsnapdir = ceph_get_snapdir(parent->d_inode);\n\t\tparent = d_find_alias(snapdir);\n\t\tdout(\"readdir_prepopulate %d items under SNAPDIR dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t} else {\n\t\tdout(\"readdir_prepopulate %d items under dn %p\\n\",\n\t\t     rinfo->dir_nr, parent);\n\t\tif (rinfo->dir_dir)\n\t\t\tceph_fill_dirfrag(parent->d_inode, rinfo->dir_dir);\n\t}\n\n\t/* FIXME: release caps/leases if error occurs */\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\n\t\tdname.name = rinfo->dir_dname[i];\n\t\tdname.len = rinfo->dir_dname_len[i];\n\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\nretry_lookup:\n\t\tdn = d_lookup(parent, &dname);\n\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t     parent, dname.len, dname.name, dn);\n\n\t\tif (!dn) {\n\t\t\tdn = d_alloc(parent, &dname);\n\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t     dname.len, dname.name, dn);\n\t\t\tif (dn == NULL) {\n\t\t\t\tdout(\"d_alloc badness\\n\");\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tret = ceph_init_dentry(dn);\n\t\t\tif (ret < 0) {\n\t\t\t\tdput(dn);\n\t\t\t\terr = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (dn->d_inode &&\n\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t     dn, dn->d_inode);\n\t\t\td_delete(dn);\n\t\t\tdput(dn);\n\t\t\tgoto retry_lookup;\n\t\t} else {\n\t\t\t/* reorder parent's d_subdirs */\n\t\t\tspin_lock(&parent->d_lock);\n\t\t\tspin_lock_nested(&dn->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tlist_move(&dn->d_child, &parent->d_subdirs);\n\t\t\tspin_unlock(&dn->d_lock);\n\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\n\t\t/* inode */\n\t\tif (dn->d_inode) {\n\t\t\tin = dn->d_inode;\n\t\t} else {\n\t\t\tin = ceph_get_inode(parent->d_sb, vino);\n\t\t\tif (IS_ERR(in)) {\n\t\t\t\tdout(\"new_inode badness\\n\");\n\t\t\t\td_drop(dn);\n\t\t\t\tdput(dn);\n\t\t\t\terr = PTR_ERR(in);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tif (fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t       req->r_request_started, -1,\n\t\t\t       &req->r_caps_reservation) < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p\\n\", in);\n\t\t\tif (!dn->d_inode)\n\t\t\t\tiput(in);\n\t\t\td_drop(dn);\n\t\t\tgoto next_item;\n\t\t}\n\n\t\tif (!dn->d_inode) {\n\t\t\tstruct dentry *realdn = splice_dentry(dn, in, NULL);\n\t\t\tif (IS_ERR(realdn)) {\n\t\t\t\terr = PTR_ERR(realdn);\n\t\t\t\td_drop(dn);\n\t\t\t\tdn = NULL;\n\t\t\t\tgoto next_item;\n\t\t\t}\n\t\t\tdn = realdn;\n\t\t}\n\n\t\tdi = dn->d_fsdata;\n\t\tdi->offset = ceph_make_fpos(frag, i + r_readdir_offset);\n\n\t\tupdate_dentry_lease(dn, rinfo->dir_dlease[i],\n\t\t\t\t    req->r_session,\n\t\t\t\t    req->r_request_started);\nnext_item:\n\t\tif (dn)\n\t\t\tdput(dn);\n\t}\n\tif (err == 0)\n\t\treq->r_did_prepopulate = true;\n\nout:\n\tif (snapdir) {\n\t\tiput(snapdir);\n\t\tdput(parent);\n\t}\n\tdout(\"readdir_prepopulate done\\n\");\n\treturn err;\n}"
  },
  {
    "function_name": "readdir_prepopulate_inodes_only",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1303-1334",
    "snippet": "static int readdir_prepopulate_inodes_only(struct ceph_mds_request *req,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tint i, err = 0;\n\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\t\tstruct inode *in;\n\t\tint rc;\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\n\t\tin = ceph_get_inode(req->r_dentry->d_sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tdout(\"new_inode badness got %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t\trc = fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t\treq->r_request_started, -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p got %d\\n\", in, rc);\n\t\t\terr = rc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_inode badness on %p got %d\\n\"",
            "in",
            "rc"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_inode",
          "args": [
            "in",
            "NULL",
            "&rinfo->dir_in[i]",
            "NULL",
            "session",
            "req->r_request_started",
            "-1",
            "&req->r_caps_reservation"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "662-918",
          "snippet": "static int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ceph_symlink_iops;",
            "const struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};",
            "static const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct inode_operations ceph_symlink_iops;\nconst struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};\nstatic const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};\n\nstatic int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"new_inode badness got %d\\n\"",
            "err"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "in"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "in"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_inode",
          "args": [
            "req->r_dentry->d_sb",
            "vino"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "48-65",
          "snippet": "struct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rinfo->dir_in[i].in->snapid"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int readdir_prepopulate_inodes_only(struct ceph_mds_request *req,\n\t\t\t\t\t   struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tint i, err = 0;\n\n\tfor (i = 0; i < rinfo->dir_nr; i++) {\n\t\tstruct ceph_vino vino;\n\t\tstruct inode *in;\n\t\tint rc;\n\n\t\tvino.ino = le64_to_cpu(rinfo->dir_in[i].in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->dir_in[i].in->snapid);\n\n\t\tin = ceph_get_inode(req->r_dentry->d_sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tdout(\"new_inode badness got %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t\trc = fill_inode(in, NULL, &rinfo->dir_in[i], NULL, session,\n\t\t\t\treq->r_request_started, -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (rc < 0) {\n\t\t\tpr_err(\"fill_inode badness on %p got %d\\n\", in, rc);\n\t\t\terr = rc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_fill_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "1026-1298",
    "snippet": "int ceph_fill_trace(struct super_block *sb, struct ceph_mds_request *req,\n\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct inode *in = NULL;\n\tstruct ceph_vino vino;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tdout(\"fill_trace %p is_dentry %d is_target %d\\n\", req,\n\t     rinfo->head->is_dentry, rinfo->head->is_target);\n\n#if 0\n\t/*\n\t * Debugging hook:\n\t *\n\t * If we resend completed ops to a recovering mds, we get no\n\t * trace.  Since that is very rare, pretend this is the case\n\t * to ensure the 'no trace' handlers in the callers behave.\n\t *\n\t * Fill in inodes unconditionally to avoid breaking cap\n\t * invariants.\n\t */\n\tif (rinfo->head->op & CEPH_MDS_OP_WRITE) {\n\t\tpr_info(\"fill_trace faking empty trace on %lld %s\\n\",\n\t\t\treq->r_tid, ceph_mds_op_name(rinfo->head->op));\n\t\tif (rinfo->head->is_dentry) {\n\t\t\trinfo->head->is_dentry = 0;\n\t\t\terr = fill_inode(req->r_locked_dir,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1);\n\t\t}\n\t\tif (rinfo->head->is_target) {\n\t\t\trinfo->head->is_target = 0;\n\t\t\tininfo = rinfo->targeti.in;\n\t\t\tvino.ino = le64_to_cpu(ininfo->ino);\n\t\t\tvino.snap = le64_to_cpu(ininfo->snapid);\n\t\t\tin = ceph_get_inode(sb, vino);\n\t\t\terr = fill_inode(in, &rinfo->targeti, NULL,\n\t\t\t\t\t session, req->r_request_started,\n\t\t\t\t\t req->r_fmode);\n\t\t\tiput(in);\n\t\t}\n\t}\n#endif\n\n\tif (!rinfo->head->is_target && !rinfo->head->is_dentry) {\n\t\tdout(\"fill_trace reply is empty!\\n\");\n\t\tif (rinfo->head->result == 0 && req->r_locked_dir)\n\t\t\tceph_invalidate_dir_request(req);\n\t\treturn 0;\n\t}\n\n\tif (rinfo->head->is_dentry) {\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\tif (dir) {\n\t\t\terr = fill_inode(dir, NULL,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1,\n\t\t\t\t\t &req->r_caps_reservation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tif (dir && req->r_op == CEPH_MDS_OP_LOOKUPNAME) {\n\t\t\tstruct qstr dname;\n\t\t\tstruct dentry *dn, *parent;\n\n\t\t\tBUG_ON(!rinfo->head->is_target);\n\t\t\tBUG_ON(req->r_dentry);\n\n\t\t\tparent = d_find_any_alias(dir);\n\t\t\tBUG_ON(!parent);\n\n\t\t\tdname.name = rinfo->dname;\n\t\t\tdname.len = rinfo->dname_len;\n\t\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\t\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\nretry_lookup:\n\t\t\tdn = d_lookup(parent, &dname);\n\t\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t\t     parent, dname.len, dname.name, dn);\n\n\t\t\tif (!dn) {\n\t\t\t\tdn = d_alloc(parent, &dname);\n\t\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t\t     dname.len, dname.name, dn);\n\t\t\t\tif (dn == NULL) {\n\t\t\t\t\tdput(parent);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\terr = ceph_init_dentry(dn);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tdput(dn);\n\t\t\t\t\tdput(parent);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else if (dn->d_inode &&\n\t\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t\t     dn, dn->d_inode);\n\t\t\t\td_delete(dn);\n\t\t\t\tdput(dn);\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\n\t\t\treq->r_dentry = dn;\n\t\t\tdput(parent);\n\t\t}\n\t}\n\n\tif (rinfo->head->is_target) {\n\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\n\n\t\tin = ceph_get_inode(sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_target_inode = in;\n\n\t\terr = fill_inode(in, req->r_locked_page, &rinfo->targeti, NULL,\n\t\t\t\tsession, req->r_request_started,\n\t\t\t\t(!req->r_aborted && rinfo->head->result == 0) ?\n\t\t\t\treq->r_fmode : -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"fill_inode badness %p %llx.%llx\\n\",\n\t\t\t\tin, ceph_vinop(in));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * ignore null lease/binding on snapdir ENOENT, or else we\n\t * will have trouble splicing in the virtual snapdir later\n\t */\n\tif (rinfo->head->is_dentry && !req->r_aborted &&\n\t    req->r_locked_dir &&\n\t    (rinfo->head->is_target || strncmp(req->r_dentry->d_name.name,\n\t\t\t\t\t       fsc->mount_options->snapdir_name,\n\t\t\t\t\t       req->r_dentry->d_name.len))) {\n\t\t/*\n\t\t * lookup link rename   : null -> possibly existing inode\n\t\t * mknod symlink mkdir  : null -> new inode\n\t\t * unlink               : linked -> null\n\t\t */\n\t\tstruct inode *dir = req->r_locked_dir;\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tbool have_dir_cap, have_lease;\n\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(dn->d_parent->d_inode != dir);\n\t\tBUG_ON(ceph_ino(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->ino));\n\t\tBUG_ON(ceph_snap(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->snapid));\n\n\t\t/* do we have a lease on the whole dir? */\n\t\thave_dir_cap =\n\t\t\t(le32_to_cpu(rinfo->diri.in->cap.caps) &\n\t\t\t CEPH_CAP_FILE_SHARED);\n\n\t\t/* do we have a dn lease? */\n\t\thave_lease = have_dir_cap ||\n\t\t\tle32_to_cpu(rinfo->dlease->duration_ms);\n\t\tif (!have_lease)\n\t\t\tdout(\"fill_trace  no dentry lease or dir cap\\n\");\n\n\t\t/* rename? */\n\t\tif (req->r_old_dentry && req->r_op == CEPH_MDS_OP_RENAME) {\n\t\t\tstruct inode *olddir = req->r_old_dentry_dir;\n\t\t\tBUG_ON(!olddir);\n\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\t\t\tdout(\"fill_trace doing d_move %p -> %p\\n\",\n\t\t\t     req->r_old_dentry, dn);\n\n\t\t\td_move(req->r_old_dentry, dn);\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\n\t\t\t/* ensure target dentry is invalidated, despite\n\t\t\t   rehashing bug in vfs_rename_dir */\n\t\t\tceph_invalidate_dentry_lease(dn);\n\n\t\t\t/* d_move screws up sibling dentries' offsets */\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tceph_dir_clear_ordered(olddir);\n\n\t\t\tdout(\"dn %p gets new offset %lld\\n\", req->r_old_dentry,\n\t\t\t     ceph_dentry(req->r_old_dentry)->offset);\n\n\t\t\tdn = req->r_old_dentry;  /* use old_dentry */\n\t\t}\n\n\t\t/* null dentry? */\n\t\tif (!rinfo->head->is_target) {\n\t\t\tdout(\"fill_trace null dentry\\n\");\n\t\t\tif (dn->d_inode) {\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\tdout(\"d_delete %p\\n\", dn);\n\t\t\t\td_delete(dn);\n\t\t\t} else {\n\t\t\t\tdout(\"d_instantiate %p NULL\\n\", dn);\n\t\t\t\td_instantiate(dn, NULL);\n\t\t\t\tif (have_lease && d_unhashed(dn))\n\t\t\t\t\td_rehash(dn);\n\t\t\t\tupdate_dentry_lease(dn, rinfo->dlease,\n\t\t\t\t\t\t    session,\n\t\t\t\t\t\t    req->r_request_started);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* attach proper inode */\n\t\tif (!dn->d_inode) {\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tihold(in);\n\t\t\tdn = splice_dentry(dn, in, &have_lease);\n\t\t\tif (IS_ERR(dn)) {\n\t\t\t\terr = PTR_ERR(dn);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treq->r_dentry = dn;  /* may have spliced */\n\t\t} else if (dn->d_inode && dn->d_inode != in) {\n\t\t\tdout(\" %p links to %p %llx.%llx, not %llx.%llx\\n\",\n\t\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode),\n\t\t\t     ceph_vinop(in));\n\t\t\thave_lease = false;\n\t\t}\n\n\t\tif (have_lease)\n\t\t\tupdate_dentry_lease(dn, rinfo->dlease, session,\n\t\t\t\t\t    req->r_request_started);\n\t\tdout(\" final dn %p\\n\", dn);\n\t} else if (!req->r_aborted &&\n\t\t   (req->r_op == CEPH_MDS_OP_LOOKUPSNAP ||\n\t\t    req->r_op == CEPH_MDS_OP_MKSNAP)) {\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\t/* fill out a snapdir LOOKUPSNAP dentry */\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(ceph_snap(dir) != CEPH_SNAPDIR);\n\t\tdout(\" linking snapped dir %p to dn %p\\n\", in, dn);\n\t\tceph_dir_clear_ordered(dir);\n\t\tihold(in);\n\t\tdn = splice_dentry(dn, in, NULL);\n\t\tif (IS_ERR(dn)) {\n\t\t\terr = PTR_ERR(dn);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_dentry = dn;  /* may have spliced */\n\t}\ndone:\n\tdout(\"fill_trace done err=%d\\n\", err);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace done err=%d\\n\"",
            "err"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dn"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dn"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_dentry",
          "args": [
            "dn",
            "in",
            "NULL"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "splice_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "978-1013",
          "snippet": "static struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "in"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dir_clear_ordered",
          "args": [
            "dir"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dir_clear_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "477-484",
          "snippet": "static inline void ceph_dir_clear_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_ordered_count++;\n\tci->i_ceph_flags &= ~CEPH_I_DIR_ORDERED;\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */\n\nstatic inline void ceph_dir_clear_ordered(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tspin_lock(&ci->i_ceph_lock);\n\tci->i_ordered_count++;\n\tci->i_ceph_flags &= ~CEPH_I_DIR_ORDERED;\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" linking snapped dir %p to dn %p\\n\"",
            "in",
            "dn"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ceph_snap(dir) != CEPH_SNAPDIR"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "dir"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dir"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dn"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" final dn %p\\n\"",
            "dn"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_dentry_lease",
          "args": [
            "dn",
            "rinfo->dlease",
            "session",
            "req->r_request_started"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "update_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "923-968",
          "snippet": "static void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" %p links to %p %llx.%llx, not %llx.%llx\\n\"",
            "dn",
            "dn->d_inode",
            "ceph_vinop(dn->d_inode)",
            "ceph_vinop(in)"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "in"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "dn->d_inode"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dn"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dn"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dn"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dn"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dn",
            "NULL"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_instantiate %p NULL\\n\"",
            "dn"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_delete",
          "args": [
            "dn"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2350-2379",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode;\n\tint isdir = 0;\n\t/*\n\t * Are we the only user?\n\t */\nagain:\n\tspin_lock(&dentry->d_lock);\n\tinode = dentry->d_inode;\n\tisdir = S_ISDIR(inode->i_mode);\n\tif (dentry->d_lockref.count == 1) {\n\t\tif (!spin_trylock(&inode->i_lock)) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcpu_relax();\n\t\t\tgoto again;\n\t\t}\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t\tfsnotify_nameremove(dentry, isdir);\n\t\treturn;\n\t}\n\n\tif (!d_unhashed(dentry))\n\t\t__d_drop(dentry);\n\n\tspin_unlock(&dentry->d_lock);\n\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_delete %p\\n\"",
            "dn"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace null dentry\\n\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"dn %p gets new offset %lld\\n\"",
            "req->r_old_dentry",
            "ceph_dentry(req->r_old_dentry)->offset"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "req->r_old_dentry"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_invalidate_dentry_lease",
          "args": [
            "dn"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_invalidate_dentry_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "988-994",
          "snippet": "void ceph_invalidate_dentry_lease(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_time = jiffies;\n\tceph_dentry(dentry)->lease_shared_gen = 0;\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_invalidate_dentry_lease(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_time = jiffies;\n\tceph_dentry(dentry)->lease_shared_gen = 0;\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" src %p '%pd' dst %p '%pd'\\n\"",
            "req->r_old_dentry",
            "req->r_old_dentry",
            "dn",
            "dn"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_move",
          "args": [
            "req->r_old_dentry",
            "dn"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2634-2639",
          "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace doing d_move %p -> %p\\n\"",
            "req->r_old_dentry",
            "dn"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" src %p '%pd' dst %p '%pd'\\n\"",
            "req->r_old_dentry",
            "req->r_old_dentry",
            "dn",
            "dn"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!olddir"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace  no dentry lease or dir cap\\n\""
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rinfo->dlease->duration_ms"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ceph_snap(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->snapid)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rinfo->diri.in->snapid"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ceph_ino(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->ino)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "dir"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dn->d_parent->d_inode != dir"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dir"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dn"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "req->r_dentry->d_name.name",
            "fsc->mount_options->snapdir_name",
            "req->r_dentry->d_name.len"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_inode badness %p %llx.%llx\\n\"",
            "in",
            "ceph_vinop(in)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "in"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_inode",
          "args": [
            "in",
            "req->r_locked_page",
            "&rinfo->targeti",
            "NULL",
            "session",
            "req->r_request_started",
            "(!req->r_aborted && rinfo->head->result == 0) ?\n\t\t\t\treq->r_fmode : -1",
            "&req->r_caps_reservation"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "662-918",
          "snippet": "static int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations ceph_symlink_iops;",
            "const struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};",
            "static const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct inode_operations ceph_symlink_iops;\nconst struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};\nstatic const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};\n\nstatic int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "in"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "in"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_inode",
          "args": [
            "sb",
            "vino"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "48-65",
          "snippet": "struct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" dn %p points to wrong inode %p\\n\"",
            "dn",
            "dn->d_inode"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_init_dentry",
          "args": [
            "dn"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "34-69",
          "snippet": "int ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations ceph_dentry_ops;",
            "const struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};",
            "const struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};",
            "const struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nconst struct dentry_operations ceph_dentry_ops;\nconst struct dentry_operations ceph_dentry_ops = {\n\t.d_revalidate = ceph_d_revalidate,\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\nconst struct dentry_operations ceph_snapdir_dentry_ops = {\n\t.d_revalidate = ceph_snapdir_d_revalidate,\n\t.d_release = ceph_d_release,\n};\nconst struct dentry_operations ceph_snap_dentry_ops = {\n\t.d_release = ceph_d_release,\n\t.d_prune = ceph_d_prune,\n};\n\nint ceph_init_dentry(struct dentry *dentry)\n{\n\tstruct ceph_dentry_info *di;\n\n\tif (dentry->d_fsdata)\n\t\treturn 0;\n\n\tdi = kmem_cache_alloc(ceph_dentry_cachep, GFP_NOFS | __GFP_ZERO);\n\tif (!di)\n\t\treturn -ENOMEM;          /* oh well */\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_fsdata) {\n\t\t/* lost a race */\n\t\tkmem_cache_free(ceph_dentry_cachep, di);\n\t\tgoto out_unlock;\n\t}\n\n\tif (ceph_snap(dentry->d_parent->d_inode) == CEPH_NOSNAP)\n\t\td_set_d_op(dentry, &ceph_dentry_ops);\n\telse if (ceph_snap(dentry->d_parent->d_inode) == CEPH_SNAPDIR)\n\t\td_set_d_op(dentry, &ceph_snapdir_dentry_ops);\n\telse\n\t\td_set_d_op(dentry, &ceph_snap_dentry_ops);\n\n\tdi->dentry = dentry;\n\tdi->lease_session = NULL;\n\tdentry->d_time = jiffies;\n\t/* avoid reordering d_fsdata setup so that the check above is safe */\n\tsmp_mb();\n\tdentry->d_fsdata = di;\n\tceph_dentry_lru_add(dentry);\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_alloc %p '%.*s' = %p\\n\"",
            "parent",
            "dname.len",
            "dname.name",
            "dn"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&dname"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"d_lookup on parent=%p name=%.*s got %p\\n\"",
            "parent",
            "dname.len",
            "dname.name",
            "dn"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "parent",
            "&dname"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "dname.name",
            "dname.len"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!parent"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_find_any_alias",
          "args": [
            "dir"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1892-1900",
          "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "req->r_dentry"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rinfo->head->is_target"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_invalidate_dir_request",
          "args": [
            "req"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_invalidate_dir_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.c",
          "lines": "2290-2301",
          "snippet": "void ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/utsname.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/gfp.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/ceph_features.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/utsname.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_invalidate_dir_request(struct ceph_mds_request *req)\n{\n\tstruct inode *inode = req->r_locked_dir;\n\n\tdout(\"invalidate_dir_request %p (complete, lease(s))\\n\", inode);\n\n\tceph_dir_clear_complete(inode);\n\tif (req->r_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_dentry);\n\tif (req->r_old_dentry)\n\t\tceph_invalidate_dentry_lease(req->r_old_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace reply is empty!\\n\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "in"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_inode",
          "args": [
            "in",
            "&rinfo->targeti",
            "NULL",
            "session",
            "req->r_request_started",
            "req->r_fmode"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "fill_inode_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tree-log.c",
          "lines": "3263-3316",
          "snippet": "static void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"print-tree.h\"",
            "#include \"locking.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include <linux/list_sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"backref.h\"\n#include \"print-tree.h\"\n#include \"locking.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include <linux/list_sort.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void fill_inode_item(struct btrfs_trans_handle *trans,\n\t\t\t    struct extent_buffer *leaf,\n\t\t\t    struct btrfs_inode_item *item,\n\t\t\t    struct inode *inode, int log_inode_only,\n\t\t\t    u64 logged_isize)\n{\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (log_inode_only) {\n\t\t/* set the generation to zero so the recover code\n\t\t * can tell the difference between an logging\n\t\t * just to say 'this inode exists' and a logging\n\t\t * to say 'update this inode with these values'\n\t\t */\n\t\tbtrfs_set_token_inode_generation(leaf, item, 0, &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, logged_isize, &token);\n\t} else {\n\t\tbtrfs_set_token_inode_generation(leaf, item,\n\t\t\t\t\t\t BTRFS_I(inode)->generation,\n\t\t\t\t\t\t &token);\n\t\tbtrfs_set_token_inode_size(leaf, item, inode->i_size, &token);\n\t}\n\n\tbtrfs_set_token_inode_uid(leaf, item, i_uid_read(inode), &token);\n\tbtrfs_set_token_inode_gid(leaf, item, i_gid_read(inode), &token);\n\tbtrfs_set_token_inode_mode(leaf, item, inode->i_mode, &token);\n\tbtrfs_set_token_inode_nlink(leaf, item, inode->i_nlink, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->atime,\n\t\t\t\t     inode->i_atime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->atime,\n\t\t\t\t      inode->i_atime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->mtime,\n\t\t\t\t     inode->i_mtime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->mtime,\n\t\t\t\t      inode->i_mtime.tv_nsec, &token);\n\n\tbtrfs_set_token_timespec_sec(leaf, &item->ctime,\n\t\t\t\t     inode->i_ctime.tv_sec, &token);\n\tbtrfs_set_token_timespec_nsec(leaf, &item->ctime,\n\t\t\t\t      inode->i_ctime.tv_nsec, &token);\n\n\tbtrfs_set_token_inode_nbytes(leaf, item, inode_get_bytes(inode),\n\t\t\t\t     &token);\n\n\tbtrfs_set_token_inode_sequence(leaf, item, inode->i_version, &token);\n\tbtrfs_set_token_inode_transid(leaf, item, trans->transid, &token);\n\tbtrfs_set_token_inode_rdev(leaf, item, inode->i_rdev, &token);\n\tbtrfs_set_token_inode_flags(leaf, item, BTRFS_I(inode)->flags, &token);\n\tbtrfs_set_token_inode_block_group(leaf, item, 0, &token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"fill_trace faking empty trace on %lld %s\\n\"",
            "req->r_tid",
            "ceph_mds_op_name(rinfo->head->op)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_mds_op_name",
          "args": [
            "rinfo->head->op"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_mds_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "50-82",
          "snippet": "const char *ceph_mds_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_MDS_OP_LOOKUP:  return \"lookup\";\n\tcase CEPH_MDS_OP_LOOKUPHASH:  return \"lookuphash\";\n\tcase CEPH_MDS_OP_LOOKUPPARENT:  return \"lookupparent\";\n\tcase CEPH_MDS_OP_LOOKUPINO:  return \"lookupino\";\n\tcase CEPH_MDS_OP_LOOKUPNAME:  return \"lookupname\";\n\tcase CEPH_MDS_OP_GETATTR:  return \"getattr\";\n\tcase CEPH_MDS_OP_SETXATTR: return \"setxattr\";\n\tcase CEPH_MDS_OP_SETATTR: return \"setattr\";\n\tcase CEPH_MDS_OP_RMXATTR: return \"rmxattr\";\n\tcase CEPH_MDS_OP_SETLAYOUT: return \"setlayou\";\n\tcase CEPH_MDS_OP_SETDIRLAYOUT: return \"setdirlayout\";\n\tcase CEPH_MDS_OP_READDIR: return \"readdir\";\n\tcase CEPH_MDS_OP_MKNOD: return \"mknod\";\n\tcase CEPH_MDS_OP_LINK: return \"link\";\n\tcase CEPH_MDS_OP_UNLINK: return \"unlink\";\n\tcase CEPH_MDS_OP_RENAME: return \"rename\";\n\tcase CEPH_MDS_OP_MKDIR: return \"mkdir\";\n\tcase CEPH_MDS_OP_RMDIR: return \"rmdir\";\n\tcase CEPH_MDS_OP_SYMLINK: return \"symlink\";\n\tcase CEPH_MDS_OP_CREATE: return \"create\";\n\tcase CEPH_MDS_OP_OPEN: return \"open\";\n\tcase CEPH_MDS_OP_LOOKUPSNAP: return \"lookupsnap\";\n\tcase CEPH_MDS_OP_LSSNAP: return \"lssnap\";\n\tcase CEPH_MDS_OP_MKSNAP: return \"mksnap\";\n\tcase CEPH_MDS_OP_RMSNAP: return \"rmsnap\";\n\tcase CEPH_MDS_OP_SETFILELOCK: return \"setfilelock\";\n\tcase CEPH_MDS_OP_GETFILELOCK: return \"getfilelock\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_mds_op_name(int op)\n{\n\tswitch (op) {\n\tcase CEPH_MDS_OP_LOOKUP:  return \"lookup\";\n\tcase CEPH_MDS_OP_LOOKUPHASH:  return \"lookuphash\";\n\tcase CEPH_MDS_OP_LOOKUPPARENT:  return \"lookupparent\";\n\tcase CEPH_MDS_OP_LOOKUPINO:  return \"lookupino\";\n\tcase CEPH_MDS_OP_LOOKUPNAME:  return \"lookupname\";\n\tcase CEPH_MDS_OP_GETATTR:  return \"getattr\";\n\tcase CEPH_MDS_OP_SETXATTR: return \"setxattr\";\n\tcase CEPH_MDS_OP_SETATTR: return \"setattr\";\n\tcase CEPH_MDS_OP_RMXATTR: return \"rmxattr\";\n\tcase CEPH_MDS_OP_SETLAYOUT: return \"setlayou\";\n\tcase CEPH_MDS_OP_SETDIRLAYOUT: return \"setdirlayout\";\n\tcase CEPH_MDS_OP_READDIR: return \"readdir\";\n\tcase CEPH_MDS_OP_MKNOD: return \"mknod\";\n\tcase CEPH_MDS_OP_LINK: return \"link\";\n\tcase CEPH_MDS_OP_UNLINK: return \"unlink\";\n\tcase CEPH_MDS_OP_RENAME: return \"rename\";\n\tcase CEPH_MDS_OP_MKDIR: return \"mkdir\";\n\tcase CEPH_MDS_OP_RMDIR: return \"rmdir\";\n\tcase CEPH_MDS_OP_SYMLINK: return \"symlink\";\n\tcase CEPH_MDS_OP_CREATE: return \"create\";\n\tcase CEPH_MDS_OP_OPEN: return \"open\";\n\tcase CEPH_MDS_OP_LOOKUPSNAP: return \"lookupsnap\";\n\tcase CEPH_MDS_OP_LSSNAP: return \"lssnap\";\n\tcase CEPH_MDS_OP_MKSNAP: return \"mksnap\";\n\tcase CEPH_MDS_OP_RMSNAP: return \"rmsnap\";\n\tcase CEPH_MDS_OP_SETFILELOCK: return \"setfilelock\";\n\tcase CEPH_MDS_OP_GETFILELOCK: return \"getfilelock\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_trace %p is_dentry %d is_target %d\\n\"",
            "req",
            "rinfo->head->is_dentry",
            "rinfo->head->is_target"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "sb"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_trace(struct super_block *sb, struct ceph_mds_request *req,\n\t\t    struct ceph_mds_session *session)\n{\n\tstruct ceph_mds_reply_info_parsed *rinfo = &req->r_reply_info;\n\tstruct inode *in = NULL;\n\tstruct ceph_vino vino;\n\tstruct ceph_fs_client *fsc = ceph_sb_to_client(sb);\n\tint err = 0;\n\n\tdout(\"fill_trace %p is_dentry %d is_target %d\\n\", req,\n\t     rinfo->head->is_dentry, rinfo->head->is_target);\n\n#if 0\n\t/*\n\t * Debugging hook:\n\t *\n\t * If we resend completed ops to a recovering mds, we get no\n\t * trace.  Since that is very rare, pretend this is the case\n\t * to ensure the 'no trace' handlers in the callers behave.\n\t *\n\t * Fill in inodes unconditionally to avoid breaking cap\n\t * invariants.\n\t */\n\tif (rinfo->head->op & CEPH_MDS_OP_WRITE) {\n\t\tpr_info(\"fill_trace faking empty trace on %lld %s\\n\",\n\t\t\treq->r_tid, ceph_mds_op_name(rinfo->head->op));\n\t\tif (rinfo->head->is_dentry) {\n\t\t\trinfo->head->is_dentry = 0;\n\t\t\terr = fill_inode(req->r_locked_dir,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1);\n\t\t}\n\t\tif (rinfo->head->is_target) {\n\t\t\trinfo->head->is_target = 0;\n\t\t\tininfo = rinfo->targeti.in;\n\t\t\tvino.ino = le64_to_cpu(ininfo->ino);\n\t\t\tvino.snap = le64_to_cpu(ininfo->snapid);\n\t\t\tin = ceph_get_inode(sb, vino);\n\t\t\terr = fill_inode(in, &rinfo->targeti, NULL,\n\t\t\t\t\t session, req->r_request_started,\n\t\t\t\t\t req->r_fmode);\n\t\t\tiput(in);\n\t\t}\n\t}\n#endif\n\n\tif (!rinfo->head->is_target && !rinfo->head->is_dentry) {\n\t\tdout(\"fill_trace reply is empty!\\n\");\n\t\tif (rinfo->head->result == 0 && req->r_locked_dir)\n\t\t\tceph_invalidate_dir_request(req);\n\t\treturn 0;\n\t}\n\n\tif (rinfo->head->is_dentry) {\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\tif (dir) {\n\t\t\terr = fill_inode(dir, NULL,\n\t\t\t\t\t &rinfo->diri, rinfo->dirfrag,\n\t\t\t\t\t session, req->r_request_started, -1,\n\t\t\t\t\t &req->r_caps_reservation);\n\t\t\tif (err < 0)\n\t\t\t\tgoto done;\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\tif (dir && req->r_op == CEPH_MDS_OP_LOOKUPNAME) {\n\t\t\tstruct qstr dname;\n\t\t\tstruct dentry *dn, *parent;\n\n\t\t\tBUG_ON(!rinfo->head->is_target);\n\t\t\tBUG_ON(req->r_dentry);\n\n\t\t\tparent = d_find_any_alias(dir);\n\t\t\tBUG_ON(!parent);\n\n\t\t\tdname.name = rinfo->dname;\n\t\t\tdname.len = rinfo->dname_len;\n\t\t\tdname.hash = full_name_hash(dname.name, dname.len);\n\t\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\nretry_lookup:\n\t\t\tdn = d_lookup(parent, &dname);\n\t\t\tdout(\"d_lookup on parent=%p name=%.*s got %p\\n\",\n\t\t\t     parent, dname.len, dname.name, dn);\n\n\t\t\tif (!dn) {\n\t\t\t\tdn = d_alloc(parent, &dname);\n\t\t\t\tdout(\"d_alloc %p '%.*s' = %p\\n\", parent,\n\t\t\t\t     dname.len, dname.name, dn);\n\t\t\t\tif (dn == NULL) {\n\t\t\t\t\tdput(parent);\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\terr = ceph_init_dentry(dn);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tdput(dn);\n\t\t\t\t\tdput(parent);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else if (dn->d_inode &&\n\t\t\t\t   (ceph_ino(dn->d_inode) != vino.ino ||\n\t\t\t\t    ceph_snap(dn->d_inode) != vino.snap)) {\n\t\t\t\tdout(\" dn %p points to wrong inode %p\\n\",\n\t\t\t\t     dn, dn->d_inode);\n\t\t\t\td_delete(dn);\n\t\t\t\tdput(dn);\n\t\t\t\tgoto retry_lookup;\n\t\t\t}\n\n\t\t\treq->r_dentry = dn;\n\t\t\tdput(parent);\n\t\t}\n\t}\n\n\tif (rinfo->head->is_target) {\n\t\tvino.ino = le64_to_cpu(rinfo->targeti.in->ino);\n\t\tvino.snap = le64_to_cpu(rinfo->targeti.in->snapid);\n\n\t\tin = ceph_get_inode(sb, vino);\n\t\tif (IS_ERR(in)) {\n\t\t\terr = PTR_ERR(in);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_target_inode = in;\n\n\t\terr = fill_inode(in, req->r_locked_page, &rinfo->targeti, NULL,\n\t\t\t\tsession, req->r_request_started,\n\t\t\t\t(!req->r_aborted && rinfo->head->result == 0) ?\n\t\t\t\treq->r_fmode : -1,\n\t\t\t\t&req->r_caps_reservation);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"fill_inode badness %p %llx.%llx\\n\",\n\t\t\t\tin, ceph_vinop(in));\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/*\n\t * ignore null lease/binding on snapdir ENOENT, or else we\n\t * will have trouble splicing in the virtual snapdir later\n\t */\n\tif (rinfo->head->is_dentry && !req->r_aborted &&\n\t    req->r_locked_dir &&\n\t    (rinfo->head->is_target || strncmp(req->r_dentry->d_name.name,\n\t\t\t\t\t       fsc->mount_options->snapdir_name,\n\t\t\t\t\t       req->r_dentry->d_name.len))) {\n\t\t/*\n\t\t * lookup link rename   : null -> possibly existing inode\n\t\t * mknod symlink mkdir  : null -> new inode\n\t\t * unlink               : linked -> null\n\t\t */\n\t\tstruct inode *dir = req->r_locked_dir;\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tbool have_dir_cap, have_lease;\n\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(dn->d_parent->d_inode != dir);\n\t\tBUG_ON(ceph_ino(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->ino));\n\t\tBUG_ON(ceph_snap(dir) !=\n\t\t       le64_to_cpu(rinfo->diri.in->snapid));\n\n\t\t/* do we have a lease on the whole dir? */\n\t\thave_dir_cap =\n\t\t\t(le32_to_cpu(rinfo->diri.in->cap.caps) &\n\t\t\t CEPH_CAP_FILE_SHARED);\n\n\t\t/* do we have a dn lease? */\n\t\thave_lease = have_dir_cap ||\n\t\t\tle32_to_cpu(rinfo->dlease->duration_ms);\n\t\tif (!have_lease)\n\t\t\tdout(\"fill_trace  no dentry lease or dir cap\\n\");\n\n\t\t/* rename? */\n\t\tif (req->r_old_dentry && req->r_op == CEPH_MDS_OP_RENAME) {\n\t\t\tstruct inode *olddir = req->r_old_dentry_dir;\n\t\t\tBUG_ON(!olddir);\n\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\t\t\tdout(\"fill_trace doing d_move %p -> %p\\n\",\n\t\t\t     req->r_old_dentry, dn);\n\n\t\t\td_move(req->r_old_dentry, dn);\n\t\t\tdout(\" src %p '%pd' dst %p '%pd'\\n\",\n\t\t\t     req->r_old_dentry,\n\t\t\t     req->r_old_dentry,\n\t\t\t     dn, dn);\n\n\t\t\t/* ensure target dentry is invalidated, despite\n\t\t\t   rehashing bug in vfs_rename_dir */\n\t\t\tceph_invalidate_dentry_lease(dn);\n\n\t\t\t/* d_move screws up sibling dentries' offsets */\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tceph_dir_clear_ordered(olddir);\n\n\t\t\tdout(\"dn %p gets new offset %lld\\n\", req->r_old_dentry,\n\t\t\t     ceph_dentry(req->r_old_dentry)->offset);\n\n\t\t\tdn = req->r_old_dentry;  /* use old_dentry */\n\t\t}\n\n\t\t/* null dentry? */\n\t\tif (!rinfo->head->is_target) {\n\t\t\tdout(\"fill_trace null dentry\\n\");\n\t\t\tif (dn->d_inode) {\n\t\t\t\tceph_dir_clear_ordered(dir);\n\t\t\t\tdout(\"d_delete %p\\n\", dn);\n\t\t\t\td_delete(dn);\n\t\t\t} else {\n\t\t\t\tdout(\"d_instantiate %p NULL\\n\", dn);\n\t\t\t\td_instantiate(dn, NULL);\n\t\t\t\tif (have_lease && d_unhashed(dn))\n\t\t\t\t\td_rehash(dn);\n\t\t\t\tupdate_dentry_lease(dn, rinfo->dlease,\n\t\t\t\t\t\t    session,\n\t\t\t\t\t\t    req->r_request_started);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* attach proper inode */\n\t\tif (!dn->d_inode) {\n\t\t\tceph_dir_clear_ordered(dir);\n\t\t\tihold(in);\n\t\t\tdn = splice_dentry(dn, in, &have_lease);\n\t\t\tif (IS_ERR(dn)) {\n\t\t\t\terr = PTR_ERR(dn);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\treq->r_dentry = dn;  /* may have spliced */\n\t\t} else if (dn->d_inode && dn->d_inode != in) {\n\t\t\tdout(\" %p links to %p %llx.%llx, not %llx.%llx\\n\",\n\t\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode),\n\t\t\t     ceph_vinop(in));\n\t\t\thave_lease = false;\n\t\t}\n\n\t\tif (have_lease)\n\t\t\tupdate_dentry_lease(dn, rinfo->dlease, session,\n\t\t\t\t\t    req->r_request_started);\n\t\tdout(\" final dn %p\\n\", dn);\n\t} else if (!req->r_aborted &&\n\t\t   (req->r_op == CEPH_MDS_OP_LOOKUPSNAP ||\n\t\t    req->r_op == CEPH_MDS_OP_MKSNAP)) {\n\t\tstruct dentry *dn = req->r_dentry;\n\t\tstruct inode *dir = req->r_locked_dir;\n\n\t\t/* fill out a snapdir LOOKUPSNAP dentry */\n\t\tBUG_ON(!dn);\n\t\tBUG_ON(!dir);\n\t\tBUG_ON(ceph_snap(dir) != CEPH_SNAPDIR);\n\t\tdout(\" linking snapped dir %p to dn %p\\n\", in, dn);\n\t\tceph_dir_clear_ordered(dir);\n\t\tihold(in);\n\t\tdn = splice_dentry(dn, in, NULL);\n\t\tif (IS_ERR(dn)) {\n\t\t\terr = PTR_ERR(dn);\n\t\t\tgoto done;\n\t\t}\n\t\treq->r_dentry = dn;  /* may have spliced */\n\t}\ndone:\n\tdout(\"fill_trace done err=%d\\n\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "splice_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "978-1013",
    "snippet": "static struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dn"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dn"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"dn %p attached to %p ino %llx.%llx\\n\"",
            "dn",
            "dn->d_inode",
            "ceph_vinop(dn->d_inode)"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "dn->d_inode"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ceph_dentry(dn)"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dn"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dn"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\"",
            "dn",
            "d_count(dn)",
            "realdn",
            "d_count(realdn)",
            "realdn->d_inode",
            "ceph_vinop(realdn->d_inode)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "realdn->d_inode"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_count",
          "args": [
            "realdn"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_destroy_seqid_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4state.c",
          "lines": "464-468",
          "snippet": "static void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <linux/sunrpc/clnt.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/workqueue.h>\n#include <linux/ratelimit.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/nfs_idmap.h>\n#include <linux/nfs_fs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic void\nnfs4_destroy_seqid_counter(struct nfs_seqid_counter *sc)\n{\n\trpc_destroy_wait_queue(&sc->wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\"",
            "PTR_ERR(realdn)",
            "dn",
            "in",
            "ceph_vinop(in)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "in"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "realdn"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "realdn"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "in",
            "dn"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dn"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dn"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dn->d_inode"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct dentry *splice_dentry(struct dentry *dn, struct inode *in,\n\t\t\t\t    bool *prehash)\n{\n\tstruct dentry *realdn;\n\n\tBUG_ON(dn->d_inode);\n\n\t/* dn must be unhashed */\n\tif (!d_unhashed(dn))\n\t\td_drop(dn);\n\trealdn = d_splice_alias(in, dn);\n\tif (IS_ERR(realdn)) {\n\t\tpr_err(\"splice_dentry error %ld %p inode %p ino %llx.%llx\\n\",\n\t\t       PTR_ERR(realdn), dn, in, ceph_vinop(in));\n\t\tif (prehash)\n\t\t\t*prehash = false; /* don't rehash on error */\n\t\tdn = realdn; /* note realdn contains the error */\n\t\tgoto out;\n\t} else if (realdn) {\n\t\tdout(\"dn %p (%d) spliced with %p (%d) \"\n\t\t     \"inode %p ino %llx.%llx\\n\",\n\t\t     dn, d_count(dn),\n\t\t     realdn, d_count(realdn),\n\t\t     realdn->d_inode, ceph_vinop(realdn->d_inode));\n\t\tdput(dn);\n\t\tdn = realdn;\n\t} else {\n\t\tBUG_ON(!ceph_dentry(dn));\n\t\tdout(\"dn %p attached to %p ino %llx.%llx\\n\",\n\t\t     dn, dn->d_inode, ceph_vinop(dn->d_inode));\n\t}\n\tif ((!prehash || *prehash) && d_unhashed(dn))\n\t\td_rehash(dn);\nout:\n\treturn dn;\n}"
  },
  {
    "function_name": "update_dentry_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "923-968",
    "snippet": "static void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "lease->seq"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_mds_session",
          "args": [
            "session"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_mds_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/mds_client.h",
          "lines": "338-343",
          "snippet": "static inline struct ceph_mds_session *\nceph_get_mds_session(struct ceph_mds_session *s)\n{\n\tatomic_inc(&s->s_ref);\n\treturn s;\n}",
          "includes": [
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mdsmap.h>",
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>",
            "#include <linux/kref.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/auth.h>\n#include <linux/ceph/mdsmap.h>\n#include <linux/ceph/messenger.h>\n#include <linux/ceph/types.h>\n#include <linux/spinlock.h>\n#include <linux/rbtree.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/kref.h>\n#include <linux/completion.h>\n\nstatic inline struct ceph_mds_session *\nceph_get_mds_session(struct ceph_mds_session *s)\n{\n\tatomic_inc(&s->s_ref);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dentry_lru_touch",
          "args": [
            "dentry"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry_lru_touch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/dir.c",
          "lines": "1285-1296",
          "snippet": "void ceph_dentry_lru_touch(struct dentry *dn)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dn);\n\tstruct ceph_mds_client *mdsc;\n\n\tdout(\"dentry_lru_touch %p %p '%pd' (offset %lld)\\n\", di, dn, dn,\n\t     di->offset);\n\tmdsc = ceph_sb_to_client(dn->d_sb)->mdsc;\n\tspin_lock(&mdsc->dentry_lru_lock);\n\tlist_move_tail(&di->lru, &mdsc->dentry_lru);\n\tspin_unlock(&mdsc->dentry_lru_lock);\n}",
          "includes": [
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/namei.h>\n#include <linux/fs_struct.h>\n#include <linux/spinlock.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_dentry_lru_touch(struct dentry *dn)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dn);\n\tstruct ceph_mds_client *mdsc;\n\n\tdout(\"dentry_lru_touch %p %p '%pd' (offset %lld)\\n\", di, dn, dn,\n\t     di->offset);\n\tmdsc = ceph_sb_to_client(dn->d_sb)->mdsc;\n\tspin_lock(&mdsc->dentry_lru_lock);\n\tlist_move_tail(&di->lru, &mdsc->dentry_lru);\n\tspin_unlock(&mdsc->dentry_lru_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "ttl",
            "dentry->d_time"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "dir"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"update_dentry_lease %p duration %lu ms ttl %lu\\n\"",
            "dentry",
            "duration",
            "ttl"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_dentry",
          "args": [
            "dentry"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "508-511",
          "snippet": "static inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_dentry_info *ceph_dentry(struct dentry *dentry)\n{\n\treturn (struct ceph_dentry_info *)dentry->d_fsdata;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void update_dentry_lease(struct dentry *dentry,\n\t\t\t\tstruct ceph_mds_reply_lease *lease,\n\t\t\t\tstruct ceph_mds_session *session,\n\t\t\t\tunsigned long from_time)\n{\n\tstruct ceph_dentry_info *di = ceph_dentry(dentry);\n\tlong unsigned duration = le32_to_cpu(lease->duration_ms);\n\tlong unsigned ttl = from_time + (duration * HZ) / 1000;\n\tlong unsigned half_ttl = from_time + (duration * HZ / 2) / 1000;\n\tstruct inode *dir;\n\n\t/* only track leases on regular dentries */\n\tif (dentry->d_op != &ceph_dentry_ops)\n\t\treturn;\n\n\tspin_lock(&dentry->d_lock);\n\tdout(\"update_dentry_lease %p duration %lu ms ttl %lu\\n\",\n\t     dentry, duration, ttl);\n\n\t/* make lease_rdcache_gen match directory */\n\tdir = dentry->d_parent->d_inode;\n\tdi->lease_shared_gen = ceph_inode(dir)->i_shared_gen;\n\n\tif (duration == 0)\n\t\tgoto out_unlock;\n\n\tif (di->lease_gen == session->s_cap_gen &&\n\t    time_before(ttl, dentry->d_time))\n\t\tgoto out_unlock;  /* we already have a newer lease. */\n\n\tif (di->lease_session && di->lease_session != session)\n\t\tgoto out_unlock;\n\n\tceph_dentry_lru_touch(dentry);\n\n\tif (!di->lease_session)\n\t\tdi->lease_session = ceph_get_mds_session(session);\n\tdi->lease_gen = session->s_cap_gen;\n\tdi->lease_seq = le32_to_cpu(lease->seq);\n\tdi->lease_renew_after = half_ttl;\n\tdi->lease_renew_from = 0;\n\tdentry->d_time = ttl;\nout_unlock:\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n}"
  },
  {
    "function_name": "fill_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "662-918",
    "snippet": "static int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations ceph_symlink_iops;",
      "const struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};",
      "static const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "xattr_blob"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_cap",
          "args": [
            "mdsc",
            "new_cap"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2274-2326",
          "snippet": "void ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_put_cap_refs(struct ceph_inode_info *ci, int had)\n{\n\tstruct inode *inode = &ci->vfs_inode;\n\tint last = 0, put = 0, flushsnaps = 0, wake = 0;\n\tstruct ceph_cap_snap *capsnap;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (had & CEPH_CAP_PIN)\n\t\t--ci->i_pin_ref;\n\tif (had & CEPH_CAP_FILE_RD)\n\t\tif (--ci->i_rd_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_CACHE)\n\t\tif (--ci->i_rdcache_ref == 0)\n\t\t\tlast++;\n\tif (had & CEPH_CAP_FILE_BUFFER) {\n\t\tif (--ci->i_wb_ref == 0) {\n\t\t\tlast++;\n\t\t\tput++;\n\t\t}\n\t\tdout(\"put_cap_refs %p wb %d -> %d (?)\\n\",\n\t\t     inode, ci->i_wb_ref+1, ci->i_wb_ref);\n\t}\n\tif (had & CEPH_CAP_FILE_WR)\n\t\tif (--ci->i_wr_ref == 0) {\n\t\t\tlast++;\n\t\t\tif (!list_empty(&ci->i_cap_snaps)) {\n\t\t\t\tcapsnap = list_first_entry(&ci->i_cap_snaps,\n\t\t\t\t\t\t     struct ceph_cap_snap,\n\t\t\t\t\t\t     ci_item);\n\t\t\t\tif (capsnap->writing) {\n\t\t\t\t\tcapsnap->writing = 0;\n\t\t\t\t\tflushsnaps =\n\t\t\t\t\t\t__ceph_finish_cap_snap(ci,\n\t\t\t\t\t\t\t\t       capsnap);\n\t\t\t\t\twake = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tdout(\"put_cap_refs %p had %s%s%s\\n\", inode, ceph_cap_string(had),\n\t     last ? \" last\" : \"\", put ? \" put\" : \"\");\n\n\tif (last && !flushsnaps)\n\t\tceph_check_caps(ci, 0, NULL);\n\telse if (flushsnaps)\n\t\tceph_flush_snaps(ci);\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\tif (put)\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_dirfrag",
          "args": [
            "inode",
            "dirinfo"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_dirfrag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "240-301",
          "snippet": "static int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_fragtree",
          "args": [
            "inode",
            "&info->fragtree",
            "dirinfo"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_fragtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "303-371",
          "snippet": "static int ceph_fill_fragtree(struct inode *inode,\n\t\t\t      struct ceph_frag_tree_head *fragtree,\n\t\t\t      struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *rb_node;\n\tint i;\n\tu32 id, nsplits;\n\tbool update = false;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tnsplits = le32_to_cpu(fragtree->nsplits);\n\tif (nsplits) {\n\t\ti = prandom_u32() % nsplits;\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tif (!__ceph_find_frag(ci, id))\n\t\t\tupdate = true;\n\t} else if (!RB_EMPTY_ROOT(&ci->i_fragtree)) {\n\t\trb_node = rb_first(&ci->i_fragtree);\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\tif (frag->frag != ceph_frag_make(0, 0) || rb_next(rb_node))\n\t\t\tupdate = true;\n\t}\n\tif (!update && dirinfo) {\n\t\tid = le32_to_cpu(dirinfo->frag);\n\t\tif (id != __ceph_choose_frag(ci, id, NULL, NULL))\n\t\t\tupdate = true;\n\t}\n\tif (!update)\n\t\tgoto out_unlock;\n\n\tdout(\"fill_fragtree %llx.%llx\\n\", ceph_vinop(inode));\n\trb_node = rb_first(&ci->i_fragtree);\n\tfor (i = 0; i < nsplits; i++) {\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tfrag = NULL;\n\t\twhile (rb_node) {\n\t\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\t\tif (ceph_frag_compare(frag->frag, id) >= 0) {\n\t\t\t\tif (frag->frag != id)\n\t\t\t\t\tfrag = NULL;\n\t\t\t\telse\n\t\t\t\t\trb_node = rb_next(rb_node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trb_node = rb_next(rb_node);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t\tfrag = NULL;\n\t\t}\n\t\tif (!frag) {\n\t\t\tfrag = __get_or_create_frag(ci, id);\n\t\t\tif (IS_ERR(frag))\n\t\t\t\tcontinue;\n\t\t}\n\t\tfrag->split_by = le32_to_cpu(fragtree->splits[i].by);\n\t\tdout(\" frag %x split by %d\\n\", frag->frag, frag->split_by);\n\t}\n\twhile (rb_node) {\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\trb_node = rb_next(rb_node);\n\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\nout_unlock:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_fill_fragtree(struct inode *inode,\n\t\t\t      struct ceph_frag_tree_head *fragtree,\n\t\t\t      struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *rb_node;\n\tint i;\n\tu32 id, nsplits;\n\tbool update = false;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tnsplits = le32_to_cpu(fragtree->nsplits);\n\tif (nsplits) {\n\t\ti = prandom_u32() % nsplits;\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tif (!__ceph_find_frag(ci, id))\n\t\t\tupdate = true;\n\t} else if (!RB_EMPTY_ROOT(&ci->i_fragtree)) {\n\t\trb_node = rb_first(&ci->i_fragtree);\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\tif (frag->frag != ceph_frag_make(0, 0) || rb_next(rb_node))\n\t\t\tupdate = true;\n\t}\n\tif (!update && dirinfo) {\n\t\tid = le32_to_cpu(dirinfo->frag);\n\t\tif (id != __ceph_choose_frag(ci, id, NULL, NULL))\n\t\t\tupdate = true;\n\t}\n\tif (!update)\n\t\tgoto out_unlock;\n\n\tdout(\"fill_fragtree %llx.%llx\\n\", ceph_vinop(inode));\n\trb_node = rb_first(&ci->i_fragtree);\n\tfor (i = 0; i < nsplits; i++) {\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tfrag = NULL;\n\t\twhile (rb_node) {\n\t\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\t\tif (ceph_frag_compare(frag->frag, id) >= 0) {\n\t\t\t\tif (frag->frag != id)\n\t\t\t\t\tfrag = NULL;\n\t\t\t\telse\n\t\t\t\t\trb_node = rb_next(rb_node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trb_node = rb_next(rb_node);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t\tfrag = NULL;\n\t\t}\n\t\tif (!frag) {\n\t\t\tfrag = __get_or_create_frag(ci, id);\n\t\t\tif (IS_ERR(frag))\n\t\t\t\tcontinue;\n\t\t}\n\t\tfrag->split_by = le32_to_cpu(fragtree->splits[i].by);\n\t\tdout(\" frag %x split by %d\\n\", frag->frag, frag->split_by);\n\t}\n\twhile (rb_node) {\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\trb_node = rb_next(rb_node);\n\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\nout_unlock:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_queue_vmtruncate",
          "args": [
            "inode"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_vmtruncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "1614-1628",
          "snippet": "void ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_vmtruncate(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tihold(inode);\n\n\tif (queue_work(ceph_sb_to_client(inode->i_sb)->trunc_wq,\n\t\t       &ci->i_vmtruncate_work)) {\n\t\tdout(\"ceph_queue_vmtruncate %p\\n\", inode);\n\t} else {\n\t\tdout(\"ceph_queue_vmtruncate %p failed, pending=%d\\n\",\n\t\t     inode, ci->i_truncate_pending);\n\t\tiput(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fill_inline_data",
          "args": [
            "inode",
            "locked_page",
            "iinfo->inline_data",
            "iinfo->inline_len"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/addr.c",
          "lines": "1402-1443",
          "snippet": "void ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/osd_client.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>\t/* generic_writepages */",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/osd_client.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagevec.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\t/* generic_writepages */\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_inline_data(struct inode *inode, struct page *locked_page,\n\t\t\t   char\t*data, size_t len)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\n\tif (locked_page) {\n\t\tpage = locked_page;\n\t} else {\n\t\tif (i_size_read(inode) == 0)\n\t\t\treturn;\n\t\tpage = find_or_create_page(mapping, 0,\n\t\t\t\t\t   mapping_gfp_mask(mapping) & ~__GFP_FS);\n\t\tif (!page)\n\t\t\treturn;\n\t\tif (PageUptodate(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdout(\"fill_inline_data %p %llx.%llx len %zu locked_page %p\\n\",\n\t     inode, ceph_vinop(inode), len, locked_page);\n\n\tif (len > 0) {\n\t\tvoid *kaddr = kmap_atomic(page);\n\t\tmemcpy(kaddr, data, len);\n\t\tkunmap_atomic(kaddr);\n\t}\n\n\tif (page != locked_page) {\n\t\tif (len < PAGE_CACHE_SIZE)\n\t\t\tzero_user_segment(page, len, PAGE_CACHE_SIZE);\n\t\telse\n\t\t\tflush_dcache_page(page);\n\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "info->cap.caps"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_get_fmode",
          "args": [
            "ci",
            "cap_fmode"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_get_fmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "872-875",
          "snippet": "static inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void __ceph_get_fmode(struct ceph_inode_info *ci, int mode)\n{\n\tci->i_nr_by_mode[mode]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"mds issued no caps on %llx.%llx\\n\"",
            "ceph_vinop(inode)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" %p got snap_caps %s\\n\"",
            "inode",
            "ceph_cap_string(le32_to_cpu(info->cap.caps))"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_cap_string",
          "args": [
            "le32_to_cpu(info->cap.caps)"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_cap_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "71-116",
          "snippet": "const char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define MAX_CAP_STR 20"
          ],
          "globals_used": [
            "static char cap_str[MAX_CAP_STR][40];",
            "static DEFINE_SPINLOCK(cap_str_lock);",
            "static int last_cap_str;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define MAX_CAP_STR 20\n\nstatic char cap_str[MAX_CAP_STR][40];\nstatic DEFINE_SPINLOCK(cap_str_lock);\nstatic int last_cap_str;\n\nconst char *ceph_cap_string(int caps)\n{\n\tint i;\n\tchar *s;\n\tint c;\n\n\tspin_lock(&cap_str_lock);\n\ti = last_cap_str++;\n\tif (last_cap_str == MAX_CAP_STR)\n\t\tlast_cap_str = 0;\n\tspin_unlock(&cap_str_lock);\n\n\ts = cap_str[i];\n\n\tif (caps & CEPH_CAP_PIN)\n\t\t*s++ = 'p';\n\n\tc = (caps >> CEPH_CAP_SAUTH) & 3;\n\tif (c) {\n\t\t*s++ = 'A';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SLINK) & 3;\n\tif (c) {\n\t\t*s++ = 'L';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = (caps >> CEPH_CAP_SXATTR) & 3;\n\tif (c) {\n\t\t*s++ = 'X';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tc = caps >> CEPH_CAP_SFILE;\n\tif (c) {\n\t\t*s++ = 'F';\n\t\ts = gcap_string(s, c);\n\t}\n\n\tif (s == cap_str[i])\n\t\t*s++ = '-';\n\t*s = 0;\n\treturn cap_str[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_dir_set_complete",
          "args": [
            "ci",
            "atomic_read(&ci->i_release_count)",
            "ci->i_ordered_count"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_dir_set_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "445-453",
          "snippet": "static inline void __ceph_dir_set_complete(struct ceph_inode_info *ci,\n\t\t\t\t\t   int release_count, int ordered_count)\n{\n\tatomic_set(&ci->i_complete_count, release_count);\n\tif (ci->i_ordered_count == ordered_count)\n\t\tci->i_ceph_flags |= CEPH_I_DIR_ORDERED;\n\telse\n\t\tci->i_ceph_flags &= ~CEPH_I_DIR_ORDERED;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */\n\nstatic inline void __ceph_dir_set_complete(struct ceph_inode_info *ci,\n\t\t\t\t\t   int release_count, int ordered_count)\n{\n\tatomic_set(&ci->i_complete_count, release_count);\n\tif (ci->i_ordered_count == ordered_count)\n\t\tci->i_ceph_flags |= CEPH_I_DIR_ORDERED;\n\telse\n\t\tci->i_ceph_flags &= ~CEPH_I_DIR_ORDERED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ci->i_release_count"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" marking %p complete (empty)\\n\"",
            "inode"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_dir_is_complete",
          "args": [
            "ci"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_dir_is_complete_ordered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "466-470",
          "snippet": "static inline bool __ceph_dir_is_complete_ordered(struct ceph_inode_info *ci)\n{\n\treturn __ceph_dir_is_complete(ci) &&\n\t\t(ci->i_ceph_flags & CEPH_I_DIR_ORDERED);\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [
            "#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\n#define CEPH_I_DIR_ORDERED\t1  /* dentries in dir are ordered */\n\nstatic inline bool __ceph_dir_is_complete_ordered(struct ceph_inode_info *ci)\n{\n\treturn __ceph_dir_is_complete(ci) &&\n\t\t(ci->i_ceph_flags & CEPH_I_DIR_ORDERED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_add_cap",
          "args": [
            "inode",
            "session",
            "le64_to_cpu(info->cap.cap_id)",
            "cap_fmode",
            "caps",
            "le32_to_cpu(info->cap.wanted)",
            "le32_to_cpu(info->cap.seq)",
            "le32_to_cpu(info->cap.mseq)",
            "le64_to_cpu(info->cap.realm)",
            "info->cap.flags",
            "&new_cap"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_add_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "511-635",
          "snippet": "void ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_add_cap(struct inode *inode,\n\t\t  struct ceph_mds_session *session, u64 cap_id,\n\t\t  int fmode, unsigned issued, unsigned wanted,\n\t\t  unsigned seq, unsigned mseq, u64 realmino, int flags,\n\t\t  struct ceph_cap **new_cap)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_cap *cap;\n\tint mds = session->s_mds;\n\tint actual_wanted;\n\n\tdout(\"add_cap %p mds%d cap %llx %s seq %d\\n\", inode,\n\t     session->s_mds, cap_id, ceph_cap_string(issued), seq);\n\n\t/*\n\t * If we are opening the file, include file mode wanted bits\n\t * in wanted.\n\t */\n\tif (fmode >= 0)\n\t\twanted |= ceph_caps_for_mode(fmode);\n\n\tcap = __get_cap_for_mds(ci, mds);\n\tif (!cap) {\n\t\tcap = *new_cap;\n\t\t*new_cap = NULL;\n\n\t\tcap->issued = 0;\n\t\tcap->implemented = 0;\n\t\tcap->mds = mds;\n\t\tcap->mds_wanted = 0;\n\t\tcap->mseq = 0;\n\n\t\tcap->ci = ci;\n\t\t__insert_cap_node(ci, cap);\n\n\t\t/* add to session cap list */\n\t\tcap->session = session;\n\t\tspin_lock(&session->s_cap_lock);\n\t\tlist_add_tail(&cap->session_caps, &session->s_caps);\n\t\tsession->s_nr_caps++;\n\t\tspin_unlock(&session->s_cap_lock);\n\t} else {\n\t\t/*\n\t\t * auth mds of the inode changed. we received the cap export\n\t\t * message, but still haven't received the cap import message.\n\t\t * handle_cap_export() updated the new auth MDS' cap.\n\t\t *\n\t\t * \"ceph_seq_cmp(seq, cap->seq) <= 0\" means we are processing\n\t\t * a message that was send before the cap import message. So\n\t\t * don't remove caps.\n\t\t */\n\t\tif (ceph_seq_cmp(seq, cap->seq) <= 0) {\n\t\t\tWARN_ON(cap != ci->i_auth_cap);\n\t\t\tWARN_ON(cap->cap_id != cap_id);\n\t\t\tseq = cap->seq;\n\t\t\tmseq = cap->mseq;\n\t\t\tissued |= cap->issued;\n\t\t\tflags |= CEPH_CAP_FLAG_AUTH;\n\t\t}\n\t}\n\n\tif (!ci->i_snap_realm) {\n\t\t/*\n\t\t * add this inode to the appropriate snap realm\n\t\t */\n\t\tstruct ceph_snap_realm *realm = ceph_lookup_snap_realm(mdsc,\n\t\t\t\t\t\t\t       realmino);\n\t\tif (realm) {\n\t\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\t\tci->i_snap_realm = realm;\n\t\t\tlist_add(&ci->i_snap_realm_item,\n\t\t\t\t &realm->inodes_with_caps);\n\t\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\t} else {\n\t\t\tpr_err(\"ceph_add_cap: couldn't find snap realm %llx\\n\",\n\t\t\t       realmino);\n\t\t\tWARN_ON(!realm);\n\t\t}\n\t}\n\n\t__check_cap_issue(ci, cap, issued);\n\n\t/*\n\t * If we are issued caps we don't want, or the mds' wanted\n\t * value appears to be off, queue a check so we'll release\n\t * later and/or update the mds wanted value.\n\t */\n\tactual_wanted = __ceph_caps_wanted(ci);\n\tif ((wanted & ~actual_wanted) ||\n\t    (issued & ~actual_wanted & CEPH_CAP_ANY_WR)) {\n\t\tdout(\" issued %s, mds wanted %s, actual %s, queueing\\n\",\n\t\t     ceph_cap_string(issued), ceph_cap_string(wanted),\n\t\t     ceph_cap_string(actual_wanted));\n\t\t__cap_delay_requeue(mdsc, ci);\n\t}\n\n\tif (flags & CEPH_CAP_FLAG_AUTH) {\n\t\tif (ci->i_auth_cap == NULL ||\n\t\t    ceph_seq_cmp(ci->i_auth_cap->mseq, mseq) < 0) {\n\t\t\tci->i_auth_cap = cap;\n\t\t\tcap->mds_wanted = wanted;\n\t\t}\n\t} else {\n\t\tWARN_ON(ci->i_auth_cap == cap);\n\t}\n\n\tdout(\"add_cap inode %p (%llx.%llx) cap %p %s now %s seq %d mds%d\\n\",\n\t     inode, ceph_vinop(inode), cap, ceph_cap_string(issued),\n\t     ceph_cap_string(issued|cap->issued), seq, mds);\n\tcap->cap_id = cap_id;\n\tcap->issued = issued;\n\tcap->implemented |= issued;\n\tif (ceph_seq_cmp(mseq, cap->mseq) > 0)\n\t\tcap->mds_wanted = wanted;\n\telse\n\t\tcap->mds_wanted |= wanted;\n\tcap->seq = seq;\n\tcap->issue_seq = seq;\n\tcap->mseq = mseq;\n\tcap->cap_gen = session->s_cap_gen;\n\n\tif (fmode >= 0)\n\t\t__ceph_get_fmode(ci, fmode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "info->cap.realm"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_snap",
          "args": [
            "inode"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_snap_op_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/strings.c",
          "lines": "115-124",
          "snippet": "const char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nconst char *ceph_snap_op_name(int o)\n{\n\tswitch (o) {\n\tcase CEPH_SNAP_OP_UPDATE: return \"update\";\n\tcase CEPH_SNAP_OP_CREATE: return \"create\";\n\tcase CEPH_SNAP_OP_DESTROY: return \"destroy\";\n\tcase CEPH_SNAP_OP_SPLIT: return \"split\";\n\t}\n\treturn \"???\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_inode %llx.%llx BAD mode 0%o\\n\"",
            "ceph_vinop(inode)",
            "inode->i_mode"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&ci->i_rctime",
            "&info->rctime"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sym"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrndup",
          "args": [
            "iinfo->symlink",
            "symlen",
            "GFP_NOFS"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "symlen != inode->i_size"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_forget_all_cached_acls",
          "args": [
            "inode"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_forget_all_cached_acls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "818-820",
          "snippet": "static inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_forget_all_cached_acls(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ci->i_xattrs.blob->vec.iov_base",
            "iinfo->xattr_data",
            "iinfo->xattr_len"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.blob"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"max_size %lld -> %llu\\n\"",
            "ci->i_max_size",
            "le64_to_cpu(info->max_size)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_fill_file_size",
          "args": [
            "inode",
            "issued",
            "le32_to_cpu(info->truncate_seq)",
            "le64_to_cpu(info->truncate_size)",
            "le64_to_cpu(info->size)"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_file_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "542-590",
          "snippet": "int ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fill_file_time",
          "args": [
            "inode",
            "issued",
            "le32_to_cpu(info->time_warp_seq)",
            "&ctime",
            "&mtime",
            "&atime"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fill_file_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "592-656",
          "snippet": "void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&ctime",
            "&info->ctime"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&mtime",
            "&info->mtime"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_decode_timespec",
          "args": [
            "&atime",
            "&info->atime"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le32_to_cpu(info->nlink)"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p mode 0%o uid.gid %d.%d\\n\"",
            "inode",
            "inode->i_mode",
            "from_kuid(&init_user_ns, inode->i_uid)",
            "from_kgid(&init_user_ns, inode->i_gid)"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "inode->i_gid"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "inode->i_uid"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(info->gid)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(info->uid)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "le32_to_cpu(info->layout.fl_stripe_unit)"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_dirty",
          "args": [
            "ci"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "550-553",
          "snippet": "static inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline int __ceph_caps_dirty(struct ceph_inode_info *ci)\n{\n\treturn ci->i_dirty_caps | ci->i_flushing_caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ceph_caps_issued",
          "args": [
            "ci",
            "&implemented"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_issued_other",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "700-715",
          "snippet": "int __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_issued_other(struct ceph_inode_info *ci, struct ceph_cap *ocap)\n{\n\tint have = ci->i_snap_caps;\n\tstruct ceph_cap *cap;\n\tstruct rb_node *p;\n\n\tfor (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {\n\t\tcap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tif (cap == ocap)\n\t\t\tcontinue;\n\t\tif (!__cap_is_valid(cap))\n\t\t\tcontinue;\n\t\thave |= cap->issued;\n\t}\n\treturn have;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_inode ENOMEM xattr blob %d bytes\\n\"",
            "iinfo->xattr_len"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_new",
          "args": [
            "iinfo->xattr_len",
            "GFP_NOFS"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_get_cap",
          "args": [
            "mdsc",
            "caps_reservation"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_cap_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "2258-2263",
          "snippet": "void ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_get_cap_refs(struct ceph_inode_info *ci, int caps)\n{\n\tspin_lock(&ci->i_ceph_lock);\n\t__take_cap_refs(ci, caps);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "le64_to_cpu(info->version)",
            "ci->i_version"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic const struct inode_operations ceph_symlink_iops;\nconst struct inode_operations ceph_file_iops = {\n\t.permission = ceph_permission,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n\t.get_acl = ceph_get_acl,\n\t.set_acl = ceph_set_acl,\n};\nstatic const struct inode_operations ceph_symlink_iops = {\n\t.readlink = generic_readlink,\n\t.follow_link = ceph_sym_follow_link,\n\t.setattr = ceph_setattr,\n\t.getattr = ceph_getattr,\n\t.setxattr = ceph_setxattr,\n\t.getxattr = ceph_getxattr,\n\t.listxattr = ceph_listxattr,\n\t.removexattr = ceph_removexattr,\n};\n\nstatic int fill_inode(struct inode *inode, struct page *locked_page,\n\t\t      struct ceph_mds_reply_info_in *iinfo,\n\t\t      struct ceph_mds_reply_dirfrag *dirinfo,\n\t\t      struct ceph_mds_session *session,\n\t\t      unsigned long ttl_from, int cap_fmode,\n\t\t      struct ceph_cap_reservation *caps_reservation)\n{\n\tstruct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;\n\tstruct ceph_mds_reply_inode *info = iinfo->in;\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint issued = 0, implemented, new_issued;\n\tstruct timespec mtime, atime, ctime;\n\tstruct ceph_buffer *xattr_blob = NULL;\n\tstruct ceph_cap *new_cap = NULL;\n\tint err = 0;\n\tbool wake = false;\n\tbool queue_trunc = false;\n\tbool new_version = false;\n\tbool fill_inline = false;\n\n\tdout(\"fill_inode %p ino %llx.%llx v %llu had %llu\\n\",\n\t     inode, ceph_vinop(inode), le64_to_cpu(info->version),\n\t     ci->i_version);\n\n\t/* prealloc new cap struct */\n\tif (info->cap.caps && ceph_snap(inode) == CEPH_NOSNAP)\n\t\tnew_cap = ceph_get_cap(mdsc, caps_reservation);\n\n\t/*\n\t * prealloc xattr data, if it looks like we'll need it.  only\n\t * if len > 4 (meaning there are actually xattrs; the first 4\n\t * bytes are the xattr count).\n\t */\n\tif (iinfo->xattr_len > 4) {\n\t\txattr_blob = ceph_buffer_new(iinfo->xattr_len, GFP_NOFS);\n\t\tif (!xattr_blob)\n\t\t\tpr_err(\"fill_inode ENOMEM xattr blob %d bytes\\n\",\n\t\t\t       iinfo->xattr_len);\n\t}\n\n\tspin_lock(&ci->i_ceph_lock);\n\n\t/*\n\t * provided version will be odd if inode value is projected,\n\t * even if stable.  skip the update if we have newer stable\n\t * info (ours>=theirs, e.g. due to racing mds replies), unless\n\t * we are getting projected (unstable) info (in which case the\n\t * version is odd, and we want ours>theirs).\n\t *   us   them\n\t *   2    2     skip\n\t *   3    2     skip\n\t *   3    3     update\n\t */\n\tif (ci->i_version == 0 ||\n\t    ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t     le64_to_cpu(info->version) > (ci->i_version & ~1)))\n\t\tnew_version = true;\n\n\tissued = __ceph_caps_issued(ci, &implemented);\n\tissued |= implemented | __ceph_caps_dirty(ci);\n\tnew_issued = ~issued & le32_to_cpu(info->cap.caps);\n\n\t/* update inode */\n\tci->i_version = le64_to_cpu(info->version);\n\tinode->i_version++;\n\tinode->i_rdev = le32_to_cpu(info->rdev);\n\tinode->i_blkbits = fls(le32_to_cpu(info->layout.fl_stripe_unit)) - 1;\n\n\tif ((new_version || (new_issued & CEPH_CAP_AUTH_SHARED)) &&\n\t    (issued & CEPH_CAP_AUTH_EXCL) == 0) {\n\t\tinode->i_mode = le32_to_cpu(info->mode);\n\t\tinode->i_uid = make_kuid(&init_user_ns, le32_to_cpu(info->uid));\n\t\tinode->i_gid = make_kgid(&init_user_ns, le32_to_cpu(info->gid));\n\t\tdout(\"%p mode 0%o uid.gid %d.%d\\n\", inode, inode->i_mode,\n\t\t     from_kuid(&init_user_ns, inode->i_uid),\n\t\t     from_kgid(&init_user_ns, inode->i_gid));\n\t}\n\n\tif ((new_version || (new_issued & CEPH_CAP_LINK_SHARED)) &&\n\t    (issued & CEPH_CAP_LINK_EXCL) == 0)\n\t\tset_nlink(inode, le32_to_cpu(info->nlink));\n\n\tif (new_version || (new_issued & CEPH_CAP_ANY_RD)) {\n\t\t/* be careful with mtime, atime, size */\n\t\tceph_decode_timespec(&atime, &info->atime);\n\t\tceph_decode_timespec(&mtime, &info->mtime);\n\t\tceph_decode_timespec(&ctime, &info->ctime);\n\t\tceph_fill_file_time(inode, issued,\n\t\t\t\tle32_to_cpu(info->time_warp_seq),\n\t\t\t\t&ctime, &mtime, &atime);\n\t}\n\n\tif (new_version ||\n\t    (new_issued & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR))) {\n\t\tci->i_layout = info->layout;\n\t\tqueue_trunc = ceph_fill_file_size(inode, issued,\n\t\t\t\t\tle32_to_cpu(info->truncate_seq),\n\t\t\t\t\tle64_to_cpu(info->truncate_size),\n\t\t\t\t\tle64_to_cpu(info->size));\n\t\t/* only update max_size on auth cap */\n\t\tif ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&\n\t\t    ci->i_max_size != le64_to_cpu(info->max_size)) {\n\t\t\tdout(\"max_size %lld -> %llu\\n\", ci->i_max_size,\n\t\t\t\t\tle64_to_cpu(info->max_size));\n\t\t\tci->i_max_size = le64_to_cpu(info->max_size);\n\t\t}\n\t}\n\n\t/* xattrs */\n\t/* note that if i_xattrs.len <= 4, i_xattrs.data will still be NULL. */\n\tif ((ci->i_xattrs.version == 0 || !(issued & CEPH_CAP_XATTR_EXCL))  &&\n\t    le64_to_cpu(info->xattr_version) > ci->i_xattrs.version) {\n\t\tif (ci->i_xattrs.blob)\n\t\t\tceph_buffer_put(ci->i_xattrs.blob);\n\t\tci->i_xattrs.blob = xattr_blob;\n\t\tif (xattr_blob)\n\t\t\tmemcpy(ci->i_xattrs.blob->vec.iov_base,\n\t\t\t       iinfo->xattr_data, iinfo->xattr_len);\n\t\tci->i_xattrs.version = le64_to_cpu(info->xattr_version);\n\t\tceph_forget_all_cached_acls(inode);\n\t\txattr_blob = NULL;\n\t}\n\n\tinode->i_mapping->a_ops = &ceph_aops;\n\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tinode->i_op = &ceph_file_iops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &ceph_file_iops;\n\t\tinode->i_fop = &ceph_file_fops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &ceph_symlink_iops;\n\t\tif (!ci->i_symlink) {\n\t\t\tu32 symlen = iinfo->symlink_len;\n\t\t\tchar *sym;\n\n\t\t\tspin_unlock(&ci->i_ceph_lock);\n\n\t\t\terr = -EINVAL;\n\t\t\tif (WARN_ON(symlen != inode->i_size))\n\t\t\t\tgoto out;\n\n\t\t\terr = -ENOMEM;\n\t\t\tsym = kstrndup(iinfo->symlink, symlen, GFP_NOFS);\n\t\t\tif (!sym)\n\t\t\t\tgoto out;\n\n\t\t\tspin_lock(&ci->i_ceph_lock);\n\t\t\tif (!ci->i_symlink)\n\t\t\t\tci->i_symlink = sym;\n\t\t\telse\n\t\t\t\tkfree(sym); /* lost a race */\n\t\t}\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinode->i_op = &ceph_dir_iops;\n\t\tinode->i_fop = &ceph_dir_fops;\n\n\t\tci->i_dir_layout = iinfo->dir_layout;\n\n\t\tci->i_files = le64_to_cpu(info->files);\n\t\tci->i_subdirs = le64_to_cpu(info->subdirs);\n\t\tci->i_rbytes = le64_to_cpu(info->rbytes);\n\t\tci->i_rfiles = le64_to_cpu(info->rfiles);\n\t\tci->i_rsubdirs = le64_to_cpu(info->rsubdirs);\n\t\tceph_decode_timespec(&ci->i_rctime, &info->rctime);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"fill_inode %llx.%llx BAD mode 0%o\\n\",\n\t\t       ceph_vinop(inode), inode->i_mode);\n\t}\n\n\t/* were we issued a capability? */\n\tif (info->cap.caps) {\n\t\tif (ceph_snap(inode) == CEPH_NOSNAP) {\n\t\t\tunsigned caps = le32_to_cpu(info->cap.caps);\n\t\t\tceph_add_cap(inode, session,\n\t\t\t\t     le64_to_cpu(info->cap.cap_id),\n\t\t\t\t     cap_fmode, caps,\n\t\t\t\t     le32_to_cpu(info->cap.wanted),\n\t\t\t\t     le32_to_cpu(info->cap.seq),\n\t\t\t\t     le32_to_cpu(info->cap.mseq),\n\t\t\t\t     le64_to_cpu(info->cap.realm),\n\t\t\t\t     info->cap.flags, &new_cap);\n\n\t\t\t/* set dir completion flag? */\n\t\t\tif (S_ISDIR(inode->i_mode) &&\n\t\t\t    ci->i_files == 0 && ci->i_subdirs == 0 &&\n\t\t\t    (caps & CEPH_CAP_FILE_SHARED) &&\n\t\t\t    (issued & CEPH_CAP_FILE_EXCL) == 0 &&\n\t\t\t    !__ceph_dir_is_complete(ci)) {\n\t\t\t\tdout(\" marking %p complete (empty)\\n\", inode);\n\t\t\t\t__ceph_dir_set_complete(ci,\n\t\t\t\t\tatomic_read(&ci->i_release_count),\n\t\t\t\t\tci->i_ordered_count);\n\t\t\t}\n\n\t\t\twake = true;\n\t\t} else {\n\t\t\tdout(\" %p got snap_caps %s\\n\", inode,\n\t\t\t     ceph_cap_string(le32_to_cpu(info->cap.caps)));\n\t\t\tci->i_snap_caps |= le32_to_cpu(info->cap.caps);\n\t\t\tif (cap_fmode >= 0)\n\t\t\t\t__ceph_get_fmode(ci, cap_fmode);\n\t\t}\n\t} else if (cap_fmode >= 0) {\n\t\tpr_warn(\"mds issued no caps on %llx.%llx\\n\",\n\t\t\t   ceph_vinop(inode));\n\t\t__ceph_get_fmode(ci, cap_fmode);\n\t}\n\n\tif (iinfo->inline_version > 0 &&\n\t    iinfo->inline_version >= ci->i_inline_version) {\n\t\tint cache_caps = CEPH_CAP_FILE_CACHE | CEPH_CAP_FILE_LAZYIO;\n\t\tci->i_inline_version = iinfo->inline_version;\n\t\tif (ci->i_inline_version != CEPH_INLINE_NONE &&\n\t\t    (locked_page ||\n\t\t     (le32_to_cpu(info->cap.caps) & cache_caps)))\n\t\t\tfill_inline = true;\n\t}\n\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tif (fill_inline)\n\t\tceph_fill_inline_data(inode, locked_page,\n\t\t\t\t      iinfo->inline_data, iinfo->inline_len);\n\n\tif (wake)\n\t\twake_up_all(&ci->i_cap_wq);\n\n\t/* queue truncate if we saw i_size decrease */\n\tif (queue_trunc)\n\t\tceph_queue_vmtruncate(inode);\n\n\t/* populate frag tree */\n\tif (S_ISDIR(inode->i_mode))\n\t\tceph_fill_fragtree(inode, &info->fragtree, dirinfo);\n\n\t/* update delegation info? */\n\tif (dirinfo)\n\t\tceph_fill_dirfrag(inode, dirinfo);\n\n\terr = 0;\nout:\n\tif (new_cap)\n\t\tceph_put_cap(mdsc, new_cap);\n\tif (xattr_blob)\n\t\tceph_buffer_put(xattr_blob);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_fill_file_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "592-656",
    "snippet": "void ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"%p mds time_warp_seq %llu < %u\\n\"",
            "inode",
            "time_warp_seq",
            "ci->i_time_warp_seq"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "time_warp_seq",
            "ci->i_time_warp_seq"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"atime %ld.%09ld -> %ld.%09ld inc\\n\"",
            "inode->i_atime.tv_sec",
            "inode->i_atime.tv_nsec",
            "atime->tv_sec",
            "atime->tv_nsec"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "atime",
            "&inode->i_atime"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mtime %ld.%09ld -> %ld.%09ld inc\\n\"",
            "inode->i_mtime.tv_sec",
            "inode->i_mtime.tv_nsec",
            "mtime->tv_sec",
            "mtime->tv_nsec"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "mtime",
            "&inode->i_mtime"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\"",
            "inode->i_mtime.tv_sec",
            "inode->i_mtime.tv_nsec",
            "mtime->tv_sec",
            "mtime->tv_nsec",
            "ci->i_time_warp_seq",
            "(int)time_warp_seq"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "time_warp_seq",
            "ci->i_time_warp_seq"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\"",
            "inode->i_ctime.tv_sec",
            "inode->i_ctime.tv_nsec",
            "ctime->tv_sec",
            "ctime->tv_nsec"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "ctime",
            "&inode->i_ctime"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_fill_file_time(struct inode *inode, int issued,\n\t\t\t u64 time_warp_seq, struct timespec *ctime,\n\t\t\t struct timespec *mtime, struct timespec *atime)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint warn = 0;\n\n\tif (issued & (CEPH_CAP_FILE_EXCL|\n\t\t      CEPH_CAP_FILE_WR|\n\t\t      CEPH_CAP_FILE_BUFFER|\n\t\t      CEPH_CAP_AUTH_EXCL|\n\t\t      CEPH_CAP_XATTR_EXCL)) {\n\t\tif (timespec_compare(ctime, &inode->i_ctime) > 0) {\n\t\t\tdout(\"ctime %ld.%09ld -> %ld.%09ld inc w/ cap\\n\",\n\t\t\t     inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n\t\t\t     ctime->tv_sec, ctime->tv_nsec);\n\t\t\tinode->i_ctime = *ctime;\n\t\t}\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) > 0) {\n\t\t\t/* the MDS did a utimes() */\n\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld \"\n\t\t\t     \"tw %d -> %d\\n\",\n\t\t\t     inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n\t\t\t     mtime->tv_sec, mtime->tv_nsec,\n\t\t\t     ci->i_time_warp_seq, (int)time_warp_seq);\n\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else if (time_warp_seq == ci->i_time_warp_seq) {\n\t\t\t/* nobody did utimes(); take the max */\n\t\t\tif (timespec_compare(mtime, &inode->i_mtime) > 0) {\n\t\t\t\tdout(\"mtime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_mtime.tv_sec,\n\t\t\t\t     inode->i_mtime.tv_nsec,\n\t\t\t\t     mtime->tv_sec, mtime->tv_nsec);\n\t\t\t\tinode->i_mtime = *mtime;\n\t\t\t}\n\t\t\tif (timespec_compare(atime, &inode->i_atime) > 0) {\n\t\t\t\tdout(\"atime %ld.%09ld -> %ld.%09ld inc\\n\",\n\t\t\t\t     inode->i_atime.tv_sec,\n\t\t\t\t     inode->i_atime.tv_nsec,\n\t\t\t\t     atime->tv_sec, atime->tv_nsec);\n\t\t\t\tinode->i_atime = *atime;\n\t\t\t}\n\t\t} else if (issued & CEPH_CAP_FILE_EXCL) {\n\t\t\t/* we did a utimes(); ignore mds values */\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t} else {\n\t\t/* we have no write|excl caps; whatever the MDS says is true */\n\t\tif (ceph_seq_cmp(time_warp_seq, ci->i_time_warp_seq) >= 0) {\n\t\t\tinode->i_ctime = *ctime;\n\t\t\tinode->i_mtime = *mtime;\n\t\t\tinode->i_atime = *atime;\n\t\t\tci->i_time_warp_seq = time_warp_seq;\n\t\t} else {\n\t\t\twarn = 1;\n\t\t}\n\t}\n\tif (warn) /* time_warp_seq shouldn't go backwards */\n\t\tdout(\"%p mds time_warp_seq %llu < %u\\n\",\n\t\t     inode, time_warp_seq, ci->i_time_warp_seq);\n}"
  },
  {
    "function_name": "ceph_fill_file_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "542-590",
    "snippet": "int ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_fscache_invalidate",
          "args": [
            "inode"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.h",
          "lines": "148-150",
          "snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ceph_fscache_invalidate(struct inode *inode)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"truncate_size %lld -> %llu\\n\"",
            "ci->i_truncate_size",
            "truncate_size"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "truncate_seq",
            "ci->i_truncate_seq"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_caps_file_wanted",
          "args": [
            "ci"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_caps_file_wanted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "848-856",
          "snippet": "int __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nint __ceph_caps_file_wanted(struct ceph_inode_info *ci)\n{\n\tint want = 0;\n\tint mode;\n\tfor (mode = 0; mode < CEPH_FILE_MODE_NUM; mode++)\n\t\tif (ci->i_nr_by_mode[mode])\n\t\t\twant |= ceph_caps_for_mode(mode);\n\treturn want;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_mapped",
          "args": [
            "inode->i_mapping"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"truncate_seq %u -> %u\\n\"",
            "ci->i_truncate_seq",
            "truncate_seq"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"size %lld -> %llu\\n\"",
            "inode->i_size",
            "size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_seq_cmp",
          "args": [
            "truncate_seq",
            "ci->i_truncate_seq"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_fill_file_size(struct inode *inode, int issued,\n\t\t\tu32 truncate_seq, u64 truncate_size, u64 size)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tint queue_trunc = 0;\n\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) > 0 ||\n\t    (truncate_seq == ci->i_truncate_seq && size > inode->i_size)) {\n\t\tdout(\"size %lld -> %llu\\n\", inode->i_size, size);\n\t\tinode->i_size = size;\n\t\tinode->i_blocks = (size + (1<<9) - 1) >> 9;\n\t\tci->i_reported_size = size;\n\t\tif (truncate_seq != ci->i_truncate_seq) {\n\t\t\tdout(\"truncate_seq %u -> %u\\n\",\n\t\t\t     ci->i_truncate_seq, truncate_seq);\n\t\t\tci->i_truncate_seq = truncate_seq;\n\n\t\t\t/* the MDS should have revoked these caps */\n\t\t\tWARN_ON_ONCE(issued & (CEPH_CAP_FILE_EXCL |\n\t\t\t\t\t       CEPH_CAP_FILE_RD |\n\t\t\t\t\t       CEPH_CAP_FILE_WR |\n\t\t\t\t\t       CEPH_CAP_FILE_LAZYIO));\n\t\t\t/*\n\t\t\t * If we hold relevant caps, or in the case where we're\n\t\t\t * not the only client referencing this file and we\n\t\t\t * don't hold those caps, then we need to check whether\n\t\t\t * the file is either opened or mmaped\n\t\t\t */\n\t\t\tif ((issued & (CEPH_CAP_FILE_CACHE|\n\t\t\t\t       CEPH_CAP_FILE_BUFFER)) ||\n\t\t\t    mapping_mapped(inode->i_mapping) ||\n\t\t\t    __ceph_caps_file_wanted(ci)) {\n\t\t\t\tci->i_truncate_pending++;\n\t\t\t\tqueue_trunc = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (ceph_seq_cmp(truncate_seq, ci->i_truncate_seq) >= 0 &&\n\t    ci->i_truncate_size != truncate_size) {\n\t\tdout(\"truncate_size %lld -> %llu\\n\", ci->i_truncate_size,\n\t\t     truncate_size);\n\t\tci->i_truncate_size = truncate_size;\n\t}\n\n\tif (queue_trunc)\n\t\tceph_fscache_invalidate(inode);\n\n\treturn queue_trunc;\n}"
  },
  {
    "function_name": "ceph_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "524-532",
    "snippet": "int ceph_drop_inode(struct inode *inode)\n{\n\t/*\n\t * Positve dentry and corresponding inode are always accompanied\n\t * in MDS reply. So no need to keep inode in the cache after\n\t * dropping all its aliases.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nint ceph_drop_inode(struct inode *inode)\n{\n\t/*\n\t * Positve dentry and corresponding inode are always accompanied\n\t * in MDS reply. So no need to keep inode in the cache after\n\t * dropping all its aliases.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "ceph_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "480-522",
    "snippet": "void ceph_destroy_inode(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *n;\n\n\tdout(\"destroy_inode %p ino %llx.%llx\\n\", inode, ceph_vinop(inode));\n\n\tceph_fscache_unregister_inode_cookie(ci);\n\n\tceph_queue_caps_release(inode);\n\n\t/*\n\t * we may still have a snap_realm reference if there are stray\n\t * caps in i_snap_caps.\n\t */\n\tif (ci->i_snap_realm) {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\n\t\tdout(\" dropping residual ref to snap realm %p\\n\", realm);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\n\tkfree(ci->i_symlink);\n\twhile ((n = rb_first(&ci->i_fragtree)) != NULL) {\n\t\tfrag = rb_entry(n, struct ceph_inode_frag, node);\n\t\trb_erase(n, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\n\n\t__ceph_destroy_xattrs(ci);\n\tif (ci->i_xattrs.blob)\n\t\tceph_buffer_put(ci->i_xattrs.blob);\n\tif (ci->i_xattrs.prealloc_blob)\n\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\n\tcall_rcu(&inode->i_rcu, ceph_i_callback);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "ceph_i_callback"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.prealloc_blob"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_buffer_put",
          "args": [
            "ci->i_xattrs.blob"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_destroy_xattrs",
          "args": [
            "ci"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_destroy_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/xattr.c",
          "lines": "536-561",
          "snippet": "void __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/ceph/pagelist.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/ceph/pagelist.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int __remove_xattr(struct ceph_inode_info *ci,\n\t\t\t  struct ceph_inode_xattr *xattr);\n\nvoid __ceph_destroy_xattrs(struct ceph_inode_info *ci)\n{\n\tstruct rb_node *p, *tmp;\n\tstruct ceph_inode_xattr *xattr = NULL;\n\n\tp = rb_first(&ci->i_xattrs.index);\n\n\tdout(\"__ceph_destroy_xattrs p=%p\\n\", p);\n\n\twhile (p) {\n\t\txattr = rb_entry(p, struct ceph_inode_xattr, node);\n\t\ttmp = p;\n\t\tp = rb_next(tmp);\n\t\tdout(\"__ceph_destroy_xattrs next p=%p (%.*s)\\n\", p,\n\t\t     xattr->name_len, xattr->name);\n\t\trb_erase(tmp, &ci->i_xattrs.index);\n\n\t\t__free_xattr(xattr);\n\t}\n\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.index_version = 0;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.index = RB_ROOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "frag"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "n",
            "&ci->i_fragtree"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_inode_frag",
            "node"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_fragtree"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ci->i_symlink"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_put_snap_realm",
          "args": [
            "mdsc",
            "realm"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_put_snap_realm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/snap.c",
          "lines": "204-220",
          "snippet": "void ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void __put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t     struct ceph_snap_realm *realm);\n\nvoid ceph_put_snap_realm(struct ceph_mds_client *mdsc,\n\t\t\t struct ceph_snap_realm *realm)\n{\n\tdout(\"put_snap_realm %llx %p %d -> %d\\n\", realm->ino, realm,\n\t     atomic_read(&realm->nref), atomic_read(&realm->nref)-1);\n\tif (!atomic_dec_and_test(&realm->nref))\n\t\treturn;\n\n\tif (down_write_trylock(&mdsc->snap_rwsem)) {\n\t\t__destroy_snap_realm(mdsc, realm);\n\t\tup_write(&mdsc->snap_rwsem);\n\t} else {\n\t\tspin_lock(&mdsc->snap_empty_lock);\n\t\tlist_add(&realm->empty_item, &mdsc->snap_empty);\n\t\tspin_unlock(&mdsc->snap_empty_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ci->i_snap_realm_item"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&realm->inodes_with_caps_lock"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" dropping residual ref to snap realm %p\\n\"",
            "realm"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_sb_to_client",
          "args": [
            "ci->vfs_inode.i_sb"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_sb_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "352-355",
          "snippet": "static inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_sb_to_client(struct super_block *sb)\n{\n\treturn (struct ceph_fs_client *)sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_queue_caps_release",
          "args": [
            "inode"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_queue_caps_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/caps.c",
          "lines": "1088-1099",
          "snippet": "void ceph_queue_caps_release(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct rb_node *p;\n\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tp = rb_next(p);\n\t\t__ceph_remove_cap(cap, true);\n\t}\n}",
          "includes": [
            "#include <linux/ceph/messenger.h>",
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/messenger.h>\n#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_queue_caps_release(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct rb_node *p;\n\n\tp = rb_first(&ci->i_caps);\n\twhile (p) {\n\t\tstruct ceph_cap *cap = rb_entry(p, struct ceph_cap, ci_node);\n\t\tp = rb_next(p);\n\t\t__ceph_remove_cap(cap, true);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_fscache_unregister_inode_cookie",
          "args": [
            "ci"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_unregister_inode_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "214-225",
          "snippet": "void ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n\tstruct fscache_cookie* cookie;\n\n\tif ((cookie = ci->fscache) == NULL)\n\t\treturn;\n\n\tci->fscache = NULL;\n\n\tfscache_uncache_all_inode_pages(cookie, &ci->vfs_inode);\n\tfscache_relinquish_cookie(cookie, 0);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_unregister_inode_cookie(struct ceph_inode_info* ci)\n{\n\tstruct fscache_cookie* cookie;\n\n\tif ((cookie = ci->fscache) == NULL)\n\t\treturn;\n\n\tci->fscache = NULL;\n\n\tfscache_uncache_all_inode_pages(cookie, &ci->vfs_inode);\n\tfscache_relinquish_cookie(cookie, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"destroy_inode %p ino %llx.%llx\\n\"",
            "inode",
            "ceph_vinop(inode)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nvoid ceph_destroy_inode(struct inode *inode)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *n;\n\n\tdout(\"destroy_inode %p ino %llx.%llx\\n\", inode, ceph_vinop(inode));\n\n\tceph_fscache_unregister_inode_cookie(ci);\n\n\tceph_queue_caps_release(inode);\n\n\t/*\n\t * we may still have a snap_realm reference if there are stray\n\t * caps in i_snap_caps.\n\t */\n\tif (ci->i_snap_realm) {\n\t\tstruct ceph_mds_client *mdsc =\n\t\t\tceph_sb_to_client(ci->vfs_inode.i_sb)->mdsc;\n\t\tstruct ceph_snap_realm *realm = ci->i_snap_realm;\n\n\t\tdout(\" dropping residual ref to snap realm %p\\n\", realm);\n\t\tspin_lock(&realm->inodes_with_caps_lock);\n\t\tlist_del_init(&ci->i_snap_realm_item);\n\t\tspin_unlock(&realm->inodes_with_caps_lock);\n\t\tceph_put_snap_realm(mdsc, realm);\n\t}\n\n\tkfree(ci->i_symlink);\n\twhile ((n = rb_first(&ci->i_fragtree)) != NULL) {\n\t\tfrag = rb_entry(n, struct ceph_inode_frag, node);\n\t\trb_erase(n, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\n\n\t__ceph_destroy_xattrs(ci);\n\tif (ci->i_xattrs.blob)\n\t\tceph_buffer_put(ci->i_xattrs.blob);\n\tif (ci->i_xattrs.prealloc_blob)\n\t\tceph_buffer_put(ci->i_xattrs.prealloc_blob);\n\n\tcall_rcu(&inode->i_rcu, ceph_i_callback);\n}"
  },
  {
    "function_name": "ceph_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "472-478",
    "snippet": "static void ceph_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tkmem_cache_free(ceph_inode_cachep, ci);\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ceph_inode_cachep",
            "ci"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic void ceph_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tkmem_cache_free(ceph_inode_cachep, ci);\n}"
  },
  {
    "function_name": "ceph_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "376-470",
    "snippet": "struct inode *ceph_alloc_inode(struct super_block *sb)\n{\n\tstruct ceph_inode_info *ci;\n\tint i;\n\n\tci = kmem_cache_alloc(ceph_inode_cachep, GFP_NOFS);\n\tif (!ci)\n\t\treturn NULL;\n\n\tdout(\"alloc_inode %p\\n\", &ci->vfs_inode);\n\n\tspin_lock_init(&ci->i_ceph_lock);\n\n\tci->i_version = 0;\n\tci->i_inline_version = 0;\n\tci->i_time_warp_seq = 0;\n\tci->i_ceph_flags = 0;\n\tci->i_ordered_count = 0;\n\tatomic_set(&ci->i_release_count, 1);\n\tatomic_set(&ci->i_complete_count, 0);\n\tci->i_symlink = NULL;\n\n\tmemset(&ci->i_dir_layout, 0, sizeof(ci->i_dir_layout));\n\n\tci->i_fragtree = RB_ROOT;\n\tmutex_init(&ci->i_fragtree_mutex);\n\n\tci->i_xattrs.blob = NULL;\n\tci->i_xattrs.prealloc_blob = NULL;\n\tci->i_xattrs.dirty = false;\n\tci->i_xattrs.index = RB_ROOT;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.version = 0;\n\tci->i_xattrs.index_version = 0;\n\n\tci->i_caps = RB_ROOT;\n\tci->i_auth_cap = NULL;\n\tci->i_dirty_caps = 0;\n\tci->i_flushing_caps = 0;\n\tINIT_LIST_HEAD(&ci->i_dirty_item);\n\tINIT_LIST_HEAD(&ci->i_flushing_item);\n\tci->i_cap_flush_seq = 0;\n\tci->i_cap_flush_last_tid = 0;\n\tmemset(&ci->i_cap_flush_tid, 0, sizeof(ci->i_cap_flush_tid));\n\tinit_waitqueue_head(&ci->i_cap_wq);\n\tci->i_hold_caps_min = 0;\n\tci->i_hold_caps_max = 0;\n\tINIT_LIST_HEAD(&ci->i_cap_delay_list);\n\tINIT_LIST_HEAD(&ci->i_cap_snaps);\n\tci->i_head_snapc = NULL;\n\tci->i_snap_caps = 0;\n\n\tfor (i = 0; i < CEPH_FILE_MODE_NUM; i++)\n\t\tci->i_nr_by_mode[i] = 0;\n\n\tmutex_init(&ci->i_truncate_mutex);\n\tci->i_truncate_seq = 0;\n\tci->i_truncate_size = 0;\n\tci->i_truncate_pending = 0;\n\n\tci->i_max_size = 0;\n\tci->i_reported_size = 0;\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\tci->i_pin_ref = 0;\n\tci->i_rd_ref = 0;\n\tci->i_rdcache_ref = 0;\n\tci->i_wr_ref = 0;\n\tci->i_wb_ref = 0;\n\tci->i_wrbuffer_ref = 0;\n\tci->i_wrbuffer_ref_head = 0;\n\tci->i_shared_gen = 0;\n\tci->i_rdcache_gen = 0;\n\tci->i_rdcache_revoking = 0;\n\n\tINIT_LIST_HEAD(&ci->i_unsafe_writes);\n\tINIT_LIST_HEAD(&ci->i_unsafe_dirops);\n\tspin_lock_init(&ci->i_unsafe_lock);\n\n\tci->i_snap_realm = NULL;\n\tINIT_LIST_HEAD(&ci->i_snap_realm_item);\n\tINIT_LIST_HEAD(&ci->i_snap_flush_item);\n\n\tINIT_WORK(&ci->i_wb_work, ceph_writeback_work);\n\tINIT_WORK(&ci->i_pg_inv_work, ceph_invalidate_work);\n\n\tINIT_WORK(&ci->i_vmtruncate_work, ceph_vmtruncate_work);\n\n\tceph_fscache_inode_init(ci);\n\n\treturn &ci->vfs_inode;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_fscache_inode_init",
          "args": [
            "ci"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_fscache_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/cache.c",
          "lines": "396-402",
          "snippet": "void ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n\tci->fscache = NULL;\n\t/* The first load is verifed cookie open time */\n\tci->i_fscache_gen = 1;\n\tINIT_WORK(&ci->i_revalidate_work, ceph_revalidate_work);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"super.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"super.h\"\n\nvoid ceph_fscache_inode_init(struct ceph_inode_info *ci)\n{\n\tci->fscache = NULL;\n\t/* The first load is verifed cookie open time */\n\tci->i_fscache_gen = 1;\n\tINIT_WORK(&ci->i_revalidate_work, ceph_revalidate_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ci->i_vmtruncate_work",
            "ceph_vmtruncate_work"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ci->i_pg_inv_work",
            "ceph_invalidate_work"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ci->i_wb_work",
            "ceph_writeback_work"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_snap_flush_item"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_snap_realm_item"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ci->i_unsafe_lock"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_unsafe_dirops"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_unsafe_writes"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ci->i_truncate_mutex"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_cap_snaps"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_cap_delay_list"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ci->i_cap_wq"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ci->i_cap_flush_tid",
            "0",
            "sizeof(ci->i_cap_flush_tid)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_flushing_item"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ci->i_dirty_item"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ci->i_dir_layout",
            "0",
            "sizeof(ci->i_dir_layout)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ci->i_complete_count",
            "0"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ci->i_release_count",
            "1"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"alloc_inode %p\\n\"",
            "&ci->vfs_inode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ceph_inode_cachep",
            "GFP_NOFS"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_alloc_inode(struct super_block *sb)\n{\n\tstruct ceph_inode_info *ci;\n\tint i;\n\n\tci = kmem_cache_alloc(ceph_inode_cachep, GFP_NOFS);\n\tif (!ci)\n\t\treturn NULL;\n\n\tdout(\"alloc_inode %p\\n\", &ci->vfs_inode);\n\n\tspin_lock_init(&ci->i_ceph_lock);\n\n\tci->i_version = 0;\n\tci->i_inline_version = 0;\n\tci->i_time_warp_seq = 0;\n\tci->i_ceph_flags = 0;\n\tci->i_ordered_count = 0;\n\tatomic_set(&ci->i_release_count, 1);\n\tatomic_set(&ci->i_complete_count, 0);\n\tci->i_symlink = NULL;\n\n\tmemset(&ci->i_dir_layout, 0, sizeof(ci->i_dir_layout));\n\n\tci->i_fragtree = RB_ROOT;\n\tmutex_init(&ci->i_fragtree_mutex);\n\n\tci->i_xattrs.blob = NULL;\n\tci->i_xattrs.prealloc_blob = NULL;\n\tci->i_xattrs.dirty = false;\n\tci->i_xattrs.index = RB_ROOT;\n\tci->i_xattrs.count = 0;\n\tci->i_xattrs.names_size = 0;\n\tci->i_xattrs.vals_size = 0;\n\tci->i_xattrs.version = 0;\n\tci->i_xattrs.index_version = 0;\n\n\tci->i_caps = RB_ROOT;\n\tci->i_auth_cap = NULL;\n\tci->i_dirty_caps = 0;\n\tci->i_flushing_caps = 0;\n\tINIT_LIST_HEAD(&ci->i_dirty_item);\n\tINIT_LIST_HEAD(&ci->i_flushing_item);\n\tci->i_cap_flush_seq = 0;\n\tci->i_cap_flush_last_tid = 0;\n\tmemset(&ci->i_cap_flush_tid, 0, sizeof(ci->i_cap_flush_tid));\n\tinit_waitqueue_head(&ci->i_cap_wq);\n\tci->i_hold_caps_min = 0;\n\tci->i_hold_caps_max = 0;\n\tINIT_LIST_HEAD(&ci->i_cap_delay_list);\n\tINIT_LIST_HEAD(&ci->i_cap_snaps);\n\tci->i_head_snapc = NULL;\n\tci->i_snap_caps = 0;\n\n\tfor (i = 0; i < CEPH_FILE_MODE_NUM; i++)\n\t\tci->i_nr_by_mode[i] = 0;\n\n\tmutex_init(&ci->i_truncate_mutex);\n\tci->i_truncate_seq = 0;\n\tci->i_truncate_size = 0;\n\tci->i_truncate_pending = 0;\n\n\tci->i_max_size = 0;\n\tci->i_reported_size = 0;\n\tci->i_wanted_max_size = 0;\n\tci->i_requested_max_size = 0;\n\n\tci->i_pin_ref = 0;\n\tci->i_rd_ref = 0;\n\tci->i_rdcache_ref = 0;\n\tci->i_wr_ref = 0;\n\tci->i_wb_ref = 0;\n\tci->i_wrbuffer_ref = 0;\n\tci->i_wrbuffer_ref_head = 0;\n\tci->i_shared_gen = 0;\n\tci->i_rdcache_gen = 0;\n\tci->i_rdcache_revoking = 0;\n\n\tINIT_LIST_HEAD(&ci->i_unsafe_writes);\n\tINIT_LIST_HEAD(&ci->i_unsafe_dirops);\n\tspin_lock_init(&ci->i_unsafe_lock);\n\n\tci->i_snap_realm = NULL;\n\tINIT_LIST_HEAD(&ci->i_snap_realm_item);\n\tINIT_LIST_HEAD(&ci->i_snap_flush_item);\n\n\tINIT_WORK(&ci->i_wb_work, ceph_writeback_work);\n\tINIT_WORK(&ci->i_pg_inv_work, ceph_invalidate_work);\n\n\tINIT_WORK(&ci->i_vmtruncate_work, ceph_vmtruncate_work);\n\n\tceph_fscache_inode_init(ci);\n\n\treturn &ci->vfs_inode;\n}"
  },
  {
    "function_name": "ceph_fill_fragtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "303-371",
    "snippet": "static int ceph_fill_fragtree(struct inode *inode,\n\t\t\t      struct ceph_frag_tree_head *fragtree,\n\t\t\t      struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *rb_node;\n\tint i;\n\tu32 id, nsplits;\n\tbool update = false;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tnsplits = le32_to_cpu(fragtree->nsplits);\n\tif (nsplits) {\n\t\ti = prandom_u32() % nsplits;\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tif (!__ceph_find_frag(ci, id))\n\t\t\tupdate = true;\n\t} else if (!RB_EMPTY_ROOT(&ci->i_fragtree)) {\n\t\trb_node = rb_first(&ci->i_fragtree);\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\tif (frag->frag != ceph_frag_make(0, 0) || rb_next(rb_node))\n\t\t\tupdate = true;\n\t}\n\tif (!update && dirinfo) {\n\t\tid = le32_to_cpu(dirinfo->frag);\n\t\tif (id != __ceph_choose_frag(ci, id, NULL, NULL))\n\t\t\tupdate = true;\n\t}\n\tif (!update)\n\t\tgoto out_unlock;\n\n\tdout(\"fill_fragtree %llx.%llx\\n\", ceph_vinop(inode));\n\trb_node = rb_first(&ci->i_fragtree);\n\tfor (i = 0; i < nsplits; i++) {\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tfrag = NULL;\n\t\twhile (rb_node) {\n\t\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\t\tif (ceph_frag_compare(frag->frag, id) >= 0) {\n\t\t\t\tif (frag->frag != id)\n\t\t\t\t\tfrag = NULL;\n\t\t\t\telse\n\t\t\t\t\trb_node = rb_next(rb_node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trb_node = rb_next(rb_node);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t\tfrag = NULL;\n\t\t}\n\t\tif (!frag) {\n\t\t\tfrag = __get_or_create_frag(ci, id);\n\t\t\tif (IS_ERR(frag))\n\t\t\t\tcontinue;\n\t\t}\n\t\tfrag->split_by = le32_to_cpu(fragtree->splits[i].by);\n\t\tdout(\" frag %x split by %d\\n\", frag->frag, frag->split_by);\n\t}\n\twhile (rb_node) {\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\trb_node = rb_next(rb_node);\n\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\nout_unlock:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "frag"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&frag->node",
            "&ci->i_fragtree"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structceph_inode_frag",
            "node"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\" frag %x split by %d\\n\"",
            "frag->frag",
            "frag->split_by"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fragtree->splits[i].by"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frag"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_or_create_frag",
          "args": [
            "ci",
            "id"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "__get_or_create_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "116-155",
          "snippet": "static struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "frag"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&frag->node",
            "&ci->i_fragtree"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_compare",
          "args": [
            "frag->frag",
            "id"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_frag_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ceph_frag.c",
          "lines": "7-22",
          "snippet": "int ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nint ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structceph_inode_frag",
            "node"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_fragtree"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_fragtree %llx.%llx\\n\"",
            "ceph_vinop(inode)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_choose_frag",
          "args": [
            "ci",
            "id",
            "NULL",
            "NULL"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_choose_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "183-223",
          "snippet": "static u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rb_node"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_make",
          "args": [
            "0",
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rb_node",
            "structceph_inode_frag",
            "node"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ci->i_fragtree"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&ci->i_fragtree"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_find_frag",
          "args": [
            "ci",
            "id"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_find_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "160-176",
          "snippet": "struct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_fill_fragtree(struct inode *inode,\n\t\t\t      struct ceph_frag_tree_head *fragtree,\n\t\t\t      struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tstruct rb_node *rb_node;\n\tint i;\n\tu32 id, nsplits;\n\tbool update = false;\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tnsplits = le32_to_cpu(fragtree->nsplits);\n\tif (nsplits) {\n\t\ti = prandom_u32() % nsplits;\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tif (!__ceph_find_frag(ci, id))\n\t\t\tupdate = true;\n\t} else if (!RB_EMPTY_ROOT(&ci->i_fragtree)) {\n\t\trb_node = rb_first(&ci->i_fragtree);\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\tif (frag->frag != ceph_frag_make(0, 0) || rb_next(rb_node))\n\t\t\tupdate = true;\n\t}\n\tif (!update && dirinfo) {\n\t\tid = le32_to_cpu(dirinfo->frag);\n\t\tif (id != __ceph_choose_frag(ci, id, NULL, NULL))\n\t\t\tupdate = true;\n\t}\n\tif (!update)\n\t\tgoto out_unlock;\n\n\tdout(\"fill_fragtree %llx.%llx\\n\", ceph_vinop(inode));\n\trb_node = rb_first(&ci->i_fragtree);\n\tfor (i = 0; i < nsplits; i++) {\n\t\tid = le32_to_cpu(fragtree->splits[i].frag);\n\t\tfrag = NULL;\n\t\twhile (rb_node) {\n\t\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\t\tif (ceph_frag_compare(frag->frag, id) >= 0) {\n\t\t\t\tif (frag->frag != id)\n\t\t\t\t\tfrag = NULL;\n\t\t\t\telse\n\t\t\t\t\trb_node = rb_next(rb_node);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trb_node = rb_next(rb_node);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t\tfrag = NULL;\n\t\t}\n\t\tif (!frag) {\n\t\t\tfrag = __get_or_create_frag(ci, id);\n\t\t\tif (IS_ERR(frag))\n\t\t\t\tcontinue;\n\t\t}\n\t\tfrag->split_by = le32_to_cpu(fragtree->splits[i].by);\n\t\tdout(\" frag %x split by %d\\n\", frag->frag, frag->split_by);\n\t}\n\twhile (rb_node) {\n\t\tfrag = rb_entry(rb_node, struct ceph_inode_frag, node);\n\t\trb_node = rb_next(rb_node);\n\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\tkfree(frag);\n\t}\nout_unlock:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "ceph_fill_dirfrag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "240-301",
    "snippet": "static int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\"",
            "ceph_vinop(inode)",
            "frag->frag",
            "frag->ndist"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dirinfo->dist[i]"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ndist",
            "CEPH_MAX_DIRFRAG_REP"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\"",
            "ceph_vinop(inode)",
            "le32_to_cpu(dirinfo->frag)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "frag"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_or_create_frag",
          "args": [
            "ci",
            "id"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__get_or_create_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "116-155",
          "snippet": "static struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\"",
            "ceph_vinop(inode)",
            "id"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "frag"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&frag->node",
            "&ci->i_fragtree"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\"",
            "ceph_vinop(inode)",
            "id"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_find_frag",
          "args": [
            "ci",
            "id"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_find_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "160-176",
          "snippet": "struct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ci->i_ceph_lock"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_fill_dirfrag(struct inode *inode,\n\t\t\t     struct ceph_mds_reply_dirfrag *dirinfo)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\tstruct ceph_inode_frag *frag;\n\tu32 id = le32_to_cpu(dirinfo->frag);\n\tint mds = le32_to_cpu(dirinfo->auth);\n\tint ndist = le32_to_cpu(dirinfo->ndist);\n\tint diri_auth = -1;\n\tint i;\n\tint err = 0;\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (ci->i_auth_cap)\n\t\tdiri_auth = ci->i_auth_cap->mds;\n\tspin_unlock(&ci->i_ceph_lock);\n\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tif (ndist == 0 && mds == diri_auth) {\n\t\t/* no delegation info needed. */\n\t\tfrag = __ceph_find_frag(ci, id);\n\t\tif (!frag)\n\t\t\tgoto out;\n\t\tif (frag->split_by == 0) {\n\t\t\t/* tree leaf, remove */\n\t\t\tdout(\"fill_dirfrag removed %llx.%llx frag %x\"\n\t\t\t     \" (no ref)\\n\", ceph_vinop(inode), id);\n\t\t\trb_erase(&frag->node, &ci->i_fragtree);\n\t\t\tkfree(frag);\n\t\t} else {\n\t\t\t/* tree branch, keep and clear */\n\t\t\tdout(\"fill_dirfrag cleared %llx.%llx frag %x\"\n\t\t\t     \" referral\\n\", ceph_vinop(inode), id);\n\t\t\tfrag->mds = -1;\n\t\t\tfrag->ndist = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\n\t/* find/add this frag to store mds delegation info */\n\tfrag = __get_or_create_frag(ci, id);\n\tif (IS_ERR(frag)) {\n\t\t/* this is not the end of the world; we can continue\n\t\t   with bad/inaccurate delegation info */\n\t\tpr_err(\"fill_dirfrag ENOMEM on mds ref %llx.%llx fg %x\\n\",\n\t\t       ceph_vinop(inode), le32_to_cpu(dirinfo->frag));\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfrag->mds = mds;\n\tfrag->ndist = min_t(u32, ndist, CEPH_MAX_DIRFRAG_REP);\n\tfor (i = 0; i < frag->ndist; i++)\n\t\tfrag->dist[i] = le32_to_cpu(dirinfo->dist[i]);\n\tdout(\"fill_dirfrag %llx.%llx frag %x ndist=%d\\n\",\n\t     ceph_vinop(inode), frag->frag, frag->ndist);\n\nout:\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn err;\n}"
  },
  {
    "function_name": "ceph_choose_frag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "225-233",
    "snippet": "u32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t     struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 ret;\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tret = __ceph_choose_frag(ci, v, pfrag, found);\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_choose_frag",
          "args": [
            "ci",
            "v",
            "pfrag",
            "found"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_choose_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "183-223",
          "snippet": "static u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ci->i_fragtree_mutex"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nu32 ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t     struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 ret;\n\tmutex_lock(&ci->i_fragtree_mutex);\n\tret = __ceph_choose_frag(ci, v, pfrag, found);\n\tmutex_unlock(&ci->i_fragtree_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ceph_choose_frag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "183-223",
    "snippet": "static u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_frag(%x) = %x\\n\"",
            "v",
            "t"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == nway"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_contains_value",
          "args": [
            "n",
            "v"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_make_child",
          "args": [
            "t",
            "frag->split_by",
            "i"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"choose_frag(%x) %x splits by %d (%d ways)\\n\"",
            "v",
            "t",
            "frag->split_by",
            "nway"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pfrag",
            "frag",
            "sizeof(*pfrag)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ceph_find_frag",
          "args": [
            "ci",
            "t"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "__ceph_find_frag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "160-176",
          "snippet": "struct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!ceph_frag_contains_value(t, v)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_contains_value",
          "args": [
            "t",
            "v"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_frag_make",
          "args": [
            "0",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic u32 __ceph_choose_frag(struct ceph_inode_info *ci, u32 v,\n\t\t\t      struct ceph_inode_frag *pfrag, int *found)\n{\n\tu32 t = ceph_frag_make(0, 0);\n\tstruct ceph_inode_frag *frag;\n\tunsigned nway, i;\n\tu32 n;\n\n\tif (found)\n\t\t*found = 0;\n\n\twhile (1) {\n\t\tWARN_ON(!ceph_frag_contains_value(t, v));\n\t\tfrag = __ceph_find_frag(ci, t);\n\t\tif (!frag)\n\t\t\tbreak; /* t is a leaf */\n\t\tif (frag->split_by == 0) {\n\t\t\tif (pfrag)\n\t\t\t\tmemcpy(pfrag, frag, sizeof(*pfrag));\n\t\t\tif (found)\n\t\t\t\t*found = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* choose child */\n\t\tnway = 1 << frag->split_by;\n\t\tdout(\"choose_frag(%x) %x splits by %d (%d ways)\\n\", v, t,\n\t\t     frag->split_by, nway);\n\t\tfor (i = 0; i < nway; i++) {\n\t\t\tn = ceph_frag_make_child(t, frag->split_by, i);\n\t\t\tif (ceph_frag_contains_value(n, v)) {\n\t\t\t\tt = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(i == nway);\n\t}\n\tdout(\"choose_frag(%x) = %x\\n\", v, t);\n\n\treturn t;\n}"
  },
  {
    "function_name": "__ceph_find_frag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "160-176",
    "snippet": "struct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_frag_compare",
          "args": [
            "f",
            "frag->frag"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_frag_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ceph_frag.c",
          "lines": "7-22",
          "snippet": "int ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nint ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structceph_inode_frag",
            "node"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct ceph_inode_frag *__ceph_find_frag(struct ceph_inode_info *ci, u32 f)\n{\n\tstruct rb_node *n = ci->i_fragtree.rb_node;\n\n\twhile (n) {\n\t\tstruct ceph_inode_frag *frag =\n\t\t\trb_entry(n, struct ceph_inode_frag, node);\n\t\tint c = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tn = n->rb_left;\n\t\telse if (c > 0)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "__get_or_create_frag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "116-155",
    "snippet": "static struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_or_create_frag added %llx.%llx frag %x\\n\"",
            "ceph_vinop(&ci->vfs_inode)",
            "f"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&frag->node",
            "&ci->i_fragtree"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&frag->node",
            "parent",
            "p"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\"",
            "&ci->vfs_inode",
            "ceph_vinop(&ci->vfs_inode)",
            "f"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "&ci->vfs_inode"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*frag)",
            "GFP_NOFS"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_frag_compare",
          "args": [
            "f",
            "frag->frag"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_frag_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/ceph_frag.c",
          "lines": "7-22",
          "snippet": "int ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ceph/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/types.h>\n#include <linux/module.h>\n\nint ceph_frag_compare(__u32 a, __u32 b)\n{\n\tunsigned va = ceph_frag_value(a);\n\tunsigned vb = ceph_frag_value(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\tva = ceph_frag_bits(a);\n\tvb = ceph_frag_bits(b);\n\tif (va < vb)\n\t\treturn -1;\n\tif (va > vb)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structceph_inode_frag",
            "node"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic struct ceph_inode_frag *__get_or_create_frag(struct ceph_inode_info *ci,\n\t\t\t\t\t\t    u32 f)\n{\n\tstruct rb_node **p;\n\tstruct rb_node *parent = NULL;\n\tstruct ceph_inode_frag *frag;\n\tint c;\n\n\tp = &ci->i_fragtree.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tfrag = rb_entry(parent, struct ceph_inode_frag, node);\n\t\tc = ceph_frag_compare(f, frag->frag);\n\t\tif (c < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (c > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn frag;\n\t}\n\n\tfrag = kmalloc(sizeof(*frag), GFP_NOFS);\n\tif (!frag) {\n\t\tpr_err(\"__get_or_create_frag ENOMEM on %p %llx.%llx \"\n\t\t       \"frag %x\\n\", &ci->vfs_inode,\n\t\t       ceph_vinop(&ci->vfs_inode), f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tfrag->frag = f;\n\tfrag->split_by = 0;\n\tfrag->mds = -1;\n\tfrag->ndist = 0;\n\n\trb_link_node(&frag->node, parent, p);\n\trb_insert_color(&frag->node, &ci->i_fragtree);\n\n\tdout(\"get_or_create_frag added %llx.%llx frag %x\\n\",\n\t     ceph_vinop(&ci->vfs_inode), f);\n\treturn frag;\n}"
  },
  {
    "function_name": "ceph_get_snapdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "70-90",
    "snippet": "struct inode *ceph_get_snapdir(struct inode *parent)\n{\n\tstruct ceph_vino vino = {\n\t\t.ino = ceph_ino(parent),\n\t\t.snap = CEPH_SNAPDIR,\n\t};\n\tstruct inode *inode = ceph_get_inode(parent->i_sb, vino);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tBUG_ON(!S_ISDIR(parent->i_mode));\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tinode->i_mode = parent->i_mode;\n\tinode->i_uid = parent->i_uid;\n\tinode->i_gid = parent->i_gid;\n\tinode->i_op = &ceph_snapdir_iops;\n\tinode->i_fop = &ceph_snapdir_fops;\n\tci->i_snap_caps = CEPH_CAP_PIN; /* so we can open */\n\tci->i_rbytes = 0;\n\treturn inode;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!S_ISDIR(parent->i_mode)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "parent->i_mode"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_get_inode",
          "args": [
            "parent->i_sb",
            "vino"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
          "lines": "48-65",
          "snippet": "struct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/ceph/decode.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/random.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/namei.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_ino",
          "args": [
            "parent"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "412-415",
          "snippet": "static inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline u64 ceph_ino(struct inode *inode)\n{\n\treturn ceph_inode(inode)->i_vino.ino;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_snapdir(struct inode *parent)\n{\n\tstruct ceph_vino vino = {\n\t\t.ino = ceph_ino(parent),\n\t\t.snap = CEPH_SNAPDIR,\n\t};\n\tstruct inode *inode = ceph_get_inode(parent->i_sb, vino);\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tBUG_ON(!S_ISDIR(parent->i_mode));\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\tinode->i_mode = parent->i_mode;\n\tinode->i_uid = parent->i_uid;\n\tinode->i_gid = parent->i_gid;\n\tinode->i_op = &ceph_snapdir_iops;\n\tinode->i_fop = &ceph_snapdir_fops;\n\tci->i_snap_caps = CEPH_CAP_PIN; /* so we can open */\n\tci->i_rbytes = 0;\n\treturn inode;\n}"
  },
  {
    "function_name": "ceph_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "48-65",
    "snippet": "struct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_inode on %lu=%llx.%llx got %p\\n\"",
            "inode->i_ino",
            "vino.ino",
            "vino.snap",
            "inode"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dout",
          "args": [
            "\"get_inode created new inode %p %llx.%llx ino %llx\\n\"",
            "inode",
            "ceph_vinop(inode)",
            "(u64)inode->i_ino"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ceph_vinop",
          "args": [
            "inode"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "t",
            "ceph_ino_compare",
            "ceph_set_ino_cb",
            "&vino"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_vino_to_ino",
          "args": [
            "vino"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstruct inode *ceph_get_inode(struct super_block *sb, struct ceph_vino vino)\n{\n\tstruct inode *inode;\n\tino_t t = ceph_vino_to_ino(vino);\n\n\tinode = iget5_locked(sb, t, ceph_ino_compare, ceph_set_ino_cb, &vino);\n\tif (inode == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (inode->i_state & I_NEW) {\n\t\tdout(\"get_inode created new inode %p %llx.%llx ino %llx\\n\",\n\t\t     inode, ceph_vinop(inode), (u64)inode->i_ino);\n\t\tunlock_new_inode(inode);\n\t}\n\n\tdout(\"get_inode on %lu=%llx.%llx got %p\\n\", inode->i_ino, vino.ino,\n\t     vino.snap, inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "ceph_set_ino_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/inode.c",
    "lines": "41-46",
    "snippet": "static int ceph_set_ino_cb(struct inode *inode, void *data)\n{\n\tceph_inode(inode)->i_vino = *(struct ceph_vino *)data;\n\tinode->i_ino = ceph_vino_to_ino(*(struct ceph_vino *)data);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ceph/decode.h>",
      "#include \"cache.h\"",
      "#include \"mds_client.h\"",
      "#include \"super.h\"",
      "#include <linux/random.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/namei.h>",
      "#include <linux/kernel.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/ceph/ceph_debug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ceph_vino_to_ino",
          "args": [
            "*(struct ceph_vino *)data"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_vino_to_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "382-389",
          "snippet": "static inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline ino_t ceph_vino_to_ino(struct ceph_vino vino)\n{\n#if BITS_PER_LONG == 32\n\treturn ceph_ino_to_ino32(vino.ino);\n#else\n\treturn (ino_t)vino.ino;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ceph_inode",
          "args": [
            "inode"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_inode_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.h",
          "lines": "347-350",
          "snippet": "static inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/fscache.h>",
            "#include <linux/ceph/libceph.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/writeback.h>",
            "#include <linux/wait.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/completion.h>",
            "#include <linux/backing-dev.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscache.h>\n#include <linux/ceph/libceph.h>\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/writeback.h>\n#include <linux/wait.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/fs.h>\n#include <linux/exportfs.h>\n#include <linux/completion.h>\n#include <linux/backing-dev.h>\n#include <asm/unaligned.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline struct ceph_fs_client *ceph_inode_to_client(struct inode *inode)\n{\n\treturn (struct ceph_fs_client *)inode->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ceph/decode.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/random.h>\n#include <linux/posix_acl.h>\n#include <linux/vmalloc.h>\n#include <linux/writeback.h>\n#include <linux/namei.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int ceph_set_ino_cb(struct inode *inode, void *data)\n{\n\tceph_inode(inode)->i_vino = *(struct ceph_vino *)data;\n\tinode->i_ino = ceph_vino_to_ino(*(struct ceph_vino *)data);\n\treturn 0;\n}"
  }
]